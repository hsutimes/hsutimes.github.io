{"pages":[{"title":"About","text":"la关于我： Time","link":"/about/index.html"}],"posts":[{"title":"2019年度机器学习49个顶级工程汇总","text":"2019年度机器学习49个顶级工程汇总 过去一年中，我们比较了近22000个机器学习开源工程，并筛选了49个顶级项目（筛选率0.22%）。 其中包括以下6个分类 计算机视觉（1~5） 强化学习（6~13） NLP（14~20） GAN（21~26） Neural Network（27~35） Toolkit（36~49） 我们花了很大的精力筛选这个list，并小心的选择出2018年1月到12月间最好的工程。为了保证名单质量，Mybridge AI协同考虑了流行度、参与度、发布时间等多重因素。 计算机视觉1、Detectron：facebook发布的目标检测工具【18913 star on Github】项目地址：https://github.com/facebookresearch/Detectron?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 2、Openpost：多人实时特征点检测工具【11052 stars on GitHub】项目地址：https://github.com/CMU-Perceptual-Computing-Lab/openpose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 3、DensePost：2维人体图片转3维的实时映射方法。【4165 stars on Github】项目地址：https://github.com/facebookresearch/Densepose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 4、Maskrcnn-benchmark：（Pytorch）语义分割与目标检测工具包。【3888 stars on Github】项目地址：https://github.com/facebookresearch/maskrcnn-benchmark?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 5、SNIPER：多尺度目标检测算法。【1963 stars on Github】项目地址：https://github.com/mahyarnajibi/SNIPER?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 强化学习6、Psychlab：Psychlab实验范例。【5595 stars on Github】项目地址：https://github.com/deepmind/lab/tree/master/game_scripts/levels/contributed/psychlab?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 7、ELF：一个灵活、轻量、可扩展的游戏研究平台。【2406 stars on Github】项目地址：https://github.com/pytorch/elf?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 8、TRFL：（TensorFlow）强化学习agent工具包。【2312 stars on Github】项目地址：https://github.com/deepmind/trfl?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 9、Horizon：首个用于大规模需求的开源强化学习平台。【1703 stars on Github】项目地址：https://github.com/facebookresearch/Horizon?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 10、Chess-alpha-zero：国际象棋强化学习项目（基于AlphaGo Zero方法）。【1307 stars on Github】项目地址：https://github.com/Zeta36/chess-alpha-zero?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 11、Dm_control：DeepMind工具包。【1231 stars on Github】项目地址：https://github.com/deepmind/dm_control?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 12、MAMEToolkit：基于强化学习的电子游戏python库。【437 stars on Github】项目地址：https://github.com/M-J-Murray/MAMEToolkit?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 13、Reaver：模块化的深度强化学习框架（星际争霸2）。【355 stars on Github】项目地址：https://github.com/inoryy/reaver?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more NLP14、Bert：BERT的TensorFlow代码，以及预训练模型。【11703 stars on Github】项目地址：https://github.com/google-research/bert?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 15、Pytext：基于Pytorch的神经语言模型框架。【4466 stars on Github】项目地址：https://github.com/facebookresearch/pytext?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 16、Bert-as-service：BERT模型的网络服务版本项目地址：https://github.com/hanxiao/bert-as-service?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 17、UnsupervisedMT：基于Phrase的无监督机器翻译方法。【1068 stars on Github】项目地址：https://github.com/facebookresearch/UnsupervisedMT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 18、DecaNLP：NLP十项全能工具，多任务模型。【1648 stars on Github】项目地址：https://github.com/salesforce/decaNLP?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 19、NLP-architect：来自英特尔AI实验室的python工具包，包含了当前NLP领域的多种最佳模型。【1751 stars on Github】项目地址：https://github.com/NervanaSystems/nlp-architect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 20、Gluon-nlp：NLP工具包。【1263 stars on Github】项目地址：https://github.com/dmlc/gluon-nlp?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more GAN21、DeOldify：一个基于深度学习的图像补全工具包。【5060 stars on Github】项目地址：https://github.com/jantic/DeOldify?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 22、Progressive_growing_of_gans：GAN的变种实现，提高生产质量、稳定性以及多样性。项目地址：https://github.com/tkarras/progressive_growing_of_gans?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 23、MUNIT：多模态无监督图像翻译。【1339 stars on Github】项目地址：https://github.com/NVlabs/MUNIT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 24、Transparent_latent_gan：使用监督学习来解释GAN的隐空间信息。【1337 stars on Github】项目地址：https://github.com/SummitKwan/transparent_latent_gan?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 25、Gandissect：基于Pytorch的可视化以及理解GAN的神经元信息。【1065 stars on Github】项目地址：https://github.com/CSAILVision/gandissect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 26、GANimation：单张图片的表情变换。【869 stars on Github】项目地址：https://github.com/albertpumarola/GANimation?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more神经网络27、Fastai：加速神经网络训练过程，并提高准确率。【11597 stars on Github】项目地址：https://github.com/fastai/fastai?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 28、DeepCreamPy：图像修复。【7046 stars on Github】项目地址：https://github.com/deeppomf/DeepCreamPy?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 29、Augmentor v0.2、图像增强工具包。【2805 stars on Github】项目地址：https://github.com/mdbloice/Augmentor?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 30、Graph_nets：Tensorflow的图网络构建工具。【2723 stars on Github】项目地址：https://github.com/deepmind/graph_nets?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 31、Textgenrnn：使用预训练字符级RNN生成文本。【1900 stars on Github】项目地址：https://github.com/minimaxir/textgenrnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 32、Person-blocker：图像中自动删除人像。【1806 stars on Github】项目地址：https://github.com/minimaxir/person-blocker?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 33、Deepvariant：DNA序列数据的分析工具项目地址：https://github.com/google/deepvariant?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 34、Video-nolocal-net：non-local神经网络的视频分类方法。【1049 stars on Github】项目地址：https://github.com/facebookresearch/video-nonlocal-net?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 35、Ann-visualizer：神经网络可视化工具。【922 stars on Github】项目地址：https://github.com/Prodicode/ann-visualizer?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 工具包36、Tfjs：一个基于JS的ML模型训练部署工具包。【10268 stars on Github】项目地址：https://github.com/tensorflow/tfjs?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 37：Dopamine：快速的强化学习研究框架。【7142 stars on Github】项目地址：https://github.com/google/dopamine?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 38、Lime：分类器解释工具包。【5173 stars on Github】项目地址：https://github.com/marcotcr/lime?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 39、Autokeras：自动机器学习的开源软件库。【4520 stars on Github】项目地址：https://github.com/jhfjhfj1/autokeras?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 40、Shap：神经网络解释工具。【3496 stars on Github】项目地址：https://github.com/slundberg/shap?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 41、MMdnn：模型适配器。【3021 stars on Github】项目地址：https://github.com/Microsoft/MMdnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 42、Mlflow：机器学习生命周期管理。【3013 stars on Github】项目地址：https://github.com/mlflow/mlflow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 43、Mace：面向移动计算平台的深度学习推断框架。【2979 stars on Github】项目地址：https://github.com/XiaoMi/mace?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 44、PySyft：关注安全性的深度学习库。【2595 stars on Github】项目地址：https://github.com/OpenMined/PySyft?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 45、Adanet：AutoML计算库。【2293 stars on Github】项目地址：https://github.com/tensorflow/adanet?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 46、Tencent-ml-images：最大的多标签图像数据库。【2094 stars on Github】项目地址：https://github.com/Tencent/tencent-ml-images?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 47、Donkeycar、开源的软硬件自动驾驶平台。【1207 stars on Github】 项目地址：https://github.com/autorope/donkeycar?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 48、PocketFlow：自动模型压缩框架。【1677 stars on Github】项目地址：https://github.com/Tencent/PocketFlow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 49、DALI：深度学习应用的优化工具包以及数据处理扩展引擎。【1013 stars on Github】项目地址：https://github.com/NVIDIA/dali?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more 传送门","link":"/2019/09/16/2019年度机器学习49个顶级工程汇总/"},{"title":"118. 杨辉三角","text":"杨辉三角题目给定一个非负整数 numRows，生成杨辉三角的前 numRows行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题解 动态规划 思路 如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。 算法 虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。 首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 0 的特殊情况，否则我们会返回 [1]。如果 numRows &gt; 0，那么我们用 [1] 作为第一行来初始化 triangle with [1]，并按如下方式继续填充： 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // First base case; if user requests zero rows, they get zero rows. if (numRows == 0) { return triangle; } // Second base case; first row is always [1]. triangle.add(new ArrayList&lt;&gt;()); triangle.get(0).add(1); for (int rowNum = 1; rowNum &lt; numRows; rowNum++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; prevRow = triangle.get(rowNum-1); // The first row element is always 1. row.add(1); // Each triangle element (other than the first and last of each row) // is equal to the sum of the elements above-and-to-the-left and // above-and-to-the-right. for (int j = 1; j &lt; rowNum; j++) { row.add(prevRow.get(j-1) + prevRow.get(j)); } // The last row element is always 1. row.add(1); triangle.add(row); } return triangle; }} 复杂度分析 时间复杂度： O(numRows²) 虽然更新 triangle 中的每个值都是在常量时间内发生的，但它会被执行 O(numRows²) 次。想要了解原因，就需要考虑总共有多少次循环迭代。很明显外层循环需要运行 numRows 次，但在外层循环的每次迭代中，内层循环要运行 rowNumrowNum 次。因此，triangle 发生的更新总数为1 + 2 + 3 + ... + *numRows*，根据高斯公式有 空间复杂度：O(numRows²) 因为我们需要存储我们在 triangle 中更新的每个数字，所以空间需求与时间复杂度相同。 Python解法 1234567891011121314151617class Solution: def generate(self, num_rows): triangle = [] for row_num in range(num_rows): # The first and last row elements are always 1. row = [None for _ in range(row_num+1)] row[0], row[-1] = 1, 1 # Each triangle element is equal to the sum of the elements # above-and-to-the-left and above-and-to-the-right. for j in range(1, len(row)-1): row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j] triangle.append(row) return triangle 递归解法 通过numRows-1，求numRows行，递归求解 1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; listw = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;Integer&gt; listn = new ArrayList&lt;Integer&gt;(); if (numRows == 0) return listw; generate(numRows - 1); for (int i = 0; i &lt; numRows; i++) { if (i == 0) { listn.add(1); continue; } else if (i == numRows - 1) { listn.add(1); continue; } else if (i == numRows - 2) { listn.add(listw.get(numRows - 2).get(i - 1) + 1); continue; } else { listn.add(listw.get(numRows - 2).get(i - 1) + listw.get(numRows - 2).get(i)); } } listw.add(listn); return listw; }}","link":"/2019/08/31/118-杨辉三角/"},{"title":"2019-games-xbox","text":"2019年最好的Xbox One游戏推荐微软最近对Xbox产品线进行了重大更新，分别以Xbox One X和Xbox One S的形式推出两个新型号，其中前者是你现在可以买到的最强的家用游戏机。 如果你正在考虑选择其中一台游戏机，但不确定到底要哪一个，请查看我们的家用游戏机购买指南。对于那些已经拥有Xbox的游戏玩家，我们精心制作了这份最好的游戏列表，随着未来伟大的新游戏发布，这份列表将会定期保持更新。 传送门","link":"/2019/10/17/2019-games-xbox/"},{"title":"24. 两两交换链表中的节点","text":"24. 两两交换链表中的节点题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.题解 非递归 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode pre = new ListNode(0); pre.next = head; ListNode temp = pre; while(temp.next != null &amp;&amp; temp.next.next != null) { ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; end.next = start; temp = start; } return pre.next; }} 递归解法 详细介绍一下递归的思路; 递归和栈处理问题类似,先把问题从前往后收集起来,然后再从后往前处理每一个问题; 两两交换链表结点,先处理最后两个或一个节点,然后再从后往前处理每一对节点; 先创建一个next临时结点保存head的下一个结点,然后让head指向下下一个节点,最后让 next节点指向head结点; 此题只有处理完后面的结点才可处理前面的结点,画图更容易理解; 123456789101112class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; // 三个节点顺序:head, next, swapPairs(next.next) ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; }}","link":"/2019/08/31/24-两两交换链表中的节点/"},{"title":"440. 字典序的第K小数字","text":"440. 字典序的第K小数字题目 给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。 注意：1 ≤ k ≤ n ≤ 109。 示例 : 12345678输入:n: 13 k: 2输出:10解释:字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。 题解乍一看这一题貌似毫无头绪，什么是字典序？如何定位这个数？没错，刚接触这个题目的时候，我的脑筋里也是一团乱麻。 但是我觉得作为一个拥有聪明才智的程序员来说，最重要的能力就是迅速抽象问题、拆解问题的能力。经过一段时间的思考，我的脑筋里还是没有答案。 哈哈。 言归正传，我们来分析一下这个问题。 首先，什么是字典序？ 什么是字典序？简而言之，就是根据数字的前缀进行排序， 比如10 &lt; 9，因为10的前缀是1，比9小， 再比如112 &lt; 12，因为112的前缀11小于12。 这样排序下来，会跟平常的升序排序会有非常大的不同。先给你一个直观的感受，一个数乘10，或者加1，哪个大？可能你会吃惊，后者会更大。 但其实掌握它的本质之后，你一点都不会吃惊。 问题建模画一个图你就懂了。 每一个节点都拥有10个孩子节点，因为作为一个前缀 ，它后面可以接0~9这十个数字。而且你可以非常容易地发现，整个字典序排列也就是对十叉树进行层序遍历。1, 10, 11, 12, 13 … 100, 101, … 回到题目的意思，我们需要找到排在第k位的数。找到他的排位，需要搞清楚三件事情: 怎么确定一个前缀下所有子节点的个数？如果第k个数在当前的前缀下，怎么继续往下面的子节点找？如果第k个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？接下来 ，我们一一拆解这些问题。 理顺思路 确定指定前缀下所有子节点数现在的任务就是给定一个前缀，返回下面子节点总数。 我们现在的思路就是用下一个前缀的起点减去当前前缀的起点，那么就是当前前缀下的所有子节点数总和啦。 123456789101112131415161718//prefix是前缀，n是上界var getCount = (prefix, n) =&gt; { let cur = prefix; let next = prefix + 1;//下一个前缀 let count = 0; //当前的前缀当然不能大于上界 while(cur &lt;= n) { count += next - cur;//下一个前缀的起点减去当前前缀的起点 cur *= 10; next *= 10; // 如果说刚刚prefix是1，next是2，那么现在分别变成10和20 // 1为前缀的子节点增加10个，十叉树增加一层, 变成了两层 // 如果说现在prefix是10，next是20，那么现在分别变成100和200， // 1为前缀的子节点增加100个，十叉树又增加了一层，变成了三层 } return count;//把当前前缀下的子节点和返回去。} 当然，不知道大家发现一个问题没有，当next的值大于上界的时候，那以这个前缀为根节点的十叉树就不是满十叉树了啊，应该到上界那里，后面都不再有子节点。因此，count += next - cur还是有些问题的，我们来修正这个问题: 1count += Math.max(n+1, next) - cur; 你可能会问:咦？怎么是n+1,而不是n呢？不是说好了n是上界吗？ 我举个例子，假若现在上界n为12，算出以1为前缀的子节点数，首先1本身是一个节点，接下来要算下面10，11，12，一共有4个子节点。 那么如果用Math.max(n, next) - cur会怎么样？ 这时候算出来会少一个，12 - 10加上根节点，最后只有3个。因此我们务必要写n+1。 现在，我们搞定了前缀的子节点数问题。 第k个数在当前前缀下现在无非就是往子树里面去看。 prefix这样处理就可以了。 1prefix *= 10 3.第k个数不在当前前缀下说白了，当前的前缀小了嘛，我们扩大前缀。 1prefix ++; 框架搭建整合一下刚刚的思路。 123456789101112131415let findKthNumber = function(n, k) { let p = 1;//作为一个指针，指向当前所在位置，当p==k时，也就是到了排位第k的数 let prefix = 1;//前缀 while(p &lt; k) { let count = getNumber(prefix, n);//获得当前前缀下所有子节点的和 if(p + count &gt; k) { //第k个数在当前前缀下 prefix *= 10; p++; //把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110 } else if(p + count &lt;= k) { //第k个数不在当前前缀下 prefix ++; p += count;//注意这里的操作，把指针指向了下一前缀的起点 } } return prefix;}; 完整代码展示 1234567891011121314151617181920212223242526/** * @param {number} n * @param {number} k * @return {number} */var findKthNumber = function(n, k) { let getCount = (prefix, n) =&gt; { let count = 0; for(let cur = prefix, next = prefix + 1; cur &lt;= n; cur *= 10, next *= 10) count += Math.min(next, n+1) - cur; return count; } let p = 1; let prefix = 1; while(p &lt; k) { let count = getCount(prefix, n); if(p + count &gt; k) { prefix *= 10; p++; } else if(p + count &lt;= k) { prefix ++; p += count; } } return prefix;}; 123456789101112131415161718192021222324252627282930313233public class Solution { /** * @param n: a integer * @param k: a integer * @return: return a integer */ public int findKthNumber(int n, int k) { int curr = 1; k = k - 1; while (k &gt; 0) { int steps = calSteps(n, curr, curr + 1); if (steps &lt;= k) { //如果不在当前层，减去steps curr += 1; k -= steps; } else { //说明在当前层,curr*10缩小搜索范围继续查找 curr *= 10; k -= 1; } } return curr; } //use long in case of overflow public int calSteps(int n, long n1, long n2) { //计算curr开头和curr+1开头之间的字符串数量 int steps = 0; while (n1 &lt;= n) { steps += Math.min(n + 1, n2) - n1; //每次加上当前的字符串数量 n1 *= 10; //每次均扩大10倍 n2 *= 10; } return steps; }}","link":"/2019/09/17/440-字典序的第K小数字/"},{"title":"334. 反转字符串","text":"334. 反转字符串题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2： 输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 题解 递归解法 123456789101112131415class Solution { public void reverseString(char[] s) { swap(0, s.length-1, s); } public void swap(int start, int end, char[] s) { if(start &gt;= end){ return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; swap(start+1, end-1, s); }} 循环解法 1234567891011class Solution { public void reverseString(char[] s) { int j=s.length-1; for(int i=0;i&lt;s.length/2;i++){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; j--; } }} Python解法 12def reverseString(self, s: List[str]) -&gt; None: s[0::]=s[::-1] c++解法 双指针，交换头尾两个指针所指的两个位置的值，指针向中间移动一个位置，重复以上操作，直到两个指针交错； 12345678910111213class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { int i = 0; int j = s.size() - 1; while(i&lt;j) { swap(s[i],s[j]); ++ i; -- j; } }};","link":"/2019/08/31/334-反转字符串/"},{"title":"BPlusTree","text":"B+ Trees B+ Trees","link":"/2019/09/30/BPlusTree/"},{"title":"26 remove-duplicates-from-sorted-array","text":"26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 双指针法 12345678910111213class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) { if (nums[j] != nums[i]) { i++; nums[i] = nums[j]; } } return i + 1; }} 复杂度分析 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。","link":"/2019/10/04/26-remove-duplicates-from-sorted-array/"},{"title":"3sum","text":"三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 题解123456789101112131415161718192021222324252627class Solution { public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if(nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len ; i++) { if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L &lt; R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; }} 传送门","link":"/2019/11/13/3sum/"},{"title":"54. 螺旋矩阵","text":"54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 方法 1：模拟直觉 绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。 算法 假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。 当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。 1234567891011121314151617181920212223242526class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List ans = new ArrayList(); if (matrix.length == 0) return ans; int R = matrix.length, C = matrix[0].length; boolean[][] seen = new boolean[R][C]; int[] dr = {0, 1, 0, -1}; int[] dc = {1, 0, -1, 0}; int r = 0, c = 0, di = 0; for (int i = 0; i &lt; R * C; i++) { ans.add(matrix[r][c]); seen[r][c] = true; int cr = r + dr[di]; int cc = c + dc[di]; if (0 &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc]){ r = cr; c = cc; } else { di = (di + 1) % 4; r += dr[di]; c += dc[di]; } } return ans; }} 12345678910111213141516171819class Solution(object): def spiralOrder(self, matrix): if not matrix: return [] R, C = len(matrix), len(matrix[0]) seen = [[False] * C for _ in matrix] ans = [] dr = [0, 1, 0, -1] dc = [1, 0, -1, 0] r = c = di = 0 for _ in range(R * C): ans.append(matrix[r][c]) seen[r][c] = True cr, cc = r + dr[di], c + dc[di] if 0 &lt;= cr &lt; R and 0 &lt;= cc &lt; C and not seen[cr][cc]: r, c = cr, cc else: di = (di + 1) % 4 r, c = r + dr[di], c + dc[di] return ans 复杂度分析 时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。 空间复杂度： O(N)，需要两个矩阵 seen 和 ans 存储所需信息。 方法 2：按层模拟 直觉 答案是最外层所有元素按照顺时针顺序输出，其次是次外层，以此类推。 算法 我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，然后是第 3 层的。 12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]] 12345678910111213141516171819202122class Solution { public List &lt; Integer &gt; spiralOrder(int[][] matrix) { List ans = new ArrayList(); if (matrix.length == 0) return ans; int r1 = 0, r2 = matrix.length - 1; int c1 = 0, c2 = matrix[0].length - 1; while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) { for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]); for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]); if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) { for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]); for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]); } r1++; r2--; c1++; c2--; } return ans; }} 复杂度分析 时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。 空间复杂度： O(N)，需要矩阵 ans 存储信息。 方法 3：顺时针旋转 这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小 首先设定上下左右边界 其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界 判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案 若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理 不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main { public static void main(String[] args) { // Scanner in = new Scanner(System.in); // int n = in.nextInt(); // in.close(); int[][] matrix = new int[][] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; List&lt;Integer&gt; list = spiralOrder(matrix); System.out.println(list); } static List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix.length == 0) return list; int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1; while (true) { // 向右 for (int i = l; i &lt;= r; i++) list.add(matrix[u][i]); if (++u &gt; d) break; // 向下 for (int i = u; i &lt;= d; i++) list.add(matrix[i][r]); if (--r &lt; l) break; // 向左 for (int i = r; i &gt;= l; i--) list.add(matrix[d][i]); if (--d &lt; u) break; // 向上 for (int i = d; i &gt;= u; i--) list.add(matrix[i][l]); if (++l &gt; r) break; } return list; }} 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector &lt;int&gt; ans; if(matrix.empty()) return ans; //若数组为空，直接返回答案 int u = 0; //赋值上下左右边界 int d = matrix.size() - 1; int l = 0; int r = matrix[0].size() - 1; while(true) { for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右 if(++ u &gt; d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同 for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); //向下 if(-- r &lt; l) break; //重新设定有边界 for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); //向左 if(-- d &lt; u) break; //重新设定下边界 for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); //向上 if(++ l &gt; r) break; //重新设定左边界 } return ans; }};","link":"/2019/09/07/54-螺旋矩阵/"},{"title":"Computer-network-books","text":"网络安全从业者书单推荐一、计算机及系统原理《编码：隐匿在计算机软硬件背后的语言》 作者：（美国）Charles Petzold 《深入理解计算机系统》 作者：（美国）Randal E. Bryant 《深入解析windows操作系统》 作者：（美国）Mark E .Russinovich ，David A.Solomon 《Linux内核设计与实现》 作者：（美国）Robert Love 《深入理解android内核设计思想》 作者：林学森 《Android系统源代码情景分析》 作者：罗升阳 《深入解析Mac OS X &amp; iOS操作系统》 作者：（美国）Jonathan Levin 《深入理解LINUX内核》 作者：（美国）Daniel P.Bovet 《代码揭秘：从C/C++的角度探秘计算机系统》 作者：左飞 《Android Dalvik虚拟机结构及机制剖析》（共2卷） 作者：吴艳霞，张国印 《最强Android书：架构大剖析》 作者：（美国）Jonathan Levin 二、编程开发1、系统平台 （1）Windows 《Windows程序设计》 作者：（美国）Charles Petzold 《Windows核心编程》 作者：（美国）Jeffrey Richter 《Windows环境下32位汇编语言程序设计》 作者：罗云彬 《Windows驱动开发技术详解》 作者：张帆，史彩成 （2）Linux / Unix 《UNIX环境高级编程》 作者：（美国）W.Richard Stevens 《Linux程序设计》 作者：（美国）Nell Matthew，Richard Stones 《鸟哥的Linux私房菜》 作者：鸟哥（蔡德明） 《Linux设备驱动程序》 作者：（美国）Jonahan Corbet （3）Mac OS X / iOS 《iOS编程》 作者：（美国）Joe Conway，Aaron Hillegass 《OS X与iOS内核编程》 作者：（澳大利亚）Ole Henry Halvorsen，Douglas Clarke （4）Android 《第一行代码 Android》 作者：郭霖 《Android编程权威指南》 作者：（美国）Bill Phillips，Brian Hardy 2、编程语言 （1）C 《C程序设计语言》 作者：（美国）Brian W. Kernighan，Dennis M. Ritchie 《C Primer Plus》 作者：（美国）Stephen Prata 《C和指针》 作者：（美国）Kenneth A．Reek 《C陷阱与缺陷》 作者：（美国）Andrew Koenig 《C专家编程》 作者：（美国）Perter VanDer Linden （2）C++ 《C++ Primer Plus》 作者：（美国）Stephen Prata 《C++ Primer》 作者：（美国）Stanley B. Lippman，Josée LaJoie，Barbara E. Moo （3）ASM 《Intel 汇编语言程序设计》 作者：（美国）Kip R.Irvine 《Intel 开发手册》 （4）JAVA 《JAVA核心技术》 作者：（美国）Cay S. Horstmann 《Java编程思想》 作者：（美国）Bruce Eckel （5）JavaScript 《JavaScript DOM编程艺术》 作者：（英国）Jeremy Keith，（加拿大）Jeffrey Sambells 《JavaScript高级程序设计》 作者：（美国）Nicholas C.Zakas （6）Python 《Python核心编程》 作者：（美国）Wesley Chun （7）Shell 《Linux Shell脚本攻略》 作者：（印度）Sarath Lakshman 3、调试技术 《软件调试》 作者：张银奎 《Debug Hacks》 作者：（日本）吉冈弘隆，大和一洋，大岩尚宏，安部东洋，吉田俊辅 《格蠹汇编：软件调试案例集锦》 作者：张银奎 4、数据结构与算法 《数据结构与算法分析：C语言描述》 作者：（美国）Mark Allen Weiss 《算法导论》 作者：（美国）Thomas H.Cormen，Charles E.Leiserson，Ronald L.Rivest 5、编译原理 《编译系统透视：图解编译原理》 作者：新设计团队 《编译原理》 作者：（美国）Alfred V.Aho，Monica S.Lam，Ravi Sethi，Jeffrey D.Ullman 6、其他 《编程高手箴言》 作者：梁肇新 《代码整洁之道》 作者：（美国）Robert C.Martin 《代码大全》 作者：（美国）Steve McConnell 三、网络技术《TCP/IP详解 卷1：协议》 作者：（美国）Kevin R. Fall，W.Richard Stevens 《Wireshark数据包分析实战》 作者：（美国）Chris Sanders 四、安全技术1、安全开发 《天书夜读：从汇编语言到Windows内核编程》 作者：谭文，邵坚磊 《Rootkit：系统灰色地带的潜伏者》 作者：（美国）Bill Blunden 《Rootkits——Windows内核的安全防护》 作者：（美国）Greg Hoglund，James Butler 《BSD ROOTKIT 设计–内核黑客指引书》 作者：（美国）Joseph Kong 《寒江独钓：Windows内核安全编程》 作者：谭文，杨潇，邵坚磊 2、逆向工程 《加密与解密》 作者：段钢 《恶意软件分析诀窍与工具箱——对抗“流氓”软件的技术与利器》 作者：（美国）Michael.Hale.Ligh，Steven Adair 《C++反汇编与逆向分析技术揭秘》 作者：钱林松，赵海旭 《IDA Pro权威指南》 作者：（美国）Chris Eagle 《逆向工程权威指南》 作者：（乌克兰）Dennis Yurichev 《Android软件安全与逆向分析》 作者：丰生强 《macOS软件安全与逆向分析》 作者：丰生强、 邢俊杰 《iOS应用逆向工程（第2版）》 作者：沙梓社，吴航 3、Web安全 《黑客攻防技术宝典：Web实战篇》 作者：（美国）Dafydd Stuttard，Marcus Pinto 《白帽子讲Web安全》 作者：吴翰清 《Web安全测试》 作者：（美国）Paco Hope，Ben Waltller 《Web前端黑客技术揭秘》 作者：钟晨鸣，徐少培 《精通脚本黑客》 作者：曾云好 4、软件 / 系统安全 《0day安全：软件漏洞分析技术》 作者：王清 《漏洞战争：软件漏洞分析精要》 作者：林桠泉 《捉虫日记》 作者：（德国）Tobias Klein 《内核漏洞的利用与防范》 作者：（美国）Enrico Perla，Massimiliano Oldani 《Fuzzing for Software Security Testing and Quality Assurance（第二版）》 作者：（美国）Charlie Miller 《iOS Hacker’s Handbook》 作者：（美国）Charlie Miller 《The Mac Hacker’S Handbook》 作者：（美国）Charlie Miller 《Android安全攻防权威指南》 作者：（美国）Joshua J.Drake，（西班牙）Pau Oliva Fora，（美国）Collin Mulliner 《The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities》 作者：（美国）Mark Dowd 《Android安全攻防实战》 作者：（美国）Keith Makan，Scott Alexander-Bown 《模糊测试：强制性安全漏洞发掘》 作者：（美国）Michael Sutton 《Exploit 编写系列教程》 作者：（美国）Corelan Team 《MacOS and iOS Internals, Volume III: Security &amp; Insecurity》 作者：（美国）Jonathan Levin 《灰帽黑客（第4版）：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》 作者：（美国）Allen Harper，Shon Harris 《威胁建模：设计和交付更安全的软件》 作者：（美国）Adam Shostack 5、无线电安全 《无线电安全攻防大揭秘》 作者：杨卿，黄琳 6、硬件安全 《硬件安全攻防大揭秘》 作者：简云定，杨卿 7、汽车安全 《智能汽车安全攻防大揭秘》 作者：李均，杨卿，曾颖涛，郑玉伟 《汽车黑客大曝光》 作者：（美国）Craig Smith 五、软技能《软技能：代码之外的生存指南》 作者：（美国）John Sonmez 《程序员健康指南》 作者：（美国）Joe Kutner 《影响力》 作者：（美国）Robert B.Cialdini 《思考，快与慢》 作者：（美国）Daniel Kahneman 《写给大家看的设计书》 作者：（美国）Robin Williams 《听故事，学PPT设计》 作者：杨雪 《横向领导力》 作者：（美国）Roger Fisher，Alan Sharp 《职业情商》 作者：张新越 《程序员的成长课》 作者：安晓辉，周鹏 《高效演讲：斯坦福最受欢迎的沟通课》 作者：（美国）Peter Meyers，Shann Nix 《程序员的英语》 作者：（韩国）朴栽浒，李海永 《少有人走的路》 作者：（美国）斯科特·派克 《异类：不一样的成功启示录》 作者：（加拿大）马尔科姆·格拉德威尔","link":"/2019/10/15/Computer-network-books/"},{"title":"Electron-vue","text":"Electron-vue 基于 vue (基本上是它听起来的样子) 来构造 electron 应用程序的样板代码。 什么是electron? electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。 它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用： Main进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。 Renderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在3. Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。Main进程和Renderer进程通过ipcMain和ipcRenderer来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。 起步该样板代码被构建为 vue-cli 的一个模板，并且包含多个选项，可以自定义你最终的脚手架程序。本项目需要使用 node@^7 或更高版本。electron-vue 官方推荐 yarn 作为软件包管理器，因为它可以更好地处理依赖关系，并可以使用 yarn clean 帮助减少最后构建文件的大小。 12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgreg/electron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev 项目结构12345678910111213141516171819202122232425262728293031323334353637my-project├─ .electron-vue│ └─ &lt;build/development&gt;.js files├─ build│ └─ icons/├─ dist│ ├─ electron/│ └─ web/├─ node_modules/├─ src│ ├─ main│ │ ├─ index.dev.js│ │ └─ index.js│ ├─ renderer│ │ ├─ components/│ │ ├─ router/│ │ ├─ store/│ │ ├─ App.vue│ │ └─ main.js│ └─ index.ejs├─ static/├─ test│ ├─ e2e│ │ ├─ specs/│ │ ├─ index.js│ │ └─ utils.js│ ├─ unit│ │ ├─ specs/│ │ ├─ index.js│ │ └─ karma.config.js│ └─ .eslintrc├─ .babelrc├─ .eslintignore├─ .eslintrc.js├─ .gitignore├─ package.json└─ README.md 产品构建123456789app.asar├─ dist│ └─ electron│ ├─ static/│ ├─ index.html│ ├─ main.js│ └─ renderer.js├─ node_modules/└─ package.json 运行效果","link":"/2019/09/08/Electron-vue/"},{"title":"C/C++ for VSC","text":"C/C++ for Visual Studio CodeRepository&nbsp;&nbsp;|&nbsp;&nbsp;Issues&nbsp;&nbsp;|&nbsp;&nbsp;Documentation&nbsp;&nbsp;|&nbsp;&nbsp;Code Samples&nbsp;&nbsp;|&nbsp;&nbsp;Offline Installers This preview release of the C/C++ extension adds language support for C/C++ to Visual Studio Code, including features such as IntelliSense and debugging. Overview and getting started C/C++ extension overview Get Started with C++ and Windows Subsystem for Linux (WSL) Get Started with C++ and Mingw-w64 Get Started with C++ and Clang/LLVM on macOS Get Started with C++ and Microsoft C++ compiler (MSVC) Quick links Editing features (IntelliSense) IntelliSense configuration Enhanced colorization Debugging Debug configuration Enable logging for IntelliSense or debugging Questions and feedbackFAQsCheck out the FAQs before filing a question. Provide feedbackFile questions, issues, or feature requests for the extension. Known issuesIf someone has already filed an issue that encompasses your feedback, please leave a 👍 or 👎 reaction on the issue to upvote or downvote it to help us prioritize the issue. Quick surveyLet us know what you think of the extension by taking the quick survey. Offline installationThe extension has platform-specific binary dependencies, therefore installation via the Marketplace requires an Internet connection in order to download additional dependencies. If you are working on a computer that does not have access to the Internet or is behind a strict firewall, you may need to use our platform-specific packages and install them by running VS Code’s &quot;Install from VSIX...&quot; command. These “offline’ packages are available at: https://github.com/Microsoft/vscode-cpptools/releases. Package Platform cpptools-linux.vsix Linux 64-bit cpptools-linux32.vsix Linux 32-bit cpptools-osx.vsix macOS cpptools-win32.vsix Windows 64-bit &amp; 32-bit ContributionContributions are always welcome. Please see our contributing guide for more details. Microsoft Open Source Code of ConductThis project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Data and telemetryThis extension collects usage data and sends it to Microsoft to help improve our products and services. Collection of telemetry is controlled via the same setting provided by Visual Studio Code: &quot;telemetry.enableTelemetry&quot;. Read our privacy statement to learn more.","link":"/2019/10/12/C-C-for-VSC/"},{"title":"Desition Tree","text":"目录 1. 什么是决策树 1.1 决策树的基本思想 1.2 “树”的成长过程 1.3 “树”怎么长 1.3.1 ID3算法 1.3.2 C4.5 1.3.3 CART算法 1.3.4 三种不同的决策树 2. 树形结构为什么不需要归一化? 3. 分类决策树和回归决策树的区别 4. 决策树如何剪枝 5. 代码实现 1. 什么是决策树1.1 决策树的基本思想其实用一下图片能更好的理解LR模型和决策树模型算法的根本区别，我们可以思考一下一个决策问题：是否去相亲，一个女孩的母亲要给这个女海介绍对象。 大家都看得很明白了吧！LR模型是一股脑儿的把所有特征塞入学习，而决策树更像是编程语言中的if-else一样，去做条件判断，这就是根本性的区别。 1.2 “树”的成长过程决策树基于“树”结构进行决策的，这时我们就要面临两个问题 ： “树”怎么长。 这颗“树”长到什么时候停。 弄懂了这两个问题，那么这个模型就已经建立起来了，决策树的总体流程是“分而治之”的思想，一是自根至叶的递归过程，一是在每个中间节点寻找一个“划分”属性，相当于就是一个特征属性了。接下来我们来逐个解决以上两个问题。 这颗“树”长到什么时候停 当前结点包含的样本全属于同一类别，无需划分；例如：样本当中都是决定去相亲的，属于同一类别，就是不管特征如何改变都不会影响结果，这种就不需要划分了。 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；例如：所有的样本特征都是一样的，就造成无法划分了，训练集太单一。 当前结点包含的样本集合为空，不能划分。 1.3 “树”怎么长在生活当中，我们都会碰到很多需要做出决策的地方，例如：吃饭地点、数码产品购买、旅游地区等，你会发现在这些选择当中都是依赖于大部分人做出的选择，也就是跟随大众的选择。其实在决策树当中也是一样的，当大部分的样本都是同一类的时候，那么就已经做出了决策。 我们可以把大众的选择抽象化，这就引入了一个概念就是纯度，想想也是如此，大众选择就意味着纯度越高。好，在深入一点，就涉及到一句话：信息熵越低，纯度越高。我相信大家或多或少都听说过“熵”这个概念，信息熵通俗来说就是用来度量包含的“信息量”，如果样本的属性都是一样的，就会让人觉得这包含的信息很单一，没有差异化，相反样本的属性都不一样，那么包含的信息量就很多了。 一到这里就头疼了，因为马上要引入信息熵的公式，其实也很简单： Pk表示的是：当前样本集合D中第k类样本所占的比例为Pk。 信息增益 废话不多说直接上公式： 看不懂的先不管，简单一句话就是：划分前的信息熵–划分后的信息熵。表示的是向纯度方向迈出的“步长”。 好了，有了前面的知识，我们就可以开始“树”的生长了。 1.3.1 ID3算法解释：在根节点处计算信息熵，然后根据属性依次划分并计算其节点的信息熵，用根节点信息熵–属性节点的信息熵=信息增益，根据信息增益进行降序排列，排在前面的就是第一个划分属性，其后依次类推，这就得到了决策树的形状，也就是怎么“长”了。 如果不理解的，可以查看我分享的图片示例，结合我说的，包你看懂： 第一张图.jpg 第二张图.jpg 第三张图.jpg 第四张图.jpg 不过，信息增益有一个问题：对可取值数目较多的属性有所偏好，例如：考虑将“编号”作为一个属性。为了解决这个问题，引出了另一个 算法C4.5。 1.3.2 C4.5为了解决信息增益的问题，引入一个信息增益率： 其中： 属性a的可能取值数目越多(即V越大)，则IV(a)的值通常就越大。信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。不过有一个缺点： 缺点：信息增益率偏向取值较少的特征。 使用信息增益率：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。 1.3.3 CART算法数学家真实聪明，想到了另外一个表示纯度的方法，叫做基尼指数(讨厌的公式)： 表示在样本集合中一个随机选中的样本被分错的概率。举例来说，现在一个袋子里有3种颜色的球若干个，伸手进去掏出2个球，颜色不一样的概率，这下明白了吧。Gini(D)越小，数据集D的纯度越高。 举个例子假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”， 当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下： 1.划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士} 2.划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士} 3.划分点： “硕士”，划分后的子集合 ： {博士}，{本科，硕士}} 对于上述的每一种划分，都可以计算出基于 划分特征= 某个特征值 将样本集合D划分为两个子集的纯度： 因而对于一个具有多个取值（超过2个）的特征，需要计算以每一个取值作为划分点，对样本D划分之后子集的纯度Gini(D,Ai)，(其中Ai 表示特征A的可能取值) 然后从所有的可能划分的Gini(D,Ai)中找出Gini指数最小的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。到此就可以长成一棵“大树”了。 1.3.4 三种不同的决策树 ID3：取值多的属性，更容易使数据更纯，其信息增益更大。 训练得到的是一棵庞大且深度浅的树：不合理。 C4.5：采用信息增益率替代信息增益。 CART：以基尼系数替代熵，最小化不纯度，而不是最大化信息增益。 2. 树形结构为什么不需要归一化?因为数值缩放不影响分裂点位置，对树模型的结构不造成影响。按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。而且，树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。 既然树形结构（如决策树、RF）不需要归一化，那为何非树形结构比如Adaboost、SVM、LR、Knn、KMeans之类则需要归一化。 对于线性模型，特征值差别很大时，运用梯度下降的时候，损失等高线是椭圆形，需要进行多次迭代才能到达最优点。但是如果进行了归一化，那么等高线就是圆形的，促使SGD往原点迭代，从而导致需要的迭代次数较少。 3. 分类决策树和回归决策树的区别Classification And Regression Tree(CART)是决策树的一种，CART算法既可以用于创建分类树（Classification Tree），也可以用于创建回归树（Regression Tree），两者在建树的过程稍有差异。 回归树： CART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第j个特征值进行分裂的，设该特征值小于s的样本划分为左子树，大于s的样本划分为右子树。 而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为： 因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数： 所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。 参考文章：经典算法详解–CART分类决策树、回归树和模型树 4. 决策树如何剪枝决策树的剪枝基本策略有 预剪枝 (Pre-Pruning) 和 后剪枝 (Post-Pruning)。 预剪枝：其中的核心思想就是，在每一次实际对结点进行进一步划分之前，先采用验证集的数据来验证如果划分是否能提高划分的准确性。如果不能，就把结点标记为叶结点并退出进一步划分；如果可以就继续递归生成节点。 后剪枝：后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点。 参考文章：决策树及决策树生成与剪枝 5. 代码实现GitHub：https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/3.Desition%20Tree/DecisionTree.ipynb 作者：@mantchs GitHub：https://github.com/NLP-LOVE/ML-NLP 欢迎大家加入讨论！共同完善此项目！群号：【541954936】","link":"/2019/09/27/Desition-Tree/"},{"title":"DCS-World-Steam-Edition","text":"DCS World Steam Edition Feel the excitement of flying the Su-25T “Frogfoot” attack jet and the TF-51D “Mustang” in the free-to-play Digital Combat Simulator World! The Open Beta version of Digital Combat Simulator World (DCS World) 2.5 is a free-to-play digital battlefield game and simulation environment. The “release” version will be available shortly after Open Beta testing is complete. The Open Beta is an optional version of DCS World that we use to first test new content and technologies before moving them to our release version. Our dream is to offer the most authentic and realistic simulation of military aircraft, tanks, ground vehicles and ships possible. This free download includes a vast mission area of the Caucasus region and Black Sea that encompasses much of Georgia. It also includes a flyable Russian Sukhoi Su-25T ground attack aircraft and the famous WWII North American TF-51D fighter. An additional 25 aircraft are available for purchase. The download comes with one of the most powerful mission editor ever designed, full network play and more than 156 AI weapons systems, 105 ground vehicles and trains, 50 air defense systems, 19 ships and 84 AI aircraft permitting you to plan and play highly sophisticated missions. DCS World is massively extensible through additional DCS modules as well as user-made add-ons and mods which you can purchase and download from our site. DCS is a true “sandbox” simulation that is also designed to cover multiple time periods of interest such as WWII, Korean War, Vietnam, Gulf War and others. Current regions to battle include the Caucasus, Nevada Test and Training Range, and Normandy 1944. New maps in development include the Persian, Syria, Afghanistan, and others. DCS World is fundamentally a deep, authentic and realistic simulation designed also to offer a more relaxed gameplay to suit the user and his particular level of experience and training. The ambition is to hand hold users from novice pilot all the way to the most advanced and sophisticated operator of such complex weapons systems as the A-10C Warthog or the F/A-18C Hornet. The only next step is the real thing! Key features of DCS World 2.5: The most realistic Free-to-Play digital battlefield ever. One-of-a-kind, internally developed graphics engine that looks amazing from 0 to 80,000 feet. Includes a beautiful, free, and highly detailed map of the Caucasus region that includes south western Russia and Georgia. Includes millions of buildings, millions of km of usable roads and railways, more than 50 million trees, and 20 fully– - - equipped operational airbases. Includes 156 free and fully operational weapons systems, 105 ground vehicles, 19 ships and 84 AI-controlled aircraft. Fly the TF-51 Mustang and Su-25T attack jet for free! Play all DCS World modules from one DCS World version. State-of-the-art graphics with amazing lighting, shadows, and performance. New breathtaking effects for explosions, clouds, fog, fire, and smoke. Hundreds of land, air and seaborne AI vehicles. The world is your sandbox. Create your own missions and campaigns for unlimited gameplay! Mission generator included allowing rapid mission creation. Enjoy multiplayer with friends, and even fly together in the same aircraft for multi-crew missions! Purchase and fly the most iconic airplanes and helicopters from WWII up to the modern day. Mouse interactive 6 degrees of freedom cockpits for most aircraft and the most accurate flight models, cockpit systems, sensors, targeting systems and sounds available. Purchase and fly the most authentic simulations of the A-10C Warthog, UH-1H Huey, F-86F Sabre, Spitfire, and many others now. Exciting new aircraft coming to DCS World like the F-14 Tomcat, F/A-18C Hornet, F-4E Phantom II, Mi-24P Hind, P-47D Thunderbolt, and many more! Purchase additional high-quality maps such as Normandy 1944, the Nevada Test and Training Range, and the Persian Gulf. Play hundreds of missions and campaigns with new campaigns continually created. Both hardcore realistic and casual gameplay modes and options available. MINIMUM SYSTEM REQUIREMENTS (LOW GRAPHICS SETTINGS):OS 64-bit Windows 7/8/10; DirectX11; CPU: Intel Core i3 at 2.8 GHz or AMD FX; RAM: 8 GB (16 GB for heavy missions); Free hard disk space: 60 GB; Discrete video card NVIDIA GeForce GTX 760 / AMD R9 280X or better; requires internet activation. RECOMMENDED SYSTEM REQUIREMENTS (HIGH GRAPHICS SETTINGS):OS 64-bit Windows 8/10; DirectX11; CPU: Core i5+ at 3+ GHz or AMD FX / Ryzen; RAM: 16 GB (32 GB for heavy missions); Free hard disk space: 120 GB on Solid State Drive (SSD); Discrete video card NVIDIA GeForce GTX 1070 / AMD Radeon RX VEGA 56 with 8GB VRAM or better; Joystick; requires internet activation. RECOMMENDED VR SYSTEMS REQUIREMENTS (VR GRAPHICS SETTINGS):OS 64-bit Windows 8/10; DirectX11; CPU: Core i5+ at 3+ GHz or AMD FX / Ryzen; RAM: 16 GB (32 GB for heavy missions); Free hard disk space: 120 GB on Solid State Drive (SSD); Discrete video card NVIDIA GeForce GTX 1080 / AMD Radeon RX VEGA 64 or better; Joystick; requires internet activation. 传送门","link":"/2019/10/26/DCS-World-Steam-Edition/"},{"title":"Git Rebase 黄金法则问题","text":"Git Rebase 黄金法则问题git 整合来自不同分支的修改主要有两种方法：merge 操作和rebase操作，merge初学者可能很熟悉。我们今天来主要说一下 rebase 操作，文章结尾会简单说一下 merge 操作的 –no-ff 参数问题。 rebase的简单定义：你可以把某一分支的所有修改都移至另外一个分支就像重新播放一样。有点儿像金庸武侠小说里面的乾坤大挪移。举个🌰假设我们本地库的代码，如下所示 123 A---B---C remotes/origin/master /D---E---F---G master 如果此时我们执行 git pull 操作，就会变成下面的样子，因为 pull 默认执行的是 merge 操作，多出来H这次没必要的提交。如下所示 123 A---B---C remotes/origin/master / \\D---E---F---G---H master 如果我们执行 git pull –rebase 操作，将会变成下面的样子，这里我们用rebase代替了默认的merge操作 12345 remotes/origin |D---E---A---B---C---F---G | master rebase 作用就是变成线性了，这在多人协作的情况变得非常关键。因为多人合作是不允许随意制造分叉的。大家可以参考我这篇文章。 这就引出了这篇博文要主要阐述的问题，rebase golden rule 问题。 Rebase golden rule“No one shall rebase a shared branch” — Everyone about rebase 简单来说就是不要在你的公共分支上做任何rebase操作。再举一个🌰。 图一是我们做rebase操作前的样子 图二是我们正确rebase的结果，即在feature分支执行rebase develop命令 图三是我们错误rebase的结果，即违反黄金法则的结果，我们在develop分支上执行了rebase feature操作 当我们在图三这种情况下对develop分支进行提交的话，会发现和远程分支冲突，然后我们手动或自动解决冲突，继续提交上去之后发现，我们修改的功能代码已经提交上去了，但是当我们看我们提交历史的记录的时候会发现有一部分重复的提交log。这就是问题所在，你的项目组长是绝对不允许在他的项目里出现这种情况，因为会影响后续的代码追查，code review等问题。说完了这个问题，这篇博文的主要任务基本完成了，最后在简单说一下 merge 的 –no-ff 参数，这也是我们在分支合并的时候经常遇到的问题。–no-ff 的意思就是关闭 merge 的 fast-forwarded，merge 操作默认执行的是 fast-forwarded。fast-forwarded 的意思就是在合并分支的时候，如果不涉及三方合并，git 只会简单的移动指针。再再举一个🌰 1234567 dev |A---B---C \\ D---E | feature 此时我们执行 merge –no-ff 操作，将会得到如下图 12345 dev |A---B---C--------F \\ / D---E 执行 merge 之后得到的结果如下 123 dev |A---B---C---D---E 如上git 将指针从C移到了E。 简单来说就是 –no-ff 的作用就是保持分支的非线性。方便我们看到分支的变化。 本文作者： Frank本文链接： http://hellofrank.github.io/2018/04/27/Git-Rebase-黄金法则问题/版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！","link":"/2019/09/10/Git-Rebase-黄金法则问题/"},{"title":"Github的webhooks网站自动化部署","text":"Github的webhooks进行网站自动化部署 相信很多码农都玩过了Git，如果对Git只是一知半解，可以移步LV写的 GIT常用操作总结，下面介绍到的一些关于 Git 的概念就不再赘述。 为啥想写这篇文章？主要是因为部门服务器因为安全性原因不允许SCP上传文件进行应用部署，然后有一些应用是放在Github上的，然后部署应用的步骤就变成： 1.git clone github项目 本地目录2.配置一下应用的pm2.json并reload3.Nginx配置一下反向代理并restart 当然如果只是一次性部署上去就不再修改的话并没啥问题，但是要是项目持续性修改迭代的话，就比较麻烦了，我们就在不断的重复着上面的步骤。作为一个码农，怎么允许不断的重复同样的工作，于是Github webhooks闪亮登场。 关于Github webhooks 必须是Github上面的项目 订阅了确定的事件（包括push/pull等命令） 自动触发 刚好符合了这几个条件，那接下来就看看如何进行网站自动化部署，主要会从下面几点来讲解： 自动化shell脚本 服务端实现 配置github webhooks 自动化脚本auto_build.sh 1234567#! /bin/bashSITE_PATH='/root/nginx/www'cd $SITE_PATHgit reset --hard origin/mastergit clean -fgit pullgit checkout master Note: 在执行上面shell脚本之前我们必须第一次手动git clone项目进去 服务端实现Github webhooks需要跟我们的服务器进行通信，确保是可以推送到我们的服务器，所以会发送一个带有X-Hub-Signature的POST请求，为了方便我们直接用第三方的库github-webhook-handler来接收参数并且做监听事件的处理等工作。 1npm i github-webhook-handler -S index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require('http');var spawn = require('child_process').spawn;var createHandler = require('github-webhook-handler');// 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径var handler = createHandler({ path: '/auto_build', secret: '' });http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end('no such location'); })}).listen(6666);handler.on('error', function (err) { console.error('Error:', err.message)});// 监听到push事件的时候执行我们的自动化脚本handler.on('push', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); runCommand('sh', ['auto_build.sh'], function( txt ){ console.log(txt); });});function runCommand( cmd, args, callback ){ var child = spawn( cmd, args ); var response = ''; child.stdout.on('data', function( buffer ){ resp += buffer.toString(); }); child.stdout.on('end', function(){ callback( resp ) });}// 由于我们不需要监听issues，所以下面代码注释掉// handler.on('issues', function (event) {// console.log('Received an issue event for %s action=%s: #%d %s',// event.payload.repository.name,// event.payload.action,// event.payload.issue.number,// event.payload.issue.title)}); 配置github webhooks 小结上面就是利用Github webhooks进行网站自动化部署的全部内容了，不难发现其实这项技术还是有局限性的，那就是依赖于github，一般我们选择的都是免费github账号，所有项目都对外，一些敏感项目是不适合放置上去的。","link":"/2019/09/09/Github的webhooks网站自动化部署/"},{"title":"Flutter Http请求开源库-dio","text":"文档语言: English | 中文简体 dio dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等… 添加依赖12dependencies: dio: ^x.x.x // 请使用pub上的最新版本 一个极简的示例12345678910import 'package:dio/dio.dart';void getHttp() async { try { Response response; response = await Dio().get(\"http://www.baidu.com\"); return print(response); } catch (e) { return print(e); }} 内容列表 示例 Dio APIs 请求配置 响应数据 拦截器 错误处理 使用application/x-www-form-urlencoded编码 FormData 转换器 设置Http代理 Https证书校验 请求取消 Cookie管理 Features and bugs 示例发起一个 GET 请求 : 1234567 Response response; Dio dio = new Dio(); response = await dio.get(\"/test?id=12&amp;name=wendu\") print(response.data.toString());// 请求参数也可以通过对象传递，上面的代码等同于： response = await dio.get(\"/test\", data: {\"id\": 12, \"name\": \"wendu\"}); print(response.data.toString()); 发起一个 POST 请求: 1response = await dio.post(\"/test\", data: {\"id\": 12, \"name\": \"wendu\"}); 发起多个并发请求: 1response = await Future.wait([dio.post(\"/info\"), dio.get(\"/token\")]); 下载文件: 1response = await dio.download(\"https://www.google.com/\", \"./xx.html\"); 发送 FormData: 12345FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, }); response = await dio.post(\"/info\", data: formData); 通过FormData上传多个文件: 1234567891011121314FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, \"file1\": new UploadFileInfo(new File(\"./upload.txt\"), \"upload1.txt\"), //支持直接上传字节数组 (List&lt;int&gt;) ，方便直接上传内存中的内容 \"file2\": new UploadFileInfo.fromBytes( utf8.encode(\"hello world\"), \"word.txt\"), // 支持文件数组上传 \"files\": [ new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\"), new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\") ]});response = await dio.post(\"/info\", data: formData); 监听发送(上传)数据进度: 1234567response = await dio.post( \"http://www.dtworkroom.com/doris/1/2.0.0/test\", data: {\"aa\": \"bb\" * 22}, onUploadProgress: (int sent, int total) { print(\"$sent $total\"); },); …你可以在这里获取所有示例代码. Dio APIs创建一个Dio实例，并配置它你可以使用默认配置或传递一个可选 Options参数来创建一个Dio实例 : 12345678910111213Dio dio = new Dio; // 使用默认配置// 配置dio实例 dio.options.baseUrl = \"https://www.xx.com/api\"; dio.options.connectTimeout = 5000; //5s dio.options.receiveTimeout = 3000;// 或者通过传递一个 `options`来创建dio实例 Options options = new Options( baseUrl: \"https://www.xx.com/api\", connectTimeout: 5000, receiveTimeout: 3000); Dio dio = new Dio(options); Dio实例的核心API是 : Future request(String path, {data, Options options,CancelToken cancelToken}) 12response = await request( \"/test\", data: {\"id\": 12, \"name\": \"xx\"}, new Options(method: \"GET\")); 请求方法别名为了方便使用，Dio提供了一些其它的Restful API, 这些API都是request的别名。 Future get(path, {data, Options options,CancelToken cancelToken}) Future post(path, {data, Options options,CancelToken cancelToken}) Future put(path, {data, Options options,CancelToken cancelToken}) Future delete(path, {data, Options options,CancelToken cancelToken}) Future head(path, {data, Options options,CancelToken cancelToken}) Future put(path, {data, Options options,CancelToken cancelToken}) Future path(path, {data, Options options,CancelToken cancelToken}) Future download(String urlPath, savePath,​ {OnDownloadProgress onProgress, data, bool flush: false, Options options,CancelToken cancelToken}) 请求配置下面是所有的请求配置选项。 如果请求method没有指定，则默认为GET : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ /// Http method. String method; /// 请求基地址,可以包含子路径，如: \"https://www.google.com/api/\". String baseUrl; /// Http请求头. Map&lt;String, dynamic&gt; headers; /// 连接服务器超时时间，单位是毫秒. int connectTimeout; /// 响应流上前后两次接受到数据的间隔，单位为毫秒。如果两次间隔超过[receiveTimeout]， /// [Dio] 将会抛出一个[DioErrorType.RECEIVE_TIMEOUT]的异常. /// 注意: 这并不是接收数据的总时限. int receiveTimeout; /// 请求数据,可以是任意类型. var data; /// 请求路径，如果 `path` 以 \"http(s)\"开始, 则 `baseURL` 会被忽略； 否则, /// 将会和baseUrl拼接出完整的的url. String path = \"\"; /// 请求的Content-Type，默认值是[ContentType.JSON]. /// 如果您想以\"application/x-www-form-urlencoded\"格式编码请求数据, /// 可以设置此选项为 `ContentType.parse(\"application/x-www-form-urlencoded\")`, 这样[Dio] /// 就会自动编码请求体. ContentType contentType; /// [responseType] 表示期望以那种格式(方式)接受响应数据。 /// 目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`. /// /// 默认值是 `JSON`, 当响应头中content-type为\"application/json\"时，dio 会自动将响应内容转化为json对象。 /// 如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`. /// /// 如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`. ResponseType responseType; /// `validateStatus` 决定http响应状态码是否被dio视为请求成功， 返回`validateStatus` /// 返回`true` , 请求结果就会按成功处理，否则会按失败处理. ValidateStatus validateStatus; /// 用户自定义字段，可以在 [Interceptor]、[Transformer] 和 [Response] 中取到. Map&lt;String, dynamic&gt; extra;} 这里有一个完成的示例. 响应数据当请求成功时会返回一个Response对象，它包含如下字段： 123456789101112{ /// 响应数据，可能已经被转换了类型, 详情请参考Options中的[ResponseType]. var data; /// 响应头 HttpHeaders headers; /// 本次请求信息 Options request; /// Http status code. int statusCode; /// 响应对象的自定义字段（可以在拦截器中设置它），调用方可以在`then`中获取. Map&lt;String, dynamic&gt; extra;} 示例如下: 12345Response response = await dio.get(\"https://www.google.com\");print(response.data);print(response.headers);print(response.request);print(response.statusCode); 拦截器每一个 Dio 实例都有一个请求拦截器 RequestInterceptor 和一个响应拦截器 ResponseInterceptor, 通过拦截器你可以在请求之前或响应之后(但还没有被 then 或 catchError处理)做一些统一的预处理操作。 1234567891011121314151617dio.interceptor.request.onSend = (Options options){ // 在请求被发送之前做一些事情 return options; //continue // 如果你想完成请求并返回一些自定义数据，可以返回一个`Response`对象或返回`dio.resolve(data)`。 // 这样请求将会被终止，上层then会被调用，then中返回的数据将是你的自定义数据data. // // 如果你想终止请求并触发一个错误,你可以返回一个`DioError`对象，或返回`dio.reject(errMsg)`， // 这样请求将被中止并触发异常，上层catchError会被调用。}dio.interceptor.response.onSuccess = (Response response) { // 在返回响应数据之前做一些预处理 return response; // continue};dio.interceptor.response.onError = (DioError e){ // 当请求失败时做一些预处理 return e;//continue} 如果你想移除拦截器，你可以将它们置为null: 123dio.interceptor.request.onSend = null;dio.interceptor.response.onSuccess = null;dio.interceptor.response.onError = null; 完成和终止请求/响应在所有拦截器中，你都可以改变请求执行流， 如果你想完成请求/响应并返回自定义数据，你可以返回一个 Response 对象或返回 dio.resolve(data)的结果。 如果你想终止(触发一个错误，上层catchError会被调用)一个请求/响应，那么可以返回一个DioError 对象或返回 dio.reject(errMsg) 的结果. 12345dio.interceptor.request.onSend = (Options options) { return dio.resolve(\"fake data\")}Response response = await dio.get(\"/test\");print(response.data); //\"fake data\" 拦截器中支持异步任务拦截器中不仅支持同步任务，而且也支持异步任务, 下面是在请求拦截器中发起异步任务的一个实例: 1234567 dio.interceptor.request.onSend = (Options options) async { //...If no token, request token firstly. Response response = await dio.get(\"/token\"); //Set the token to headers options.headers[\"token\"] = response.data[\"data\"][\"token\"]; return options; //continue} Lock/unlock 拦截器你可以通过调用拦截器的 lock()/unlock 方法来锁定/解锁拦截器。一旦请求/响应拦截器被锁定，接下来的请求/响应将会在进入请求/响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行(进入拦截器)。这在一些需要串行化请求/响应的场景中非常实用，后面我们将给出一个示例。 12345678910111213tokenDio = new Dio(); //Create a new instance to request the token.tokenDio.options = dio;dio.interceptor.request.onSend = (Options options) async { // If no token, request token firstly and lock this interceptor // to prevent other request enter this interceptor. dio.interceptor.request.lock(); // We use a new Dio(to avoid dead lock) instance to request token. Response response = await tokenDio.get(\"/token\"); //Set the token to headers options.headers[\"token\"] = response.data[\"data\"][\"token\"]; dio.interceptor.request.unlock(); return options; //continue} Clear() 你也可以调用拦截器的clear()方法来清空等待队列。 别名当请求拦截器被锁定时，接下来的请求将会暂停，这等价于锁住了dio实例，因此，Dio示例上提供了请求拦截器lock/unlock的别名方法： dio.lock() == dio.interceptor.request.lock() dio.unlock() == dio.interceptor.request.unlock() dio.clear() == dio.interceptor.request.clear() 示例假设这么一个场景：出于安全原因，我们需要给所有的请求头中添加一个csrfToken，如果csrfToken不存在，我们先去请求csrfToken，获取到csrfToken后，再发起后续请求。 由于请求csrfToken的过程是异步的，我们需要在请求过程中锁定后续请求（因为它们需要csrfToken), 直到csrfToken请求成功后，再解锁，代码如下： 1234567891011121314151617dio.interceptor.request.onSend = (Options options) { print('send request：path:${options.path}，baseURL:${options.baseUrl}'); if (csrfToken == null) { print(\"no token，request token firstly...\"); //lock the dio. dio.lock(); return tokenDio.get(\"/token\").then((d) { options.headers[\"csrfToken\"] = csrfToken = d.data['data']['token']; print(\"request token succeed, value: \" + d.data['data']['token']); print('continue to perform request：path:${options.path}，baseURL:${options.path}'); return options; }).whenComplete(() =&gt; dio.unlock()); // unlock the dio } else { options.headers[\"csrfToken\"] = csrfToken; return options; } }; 完整的示例代码请点击 这里. 错误处理当请求过程中发生错误时, Dio 会包装 Error/Exception 为一个 DioError: 12345678910111213141516try { //404 await dio.get(\"https://wendux.github.io/xsddddd\");} on DioError catch (e) { // The request was made and the server responded with a status code // that falls out of the range of 2xx and is also not 304. if (e.response) { print(e.response.data); print(e.response.headers); print(e.response.request); } else { // Something happened in setting up or sending the request that triggered an Error print(e.request); print(e.message); }} DioError 字段12345678910111213 { /// 响应信息, 如果错误发生在在服务器返回数据之前，它为 `null` Response response; /// 错误描述. String message; /// 错误类型，见下文 DioErrorType type; /// 错误栈信息，可能为null StackTrace stackTrace;} DioErrorType12345678910111213141516171819enum DioErrorType { /// Default error type, usually occurs before connecting the server. DEFAULT, /// When opening url timeout, it occurs. CONNECT_TIMEOUT, /// Whenever more than [receiveTimeout] (in milliseconds) passes between two events from response stream, /// [Dio] will throw the [DioError] with [DioErrorType.RECEIVE_TIMEOUT]. /// /// Note: This is not the receiving time limitation. RECEIVE_TIMEOUT, /// When the server response, but with a incorrect status, such as 404, 503... RESPONSE, /// When the request is cancelled, dio will throw a error with this type. CANCEL} 使用application/x-www-form-urlencoded编码默认情况下, Dio 会将请求数据(除过String类型)序列化为 JSON. 如果想要以 application/x-www-form-urlencoded格式编码, 你可以显式设置contentType : 1234//Instance leveldio.options.contentType=ContentType.parse(\"application/x-www-form-urlencoded\");//or works oncedio.post(\"/info\",data:{\"id\":5}, options: new Options(contentType:ContentType.parse(\"application/x-www-form-urlencoded\"))); 这里有一个示例. FormDataDio支持发送 FormData, 请求数据将会以 multipart/form-data方式编码, FormData中可以一个或多个包含文件 . 123456FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, \"file\": new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\")});response = await dio.post(\"/info\", data: formData); 注意: 只有 post 方法支持发送 FormData. 这里有一个完整的示例. 转换器转换器Transformer 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器DefaultTransformer作为默认的 Transformer. 如果你想对请求/响应数据进行自定义编解码处理，可以提供自定义转换器，通过 dio.transformer设置。 请求转换器 Transformer.transformRequest(...) 只会被用于 ‘PUT’、 ‘POST’、 ‘PATCH’方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 Transformer.transformResponse() 会被用于所有请求方法的返回数据。 执行流虽然在拦截器中也可以对数据进行预处理，但是转换器主要职责是对请求/响应数据进行编解码，之所以将转化器单独分离，一是为了和拦截器解耦，二是为了不修改原始请求数据(如果你在拦截器中修改请求数据(options.data)，会覆盖原始请求数据，而在某些时候您可能需要原始请求数据). Dio的请求流是： 请求拦截器 &gt;&gt; 请求转换器 &gt;&gt; 发起请求 &gt;&gt; 响应转换器 &gt;&gt; 响应拦截器 &gt;&gt; 最终结果。 这是一个自定义转换器的示例. 设置Http代理Dio 是使用 HttpClient发起的http请求，所以你可以通过配置 httpClient来支持代理，示例如下： 12345678dio.onHttpClientCreate = (HttpClient client) { client.findProxy = (uri) { //proxy all request to localhost:8888 return \"PROXY localhost:8888\"; }; // 你也可以自己创建一个新的HttpClient实例返回。 // return new HttpClient(SecurityContext);}; 完整的示例请查看这里. Https证书校验有两种方法可以校验https证书，假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下： 123456789String PEM=\"XXXXX\"; //证书内容dio.onHttpClientCreate = (HttpClient client) { client.badCertificateCallback=(X509Certificate cert, String host, int port){ if(cert.pem==PEM){ // 证书一致，则放行 return true; } return false; };}; X509Certificate是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。 对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到badCertificateCallback回调中： 1234567dio.onHttpClientCreate = (HttpClient client) { SecurityContext sc = new SecurityContext(); //file为证书路径 sc.setTrustedCertificates(file); HttpClient httpClient = new HttpClient(context: sc); return httpClient;}; 注意，通过setTrustedCertificates()设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。 请求取消你可以通过 cancel token 来取消发起的请求： 1234567891011CancelToken token = new CancelToken();dio.get(url, cancelToken: token) .catchError((DioError err){ if (CancelToken.isCancel(err)) { print('Request canceled! '+ err.message) }else{ // handle error. } });// cancel the requests with \"cancelled\" message.token.cancel(\"cancelled\"); 注意: 同一个cancel token 可以用于多个请求，当一个cancel token取消时，所有使用该cancel token的请求都会被取消。 完整的示例请参考取消示例. Cookie管理你可以通过 cookieJar 来自动管理请求/响应cookie. dio cookie 管理 API 是基于开源库 cookie_jar. 你可以创建一个CookieJar 或 PersistCookieJar 来帮您自动管理cookie, dio 默认使用 CookieJar , 它会将cookie保存在内存中。 如果您想对cookie进行持久化, 请使用 PersistCookieJar , 示例代码如下: 12var dio = new Dio();dio.cookieJar = new PersistCookieJar(\"./cookies\"); PersistCookieJar 实现了RFC中标准的cookie策略. PersistCookieJar 会将cookie保存在文件中，所以 cookies 会一直存在除非显式调用 delete 删除. 更多关于 cookie_jar 请参考 : https://github.com/flutterchina/cookie_jar . Copyright &amp; License此开源项目为Flutter中文网(https://flutterchina.club) 授权 ，license 是 MIT. 如果您喜欢，欢迎star. Flutter中文网开源项目计划 开发一系列Flutter SDK之外常用(实用)的Package、插件，丰富Flutter第三方库，为Flutter生态贡献来自中国开发者的力量。所有项目将发布在 Github Flutter中文网 Organization ，所有源码贡献者将加入到我们的Organization，成为成员. 目前社区已有几个开源项目开始公测，欢迎您加入开发或测试，详情请查看: Flutter中文网开源项目。 如果您想加入到“开源项目计划”， 请发邮件到824783146@qq.com， 并附上自我介绍(个人基本信息+擅长/关注技术)。 Features and bugsPlease file feature requests and bugs at the issue tracker.","link":"/2019/09/09/Flutter-Http请求开源库-dio/"},{"title":"Java反编译工具jad","text":"Jad(JAva Decompiler)Jad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。下载点击 使用方法： [1] 反编译一个class文件：jad example.class，会生成example.jad，用文本编辑器打开就是java源代码 [2] 指定生成源代码的后缀名：jad -sjava example.class，生成example.java [3] 改变生成的源代码的名称，可以先使用-p将反编译后的源代码输出到控制台窗口，然后使用重定向，输出到文件：jad -p example.class &gt; myexample.java [4] 把源代码文件输出到指定的目录：jad -dnewdir -sjava example.class，在newdir目录下生成example.java [5] 把packages目录下的class文件全部反编译：jad -sjava packages/*.class [6] 把packages目录以及子目录下的文件全部反编译：jad -sjava packages/*/.class，不过你仍然会发现所有的源代码文件被放到了同一个文件中，没有按照class文件的包路径建立起路径 [7] 把packages目录以及子目录下的文件全部反编译并建立和java包一致的文件夹路径，可以使用-r命令：jad -r -sjava packages/*/.class [8] 当重复使用命令反编译时，Jad会提示“whether you want to overwrite it or not”，使用-o可以强制覆盖旧文件 [9] 还有其他的参数可以设置生成的源代码的格式，可以输入jad命令查看帮助，这里有个人做了简单的翻译：jad命令总结 [10] 当然，你会发现有些源文件头部有些注释信息，不用找了，jad没有参数可以去掉它，用别的办法吧。 测试Main.java 123456789101112131415161718192021222324252627282930public class Main { static volatile int t = 0; public static void main(String[] args) { int n = 100; Thread[] threads = new Thread[n]; for (int i = 0; i &lt; n; i++) { threads[i] = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { add(); } } }); threads[i].start(); } while (Thread.activeCount() &gt; 1) Thread.yield(); System.out.println(t); } static void add() { t++; }} Main.class 1234567891011121314151617cafe babe 0000 0034 0037 0a00 0d00 1d07001e 0700 1f0a 0003 001d 0a00 0200 200a0002 0021 0a00 0200 220a 0002 0023 09002400 2509 000c 0026 0a00 2700 2807 00290700 2a01 000c 496e 6e65 7243 6c61 73736573 0100 0174 0100 0149 0100 063c 696e6974 3e01 0003 2829 5601 0004 436f 64650100 0f4c 696e 654e 756d 6265 7254 61626c65 0100 046d 6169 6e01 0016 285b 4c6a6176 612f 6c61 6e67 2f53 7472 696e 673b2956 0100 0d53 7461 636b 4d61 7054 61626c65 0700 2b01 0003 6164 6401 0008 3c636c69 6e69 743e 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0011 0012 0100 106a 6176 612f 6c61 6e672f54 6872 6561 6401 0006 4d61 696e 2431... 反编译后的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.kpdus.com/jad.html// Decompiler options: packimports(3) // Source File Name: Main.javaimport java.io.PrintStream;public class Main{ public Main() { } public static void main(String args[]) { byte byte0 = 100; Thread athread[] = new Thread[byte0]; for(int i = 0; i &lt; byte0; i++) { athread[i] = new Thread(new Runnable() { public void run() { for(int j = 0; j &lt; 10000; j++) Main.add(); } }); athread[i].start(); } for(; Thread.activeCount() &gt; 1; Thread.yield()); System.out.println(t); } static void add() { t++; } static volatile int t = 0;}","link":"/2019/09/06/Java反编译工具jad/"},{"title":"Java面试题（框架+JVM+多线程+算法+数据库）","text":"基础与框架 String类能被继承吗，为什么 String，Stringbuffer，StringBuilder的区别？ ArrayList和LinkedList有什么区别 类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等 HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么 什么情况下会发生栈内存溢出 什么是nio，原理 反射中，Class.forName和ClassLoader区别 tomcat结构，类加载器流程 讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式 Spring的beanFactory和factoryBean的区别 Spring加载流程 Spring如何管理事务的 多线程 线城池的最大线程数目根据什么确定 多线程的几种实现方式，什么是线程安全，什么是重排序3.volatile的原理，作用，能代替锁么 sleep和wait的区别，以及wait的实现原理 Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁 用过哪些原子类，他们的参数以及原理是什么 用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等 有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。 spring的controller是单例还是多例，怎么保证并发的安全 用三个线程按顺序循环打印abc三个字母，比如abcabcabc ThreadLocal用过么，原理是什么，用的时候要注意什么 如果让你实现一个并发安全的链表，你会怎么做 JVM相关 jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms 当出现了内存溢出，你怎么排错 JVM内存模型的相关知识了解多少 简单说说你了解的类加载器 JAVA的反射机制 网络 http1.0和http1.1有什么区别 TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么 TIME_WAIT和CLOSE_WAIT的区别 说说你知道的几种HTTP响应码 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤 Linux下IO模型有几种，各自的含义是什么 TCP/IP如何保证可靠性，数据包有哪些数据组成 架构设计与分布式： tomcat如何调优，各种参数的意义 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等 如何防止缓存雪崩12.用java自己实现一个LRU 分布式集群下如何做到唯一序列号 设计一个秒杀系统，30分钟没付款就自动关闭交易 如何做一个分布式锁 用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 MQ系统的数据如何保证不丢失 分布式事务的原理，如何使用分布式事务 什么是一致性hash 什么是restful，讲讲你理解的restful 如何设计建立和保持100w的长连接？ 解释什么是MESI协议(缓存一致性) 说说你知道的几种HASH算法，简单的也可以 什么是paxos算法 redis和memcached 的内存管理的区别 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新 算法 10亿个数字里里面找最小的10个2、有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优3、2亿个随机生成的无序整数,找出中间大小的值4、遍历二叉树六、数据库1.数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点 高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义 SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？ 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁 MYsql的索引实现方式 聚集索引和非聚集索引的区别 数据库中 BTREE和B+tree区别 作者：程序汪追风链接：https://juejin.im/post/5d5fd40bf265da03df5f1b3a来源：掘金","link":"/2019/08/24/Java面试题（框架-JVM-多线程-算法-数据库）/"},{"title":"Java12的新特性","text":"Java12的新特性 Java5的新特性Java6的新特性Java7的新特性Java8的新特性Java9的新特性Java10的新特性Java11的新特性Java12的新特性Java13的新特性 版本号1234java -versionopenjdk version &quot;12&quot; 2019-03-19OpenJDK Runtime Environment (build 12+33)OpenJDK 64-Bit Server VM (build 12+33, mixed mode) 从version信息可以看出是build 12+33 特性列表 189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental) Shenandoah GC是一个面向low-pause-time的垃圾收集器，它最初由Red Hat实现，支持aarch64及amd64 architecture；ZGC也是面向low-pause-time的垃圾收集器，不过ZGC是基于colored pointers来实现，而Shenandoah GC是基于brooks pointers来实现；如果要使用Shenandoah GC需要编译时–with-jvm-features选项带有shenandoahgc，然后启动时使用-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC 230: Microbenchmark Suite 在jdk源码里头新增了一套基础的microbenchmarks suite 325: Switch Expressions (Preview) 对switch进行了增强，除了使用statement还可以使用expression，比如原来的写法如下： 1234567891011121314151617switch (day) { case MONDAY: case FRIDAY: case SUNDAY: System.out.println(6); break; case TUESDAY: System.out.println(7); break; case THURSDAY: case SATURDAY: System.out.println(8); break; case WEDNESDAY: System.out.println(9); break;} 现在可以改为如下写法： 123456switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6); case TUESDAY -&gt; System.out.println(7); case THURSDAY, SATURDAY -&gt; System.out.println(8); case WEDNESDAY -&gt; System.out.println(9);} 以及在表达式返回值 123456int numLetters = switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; 6; case TUESDAY -&gt; 7; case THURSDAY, SATURDAY -&gt; 8; case WEDNESDAY -&gt; 9;}; 对于需要返回值的switch expression要么正常返回值要么抛出异常，以下这两种写法都是错误的 1234567891011121314int i = switch (day) { case MONDAY -&gt; { System.out.println(\"Monday\"); // ERROR! Block doesn't contain a break with value } default -&gt; 1;};i = switch (day) { case MONDAY, TUESDAY, WEDNESDAY: break 0; default: System.out.println(\"Second half of the week\"); // ERROR! Group doesn't contain a break with value}; 334: JVM Constants API 新增了JVM Constants API，具体来说就是java.base模块新增了java.lang.constant包，引入了ConstantDesc接口(ClassDesc、MethodTypeDesc、MethodHandleDesc这几个接口直接继承了ConstantDesc接口)以及Constable接口；ConstantDesc接口定义了resolveConstantDesc方法，Constable接口定义了describeConstable方法；String、Integer、Long、Float、Double均实现了这两个接口，而EnumDesc实现了ConstantDesc接口 340: One AArch64 Port, Not Two 64-bit Arm platform (arm64)，也可以称之为aarch64；之前JDK有两个关于aarch64的实现，分别是src/hotspot/cpu/arm以及open/src/hotspot/cpu/aarch64，它们的实现重复了，为了集中精力更好地实现aarch64，该特性在源码中删除了open/src/hotspot/cpu/arm中关于64-bit的实现，保留其中32-bit的实现，于是open/src/hotspot/cpu/aarch64部分就成了64-bit ARM architecture的默认实现 341: Default CDS Archives java10的新特性JEP 310: Application Class-Data Sharing扩展了JDK5引入的Class-Data Sharing，支持application的Class-Data Sharing；Class-Data Sharing可以用于多个JVM共享class，提升启动速度，最早只支持system classes及serial GC，JDK9对其进行扩展以支持application classes及其他GC算法，并在JDK10中开源出来(以前是commercial feature)；JDK11将-Xshare:off改为默认-Xshare:auto，以更加方便使用CDS特性；JDK12的这个特性即在64-bit平台上编译jdk的时候就默认在${JAVA_HOME}/lib/server目录下生成一份名为classes.jsa的默认archive文件(大概有18M)方便大家使用 344: Abortable Mixed Collections for G1 G1在garbage collection的时候，一旦确定了collection set(CSet)开始垃圾收集这个过程是without stopping的，当collection set过大的时候，此时的STW时间会过长超出目标pause time，这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，允许将其分为mandatory及optional两部分(当完成mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标 346: Promptly Return Unused Committed Memory from G1 G1目前只有在full GC或者concurrent cycle的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时会还committed Java heap memory给操作系统。JDK12的这个特性新增了两个参数分别是G1PeriodicGCInterval及G1PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。当上一次garbage collection pause过去G1PeriodicGCInterval(milliseconds)时间之后，如果getloadavg()(one-minute)低于G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(如果开启G1PeriodicGCInvokesConcurrent)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统 细项解读上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见JDK 12 Release Notes，这里举几个例子。添加项 支持unicode 11 支持Compact Number Formatting 使用实例如下 12345678910@Testpublic void testCompactNumberFormat(){ var cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT); System.out.println(cnf.format(1_0000)); System.out.println(cnf.format(1_9200)); System.out.println(cnf.format(1_000_000)); System.out.println(cnf.format(1L &lt;&lt; 30)); System.out.println(cnf.format(1L &lt;&lt; 40)); System.out.println(cnf.format(1L &lt;&lt; 50));} 输出 1234561万2万100万11亿1兆1126兆 String支持transform、indent操作 1234567891011121314@Testpublic void testStringTransform(){ System.out.println(\"hello\".transform(new Function&lt;String, Integer&gt;() { @Override public Integer apply(String s) { return s.hashCode(); } }));}@Testpublic void testStringIndent(){ System.out.println(\"hello\".indent(3));} Files新增mismatch方法 12345678910111213141516@Testpublic void testFilesMismatch() throws IOException { FileWriter fileWriter = new FileWriter(\"/tmp/a.txt\"); fileWriter.write(\"a\"); fileWriter.write(\"b\"); fileWriter.write(\"c\"); fileWriter.close(); FileWriter fileWriterB = new FileWriter(\"/tmp/b.txt\"); fileWriterB.write(\"a\"); fileWriterB.write(\"1\"); fileWriterB.write(\"c\"); fileWriterB.close(); System.out.println(Files.mismatch(Path.of(\"/tmp/a.txt\"),Path.of(\"/tmp/b.txt\")));} Collectors新增teeing方法用于聚合两个downstream的结果 1234567891011@Testpublic void testCollectorTeeing(){ var result = Stream.of(\"Devoxx\",\"Voxxed Days\",\"Code One\",\"Basel One\") .collect(Collectors.teeing(Collectors.filtering(n -&gt; n.contains(\"xx\"),Collectors.toList()), Collectors.filtering(n -&gt; n.endsWith(\"One\"),Collectors.toList()), (List&lt;String&gt; list1, List&lt;String&gt; list2) -&gt; List.of(list1,list2) )); System.out.println(result.get(0)); System.out.println(result.get(1));} CompletionStage新增exceptionallyAsync、exceptionallyCompose、exceptionallyComposeAsync方法 1234567891011121314@Testpublic void testExceptionallyAsync() throws ExecutionException, InterruptedException { LOGGER.info(\"begin\"); int result = CompletableFuture.supplyAsync(() -&gt; { LOGGER.info(\"calculate\"); int i = 1/0; return 100; }).exceptionallyAsync((t) -&gt; { LOGGER.info(\"error error:{}\",t.getMessage()); return 0; }).get(); LOGGER.info(\"result:{}\",result);} JDK12之前CompletionStage只有一个exceptionally，该方法体在主线程执行，JDK12新增了exceptionallyAsync、exceptionallyComposeAsync方法允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage Allocation of Old Generation of Java Heap on Alternate Memory Devices G1及Parallel GC引入experimental特性，允许将old generation分配在诸如NV-DIMM memory的alternative memory device ZGC: Concurrent Class Unloading ZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用 新增-XX:+ExtensiveErrorReports -XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数 新增安全相关的改进 支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationExceptionkeytool新增-groupname选项允许在生成key pair的时候指定一个named group新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成Java Flight Recorder新增了security-related的event支持ChaCha20 and Poly1305 TLS Cipher Suites jdeps Reports Transitive Dependences jdeps的–print-module-deps, –list-deps, 以及–list-reduce-deps选项得到增强，新增–no-recursive用于non-transitive的依赖分析，–ignore-missing-deps用于suppress missing dependence errors 移除项 移除com.sun.awt.SecurityWarnin 移除FileInputStream、FileOutputStream、Java.util.ZipFile/Inflator/Deflator的finalize方法 移除GTE CyberTrust Global Root 移除javac的-source, -target对6及1.6的支持，同时移除–release选项 废弃项 废弃的API列表见deprecated-list 废弃-XX:+/-MonitorInUseLists选项 废弃Default Keytool的-keyalg值 已知问题 Swing不支持GTK+ 3.20及以后的版本 在使用JVMCI Compiler(比如Graal)的时候，JVMTI的can_pop_frame及can_force_early_return的capabilities是被禁用的 其他事项 如果用户没有指定user.timezone且从操作系统获取的为空，那么user.timezone属性的初始值为空变为null java.net.URLPermission的行为发生轻微变化，以前它会忽略url中的query及fragment部分，这次改动新增query及fragment部分，即scheme : // authority [ / path ]变动为scheme : // authority [ / path ] [ ignored-query-or-fragment ] javax.net.ssl.SSLContext API及Java Security Standard Algorithm Names规范移除了必须实现TLSv1及TLSv1.1的规定 小结 java12不是LTS(Long-Term Support)版本(oracle版本才有LTS)，oracle对该版本的support周期为6个月。这个版本主要有几个更新点，一个是语法层更新，一个是API层面的更新，另外主要是GC方面的更新。 语法层面引入了preview版本的Switch Expressions；API层面引入了JVM Constants API，引入CompactNumberFormat，让NumberFormat支持COMPACTSTYLE，对String、Files、Collectors、CompletionStage等新增方法；GC方面引入了experimental版本的Shenandoah GC，不过oracle build的openjdk没有enable Shenandoah GC support；另外主要对ZGC及G1 GC进行了改进 其中JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用；对于G1 GC则新增支持Abortable Mixed Collections以及Promptly Return Unused Committed Memory特性 作者：go4it链接：https://juejin.im/post/5c91fcc9e51d45563b62382c来源：掘金","link":"/2019/09/16/Java12的新特性/"},{"title":"Java面试题","text":"基础与框架String类能被继承吗，为什么? 不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final不能用于修饰构造方法。 注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。 使用final方法的原因有二： 第一、把方法锁定，防止任何继承类修改它的意义和实现。 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑） 下面这段话摘自《Java编程思想》第四版第143页：“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。” 关于String类，要了解常量池的概念 1String s = new String(“xyz”); //创建了几个对象 答案： 1个或2个， 如果”xyz”已经存在于常量池中，则只在堆中创建”xyz”对象的一个拷贝，否则还要在常量池中在创建一份 1String s = \"a\"+\"b\"+\"c\"+\"d\"; //创建了几个对象 答案： 这个和JVM实现有关， 如果常量池为空，可能是1个也可能是7个等 String，Stringbuffer，StringBuilder的区别？1、用来处理字符串常用的类有3种：String、StringBuffer和StringBuilder2、三者之间的区别：都是final类，都不允许被继承；String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；StringBuffer类是线程安全的，StringBuilder不是线程安全的； String 和 StringBuffer：1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低； 2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况； 3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如： 12String s1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换： 12345Java Compiler直接把上述第一条语句编译为：String s2 = “This is only a”;String s3 = “ simple”;String s4 = “ test”;String s1 = s2 + s3 + s4; 传送门 ArrayList和LinkedList有什么区别ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。 数据的更新和查找ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻 数据的增加和删除对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。 传送门 类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量（父类实例成员变量）、父类构造函数、子类非静态变量（子类实例成员变量）、子类构造函数。 传送门 用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等 Hashtable,HashMap,ConcurrentHashMap 线程不安全的HashMap因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。 HashMapHashMap内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。其中每个结点存储的是一个键值对整体（Entry），HashMap采用拉链法解决哈希冲突 传送门 效率低下的HashTable容器 HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。 ConcurrentHashMap的锁分段技术 HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 传送门 hashcode() 方法，在object类中定义如下： 1public native int hashCode(); native说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double。。。。等等这些类都是覆盖了hashcode()方法的例如String类中:就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。(为什么取31?主要是因为31是一个奇质数，所以31i=32i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多). 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发 HashMap 底层是基于 数组 + 链表 组成的 传送门 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么 实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。抽象类和接口的区别 由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 接口可以继承多个接口。java类是单继承的。classB Extends classAjava接口可以多继承。Interface3 Extends Interface0, Interface1, interface……不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。 什么情况下会发生栈内存溢出方法递归调用产生这种结果 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化） 所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。栈溢出(StackOverflowError) 什么是nio，原理 NIO是为了弥补传统I/O工作模式的不足而研发的，NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型I/O能力。 NIO的工作原理是什么？ 在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O操作完成即可返回，从而减少了管理I/O连接导致的系统开销，大幅度提高了系统性能。 当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。 并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络I/O设计的并发型服务器程序与以往基于阻塞I/O的实现程序有很大不同，在使用非阻塞网络I/O的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。 使用非阻塞型I/O进行并发型服务器程序设计分三个部分：1. 向Selector对象注册感兴趣的事件；2.从Selector中获取所感兴趣的事件；3. 根据不同的事件进行相应的处理。 在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展。 传送门 反射中，Class.forName和ClassLoader区别Java中Class.forName和classloader都可以用来对类进行加载。 Class.forName(“className”); 其实这种方法调运的是：Class.forName(className, true, ClassLoader.getCallerClassLoader())方法 参数一：className，需要加载的类的名称。 参数二：true，是否对class进行初始化（需要initialize） 参数三：classLoader，对应的类加载器 ClassLoader.laodClass(“className”); 其实这种方法调运的是：ClassLoader.loadClass(name, false)方法 参数一：name,需要加载的类的名称 参数二：false，这个类加载以后是否需要去连接（不需要linking） 可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。 而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。 传送门 tomcat结构，类加载器流程 Tomcat 的总体结构 从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。 什么是类加载器？虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 传送门 讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式Spring的beanFactory和factoryBean的区别Spring加载流程Spring如何管理事务的多线程线城池的最大线程数目根据什么确定多线程的几种实现方式，什么是线程安全，什么是重排序volatile的原理，作用，能代替锁么sleep和wait的区别，以及wait的实现原理Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁用过哪些原子类，他们的参数以及原理是什么用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。spring的controller是单例还是多例，怎么保证并发的安全用三个线程按顺序循环打印abc三个字母，比如abcabcabcThreadLocal用过么，原理是什么，用的时候要注意什么如果让你实现一个并发安全的链表，你会怎么做JVM相关jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms当出现了内存溢出，你怎么排错JVM内存模型的相关知识了解多少简单说说你了解的类加载器JAVA的反射机制网络http1.0和http1.1有什么区别TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么TIME_WAIT和CLOSE_WAIT的区别说说你知道的几种HTTP响应码当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤Linux下IO模型有几种，各自的含义是什么TCP/IP如何保证可靠性，数据包有哪些数据组成架构设计与分布式：tomcat如何调优，各种参数的意义常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等如何防止缓存雪崩12.用java自己实现一个LRU分布式集群下如何做到唯一序列号设计一个秒杀系统，30分钟没付款就自动关闭交易如何做一个分布式锁用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗MQ系统的数据如何保证不丢失分布式事务的原理，如何使用分布式事务什么是一致性hash什么是restful，讲讲你理解的restful如何设计建立和保持100w的长连接？解释什么是MESI协议(缓存一致性)说说你知道的几种HASH算法，简单的也可以什么是paxos算法redis和memcached 的内存管理的区别一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新算法10亿个数字里里面找最小的10个有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优2亿个随机生成的无序整数,找出中间大小的值遍历二叉树数据库数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁MYsql的索引实现方式聚集索引和非聚集索引的区别数据库中 BTREE和B+tree区别","link":"/2019/09/13/Java面试题/"},{"title":"Java知识点","text":"Java相关请问JDK和JRE的区别是什么？ JDK ：Java 开发工具包,jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。JRE ：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。 springboot的注解有什么，原理？@Bean用来代替 XML 配置文件里面的 &lt;bean …&gt; 配置。@ImportResource如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 @Configuration 方式配置的非常管用。@Import用来引入额外的一个或者多个 @Configuration 修饰的配置文件类。@SpringBootConfiguration这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。@EnableAutoConfiguration 自动配置。@ComponentScan 组件扫描，可自动发现和装配一些Bean。@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。@Autowired自动导入。@PathVariable获取参数。@JsonBackReference解决嵌套外链问题。@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。 @RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 @RequestParam：用在方法的参数前面。@RequestParamString a =request.getParameter(“a”)。 @PathVariable:路径变量。如 1234@RequestMapping(“user/get/mac/{macAddress}”) public String getByMacAddress(@PathVariable String macAddress){ //do something; } Spring Boot的自动配置看起来神奇，其实原理非常简单，背后全依赖于@Conditional注解来实现的。 object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法: 1public native int hashCode(); 根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。 hashCode方法的作用 对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在） 也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。 hash 算法 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。 如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。 但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。 总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。 hashmap的put过程 主要就是根据自己看过的源码说一下流程put 方法通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。 123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 判断数组是否为空，如果是空，则创建默认长度位 16 的数组。 通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。 如果有元素，说明 hash 冲突了，则再次进行 3 种判断。 判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。 如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。 如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。 最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。 对维护着迭代器的modCount 变量加一。 最后判断，如果当前数组的长度已经大于阀值了。则重新hash。 ArrayList LinkList的特点ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。 数据的更新和查找ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻 数据的增加和删除对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。 红黑树定义红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。 它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。 由于 TreeMap 就是由红黑树实现的。 黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。 每个节点要么是红色，要么是黑色； 根节点永远是黑色的； 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）； 每个红色节点的两个子节点一定都是黑色； 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点； Java 反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 123456public class FatherClass { public String mFatherName; public int mFatherAge; public void printFatherMsg(){}} 多线程相关synchronizedsynchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。 锁机制有如下两种特性： 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。 synchronized 可以修饰方法和代码块 synchronized(this|object) {} synchronized(类.class) {} 修饰非静态方法 修饰静态方法 reentrantLock 除了可重入还有什么关键特性 可重入 现在有方法 m1 和 m2，两个方法均使用了同一把锁对方法进行同步控制，同时方法 m1 会调用 m2。线程 t 进入方法 m1 成功获得了锁，此时线程 t 要在没有释放锁的情况下，调用 m2 方法。由于 m1 和 m2 使用的是同一把可重入锁，所以线程 t 可以进入方法 m2，并再次获得锁，而不会被阻塞住。 公平和非公平锁 公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法ReentrantLock(boolean fair)调整加锁的模式。 ThreadLocal 会造成什么问题? 为什么会造成内存泄漏? ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型。 总结：ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。 ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。 ThreadLocal类提供了四个对外开放的接口方法 (1) void set(Object value)设置当前线程的线程局部变量的值。(2) public Object get()该方法返回当前线程所对应的线程局部变量。(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用。(4) protected Object initialValue()返回该线程局部变量的初始值。 在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。 最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的就可能出现内存泄露。（在web应用中，每次http请求都是一个线程，tomcat容器配置使用线程池时会出现内存泄漏问题） 使用ThreadLocal，建议用static修饰 static ThreadLocal headerLocal = new ThreadLocal(); 使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。 单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？内部类 单例模式，有“懒汉式”和“饿汉式”两种。懒汉式单例类的实例在第一次被引用时候才被初始化。饿汉式单例类的实例在加载的时候就被初始化。 静态内部类模式 12345678910public class Singleton { private Singleton(){ } public static Singleton getSingleton(){ return Inner.instance; } private static class Inner { private static final Singleton instance = new Singleton(); } } 实现代码简洁。和双重检查单例对比，静态内部类单例实现代码真的是太简洁，又清晰明了。 延迟初始化。调用getSingleton才初始化Singleton对象。 线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。 线程A和线程B同时试图获得Singleton对象的初始化锁，假设线程A获取到了，那么线程B一直等待初始化锁。线程A执行类初始化，就算双重检查模式中伪代码发生了重排序，也不会影响线程A的初始化结果。初始化完后，释放锁。线程B获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。 数据库相关添加索引的时候要注意什么索引可以提高数据的访问速度，但同时也增加了插入、更新和删除操作的处理时间。所以是否要为表增加索引、索引建立在那些字段上，是创建索引前必须要考虑的问题。解决此问题就是分析应用程序的业务处理、数据使用，为经常被用作查询条件、或者被要求排序的字段建立索引。 1、表的主键、外键必须有索引；2、数据量超过300的表应该有索引；3、经常与其他表进行连接的表，在连接字段上应该建立索引；4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；5、索引应该建在选择性高的字段上；6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；7、复合索引的建立需要进行仔细分析； 聚簇索引:通常由主键或者非空唯一索引实现的，叶子节点存储了一整行数据非聚簇索引：又称二级索引，就是我们常用的普通索引，叶子节点存了索引值和主键值，在根据主键从聚簇索引查 索引优化以及在使用索引的时候要注意什么1.索引列不要使用函数和运算 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符 当查询条件为多个的时候，可以采用复合索引 范围查询对多列查询的影响 遵循最左匹配原则 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。 索引列不会包含NULL值 尽量避免使用 or 来连接条件 隐式转换的影响 like 语句的索引失效问题 redis的键的淘汰策略，会达成了redis缓存的淘汰策略Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。事实上，实例中的内存除了保存原始的键值对所需的开销外，还有一些运行时产生的额外内存，包括： 垃圾数据和过期Key所占空间 字典渐进式Rehash导致未及时删除的空间 Redis管理数据，包括底层数据结构开销，客户端信息，读写缓冲区等 主从复制，bgsave时的额外开销 为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。 访问Key时，会判断Key是否过期，逐出过期Key; CPU空闲时在定期serverCron任务中，逐出部分过期Key; 每次事件循环执行的时候，逐出部分过期Key; 网络相关tcp四次握手，最后的状态是什么?等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2） 为什么要等着2MSL，等待多了会造成什么 保证A发送的最后一个ACK报文段能够到达B。 防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 http请求的报文结构，keep-alive是用来做什么的当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。 12Keep-Alive: timeout=5, max=100timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接 spring spingbootspring为什么要注入接口，而不是实现类首先说明，注入的对象确实为实现类的对象。（并不是实现类的代理对象，注入并不涉及代理） 如果只是单纯注入是可以用实现类接收注入对象的，但是往往开发中会对实现类做增强，如事务，日志等，实现增强的AOP技术是通过动态代理实现的，而spring默认是JDK动态代理，对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。 回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程 Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果目标对象没有实现接口我们该如何代理呢？这时候我们就需要使用CGLIB来实现AOP了。 假如我们要使用动态代理实现AOP，那么我们只能在写一个增强的接口，然后让目标类实现增强接口，然后我们就可以使用动态代理实现目标类的增强，可是假如我们不想让目标类实现其他的接口，那么我们就只能使用CGLIB技术来实现目标类的增强了。CGLIB实现目标类增强的原理是这样的：CGLIB会动态创建一个目标类的子类，然后返回该子类的对象，也就是增强对象，至于增强的逻辑则是在子类中完成的。我们知道子类要么和父类有一样的功能，要么就比父类功能强大，所以CGLIB是通过创建目标类的子类对象来实现增强的，所以： 1目标子类 = 目标类 + 增强逻辑 口述算法思路给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）最小值思路：用一个辅助栈stack2记住每次入栈stack1的当前最小值:在stack1入栈时，往stack2中加入当前最小值；stack1元素出栈时，stack2也出栈一个元素。最小值从stack2中获取及栈顶元素。O(1) 最大值思路：同上O(1) 网络编程哪几种IO类型 阻塞I/O（blocking IO） 非阻塞I/O (nonblocking I/O) I/O 复用 (I/O multiplexing) 信号驱动I/O (signal driven I/O (SIGIO)) 异步I/O (asynchronous I/O) JVMJVM的内存结构 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。 方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。 类加载机制Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。 双亲委派模型双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。 双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。 有什么想问我的有的 你怎样形容小米公司的企业文化？ 什么类型的员工能在小米公司有比较好的发展？ 关于软件开发工程师-Java方向岗位的技术栈、日常主要工作是什么、期间可以获得晋升机会？ 能给我多讲讲招聘程序吗？ 我没有其他问题了，与您交流非常愉快，能留一张您的名片么？（或者方便加一下您的微信么？）","link":"/2019/09/20/Java知识点/"},{"title":"LinkedList类","text":"LinkedList类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242/* * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */package java.util;import java.util.function.Consumer;/** * Doubly-linked list implementation of the {@code List} and {@code Deque} * interfaces. Implements all optional list operations, and permits all * elements (including {@code null}). * * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked * list. Operations that index into the list will traverse the list from * the beginning or the end, whichever is closer to the specified index. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked list concurrently, and at least * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more elements; merely setting the value of * an element is not a structural modification.) This is typically * accomplished by synchronizing on some object that naturally * encapsulates the list. * * If no such object exists, the list should be \"wrapped\" using the * {@link Collections#synchronizedList Collections.synchronizedList} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the list:&lt;pre&gt; * List list = Collections.synchronizedList(new LinkedList(...));&lt;/pre&gt; * * &lt;p&gt;The iterators returned by this class's {@code iterator} and * {@code listIterator} methods are &lt;i&gt;fail-fast&lt;/i&gt;: if the list is * structurally modified at any time after the iterator is created, in * any way except through the Iterator's own {@code remove} or * {@code add} methods, the iterator will throw a {@link * ConcurrentModificationException}. Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than * risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw {@code ConcurrentModificationException} on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=\"{@docRoot}/../technotes/guides/collections/index.html\"&gt; * Java Collections Framework&lt;/a&gt;. * * @author Josh Bloch * @see List * @see ArrayList * @since 1.2 * @param &lt;E&gt; the type of elements held in this collection */public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{ transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** * Constructs an empty list. */ public LinkedList() { } /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } /** * Links e as first element. */ private void linkFirst(E e) { final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; } /** * Links e as last element. */ void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } /** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } /** * Unlinks non-null first node f. */ private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) { // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; } /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } /** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */ public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } /** * Returns the last element in this list. * * @return the last element in this list * @throws NoSuchElementException if this list is empty */ public E getLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } /** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */ public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } /** * Removes and returns the last element from this list. * * @return the last element from this list * @throws NoSuchElementException if this list is empty */ public E removeLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } /** * Inserts the specified element at the beginning of this list. * * @param e the element to add */ public void addFirst(E e) { linkFirst(e); } /** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to {@link #add}. * * @param e the element to add */ public void addLast(E e) { linkLast(e); } /** * Returns {@code true} if this list contains the specified element. * More formally, returns {@code true} if and only if this list contains * at least one element {@code e} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return {@code true} if this list contains the specified element */ public boolean contains(Object o) { return indexOf(o) != -1; } /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() { return size; } /** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to {@link #addLast}. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */ public boolean add(E e) { linkLast(e); return true; } /** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * {@code i} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns {@code true} if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return {@code true} if this list contained the specified element */ public boolean remove(Object o) { if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the specified * collection's iterator. The behavior of this operation is undefined if * the specified collection is modified while the operation is in * progress. (Note that this will occur if the specified collection is * this list, and it's nonempty.) * * @param c collection containing elements to be added to this list * @return {@code true} if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c); } /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return {@code true} if this list changed as a result of the call * @throws IndexOutOfBoundsException {@inheritDoc} * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } /** * Removes all of the elements from this list. * The list will be empty after this call returns. */ public void clear() { // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) { Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; modCount++; } // Positional Access Operations /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException {@inheritDoc} */ public E get(int index) { checkElementIndex(index); return node(index).item; } /** * Replaces the element at the specified position in this list with the * specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException {@inheritDoc} */ public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } /** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } /** * Tells if the argument is the index of an existing element. */ private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } /** * Tells if the argument is the index of a valid position for an * iterator or an add operation. */ private boolean isPositionIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt;= size; } /** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */ private String outOfBoundsMsg(int index) { return \"Index: \"+index+\", Size: \"+size; } private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private void checkPositionIndex(int index) { if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * Returns the (non-null) Node at the specified element index. */ Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } // Search Operations /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index {@code i} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the first occurrence of the specified element in * this list, or -1 if this list does not contain the element */ public int indexOf(Object o) { int index = 0; if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } /** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index {@code i} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the last occurrence of the specified element in * this list, or -1 if this list does not contain the element */ public int lastIndexOf(Object o) { int index = size; if (o == null) { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { index--; if (x.item == null) return index; } } else { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { index--; if (o.equals(x.item)) return index; } } return -1; } // Queue operations. /** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */ public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; } /** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */ public E element() { return getFirst(); } /** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */ public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); } /** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */ public E remove() { return removeFirst(); } /** * Adds the specified element as the tail (last element) of this list. * * @param e the element to add * @return {@code true} (as specified by {@link Queue#offer}) * @since 1.5 */ public boolean offer(E e) { return add(e); } // Deque operations /** * Inserts the specified element at the front of this list. * * @param e the element to insert * @return {@code true} (as specified by {@link Deque#offerFirst}) * @since 1.6 */ public boolean offerFirst(E e) { addFirst(e); return true; } /** * Inserts the specified element at the end of this list. * * @param e the element to insert * @return {@code true} (as specified by {@link Deque#offerLast}) * @since 1.6 */ public boolean offerLast(E e) { addLast(e); return true; } /** * Retrieves, but does not remove, the first element of this list, * or returns {@code null} if this list is empty. * * @return the first element of this list, or {@code null} * if this list is empty * @since 1.6 */ public E peekFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; } /** * Retrieves, but does not remove, the last element of this list, * or returns {@code null} if this list is empty. * * @return the last element of this list, or {@code null} * if this list is empty * @since 1.6 */ public E peekLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; } /** * Retrieves and removes the first element of this list, * or returns {@code null} if this list is empty. * * @return the first element of this list, or {@code null} if * this list is empty * @since 1.6 */ public E pollFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); } /** * Retrieves and removes the last element of this list, * or returns {@code null} if this list is empty. * * @return the last element of this list, or {@code null} if * this list is empty * @since 1.6 */ public E pollLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); } /** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to {@link #addFirst}. * * @param e the element to push * @since 1.6 */ public void push(E e) { addFirst(e); } /** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * * &lt;p&gt;This method is equivalent to {@link #removeFirst()}. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */ public E pop() { return removeFirst(); } /** * Removes the first occurrence of the specified element in this * list (when traversing the list from head to tail). If the list * does not contain the element, it is unchanged. * * @param o element to be removed from this list, if present * @return {@code true} if the list contained the specified element * @since 1.6 */ public boolean removeFirstOccurrence(Object o) { return remove(o); } /** * Removes the last occurrence of the specified element in this * list (when traversing the list from head to tail). If the list * does not contain the element, it is unchanged. * * @param o element to be removed from this list, if present * @return {@code true} if the list contained the specified element * @since 1.6 */ public boolean removeLastOccurrence(Object o) { if (o == null) { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } /** * Returns a list-iterator of the elements in this list (in proper * sequence), starting at the specified position in the list. * Obeys the general contract of {@code List.listIterator(int)}.&lt;p&gt; * * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally * modified at any time after the Iterator is created, in any way except * through the list-iterator's own {@code remove} or {@code add} * methods, the list-iterator will throw a * {@code ConcurrentModificationException}. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * @param index index of the first element to be returned from the * list-iterator (by a call to {@code next}) * @return a ListIterator of the elements in this list (in proper * sequence), starting at the specified position in the list * @throws IndexOutOfBoundsException {@inheritDoc} * @see List#listIterator(int) */ public ListIterator&lt;E&gt; listIterator(int index) { checkPositionIndex(index); return new ListItr(index); } private class ListItr implements ListIterator&lt;E&gt; { private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) { // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; } public boolean hasNext() { return nextIndex &lt; size; } public E next() { checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; } public boolean hasPrevious() { return nextIndex &gt; 0; } public E previous() { checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; } public int nextIndex() { return nextIndex; } public int previousIndex() { return nextIndex - 1; } public void remove() { checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; } public void set(E e) { if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; } public void add(E e) { checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; } public void forEachRemaining(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) { action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; } checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } /** * @since 1.6 */ public Iterator&lt;E&gt; descendingIterator() { return new DescendingIterator(); } /** * Adapter to provide descending iterators via ListItr.previous */ private class DescendingIterator implements Iterator&lt;E&gt; { private final ListItr itr = new ListItr(size()); public boolean hasNext() { return itr.hasPrevious(); } public E next() { return itr.previous(); } public void remove() { itr.remove(); } } @SuppressWarnings(\"unchecked\") private LinkedList&lt;E&gt; superClone() { try { return (LinkedList&lt;E&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e); } } /** * Returns a shallow copy of this {@code LinkedList}. (The elements * themselves are not cloned.) * * @return a shallow copy of this {@code LinkedList} instance */ public Object clone() { LinkedList&lt;E&gt; clone = superClone(); // Put clone into \"virgin\" state clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // Initialize clone with our elements for (Node&lt;E&gt; x = first; x != null; x = x.next) clone.add(x.item); return clone; } /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be \"safe\" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list * in proper sequence */ public Object[] toArray() { Object[] result = new Object[size]; int i = 0; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; return result; } /** * Returns an array containing all of the elements in this list in * proper sequence (from first to last element); the runtime type of * the returned array is that of the specified array. If the list fits * in the specified array, it is returned therein. Otherwise, a new * array is allocated with the runtime type of the specified array and * the size of this list. * * &lt;p&gt;If the list fits in the specified array with room to spare (i.e., * the array has more elements than the list), the element in the array * immediately following the end of the list is set to {@code null}. * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if * the caller knows that the list does not contain any null elements.) * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose {@code x} is a list known to contain only strings. * The following code can be used to dump the list into a newly * allocated array of {@code String}: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that {@code toArray(new Object[0])} is identical in function to * {@code toArray()}. * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; Object[] result = a; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; if (a.length &gt; size) a[size] = null; return a; } private static final long serialVersionUID = 876323262645176354L; /** * Saves the state of this {@code LinkedList} instance to a stream * (that is, serializes it). * * @serialData The size of the list (the number of elements it * contains) is emitted (int), followed by all of its * elements (each an Object) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // Write out size s.writeInt(size); // Write out all elements in the proper order. for (Node&lt;E&gt; x = first; x != null; x = x.next) s.writeObject(x.item); } /** * Reconstitutes this {@code LinkedList} instance from a stream * (that is, deserializes it). */ @SuppressWarnings(\"unchecked\") private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) linkLast((E)s.readObject()); } /** * Creates a &lt;em&gt;&lt;a href=\"Spliterator.html#binding\"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this * list. * * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and * {@link Spliterator#ORDERED}. Overriding implementations should document * the reporting of additional characteristic values. * * @implNote * The {@code Spliterator} additionally reports {@link Spliterator#SUBSIZED} * and implements {@code trySplit} to permit limited parallelism.. * * @return a {@code Spliterator} over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() { return new LLSpliterator&lt;E&gt;(this, -1, 0); } /** A customized variant of Spliterators.IteratorSpliterator */ static final class LLSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; { static final int BATCH_UNIT = 1 &lt;&lt; 10; // batch array size increment static final int MAX_BATCH = 1 &lt;&lt; 25; // max batch array size; final LinkedList&lt;E&gt; list; // null OK unless traversed Node&lt;E&gt; current; // current node; null until initialized int est; // size estimate; -1 until first needed int expectedModCount; // initialized when est set int batch; // batch size for splits LLSpliterator(LinkedList&lt;E&gt; list, int est, int expectedModCount) { this.list = list; this.est = est; this.expectedModCount = expectedModCount; } final int getEst() { int s; // force initialization final LinkedList&lt;E&gt; lst; if ((s = est) &lt; 0) { if ((lst = list) == null) s = est = 0; else { expectedModCount = lst.modCount; current = lst.first; s = est = lst.size; } } return s; } public long estimateSize() { return (long) getEst(); } public Spliterator&lt;E&gt; trySplit() { Node&lt;E&gt; p; int s = getEst(); if (s &gt; 1 &amp;&amp; (p = current) != null) { int n = batch + BATCH_UNIT; if (n &gt; s) n = s; if (n &gt; MAX_BATCH) n = MAX_BATCH; Object[] a = new Object[n]; int j = 0; do { a[j++] = p.item; } while ((p = p.next) != null &amp;&amp; j &lt; n); current = p; batch = j; est = s - j; return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED); } return null; } public void forEachRemaining(Consumer&lt;? super E&gt; action) { Node&lt;E&gt; p; int n; if (action == null) throw new NullPointerException(); if ((n = getEst()) &gt; 0 &amp;&amp; (p = current) != null) { current = null; est = 0; do { E e = p.item; p = p.next; action.accept(e); } while (p != null &amp;&amp; --n &gt; 0); } if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); } public boolean tryAdvance(Consumer&lt;? super E&gt; action) { Node&lt;E&gt; p; if (action == null) throw new NullPointerException(); if (getEst() &gt; 0 &amp;&amp; (p = current) != null) { --est; E e = p.item; current = p.next; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } public int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } }}","link":"/2019/09/25/LinkedList类/"},{"title":"OpenCV边缘检测","text":"OpenCV边缘检测 12345678910111213import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('1024.jpg',0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap='gray')plt.title('original'),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap='gray')plt.title('edge'),plt.xticks([]),plt.yticks([])plt.show()","link":"/2019/09/14/OpenCV边缘检测/"},{"title":"Nobel Prize","text":"诺贝尔奖（以瑞典化学家诺贝尔命名的奖项） 诺贝尔奖（The Nobel Prize），是以瑞典的著名化学家、硝化甘油炸药的发明人阿尔弗雷德·贝恩哈德·诺贝尔（Alfred Bernhard Nobel）的部分遗产（3100万瑞典克朗）作为基金在1895年创立的奖项。 [1-2] 在世界范围内，诺贝尔奖通常被认为是所有颁奖领域内最重要的奖项。 [2-4] 诺贝尔奖最初分设物理（Physics）、化学（ [5] Chemistry）、生理学或医学（Physiology or Medicine）、文学（Literature）、和平（Peace）等五个奖项，于1901年首次颁发。 [2] [4] 1968年，瑞典国家银行在成立300周年之际，捐出大额资金给诺贝尔基金，增设“瑞典国家银行纪念诺贝尔经济科学奖”（The Sveriges Riksbank Prize in Economic Sciences in Memory of Alfred Nobel）； [6-7] 该奖于1969年首次颁发，人们习惯上称这个额外的奖项为诺贝尔经济学奖。 [6-7] 诺贝尔奖以“诺贝尔奖基金会”每年的利息或投资收益授予世界上在这六个领域对人类做出最重大贡献的人。 [1] 截止至2018年，诺贝尔奖共授予了904位个人和24个团体，这其中4位个人以及1个团体（联合国难民署）曾两次获得诺贝尔奖、1个团体（红十字会）曾三次获得诺贝尔奖，故总计908次授予个人、27次授予团体。 [1-2] 诺贝尔奖包括金质奖章、证书和奖金。 [1-2] 获奖分布12345678910美国327人英国 98 人德国 76 人法国 48 人瑞典 27人日本 27人俄罗斯 19人瑞士 17人荷兰 14人意大利 14人 高校得主诺贝尔奖自1901年首次颁发，截止至2018年，共授予了904位个人和24个团体，这其中4位个人以及1个团体（联合国难民署）曾两次获得诺贝尔奖、1个团体（红十字会）曾三次获得诺贝尔奖，故总计908次授予个人、27次授予团体。 [2] [4] 每个诺贝尔奖得主（除了文学和和平奖）在获奖时，几乎都在某一所大学或与大学相关的研究机构工作，而诺贝尔奖颁奖委员会也会特别说明该获奖者的工作机构。 [41-42] 各高校诺贝尔奖得主数量，从一定层面上体现出该校的学术实力和在世界学术界的地位。 [4] 据相关资料统计，截止2018 [43] 年10月，按照诺贝尔奖得主数量（校友、教职工以及研究人员），世界前30名高校名单如下： 排名大学名称地区诺贝尔奖人数1哈佛大学美国158人2剑桥大学英国117人3加州大学伯克利分校美国107人4芝加哥大学美国98人5哥伦比亚大学美国96人6麻省理工学院美国93人7斯坦福大学美国83人8加州理工学院美国73人9牛津大学英国69人10普林斯顿大学美国65人11耶鲁大学美国61人12康奈尔大学美国58人13柏林洪堡大学德国55人14巴黎大学法国50人15哥廷根大学德国45人16慕尼黑大学德国42人17哥本哈根大学丹麦39人18（并列）约翰·霍普金斯大学美国37人18（并列）纽约大学美国37人20洛克菲勒大学美国36人21宾夕法尼亚大学美国35人22伦敦大学学院英国34人23苏黎世联邦理工学院瑞士32人24（并列）伊利诺伊大学厄巴纳-香槟分校美国30人24（并列）明尼苏达大学美国30人26（并列）加州大学圣地亚哥分校美国27人26（并列）海德堡大学德国27人28（并列）曼彻斯特大学英国25人28（并列）密歇根大学美国25人28（并列）威斯康星大学麦迪逊分校美国25人 华人得主中国大陆及中国港澳台地区获得者 2015年 屠呦呦北京时间2015年10月5日。2015年诺贝尔生理学或医学奖得主：屠呦呦。她多年从事中药和中西药结合研究，突出贡献是创制新型抗疟药-青蒿素和双氢青蒿素。 [46]中国药学家屠呦呦2015年10月5日获得了诺贝尔医学奖，成为国内第一个诺贝尔科学类奖项获得者也是第一个获得诺贝尔奖的中国籍女性。 [47] 她也成为第一位获得诺贝尔科学奖项的中国本土科学家、第一位获得诺贝尔生理医学奖的华人科学家。 2010年 刘晓波2010年，刘晓波获得挪威诺贝尔和平奖委员会颁发的诺贝尔和平奖，成为首位或第二位（如果算上第十四世达赖喇嘛）获得该奖的中华人民共和国公民 [48-49] 。 2012年 莫言北京时间2012年10月11日，瑞典文学院宣布中国作家莫言获得2012年诺贝尔文学奖，获奖理由是：通过幻觉现实主义将民间故事、历史与当代社会融合在一起。 [50-51] 莫言成为第一个获得诺贝尔文学奖的中国籍作家。 1957年李政道与杨振宁 两人于1957年因提出“宇称不守恒”观念被实验证明而获诺贝尔物理学奖，获奖时均为中华台北籍贯。其中李政道于1962年加入美国国籍。杨振宁1964年2月23日加入美国国籍，2015年4月1日放弃美国国籍，随后加入中华人民共和国国籍。2017年初，杨振宁和姚期智两位教授依照《中国科学院章程》和《中国科学院外籍院士转为中国科学院院士暂行办法》由中国科学院外籍院士正式转为中国科学院院士。杨振宁院士加入中国科学院数学物理学部。 [52]海外华人获得者 海外华人诺贝尔奖获得者： 丁肇中：1936年生于美国，美籍华人。丁肇中和伯顿·里克特由于1974年发现了J/ψ粒子而同时获得1976年诺贝尔物理学奖，时年40岁。 李远哲：1936年生于台湾，1962年移居美国，1974年加入美国国籍，1986年以分子水平化学反应动力学的研究与赫施巴赫及约翰·波兰伊共获诺贝尔化学奖，时年50岁。1994年放弃美国国籍，返回台湾出任中央研究院院长。 朱棣文：1948年生于美国，祖籍江苏苏州太仓，美籍华人。1997年因“发展了用雷射冷却和捕获原子的方法”获得诺贝尔物理学奖，时年49岁，2008-2012年任美国能源部部长。 崔琦：1939年生于河南平顶山，美籍华人，1998年美国普林斯顿大学的崔琦、哥伦比亚大学的霍斯特·路德维希·施特默及史丹佛大学的劳克林三人因“他们发现了电子量子流体现象，一种新形态的量子流体，其中有带分数电荷的激发态”而获得获1998年诺贝尔物理学奖，时年59岁。 高行健：1948年生于江西，祖籍江苏泰州。1987年移居法国，1997年加入法国国籍。2000年高行健因为作品《灵山》获诺贝尔文学奖，成为第一位获得诺贝尔文学奖的华人作家。 钱永健：1952年出生于美国，祖籍浙江杭州，美籍华人。日裔美国科学家下村修、美国科学家马丁·查尔菲以及美国华裔科学家钱永健因为发现绿色荧光蛋白方面做出突出成就分享2008年诺贝尔化学奖。他是中国导弹之父钱学森的堂侄，美国华裔化学家。 高锟：1933年出生于中国上海金山区，英美双国籍，曾任香港中文大学校长。2009年因在“有关光在纤维中的传输以用于光学通信方面”取得了突破性成就，与发明了半导体成像器件——电荷耦合器件（CCD）图像传感器的韦拉德·博伊尔和乔治·史密斯共同获得2009诺贝尔物理学奖，时年75岁。 历届得主2012年-今 年份物理学奖化学奖生理学或医学奖文学奖经济学奖和平奖2012年 塞尔日·阿罗什大卫·维因兰德罗伯特J·勒夫科维兹 布莱恩·K·卡比尔卡 约翰·伯特兰·格登、山中伸弥 莫言埃尔文·罗斯、罗伊德·沙普利 欧洲联盟2013年彼得·希格斯 弗朗索瓦·恩格勒 马丁·卡普拉斯、迈克尔·莱维特、阿里耶·瓦谢勒 詹姆斯·E·罗斯曼、兰迪·谢克曼、托马斯·苏德霍夫 艾丽斯·芒罗尤金·法玛 拉尔斯·皮·汉森、罗伯特·席勒 禁止化学武器组织2014年赤崎勇 天野浩 中村修二 埃里克·白兹格 威廉姆·艾斯科 ·莫尔纳尔 斯特凡·w·赫尔 约翰·欧基夫 梅-布里特·莫泽、爱德华·莫索尔 帕特里克·莫迪亚诺让·梯若尔萨蒂亚尔希 马拉拉·优素福·扎伊 2015年梶田隆章 阿瑟·麦克唐纳 [12]&nbsp; 托马斯·林达尔 保罗·莫德里奇 阿齐兹·桑贾尔 [13]&nbsp; 威廉·C·坎贝尔 大村智 屠呦呦 [12]&nbsp; 斯维特拉娜·阿列克谢耶维奇 [14]&nbsp; 安格斯·迪顿 [15]&nbsp; 突尼斯全国对话大会2016年戴维·索利斯 邓肯·霍尔丹 迈克尔·科斯特利茨 [16]&nbsp; 让-彼埃尔·索瓦 伯纳德·费林加 詹姆斯·弗雷泽·司徒塔特勋爵 [17]&nbsp; 大隅良典 [18]&nbsp; 鲍勃·迪伦 [19]&nbsp; 奥利弗·哈特本特·霍姆斯特罗姆 [20]&nbsp; 胡安·曼努埃尔·桑托斯·卡尔德龙 [21]&nbsp; 2017年 [22]&nbsp; 雷纳·韦斯 基普·S·索恩 巴里·巴里什 雅克·杜波切特 阿希姆·弗兰克 理查德·亨德森 [23]&nbsp; 杰弗理·霍尔迈克尔·罗斯巴殊 迈克尔·杨 [24]&nbsp; 石黑一雄 [25]&nbsp; 理查德·H·泰勒 [26]&nbsp; 国际废除核武器运动（ICAN） [27]&nbsp; 2018年阿瑟·阿什金、热拉尔·穆鲁、唐娜·斯特里克兰 [28]&nbsp; 弗朗西斯·阿诺德、乔治·史密斯、格雷戈里·温特尔 [29]&nbsp; 詹姆斯·艾利森、本庶佑 [30]&nbsp; 奥尔加·托卡尔丘克 [31-32]&nbsp; 保罗·罗 默、威廉·诺德豪斯 [33]&nbsp; 德尼·慕克维格 、纳迪亚·穆拉德 [34]&nbsp; 2019年詹姆斯·皮布尔斯、米歇尔·马约尔、迪迪埃·奎洛兹 [35]&nbsp; 约翰·古迪纳夫、斯坦利·惠廷厄姆、吉野彰 [36]&nbsp; 威廉·凯林、彼得·拉特克利夫 、格雷格·塞门扎 [37]&nbsp; 彼得·汉德克 [32]&nbsp; 参考资料 Nobel Prize Facts ．诺贝尔奖官网[引用日期2019-03-13] The Nobel Prize ．诺贝尔奖官网[引用日期2019-03-13] Top Award (ShanghaiRanking Academic Excellence Survey 2017) ．世界大学学术排名官网[引用日期2017-10-11] All Nobel Prizes ．诺贝尔奖官网[引用日期2016-11-09] 漫画解读诺贝尔化学奖：达尔文进化论的活学活用！| 直击诺奖 ．搜狐[引用日期2019-08-28] The Sveriges Riksbank Prize in Economic Sciences in Memory of Alfred Nobel ．诺贝尔奖官网[引用日期2018-03-30] All Prizes in Economic Sciences ．诺贝尔奖官网[引用日期2018-03-30] 受性丑闻风波影响 2018年将不颁发诺贝尔文学奖 ．海外网[引用日期2018-05-04] 瑞典因诺奖停颁增设新文学奖 村上春树进候选名单 ．网易新闻[引用日期2018-09-05] 弥天大谎：“96.7%诺贝尔奖获得者信教 ．搜狐[引用日期2015-11-24] 诺贝尔基金会今年提高奖金，授予获奖者约人民币740万元 ．澎拜网．2017-09-26[引用日期2017-09-26] The Nobel Prize in Physics 2015 ．NobelPrize.org．2015-10-06[引用日期2015-10-06] 3名学者获诺贝尔化学奖 ．网易[引用日期2015-10-07] 快讯：斯维特拉娜获2015年诺贝尔文学奖 ．中国经济网[引用日期2015-10-08] 安格斯·迪顿获得2015年诺贝尔经济学奖 ．环球网[引用日期2015-10-12] The 2016 Nobel Prize in Physics ．Nobelprize.org．2016.10.04[引用日期2016-10-04] The 2016 Nobel Prize in Chemistry ．Nobelprize.org．2016.10.05[引用日期2016-10-05] 2016诺贝尔生理学或医学奖揭晓 日本科学家获奖 ．凤凰网[引用日期2016-10-03] The Nobel Prize in Literature 2016 ．Nobelprize.org．2016.10.13[引用日期2016-10-14] The Prize in Economic Sciences 2016 ．NobelPrize.org．2016.10.10[引用日期2016-10-10] The Nobel Peace Prize i2016 ．Nobelprize.org．．2016.10.07[引用日期2016-10-07] 三名美国科学家获2017年诺贝尔物理学奖 ．网易[引用日期2017-10-03] 网易首页 &gt; 新闻中心 &gt; 新闻 &gt; 正文 交友 2017年诺贝尔化学奖揭晓 ．网易[引用日期2017-10-04] 2017年诺贝尔生理学或医学奖揭晓 ．科学网[引用日期2017-10-02] 日裔英国籍作家石黑一雄获2017年诺贝尔文学奖 ．凤凰网[引用日期2017-10-05] 美国经济学家理查德·塞勒获得2017年诺贝尔经济学奖 ．新华网[引用日期2017-10-09] 国际废除核武器运动获得2017年诺贝尔和平奖 ．新浪[引用日期2017-10-06] 诺贝尔物理学奖揭晓：美法加三名科学家因激光物理获奖 ．澎湃新闻[引用日期2018-10-02] 快讯！2018年诺贝尔化学奖名单出炉！ ．环球网[引用日期2018-10-03] 两位诺奖获得者系免疫学家，盘点近年诺贝尔生理及医学奖获奖者 ．荔枝网[引用日期2018-10-02] 今年将颁发2018年与2019年诺贝尔文学奖 ．中国经济网[引用日期2019-09-01] 刚刚！2018和2019诺贝尔文学奖同时揭晓 ．海外网[引用日期2019-10-10] 2018诺贝尔经济学奖揭晓 两名美国学者获奖 ．海外网[引用日期2018-10-08] 刚国（金）医生及伊拉克女活动家获诺奖和平奖 ．新浪[引用日期2018-10-05] 三名科学家分享2019年诺贝尔物理学奖 ．新华网[引用日期2019-10-08] 三名科学家分享2019年诺贝尔化学奖 ．新华网[引用日期2019-10-10] 快讯！2019诺贝尔生理学或医学奖揭晓 ．海外网[引用日期2019-10-07] 有多少诺贝尔奖获得者不信教？ ． 生物谷[引用日期2017-04-09] 世界各国诺贝尔奖获奖人数统计排名 日本位列第8 ．新华网．2013年09月30日[引用日期2015-03-20] 美德三名科学家获2014年诺贝尔化学奖 ．新华网．2014-10-08[引用日期2014-10-08] Nobel Laureates and Research Affiliations ．诺贝尔奖官网[引用日期2016-11-29] Nobel Prize 介绍 ．诺贝尔奖官网[引用日期2016-11-29] 试管中的达尔文进化论！2018诺贝尔化学奖女得主亲自解释获奖的酶定向进化 ．新浪[引用日期2019-08-26] ISRAEL’S TWELVE NOBEL LAUREATES ．jpost[引用日期2019-04-22] 日本人のノーベル赏受赏者一覧 ．京都大学（官网）[引用日期2019-04-22] 祝贺北京大学校友屠呦呦获2015诺贝尔生理医学奖 ．北京大学[引用日期2015-10-07] 中国人终于获得诺贝尔科学奖项了！创造力多重要！ ．搜狐网[引用日期2015-10-05] 益多：从达赖到刘晓波获“诺贝尔和平奖”说明了什么 ．人民网．2010年10月14日[引用日期2018-09-09] 刘晓波与诺贝尔和平奖的双重笑料 ．人民网．2010年10月22日[引用日期2018-09-09] 中国作家莫言获2012年诺贝尔文学奖 ．新华网[引用日期2014-02-20] 莫言获得诺贝尔文学奖的现实意义 ．五星文库[引用日期2014-02-20] 对话”杨振宁、姚期智：我为什么放弃外国国籍？ ．新浪科技．2017-02-21[引用日期2017-02-22] 快讯！2019诺贝尔化学奖揭晓 ．海外网[引用日期2019-10-09] 最年轻诺贝尔奖获得者25岁!细数诺贝尔奖之最 ．21CN新闻网．2007-10-15[引用日期2012-11-05]","link":"/2019/10/11/Nobel-Prize/"},{"title":"Suffix-expression","text":"后缀表达式后缀表达式，又称逆波兰式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。 后缀表达式计算：后缀表达式计算与前缀表达式类似，只是顺序是从左至右，具体过程如下：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如：后缀表达式为“2 3 + 4 × 5 -”计算过程如下： （1）从左至右扫描，将 2 和 3 压入堆栈； （2）遇到 + 运算符，因此弹出 3 和 2（ 3 为栈顶元素，2 为次顶元素，注意与前缀表达式做比较），计算出 3+2 的值，得 5，再将 5 入栈； （3）将 4 入栈； （4）接下来是 × 运算符，因此弹出 4 和 5，计算出 4 × 5 = 20，将 20 入栈； （5）将 5 入栈； （6）最后是-运算符，计算出 20-5 的值，即 15，由此得出最终结果。 中缀表达式转后缀表达式：与转换为前缀表达式相似，步骤如下： （1）初始化两个栈：运算符栈s1和储存中间结果的栈s2； （2）从左至右扫描中缀表达式； （3）遇到操作数时，将其压s2； （4）遇到运算符时，比较其与 s1 栈顶运算符的优先级： a：如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； b：否则，若优先级比栈顶运算符的高，也将运算符压入 s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）; c：否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到（4）-（1）与s1中新的栈顶运算符相比较； （5）遇到括号时： a：如果是左括号“(”，则直接压入 s1； b：如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2 ，直到遇到左括号为止，此时将这一对括号丢弃； （6）重复步骤（2）至（5），直到表达式的最右边； （7）将 s1 中剩余的运算符依次弹出并压入 s2； （8）依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序） 例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下： 扫描到的元素 s2(栈底-&gt;栈顶) s1 (栈底-&gt;栈顶) 说明 1 1 空 数字，直接入栈 + 1 + s1为空，运算符直接入栈 ( 1 + ( 左括号，直接入栈 ( 1 + ( ( 同上 2 1 2 + ( ( 数字 + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈 3 1 2 3 + ( ( + 数字 ) 1 2 3 + + ( 右括号，弹出运算符直至遇到左括号 × 1 2 3 + + ( × s1栈顶为左括号，运算符直接入栈 4 1 2 3 + 4 + ( × 数字 ) 1 2 3 + 4 × + 右括号，弹出运算符直至遇到左括号 – 1 2 3 + 4 × + – -与+优先级相同，因此弹出+，再压入- 5 1 2 3 + 4 × + 5 – 数字 到达最右端 1 2 3 + 4 × + 5 – 空 s1中剩余的运算符 得到的最终结果为：“ 1 2 3 + 4 × + 5 – ”","link":"/2019/11/05/Suffix-expression/"},{"title":"PLMpapers","text":"PLMpapersContributed by Xiaozhi Wang and Zhengyan Zhang. IntroductionPre-trained Languge Model (PLM) is a very popular topic in NLP. In this repo, we list some representative work on PLM and show their relationship with a diagram. Feel free to distribute or use it! Here you can get the source PPT file of the diagram if you want to use it in your presentation. Corrections and suggestions are welcomed. We also released OpenCLap, an open-source Chinese language pre-trained model zoo. Welcome to try it. PapersModels Semi-supervised Sequence Learning. Andrew M. Dai, Quoc V. Le. NIPS 2015. [pdf] context2vec: Learning Generic Context Embedding with Bidirectional LSTM. Oren Melamud, Jacob Goldberger, Ido Dagan. CoNLL 2016. [pdf] [project] (context2vec) Unsupervised Pretraining for Sequence to Sequence Learning. Prajit Ramachandran, Peter J. Liu, Quoc V. Le. EMNLP 2017. [pdf] (Pre-trained seq2seq)` Deep contextualized word representations. Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee and Luke Zettlemoyer. NAACL 2018. [pdf] [project] (ELMo) Universal Language Model Fine-tuning for Text Classification. Jeremy Howard and Sebastian Ruder. ACL 2018. [pdf] [project] (ULMFiT) Improving Language Understanding by Generative Pre-Training. Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever. Preprint. [pdf] [project] (GPT) BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. NAACL 2019. [pdf] [code &amp; model] Language Models are Unsupervised Multitask Learners. Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei and Ilya Sutskever. Preprint. [pdf] [code] (GPT-2) ERNIE: Enhanced Language Representation with Informative Entities. Zhengyan Zhang, Xu Han, Zhiyuan Liu, Xin Jiang, Maosong Sun and Qun Liu. ACL 2019. [pdf] [code &amp; model] (ERNIE (Tsinghua) ) ERNIE: Enhanced Representation through Knowledge Integration. Yu Sun, Shuohuan Wang, Yukun Li, Shikun Feng, Xuyi Chen, Han Zhang, Xin Tian, Danxiang Zhu, Hao Tian and Hua Wu. Preprint. [pdf] [code] (ERNIE (Baidu) ) Defending Against Neural Fake News. Rowan Zellers, Ari Holtzman, Hannah Rashkin, Yonatan Bisk, Ali Farhadi, Franziska Roesner, Yejin Choi. NeurIPS 2019. [pdf] [project] (Grover) Cross-lingual Language Model Pretraining. Guillaume Lample, Alexis Conneau. NeurIPS 2019. [pdf] [code &amp; model] (XLM) Multi-Task Deep Neural Networks for Natural Language Understanding. Xiaodong Liu, Pengcheng He, Weizhu Chen, Jianfeng Gao. ACL 2019. [pdf] [code &amp; model] (MT-DNN) MASS: Masked Sequence to Sequence Pre-training for Language Generation. Kaitao Song, Xu Tan, Tao Qin, Jianfeng Lu, Tie-Yan Liu. ICML 2019. [pdf] [code &amp; model] Unified Language Model Pre-training for Natural Language Understanding and Generation. Li Dong, Nan Yang, Wenhui Wang, Furu Wei, Xiaodong Liu, Yu Wang, Jianfeng Gao, Ming Zhou, Hsiao-Wuen Hon. Preprint. [pdf] (UniLM) XLNet: Generalized Autoregressive Pretraining for Language Understanding. Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le. NeurIPS 2019. [pdf] [code &amp; model] RoBERTa: A Robustly Optimized BERT Pretraining Approach. Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, Veselin Stoyanov. Preprint. [pdf] [code &amp; model] SpanBERT: Improving Pre-training by Representing and Predicting Spans. Mandar Joshi, Danqi Chen, Yinhan Liu, Daniel S. Weld, Luke Zettlemoyer, Omer Levy. Preprint. [pdf] [code &amp; model] Knowledge Enhanced Contextual Word Representations. Matthew E. Peters, Mark Neumann, Robert L. Logan IV, Roy Schwartz, Vidur Joshi, Sameer Singh, Noah A. Smith. EMNLP 2019. [pdf] (KnowBert) VisualBERT: A Simple and Performant Baseline for Vision and Language. Liunian Harold Li, Mark Yatskar, Da Yin, Cho-Jui Hsieh, Kai-Wei Chang. Preprint. [pdf] [code &amp; model] ViLBERT: Pretraining Task-Agnostic Visiolinguistic Representations for Vision-and-Language Tasks. Jiasen Lu, Dhruv Batra, Devi Parikh, Stefan Lee. NeurIPS 2019. [pdf] [code &amp; model] VideoBERT: A Joint Model for Video and Language Representation Learning. Chen Sun, Austin Myers, Carl Vondrick, Kevin Murphy, Cordelia Schmid. ICCV 2019. [pdf] LXMERT: Learning Cross-Modality Encoder Representations from Transformers. Hao Tan, Mohit Bansal. EMNLP 2019. [pdf] [code &amp; model] VL-BERT: Pre-training of Generic Visual-Linguistic Representations. Weijie Su, Xizhou Zhu, Yue Cao, Bin Li, Lewei Lu, Furu Wei, Jifeng Dai. Preprint. [pdf] Unicoder-VL: A Universal Encoder for Vision and Language by Cross-modal Pre-training. Gen Li, Nan Duan, Yuejian Fang, Ming Gong, Daxin Jiang, Ming Zhou. Preprint. [pdf] K-BERT: Enabling Language Representation with Knowledge Graph. Weijie Liu, Peng Zhou, Zhe Zhao, Zhiruo Wang, Qi Ju, Haotang Deng, Ping Wang. Preprint. [pdf] Fusion of Detected Objects in Text for Visual Question Answering. Chris Alberti, Jeffrey Ling, Michael Collins, David Reitter. EMNLP 2019. [pdf] (B2T2) Contrastive Bidirectional Transformer for Temporal Representation Learning. Chen Sun, Fabien Baradel, Kevin Murphy, Cordelia Schmid. Preprint. [pdf] (CBT) ERNIE 2.0: A Continual Pre-training Framework for Language Understanding. Yu Sun, Shuohuan Wang, Yukun Li, Shikun Feng, Hao Tian, Hua Wu, Haifeng Wang. Preprint. [pdf] [code] 75 Languages, 1 Model: Parsing Universal Dependencies Universally. Dan Kondratyuk, Milan Straka. EMNLP 2019. [pdf] [code &amp; model] (UDify) Pre-Training with Whole Word Masking for Chinese BERT. Yiming Cui, Wanxiang Che, Ting Liu, Bing Qin, Ziqing Yang, Shijin Wang, Guoping Hu. Preprint. [pdf] [code &amp; model] (Chinese-BERT-wwm) UNITER: Learning UNiversal Image-TExt Representations. Yen-Chun Chen, Linjie Li, Licheng Yu, Ahmed El Kholy, Faisal Ahmed, Zhe Gan, Yu Cheng, Jingjing Liu. Preprint. [pdf] HUBERT Untangles BERT to Improve Transfer across NLP Tasks. Anonymous authors. ICLR 2020 under review. [pdf] MultiFiT: Efficient Multi-lingual Language Model Fine-tuning. Julian Eisenschlos, Sebastian Ruder, Piotr Czapla, Marcin Kardas, Sylvain Gugger, Jeremy Howard. EMNLP 2019. [pdf] [code &amp; model] Knowledge Distillation &amp; Model Compression TinyBERT: Distilling BERT for Natural Language Understanding. Xiaoqi Jiao, Yichun Yin, Lifeng Shang, Xin Jiang, Xiao Chen, Linlin Li, Fang Wang, Qun Liu. Preprint. [pdf] Distilling Task-Specific Knowledge from BERT into Simple Neural Networks. Raphael Tang, Yao Lu, Linqing Liu, Lili Mou, Olga Vechtomova, Jimmy Lin. Preprint. [pdf] Patient Knowledge Distillation for BERT Model Compression. Siqi Sun, Yu Cheng, Zhe Gan, Jingjing Liu. EMNLP 2019. [pdf] [code] Model Compression with Multi-Task Knowledge Distillation for Web-scale Question Answering System. Ze Yang, Linjun Shou, Ming Gong, Wutao Lin, Daxin Jiang. Preprint. [pdf] PANLP at MEDIQA 2019: Pre-trained Language Models, Transfer Learning and Knowledge Distillation. Wei Zhu, Xiaofeng Zhou, Keqiang Wang, Xun Luo, Xiepeng Li, Yuan Ni, Guotong Xie. The 18th BioNLP workshop. [pdf] Improving Multi-Task Deep Neural Networks via Knowledge Distillation for Natural Language Understanding. Xiaodong Liu, Pengcheng He, Weizhu Chen, Jianfeng Gao. Preprint. [pdf] [code &amp; model] Well-Read Students Learn Better: The Impact of Student Initialization on Knowledge Distillation. Iulia Turc, Ming-Wei Chang, Kenton Lee, Kristina Toutanova. Preprint. [pdf] Small and Practical BERT Models for Sequence Labeling. Henry Tsai, Jason Riesa, Melvin Johnson, Naveen Arivazhagan, Xin Li, Amelia Archer. EMNLP 2019. [pdf] Q-BERT: Hessian Based Ultra Low Precision Quantization of BERT. Sheng Shen, Zhen Dong, Jiayu Ye, Linjian Ma, Zhewei Yao, Amir Gholami, Michael W. Mahoney, Kurt Keutzer. Preprint. [pdf] ALBERT: A Lite BERT for Self-supervised Learning of Language Representations. Anonymous authors. ICLR 2020 under review. [pdf] Extreme Language Model Compression with Optimal Subwords and Shared Projections. Sanqiang Zhao, Raghav Gupta, Yang Song, Denny Zhou. Preprint. [pdf] DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter. Victor Sanh, Lysandre Debut, Julien Chaumond, Thomas Wolf. Preprint. [pdf] Analysis Revealing the Dark Secrets of BERT. Olga Kovaleva, Alexey Romanov, Anna Rogers, Anna Rumshisky. EMNLP 2019. [pdf] How Does BERT Answer Questions? A Layer-Wise Analysis of Transformer Representations. Betty van Aken, Benjamin Winter, Alexander Löser, Felix A. Gers. CIKM 2019. [pdf] Are Sixteen Heads Really Better than One?. Paul Michel, Omer Levy, Graham Neubig. Preprint. [pdf] [code] Is BERT Really Robust? A Strong Baseline for Natural Language Attack on Text Classification and Entailment. Di Jin, Zhijing Jin, Joey Tianyi Zhou, Peter Szolovits. Preprint. [pdf] [code] BERT has a Mouth, and It Must Speak: BERT as a Markov Random Field Language Model. Alex Wang, Kyunghyun Cho. NeuralGen 2019. [pdf] [code] Linguistic Knowledge and Transferability of Contextual Representations. Nelson F. Liu, Matt Gardner, Yonatan Belinkov, Matthew E. Peters, Noah A. Smith. NAACL 2019. [pdf] What Does BERT Look At? An Analysis of BERT’s Attention. Kevin Clark, Urvashi Khandelwal, Omer Levy, Christopher D. Manning. BlackBoxNLP 2019. [pdf] [code] Open Sesame: Getting Inside BERT’s Linguistic Knowledge. Yongjie Lin, Yi Chern Tan, Robert Frank. BlackBoxNLP 2019. [pdf] [code] Analyzing the Structure of Attention in a Transformer Language Model. Jesse Vig, Yonatan Belinkov. BlackBoxNLP 2019. [pdf] Blackbox meets blackbox: Representational Similarity and Stability Analysis of Neural Language Models and Brains. Samira Abnar, Lisa Beinborn, Rochelle Choenni, Willem Zuidema. BlackBoxNLP 2019. [pdf] BERT Rediscovers the Classical NLP Pipeline. Ian Tenney, Dipanjan Das, Ellie Pavlick. ACL 2019. [pdf] How multilingual is Multilingual BERT?. Telmo Pires, Eva Schlinger, Dan Garrette. ACL 2019. [pdf] What Does BERT Learn about the Structure of Language?. Ganesh Jawahar, Benoît Sagot, Djamé Seddah. ACL 2019. [pdf] Beto, Bentz, Becas: The Surprising Cross-Lingual Effectiveness of BERT. Shijie Wu, Mark Dredze. EMNLP 2019. [pdf] How Contextual are Contextualized Word Representations? Comparing the Geometry of BERT, ELMo, and GPT-2 Embeddings. Kawin Ethayarajh. EMNLP 2019. [pdf] Probing Neural Network Comprehension of Natural Language Arguments. Timothy Niven, Hung-Yu Kao. ACL 2019. [pdf] [code] Universal Adversarial Triggers for Attacking and Analyzing NLP. Eric Wallace, Shi Feng, Nikhil Kandpal, Matt Gardner, Sameer Singh. EMNLP 2019. [pdf] [code] The Bottom-up Evolution of Representations in the Transformer: A Study with Machine Translation and Language Modeling Objectives. Elena Voita, Rico Sennrich, Ivan Titov. EMNLP 2019. [pdf] Do NLP Models Know Numbers? Probing Numeracy in Embeddings. Eric Wallace, Yizhong Wang, Sujian Li, Sameer Singh, Matt Gardner. EMNLP 2019. [pdf] Investigating BERT’s Knowledge of Language: Five Analysis Methods with NPIs. Alex Warstadt, Yu Cao, Ioana Grosu, Wei Peng, Hagen Blix, Yining Nie, Anna Alsop, Shikha Bordia, Haokun Liu, Alicia Parrish, Sheng-Fu Wang, Jason Phang, Anhad Mohananey, Phu Mon Htut, Paloma Jeretič, Samuel R. Bowman. EMNLP 2019. [pdf] [code] Visualizing and Understanding the Effectiveness of BERT. Yaru Hao, Li Dong, Furu Wei, Ke Xu. EMNLP 2019. [pdf] Visualizing and Measuring the Geometry of BERT. Andy Coenen, Emily Reif, Ann Yuan, Been Kim, Adam Pearce, Fernanda Viégas, Martin Wattenberg. NeurIPS 2019. [pdf] On the Validity of Self-Attention as Explanation in Transformer Models. Gino Brunner, Yang Liu, Damián Pascual, Oliver Richter, Roger Wattenhofer. Preprint. [pdf] Transformer Dissection: An Unified Understanding for Transformer’s Attention via the Lens of Kernel. Yao-Hung Hubert Tsai, Shaojie Bai, Makoto Yamada, Louis-Philippe Morency, Ruslan Salakhutdinov. EMNLP 2019. [pdf] Language Models as Knowledge Bases? Fabio Petroni, Tim Rocktäschel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H. Miller, Sebastian Riedel. EMNLP 2019, [pdf] [code] To Tune or Not to Tune? Adapting Pretrained Representations to Diverse Tasks. Matthew E. Peters, Sebastian Ruder, Noah A. Smith. RepL4NLP 2019, [pdf] Tutorial &amp; Resource Transfer Learning in Natural Language Processing. Sebastian Ruder, Matthew E. Peters, Swabha Swayamdipta, Thomas Wolf. NAACL 2019. [slides] Transformers: State-of-the-art Natural Language Processing. Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, Jamie Brew. Preprint. [pdf] [code]","link":"/2019/10/20/PLMpapers/"},{"title":"Spring框架面试总结","text":"介绍spring框架它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。 Spring的优点？ 降低了组件之间的耦合性 ，实现了软件各层之间的解耦 可以使用容易提供的众多服务，如事务管理，消息服务等 容器提供单例模式支持 容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 容器提供了众多的辅助类，能加快应用的开发 spring对于主流的应用框架提供了集成支持，如hibernate， JPA，Struts等 spring属于低侵入式设计，代码的污染极低 独立于各种应用服务器 spring的DI机制降低了业务对象替换的复杂性 Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring 的部分或全部 spring有两种代理方式：答: 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 优点：因为有接口，所以使系统更加松耦合 缺点：为每一个目标类创建接口 若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好 如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。 构造方法注入和设值注入有什么区别？请注意以下明显的区别： 在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。 对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。 在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 设值注入不会重写构造方法的值。 在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 请介绍一下Spring框架中Bean的生命周期一、Bean的定义 Spring通常通过配置文件定义Bean。如： 这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 二、Bean的初始化 有两种方式初始化Bean。 1、在配置文档中通过指定init-method 属性来完成 2、实现 org.springframwork.beans.factory.InitializingBean接口 那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 三、Bean的调用 有三种方式可以得到Bean并进行调用： 1、使用BeanWrapper 2、使用BeanFactory 3、使用ApplicationConttext 四、Bean的销毁 1、使用配置文件中的 destory-method 属性 2、实现 org.springframwork.bean.factory.DisposebleBean接口 Spring中AOP的应用场景、Aop原理、好处？答：AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用: Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化 校准、Performance optimization 性能优化、Persistence 持久化、Resource pooling 资源池、Synchronization 同步、Transactions 事务 原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。 优点：1.各个步骤之间的良好隔离性耦合性大大降低 2.源代码无关性，再扩展功能的同时不对源码进行修改操作 有几种不同类型的自动代理？BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying ApplicationContext通常的实现是什么?FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。 有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 什么是IOC，什么又是DI，他们有什么区别？一、IOC介绍 IOC是控制反转。 创建对象实例的控制权从代码控制剥离到IOC容器控制(之前的写法，由程序代码直接操控使用new关键字)，实际就是你在xml文件控制，控制权的转移是所谓反转，侧重于原理。 二、DI介绍 DI是依赖注入 创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。 spring事务定义事务的定义：事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么都成功。其必须遵循四个原则（ACID）。 原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做； 一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。 隔离性（Isolation）：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性； 持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。 Spring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。","link":"/2019/09/04/Spring框架面试总结/"},{"title":"Recommendation System","text":"目录 1. 什么是推荐系统 2. 总体架构 2.1 离线推荐 2.2 在线训练 3. 特征数据 4. 协同过滤算法 4.1 基于物品的协同过滤(ItemCF) 4.2 基于用户的协同过滤(UserCF) 4.3 矩阵分解 5. 隐语义模型 5.1 基本思想 5.2 模型理解 6. 排序算法 7. 评估测试 7.1 A/B测试 7.2 其它评估方法 8. 推荐系统冷启动问题 8.1 用户冷启动 8.2 物品冷启动 8.3 系统冷启动 9. 参考文献 1. 什么是推荐系统推荐系统是利用电子商务网站向客户提供商品信息和建议，帮助用户决定应该购买什么产品，模拟销售人员帮助客户完成购买过程。个性化推荐是根据用户的兴趣特点和购买行为，向用户推荐用户感兴趣的信息和商品。 随着电子商务规模的不断扩大，商品个数和种类快速增长，顾客需要花费大量的时间才能找到自己想买的商品。这种浏览大量无关的信息和产品过程无疑会使淹没在信息过载问题中的消费者不断流失。 为了解决这些问题，个性化推荐系统应运而生。个性化推荐系统是建立在海量数据挖掘基础上的一种高级商务智能平台，以帮助电子商务网站为其顾客购物提供完全个性化的决策支持和信息服务。 常见的推荐栏位例如：淘宝的猜你喜欢、看了又看、推荐商品，美团的首页推荐、附近推荐等。 推荐系统是比较偏向于工程类的系统，要做得更加的精确，需要的不仅仅是推荐算法，还有用户意图识别、文本分析、行为分析等，是一个综合性很强的系统。 2. 总体架构本节介绍的几种推荐系统架构，并不是互相独立的关系，实际的推荐系统可能会用到其中一种或者几种的架构。在实际设计的过程中，读者可以把本文介绍的架构作为一个设计的起点，更多地结合自身业务特点进行独立思考，从而设计出适合自身业务的系统。 根据响应用户行为的速度不同，推荐系统可以大致分为基于离线训练和在线训练的推荐系统。 2.1 离线推荐于离线训练的推荐系统架构是最常见的一种推荐系统架构。这里的“离线”训练指的是使用历史一段时间（ 比如周或者几周 ）的数据进行训练，模型迭代的周期较长（一般 以小时为单位 ）。模型拟合的是用户的中长期兴趣。 如下图所示， 一个典型的基于离线训练的推荐系统架构由数据上报、离线训练、在线存储、实时计算和 A/B 测试这几个模块组成。其中，数据上报和离线训练组成了监督学习中的学习系统，而实时计算和 A/B 测试组成了预测系统。另外，除了模型之外，还有一个在线存储模块，用于存储模型和模型需要的特征信息供实时计算模块调用。图中的各个模块组成了训练和预测两条数据流，训练的数据流搜集业务的数据最后生成模型存储于在线存储模块；预测的数据流接受业务的预测请求，通过 A/B 测试模块访问实时计算模块获取预测结果。 数据上报：据上报模块的作用是搜集业务数据组成训练样本。一般分为收集、验证、清洗和转换几个步骤。将收集的数据转化为训练所需要的样本格式，保存到离线存储模块。 离线训练：线训练模块又细分为离线存储和离线计算。实际业务中使用的推荐系统一般都需要处理海量的用户行为数据，所以离线存储模块需要有一个分布式的文件系统或者存储平台来存储这些数据。离线计算常见的操作有：样本抽样、特征工程、模型训练、相似度计算等。 在线存储：因为线上的服务对于时延都有严格的要求。比如，某个用户打开手机 APP ，他肯定希望APP 能够快速响应，如果耗时过长，就会影响用户的体验。一般来说，这就要求推荐系统在几十毫秒以内处理完用户请求返回推荐结果，所以，针对线上的服务，需要有一个专门的在线存储模块，负责存储用于线上的模型和特征数据 。 实时推荐：实时推荐模块的功能是对来自业务的新请求进行预测。1.获取用户特征；2.调用推荐模型；3.结果排序。 在实际应用中，因为业务的物品列表太大，如果实时计算对每 个物品使用复杂的模型进行打分，就有可能耗时过长而影响用户满意度。所以，一种常见的做法是将推荐列表生成分为召回和排序两步。召回的作用是从大量的候选物品中（例如上百万）筛选出一批用户较可能喜欢的候选集 （一般是几百）。排序的作用是对召回得到的相对较小的候选集使用排序模型进行打分。更进一步，在排序得到推荐列表后，为了多样性和运营的一些考虑，还会加上第三步重排过滤，用于对精排后的推荐列表进行处理。 A/B测试：对于互联网产品来说， A/B 测试基本上是一个必备的模块，对于推荐系统来说也不例外，它可以帮助开发人员评估新算法对客户行为的影响。除了 离线的指标外，一个新的推荐算法上线之前 般都会经过 A/B 测试来测试新算法的有效性。 下图是与之对应的实际系统中各个组件的流转过程。需要注意的是生成推荐列表就已经做完了召回和排序的操作，业务层直接调用API就可以得到这个推荐列表。 2.2 在线训练对于业务来说，我们希望用户对于上 个广告的反馈 （喜欢或者不 欢，有没有点击 ，可以很快地用于下一个广告的推荐中。这就要求我们用另 种方法来解决这个问题，这个方法就是在线训练。 基于在线训练的推荐系统架构适合于广告和电商等高维度大数据量且对实时性要求很高的场景 相比较基于离线训练的推荐系统，基于在线训练的推荐系统不区分训练和测试阶段，每个回合都在学习，通过实时的反馈来调整策略。 方面，在线训练要求其样本、特征和模型的处理都是实时的，以便推荐的内容更快地反映用户实时的喜好；另一方面，因为在线训练井不需要将所有的训练数据都存储下来，所以不需要巨大的离线存储开销，使得系统具有很好的伸缩性，可以支持超大的数据量和模型。 样本处理：和基于离线训练的推荐系统相比，在线训练在数据上报阶段的主要不同体现在样本处理上。，对于离线训练来说，上报后的数据先是被存储到一个分布式文件系统，然后等待离线计算任务来对样本进行处理；对于在线训练来说，对样本的去重、过滤和采样等计算都需要实时进行。 实时特性：实时特征模块通过实时处理样本数据拼接训练需要的特征构造训练样本，输入流式训练模块用于更新模型。该模块的主要的功能是特征拼接和特征工程。 流式训练：、流式训练模块的主要作用是使用实时训练样本来更新模型。推荐算法中增量更新部分的计算，通过流式计算的方式来进行更新。在线训练的优势之一，是可以支持模型的稀疏存储。训练方面，在线模型不一定都是从零开始训练，而是可以将离线训练得到的模型参数作为基础，在这个基础上进行增量训练。 模型存储和加载：模型一般存储在参数服务器中。模型更新后，将模型文件推送到线上存储，并由线上服务模块动态加载。 3. 特征数据要训练推荐模型，就需要先收集用户的行为数据生成特征向量以后才能进行训练，而一个特征向量由特征以及特征的权重组成，在利用用户行为计算特征向量时需要考虑以下因素。 用户行为的种类：在一个网站中，用户可以对物品产生很多不同种类的行为。用户可以浏览物品、单击物品的链接、收藏物品、给物品打分、购买物品、评论物品、给物品打上不同的标签、和好友分享物品、搜索不同的关键词等。这些行为都会对物品特征的权重产生影响，但不同行为的影响不同，大多时候很难确定什么行为更加重要，一般的标准就是用户付出代价越大的行为权重越高。 用户行为产生的时间：一般来说，用户近期的行为比较重要，而用户很久之前的行为相对比较次要。因此，如果用户最近购买过某一个物品，那么这个物品对应的特征将会具有比较高的权重。 用户行为的次数：有时用户对一个物品会产生很多次行为。比如用户会听一首歌很多次，看一部电视剧的很多集等。因此用户对同一个物品的同一种行为发生的次数也反映了用户对物品的兴趣，行为次数多的物品对应的特征权重越高。 物品的热门程度：如果用户对一个很热门的物品产生了行为，往往不能代表用户的个性，因为用户可能是在跟风，可能对该物品并没有太大兴趣，特别是在用户对一个热门物品产生了偶尔几次不重要的行为（比如浏览行为）时，就更说明用户对这个物品可能没有什么兴趣，可能只是因为这个物品的链接到处都是，很容易点到而已。反之，如果用户对一个不热门的物品产生了行为，就说明了用户的个性需求。因此，推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重。 数据去燥：对样本做去噪。对于数据中混杂的刷单等类作弊行为的数据，要将其排除出训练数据,否则它会直接影响模型的效果；样本中的缺失值也要做处理。 正负样本均衡：一般我们收集用户的行为数据都是属于正样本，造成了严重的不平衡。所以对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。 特征组合：我们需要考虑特征与特征之间的关系。例如在美团酒店搜索排序中，酒店的销量、价格、用户的消费水平等是强相关的因素，用户的年龄、位置可能是弱相关的因素，用户的ID是完全无关的因素。在确定了哪些因素可能与预测目标相关后，我们需要将此信息表示为数值类型,即为特征抽取的过程。除此之外，用户在App上的浏览、交易等行为记录中包含了大量的信息，特征抽取则主要是从这些信息抽取出相关因素，用数值变量进行表示。常用的统计特征有计数特征,如浏览次数、下单次数等;比率特征，如点击率、转化率等;统计量特征，如价格均值、标准差、分位数、偏度、峰度等。 4. 协同过滤算法协同过滤算法起源于 1992 年，被 Xerox 公司用于个性化定制邮件系统。Xerox 司的用户需要在数十种主题中选择三到五种主题，协同过滤算法根据不同的主题过滤邮件，最终达到个性化的目的。 协同过滤算法分为基于物品的协同过滤和基于用户的协同过滤，输出结果为 TOPn 的推荐列表。 4.1 基于物品的协同过滤(ItemCF)基于物品的协同过滤算法的核心思想：给用户推荐那些和他们之前喜欢的物品相似的物品。 基于物品的协同过滤算法首先计算物品之间的相似度， 计算相似度的方法有以下几种： 基于共同喜欢物品的用户列表计算 在此，分母中 N(i) 是购买物品 i 的用户数，N(j) 是购买物品 j 的用户数，而分子 是同时购买物品i 和物品 j 的用户数。。可见上述的公式的核心是计算同时购买这件商品的人数比例 。当同时购买这两个物品人数越多，他们的相似度也就越高。另外值得注意的是，在分母中我们用了物品总购买人数做惩罚，也就是说某个物品可能很热门，导致它经常会被和其他物品一起购买，所以除以它的总购买人数，来降低它和其他物品的相似分数。 基于余弦的相似度计算 上面的方法计算物品相似度是直接使同时购买这两个物品的人数。但是也有可能存在用户购买了但不喜欢的情况 所以如果数据集包含了具体的评分数据 我们可以进一步把用户评分引入到相似度计算中 。 其中 是用户 k 对物品 i 的评分，如果没有评分则为 0。 热门物品的惩罚 对于热门物品的问题，可以用如下公式解决： 当 时，N(i) 越小，惩罚得越厉害，从而会使热 物品相关性分数下降。 4.2 基于用户的协同过滤(UserCF)基于用户的协同过滤（User CF ）的原理其实是和基于物品的协同过滤类似的。所不同的是，基于物品的协同过滤的原理是用户 U 购买了 A 物品，推荐给用户 U 和 A 相似的物品 B、C、D。而基于用户的协同过滤，是先计算用户 U 与其他的用户的相似度，然后取和 U 最相似的几个用户，把他们购买过的物品推荐给用户U。 为了计算用户相似度，我们首先要把用户购买过物品的索引数据转化成物品被用户购买过的索引数据，即物品的倒排索引： 建立好物品的倒排索引后，就可以根据相似度公式计算用户之间的相似度： 其中 N(a) 表示用户 a 购买物品的数量，N(b) 表示用户 b 购买物品的数量，N(a)∩N(b) 表示用户 a 和 b 购买相同物品的数量。有了用户的相似数据，针对用户 U 挑选 K 个最相似的用户，把他们购买过的物品中，U 未购买过的物品推荐给用户 U 即可。 4.3 矩阵分解上述计算会得到一个相似度矩阵，而这个矩阵的大小和纬度都是很大的，需要进行降维处理，用到的是SVD的降维方法，具体可以参考我之前写的降维方法：2.5 降维方法 基于稀疏自编码的矩阵分解 矩阵分解技术在推荐领域的应用比较成熟，但是通过上一节的介绍，我们不难发现矩阵分解本质上只通过一次分解来对 原矩阵进行逼近，特征挖掘的层次不够深入。另外矩阵分解也没有运用到物品本身的内容特征，例如书本的类别分类、音乐的流派分类等。随着神经网络技术的兴起，笔者发现通过多层感知机，可以得到更加深度的特征表示，并且可以对内容分类特征加以应用。首先，我们介绍一下稀疏自编码神经网络的设计思路。 基础的自编码结构 最简单的自编码结构如下图，构造个三层的神经网络，我们让输出层等于输入层，且中间层的维度远低于输入层和输出层，这样就得到了第一层的特征压缩。 简单来说自编码神经网络尝试学习中间层约等于输入层的函数。换句话说，它尝试逼近一个恒等函数。如果网络的输入数据是完全随机的，比如每一个输入都是一个跟其他特征完全无关的独立同分布高斯随机变 ，那么这一压缩表示将会非常难于学习。但是如果输入数据中隐含着 些特定的结构，比如某些输入特征是彼此相关的，那么这一算法就可以发现输入数据中的这些相关性。 多层结构 基于以上的单层隐藏层的网络结构，我们可以扩展至多层网络结构，学习到更高层次的抽象特征。 5. 隐语义模型5.1 基本思想推荐系统中一个重要的分支，隐语义建模。隐语义模型LFM：Latent Factor Model，其核心思想就是通过隐含特征联系用户兴趣和物品。 过程分为三个部分，将物品映射到隐含分类，确定用户对隐含分类的兴趣，然后选择用户感兴趣的分类中的物品推荐给用户。它是基于用户行为统计的自动聚类。 隐语义模型在Top-N推荐中的应用十分广泛。常用的隐语义模型，LSA(Latent Semantic Analysis)，LDA(Latent Dirichlet Allocation)，主题模型(Topic Model)，矩阵分解(Matrix Factorization)等等。 首先通过一个例子来理解一下这个模型，比如说有两个用户A和B，目前有用户的阅读列表，用户A的兴趣涉及侦探小说，科普图书以及一些计算机技术书，而用户B的兴趣比较集中在数学和机器学习方面。那么如何给A和B推荐图书呢？ 对于UserCF，首先需要找到和他们看了同样书的其他用户(兴趣相似的用户)，然后在给他们推荐那些用户喜欢的其他书。对于ItemCF,需要给他们推荐和他们已经看的书相似的书，比如用户B 看了很多数据挖掘方面的书，那么可以给他推荐机器学习或者模式识别方面的书。 还有一种方法就是使用隐语义模型，可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。 5.2 模型理解 如何给物品进行分类？ 如何确定用户对哪些类的物品感兴趣，以及感兴趣的程度？ 对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何确定这些物品在一个类中的权重？ 为了解决上面的问题，研究人员提出：为什么我们不从数据出发，自动地找到那些类，然后进行个性化推荐，隐语义分析技术因为采取基于用户行为统计的自动聚类，较好地解决了上面的问题。隐语义分析技术从诞生到今天产生了很多著名的模型和方法，其中和推荐技术相关的有pLSA，LDA，隐含类别模型（latent class model）, 隐含主题模型（latent topic model）, 矩阵分解（matrix factorization）。 LFM通过如下公式计算用户 u 对物品 i 的兴趣： 这个公式中 和 是模型的参数，其中 度量了用户 u 的兴趣和第 k 个隐类的关系，而 度量了第 k 个隐类和物品 i 之间的关系。那么，下面的问题就是如何计算这两个参数。 对最优化理论或者机器学习有所了解的读者，可能对如何计算这两个参数都比较清楚。这两个参数是从数据集中计算出来的。要计算这两个参数，需要一个训练集，对于每个用户u，训练集里都包含了用户u喜欢的物品和不感兴趣的物品，通过学习这个数据集，就可以获得上面的模型参数。 6. 排序算法在工业应用中，推荐系统通常可分为两部分，召回和排序。协同过滤属于召回的算法，从召回中得到一个比较小的推荐列表，然后经过排序之后才会输出到最终的推荐列表里，是一个有序的推荐列表。 这个过程会从几千万 item 中筛选出几百或者上千的候选集，然后在排序阶段选出30个给到每位用户。这个排序可理解为一个函数，F(user, item, context)，输入为用户、物品、环境，输出一个0到1之间的分数，取分数最高的几首。这一过程通常称为 CTR 预估。那么 F 函数常见的运作形式有： Logistic Regression 最简单的是逻辑回归(Logistic Regression)，一个广义线性模型。拿某 user 的用户画像(一个向量)比如[3, 1]，拼接上某 item 的物品画像比如[4, 0]，再加上代表 context 的向量[0, 1, 1]后得到[3, 1, 4, 0, 0, 1, 1]，若该 user 曾与该 item 发生过联系则 label 为1，这些加起来是一个正样本，同时可以将用户“跳过”的 item 或热门的却没有与用户产生过联系的 item 作为负样本，label 为0。按照这样的输入和输出就可以训练出排序算法了。详细模型见：2. 逻辑回归 GBDT 使用梯度提升决策树(GBDT) 的方案也可以解决这个排序的问题，只是模型与 LR 不一样。GBDT作为集成模型，会使用多棵决策树，每棵树去拟合前一棵树的残差来得到很好的拟合效果。一个样本输入到一棵树中，会根据各节点的条件往下走到某个叶子节点，将此节点值置为1，其余置为0。详细模型算法见：3.2 GBDT GBDT+LR GBDT与LR的stacking模型相对于只用GBDT会有略微的提升，更大的好处是防止GBDT过拟合。升级为GBDT+LR后，线上效果提升了约5%，并且因为省去了对新特征进行人工转换的步骤，增加特征的迭代测试也更容易了。 GBDT+FM GBDT是不支持高维稀疏特征的，如果将高维特征加到LR中，一方面需要人工组合高维特征，另一方面模型维度和计算复杂度会是O（N^2）级别的增长。所以设计了GBDT+FM的模型如图所示，采用Factorization Machines模型替换LR。 Factorization Machines（FM）模型如下所示： 具有以下几个优点①前两项为一个线性模型，相当于LR模型的作用②第三项为一个二次交叉项，能够自动对特征进行交叉组合③通过增加隐向量，模型训练和预测的计算复杂度降为了O(N)④支持稀疏特征。 几个优点，使的GBDT+FM具有了良好的稀疏特征支持，FM使用GBDT的叶子结点和稀疏特征（内容特征）作为输入，模型结构示意图如下，GBDT+FM模型上线后相比GBDT+LR在各项指标的效果提升在4%~6%之间。 DNN+GBDT+FM GBDT+FM模型，对embedding等具有结构信息的深度特征利用不充分，而深度学习（Deep Neural Network）能够对嵌入式（embedding）特征和普通稠密特征进行学习，抽取出深层信息，提高模型的准确性，并已经成功应用到众多机器学习领域。因此我们将DNN引入到排序模型中，提高排序整体质量。 DNN+GBDT+FM的ensemble模型架构如图所示，FM层作为模型的最后一层，即融合层，其输入由三部分组成：DNN的最后一层隐藏层、GBDT的输出叶子节点、高维稀疏特征。DNN+GBDT+FM的ensemble模型架构介绍如下所示，该模型上线后相对于GBDT+FM有4%的效果提升。 使用分布式的TensorFlow进行训练，使用基于TensorFlow Serving的微服务进行在线预测，DNN+GBDT+FM的ensemble模型使用的是Adam优化器。Adam结合了The Adaptive Gradient Algorithm（AdaGrad）和Root Mean Square Propagation（RMSProp）算法。具有更优的收敛速率，每个变量有独自的下降步长，整体下降步长会根据当前梯度进行调节，能够适应带噪音的数据。实验测试了多种优化器，Adam的效果是最优的。 工业界DNN ranking现状 Youtube于2016年推出DNN排序算法。 上海交通大学和UCL于2016年推出Product-based Neural Network（PNN）网络进行用户点击预测。PNN相当于在DNN层做了特征交叉，我们的做法是把特征交叉交给FM去做，DNN专注于深层信息的提取。 Google于2016年推出Wide And Deep Model，这个也是我们当前模型的基础，在此基础上使用FM替换了Cross Feature LR，简化了计算复杂度，提高交叉的泛化能力。 阿里今年使用attention机制推出了Deep Interest Network（DIN）进行商品点击率预估，优化embedding向量的准确性，值得借鉴。 7. 评估测试7.1 A/B测试新的推荐模型上线后要进行A/B测试，将它和旧的算法进行比较。 AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。对AB测试感兴趣的读者可以浏览一下网站http://www.abtests.com/ ，该网站给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。 切分流量是AB测试中的关键，不同的层以及控制这些层的团队需要从一个统一的地方获得自己AB测试的流量，而不同层之间的流量应该是正交的。 “正交性”是从几何中借来的术语。如果两条直线相交成直角，他们就是正交的。用向量术语来说，这两条直线互不依赖。 下图是一个简单的AB测试系统。用户进入网站后，流量分配系统决定用户是否需要被进行AB测试，如果需要的话，流量分配系统会给用户打上在测试中属于什么分组的标签。然后用户浏览网页，而用户在浏览网页时的行为都会被通过日志系统发回后台的日志数据库。此时，如果用户有测试分组的标签，那么该标签也会被发回后台数据库。在后台，实验人员的工作首先是配置流量分配系统，决定满足什么条件的用户参加什么样的测试。其次，实验人员需要统计日志数据库中的数据，通过评测系统生成不同分组用户的实验报告，并比较和评测实验结果。 当完成了AB测试后，根据指标结果，如果优于之前的推荐算法，那么旧的算法就可以替换成新的了。 7.2 其它评估方法模型准备就绪后，一般会先通过离线指标来评估模型的好坏， 然后再决定能否上线测试。离线算法评估常见的指标包括准确率、覆盖度 、多样性、新颖性和 UC 等。在线测试一般通过 A/B 测试进行，常见的指标有点击率、用户停留时间、 广告收入等，需要注意分析统计显著性。同时，需要注意短期的指标和长期的指标相结合， 一些短期指标的提升有时候反而会导致长期指标下降 比如 ，经常推荐美女或者搞笑类的内容会带来短期的点击率提高，但是可能会引起长期的用户粘性下降。设计者需要从自己的产品角度出发，根据产品的需要制定评估指标，这样才能更好地指导推荐系统的优化方向。常见的评价指标如下： 8. 推荐系统冷启动问题冷启动（ cold start ）在推荐系统中表示该系统积累数据量过少，无法给新用户作个性化推荐的问题，这是产品推荐的一大难题。每个有推荐功能的产品都会遇到冷启动的问题。一方面，当新商品时上架 会遇到冷启动的问题，没有收集到任何一个用户对其浏览、点击或者购买的行为，也无从判断如何将商品进行推荐；另一方面，新用户到来的时候，如果没有他在应用上的行为数据，也无法预测其兴趣，如果给用户的推荐千篇律，没有亮点，会使用户在一开始就对产品失去兴趣，从而放弃使用。所以在冷启动的时候要同时考虑用户的冷启动和物品的冷启动。 基本上，冷启动题可以分为以下三类。 8.1 用户冷启动用户冷启动主要解决如何给新用户作个性化推荐的问题。当新用户到来时，我 没有他的行为数据，所以也无法根据他的历史行为预 其兴趣，从而无法借此给他做个性化推荐。解决方法参考以下： 利用用户的账号信息。 利用用户的手机 IMEI 号进行冷启动。 制造选工页，让用户选择自己感兴趣的点后，即时生成粗粒度的推荐。 8.2 物品冷启动物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。解决方法参考以下： 利用物品的内容、分类信息。 利用专家标注的数据。 8.3 系统冷启动系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性推荐系统，从而在产品刚上线时就让用户体验到个性 推荐服务这一问题。 9. 参考文献 推荐系统实践–项亮 推荐系统与深度学习 美团机器学习实践 作者:@mantchs GitHub:https://github.com/NLP-LOVE/ML-NLP 欢迎大家加入讨论！共同完善此项目！群号:【541954936】","link":"/2019/09/27/Recommendation-System/"},{"title":"TensorFlow 2.0 中文手写字识别（汉字OCR）","text":"TensorFlow 2.0 中文手写字识别（汉字OCR） 搜索空间空前巨大，我们使用的数据集1.0版本汉字就多大3755个，如果加上1.1版本一起，总共汉字可以分为多达7599+个类别！这比10个阿拉伯字母识别难度大很多！ 数据集处理挑战更大，相比于mnist和fasionmnist来说，汉字手写字体识别数据集非常少，而且仅有的数据集数据预处理难度非常大，非常不直观，但是，千万别吓到，相信你看完本教程一定会收货满满! 汉字识别更考验选手的建模能力，还在分类花？分类猫和狗？随便搭建的几层在搜索空间巨大的汉字手写识别里根本不work！你现在是不是想用很深的网络跃跃欲试？更深的网络在这个任务上可能根本不可行！！看完本教程我们就可以一探究竟！总之一句话，模型太简单和太复杂都不好，甚至会发散！（想亲身体验模型训练发散抓狂的可以来尝试一下！）。 数据准备在开始之前，先介绍一下本项目所采用的数据信息。我们的数据全部来自于CASIA的开源中文手写字数据集，该数据集分为两部分： CASIA-HWDB：离线的HWDB，我们仅仅使用1.0-1.2，这是单字的数据集，2.0-2.2是整张文本的数据集，我们暂时不用，单字里面包含了约7185个汉字以及171个英文字母、数字、标点符号等； CASIA-OLHWDB：在线的HWDB，格式一样，包含了约7185个汉字以及171个英文字母、数字、标点符号等，我们不用。 其实你下载1.0的train和test差不多已经够了，可以直接运行 dataset/get_hwdb_1.0_1.1.sh 下载。原始数据下载链接点击这里. 由于原始数据过于复杂，我们使用一个类来封装数据读取过程，这是我们展示的效果： 看到这么密密麻麻的文字相信连人类都…. 开始头疼了，这些复杂的文字能够通过一个神经网络来识别出来？？答案是肯定的…. 不有得感叹一下神经网络的强大。。上面的部分文字识别出来的结果是这样的： 关于数据的处理部分，从服务器下载到的原始数据是 trn_gnt.zip 解压之后是 gnt.alz， 需要再次解压得到一个包含 gnt文件的文件夹。里面每一个gnt文件都包含了若干个汉字及其标注。直接处理比较麻烦，也不方便抽取出图片再进行操作，虽然转为图片存入文件夹比较直观，但是不适合批量读取和训练, 后面我们统一转为tfrecord进行训练。 更新: 实际上，由于单个汉字图片其实很小，差不多也就最大80x80的大小，这个大小不适合转成图片保存到本地，因此我们将hwdb原始的二进制保存为tfrecord。同时也方便后面训练，可以直接从tfrecord读取图片进行训练。 训练过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def train(): all_characters = load_characters() num_classes = len(all_characters) logging.info('all characters: {}'.format(num_classes)) train_dataset = load_ds() train_dataset = train_dataset.shuffle(100).map(preprocess).batch(32).repeat() val_ds = load_val_ds() val_ds = val_ds.shuffle(100).map(preprocess).batch(32).repeat() for data in train_dataset.take(2): print(data) # init model model = build_net_003((64, 64, 1), num_classes) model.summary() logging.info('model loaded.') start_epoch = 0 latest_ckpt = tf.train.latest_checkpoint(os.path.dirname(ckpt_path)) if latest_ckpt: start_epoch = int(latest_ckpt.split('-')[1].split('.')[0]) model.load_weights(latest_ckpt) logging.info('model resumed from: {}, start at epoch: {}'.format(latest_ckpt, start_epoch)) else: logging.info('passing resume since weights not there. training from scratch') if use_keras_fit: model.compile( optimizer=tf.keras.optimizers.Adam(), loss=tf.keras.losses.SparseCategoricalCrossentropy(), metrics=['accuracy']) callbacks = [ tf.keras.callbacks.ModelCheckpoint(ckpt_path, save_weights_only=True, verbose=1, period=500) ] try: model.fit( train_dataset, validation_data=val_ds, validation_steps=1000, epochs=15000, steps_per_epoch=1024, callbacks=callbacks) except KeyboardInterrupt: model.save_weights(ckpt_path.format(epoch=0)) logging.info('keras model saved.') model.save_weights(ckpt_path.format(epoch=0)) model.save(os.path.join(os.path.dirname(ckpt_path), 'cn_ocr.h5')) 大家在以后编写训练代码的时候其实可以保持这个好的习惯。 OK，整个模型训练起来之后，可以在短时间内达到95%的准确率： 总结通过本教程，我们完成了使用tensorflow 2.0全新的API搭建一个中文汉字手写识别系统。模型基本能够实现我们想要的功能。要知道，这个模型可是在搜索空间多大3755的类别当中准确的找到最相似的类别！！通过本实验，我们有几点心得： 神经网络不仅仅是在学习，它具有一定的想象力！！比如它的一些看着很像的字：拜-佯， 扮-捞，笨-苯…. 这些字如果手写出来，连人都比较难以辨认！！但是大家要知道这些字在类别上并不是相领的！也就是说，模型具有一定的联想能力！ 不管问题多复杂，要敢于动手、善于动手。","link":"/2019/09/06/TensorFlow-2-0-中文手写字识别（汉字OCR）/"},{"title":"System类","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256/* * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * */package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;/** * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author unascribed * @since JDK1.0 */public final class System { /* register the natives via the static initializer. * * VM will invoke the initializeSystemClass method to complete * the initialization for this class separated from clinit. * Note that to use properties set by the VM, see the constraints * described in the initializeSystemClass method. */ private static native void registerNatives(); static { registerNatives(); } /** Don't let anyone instantiate this class */ private System() { } /** * The \"standard\" input stream. This stream is already * open and ready to supply input data. Typically this stream * corresponds to keyboard input or another input source specified by * the host environment or user. */ public final static InputStream in = null; /** * The \"standard\" output stream. This stream is already * open and ready to accept output data. Typically this stream * corresponds to display output or another output destination * specified by the host environment or user. * &lt;p&gt; * For simple stand-alone Java applications, a typical way to write * a line of output data is: * &lt;blockquote&gt;&lt;pre&gt; * System.out.println(data) * &lt;/pre&gt;&lt;/blockquote&gt; * &lt;p&gt; * See the &lt;code&gt;println&lt;/code&gt; methods in class &lt;code&gt;PrintStream&lt;/code&gt;. * * @see java.io.PrintStream#println() * @see java.io.PrintStream#println(boolean) * @see java.io.PrintStream#println(char) * @see java.io.PrintStream#println(char[]) * @see java.io.PrintStream#println(double) * @see java.io.PrintStream#println(float) * @see java.io.PrintStream#println(int) * @see java.io.PrintStream#println(long) * @see java.io.PrintStream#println(java.lang.Object) * @see java.io.PrintStream#println(java.lang.String) */ public final static PrintStream out = null; /** * The \"standard\" error output stream. This stream is already * open and ready to accept output data. * &lt;p&gt; * Typically this stream corresponds to display output or another * output destination specified by the host environment or user. By * convention, this output stream is used to display error messages * or other information that should come to the immediate attention * of a user even if the principal output stream, the value of the * variable &lt;code&gt;out&lt;/code&gt;, has been redirected to a file or other * destination that is typically not continuously monitored. */ public final static PrintStream err = null; /* The security manager for the system. */ private static volatile SecurityManager security = null; /** * Reassigns the \"standard\" input stream. * * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; * method is called with a &lt;code&gt;RuntimePermission(\"setIO\")&lt;/code&gt; permission * to see if it's ok to reassign the \"standard\" input stream. * &lt;p&gt; * * @param in the new standard input stream. * * @throws SecurityException * if a security manager exists and its * &lt;code&gt;checkPermission&lt;/code&gt; method doesn't allow * reassigning of the standard input stream. * * @see SecurityManager#checkPermission * @see java.lang.RuntimePermission * * @since JDK1.1 */ public static void setIn(InputStream in) { checkIO(); setIn0(in); } /** * Reassigns the \"standard\" output stream. * * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; * method is called with a &lt;code&gt;RuntimePermission(\"setIO\")&lt;/code&gt; permission * to see if it's ok to reassign the \"standard\" output stream. * * @param out the new standard output stream * * @throws SecurityException * if a security manager exists and its * &lt;code&gt;checkPermission&lt;/code&gt; method doesn't allow * reassigning of the standard output stream. * * @see SecurityManager#checkPermission * @see java.lang.RuntimePermission * * @since JDK1.1 */ public static void setOut(PrintStream out) { checkIO(); setOut0(out); } /** * Reassigns the \"standard\" error output stream. * * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; * method is called with a &lt;code&gt;RuntimePermission(\"setIO\")&lt;/code&gt; permission * to see if it's ok to reassign the \"standard\" error output stream. * * @param err the new standard error output stream. * * @throws SecurityException * if a security manager exists and its * &lt;code&gt;checkPermission&lt;/code&gt; method doesn't allow * reassigning of the standard error output stream. * * @see SecurityManager#checkPermission * @see java.lang.RuntimePermission * * @since JDK1.1 */ public static void setErr(PrintStream err) { checkIO(); setErr0(err); } private static volatile Console cons = null; /** * Returns the unique {@link java.io.Console Console} object associated * with the current Java virtual machine, if any. * * @return The system console, if any, otherwise &lt;tt&gt;null&lt;/tt&gt;. * * @since 1.6 */ public static Console console() { if (cons == null) { synchronized (System.class) { cons = sun.misc.SharedSecrets.getJavaIOAccess().console(); } } return cons; } /** * Returns the channel inherited from the entity that created this * Java virtual machine. * * &lt;p&gt; This method returns the channel obtained by invoking the * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel * inheritedChannel} method of the system-wide default * {@link java.nio.channels.spi.SelectorProvider} object. &lt;/p&gt; * * &lt;p&gt; In addition to the network-oriented channels described in * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel * inheritedChannel}, this method may return other kinds of * channels in the future. * * @return The inherited channel, if any, otherwise &lt;tt&gt;null&lt;/tt&gt;. * * @throws IOException * If an I/O error occurs * * @throws SecurityException * If a security manager is present and it does not * permit access to the channel. * * @since 1.5 */ public static Channel inheritedChannel() throws IOException { return SelectorProvider.provider().inheritedChannel(); } private static void checkIO() { SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(\"setIO\")); } } private static native void setIn0(InputStream in); private static native void setOut0(PrintStream out); private static native void setErr0(PrintStream err); /** * Sets the System security. * * &lt;p&gt; If there is a security manager already installed, this method first * calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method * with a &lt;code&gt;RuntimePermission(\"setSecurityManager\")&lt;/code&gt; * permission to ensure it's ok to replace the existing * security manager. * This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;. * * &lt;p&gt; Otherwise, the argument is established as the current * security manager. If the argument is &lt;code&gt;null&lt;/code&gt; and no * security manager has been established, then no action is taken and * the method simply returns. * * @param s the security manager. * @exception SecurityException if the security manager has already * been set and its &lt;code&gt;checkPermission&lt;/code&gt; method * doesn't allow it to be replaced. * @see #getSecurityManager * @see SecurityManager#checkPermission * @see java.lang.RuntimePermission */ public static void setSecurityManager(final SecurityManager s) { try { s.checkPackageAccess(\"java.lang\"); } catch (Exception e) { // no-op } setSecurityManager0(s); } private static synchronized void setSecurityManager0(final SecurityManager s) { SecurityManager sm = getSecurityManager(); if (sm != null) { // ask the currently installed security manager if we // can replace it. sm.checkPermission(new RuntimePermission (\"setSecurityManager\")); } if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) { // New security manager class is not on bootstrap classpath. // Cause policy to get initialized before we install the new // security manager, in order to prevent infinite loops when // trying to initialize the policy (which usually involves // accessing some security and/or system properties, which in turn // calls the installed security manager's checkPermission method // which will loop infinitely if there is a non-system class // (in this case: the new security manager class) on the stack). AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { public Object run() { s.getClass().getProtectionDomain().implies (SecurityConstants.ALL_PERMISSION); return null; } }); } security = s; } /** * Gets the system security interface. * * @return if a security manager has already been established for the * current application, then that security manager is returned; * otherwise, &lt;code&gt;null&lt;/code&gt; is returned. * @see #setSecurityManager */ public static SecurityManager getSecurityManager() { return security; } /** * Returns the current time in milliseconds. Note that * while the unit of time of the return value is a millisecond, * the granularity of the value depends on the underlying * operating system and may be larger. For example, many * operating systems measure time in units of tens of * milliseconds. * * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;/code&gt; for * a discussion of slight discrepancies that may arise between * \"computer time\" and coordinated universal time (UTC). * * @return the difference, measured in milliseconds, between * the current time and midnight, January 1, 1970 UTC. * @see java.util.Date */ public static native long currentTimeMillis(); /** * Returns the current value of the running Java Virtual Machine's * high-resolution time source, in nanoseconds. * * &lt;p&gt;This method can only be used to measure elapsed time and is * not related to any other notion of system or wall-clock time. * The value returned represents nanoseconds since some fixed but * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values * may be negative). The same origin is used by all invocations of * this method in an instance of a Java virtual machine; other * virtual machine instances are likely to use a different origin. * * &lt;p&gt;This method provides nanosecond precision, but not necessarily * nanosecond resolution (that is, how frequently the value changes) * - no guarantees are made except that the resolution is at least as * good as that of {@link #currentTimeMillis()}. * * &lt;p&gt;Differences in successive calls that span greater than * approximately 292 years (2&lt;sup&gt;63&lt;/sup&gt; nanoseconds) will not * correctly compute elapsed time due to numerical overflow. * * &lt;p&gt;The values returned by this method become meaningful only when * the difference between two such values, obtained within the same * instance of a Java virtual machine, is computed. * * &lt;p&gt; For example, to measure how long some code takes to execute: * &lt;pre&gt; {@code * long startTime = System.nanoTime(); * // ... the code being measured ... * long estimatedTime = System.nanoTime() - startTime;}&lt;/pre&gt; * * &lt;p&gt;To compare two nanoTime values * &lt;pre&gt; {@code * long t0 = System.nanoTime(); * ... * long t1 = System.nanoTime();}&lt;/pre&gt; * * one should use {@code t1 - t0 &lt; 0}, not {@code t1 &lt; t0}, * because of the possibility of numerical overflow. * * @return the current value of the running Java Virtual Machine's * high-resolution time source, in nanoseconds * @since 1.5 */ public static native long nanoTime(); /** * Copies an array from the specified source array, beginning at the * specified position, to the specified position of the destination array. * A subsequence of array components are copied from the source * array referenced by &lt;code&gt;src&lt;/code&gt; to the destination array * referenced by &lt;code&gt;dest&lt;/code&gt;. The number of components copied is * equal to the &lt;code&gt;length&lt;/code&gt; argument. The components at * positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; in the source array are copied into * positions &lt;code&gt;destPos&lt;/code&gt; through * &lt;code&gt;destPos+length-1&lt;/code&gt;, respectively, of the destination * array. * &lt;p&gt; * If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the * same array object, then the copying is performed as if the * components at positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary * array with &lt;code&gt;length&lt;/code&gt; components and then the contents of * the temporary array were copied into positions * &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the * destination array. * &lt;p&gt; * If &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. * &lt;p&gt; * If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination * array is not modified. * &lt;p&gt; * Otherwise, if any of the following is true, an * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown and the destination is * not modified: * &lt;ul&gt; * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an object that is not an * array. * &lt;li&gt;The &lt;code&gt;dest&lt;/code&gt; argument refers to an object that is not an * array. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument and &lt;code&gt;dest&lt;/code&gt; argument refer * to arrays whose component types are different primitive types. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a primitive * component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array * with a reference component type. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a reference * component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array * with a primitive component type. * &lt;/ul&gt; * &lt;p&gt; * Otherwise, if any of the following is true, an * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is * thrown and the destination is not modified: * &lt;ul&gt; * &lt;li&gt;The &lt;code&gt;srcPos&lt;/code&gt; argument is negative. * &lt;li&gt;The &lt;code&gt;destPos&lt;/code&gt; argument is negative. * &lt;li&gt;The &lt;code&gt;length&lt;/code&gt; argument is negative. * &lt;li&gt;&lt;code&gt;srcPos+length&lt;/code&gt; is greater than * &lt;code&gt;src.length&lt;/code&gt;, the length of the source array. * &lt;li&gt;&lt;code&gt;destPos+length&lt;/code&gt; is greater than * &lt;code&gt;dest.length&lt;/code&gt;, the length of the destination array. * &lt;/ul&gt; * &lt;p&gt; * Otherwise, if any actual component of the source array from * position &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; cannot be converted to the component * type of the destination array by assignment conversion, an * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown. In this case, let * &lt;b&gt;&lt;i&gt;k&lt;/i&gt;&lt;/b&gt; be the smallest nonnegative integer less than * length such that &lt;code&gt;src[srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; * cannot be converted to the component type of the destination * array; when the exception is thrown, source array components from * positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1&lt;/code&gt; * will already have been copied to destination array positions * &lt;code&gt;destPos&lt;/code&gt; through * &lt;code&gt;destPos+&lt;/code&gt;&lt;i&gt;k&lt;/I&gt;&lt;code&gt;-1&lt;/code&gt; and no other * positions of the destination array will have been modified. * (Because of the restrictions already itemized, this * paragraph effectively applies only to the situation where both * arrays have component types that are reference types.) * * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. * @exception IndexOutOfBoundsException if copying would cause * access of data outside array bounds. * @exception ArrayStoreException if an element in the &lt;code&gt;src&lt;/code&gt; * array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array * because of a type mismatch. * @exception NullPointerException if either &lt;code&gt;src&lt;/code&gt; or * &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); /** * Returns the same hash code for the given object as * would be returned by the default method hashCode(), * whether or not the given object's class overrides * hashCode(). * The hash code for the null reference is zero. * * @param x object for which the hashCode is to be calculated * @return the hashCode * @since JDK1.1 */ public static native int identityHashCode(Object x); /** * System properties. The following properties are guaranteed to be defined: * &lt;dl&gt; * &lt;dt&gt;java.version &lt;dd&gt;Java version number * &lt;dt&gt;java.vendor &lt;dd&gt;Java vendor specific string * &lt;dt&gt;java.vendor.url &lt;dd&gt;Java vendor URL * &lt;dt&gt;java.home &lt;dd&gt;Java installation directory * &lt;dt&gt;java.class.version &lt;dd&gt;Java class version number * &lt;dt&gt;java.class.path &lt;dd&gt;Java classpath * &lt;dt&gt;os.name &lt;dd&gt;Operating System Name * &lt;dt&gt;os.arch &lt;dd&gt;Operating System Architecture * &lt;dt&gt;os.version &lt;dd&gt;Operating System Version * &lt;dt&gt;file.separator &lt;dd&gt;File separator (\"/\" on Unix) * &lt;dt&gt;path.separator &lt;dd&gt;Path separator (\":\" on Unix) * &lt;dt&gt;line.separator &lt;dd&gt;Line separator (\"\\n\" on Unix) * &lt;dt&gt;user.name &lt;dd&gt;User account name * &lt;dt&gt;user.home &lt;dd&gt;User home directory * &lt;dt&gt;user.dir &lt;dd&gt;User's current working directory * &lt;/dl&gt; */ private static Properties props; private static native Properties initProperties(Properties props); /** * Determines the current system properties. * &lt;p&gt; * First, if there is a security manager, its * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called with no * arguments. This may result in a security exception. * &lt;p&gt; * The current set of system properties for use by the * {@link #getProperty(String)} method is returned as a * &lt;code&gt;Properties&lt;/code&gt; object. If there is no current set of * system properties, a set of system properties is first created and * initialized. This set of system properties always includes values * for the following keys: * &lt;table summary=\"Shows property keys and associated values\"&gt; * &lt;tr&gt;&lt;th&gt;Key&lt;/th&gt; * &lt;th&gt;Description of Associated Value&lt;/th&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Runtime Environment version&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Runtime Environment vendor&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor.url&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java vendor URL&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.home&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java installation directory&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine specification version&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.vendor&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine specification vendor&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.name&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine specification name&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine implementation version&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.vendor&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine implementation vendor&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.name&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Virtual Machine implementation name&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Runtime Environment specification version&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.vendor&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Runtime Environment specification vendor&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.name&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java Runtime Environment specification name&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java class format version number&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.path&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Java class path&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.library.path&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;List of paths to search when loading libraries&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.io.tmpdir&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Default temp file path&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.compiler&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Name of JIT compiler to use&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.ext.dirs&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Path of extension directory or directories * &lt;b&gt;Deprecated.&lt;/b&gt; &lt;i&gt;This property, and the mechanism * which implements it, may be removed in a future * release.&lt;/i&gt; &lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.name&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Operating system name&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.arch&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Operating system architecture&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.version&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Operating system version&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;file.separator&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;File separator (\"/\" on UNIX)&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;path.separator&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Path separator (\":\" on UNIX)&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;line.separator&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Line separator (\"\\n\" on UNIX)&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.name&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;User's account name&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.home&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;User's home directory&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.dir&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;User's current working directory&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * &lt;p&gt; * Multiple paths in a system property value are separated by the path * separator character of the platform. * &lt;p&gt; * Note that even if the security manager does not permit the * &lt;code&gt;getProperties&lt;/code&gt; operation, it may choose to permit the * {@link #getProperty(String)} operation. * * @return the system properties * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method doesn't allow access * to the system properties. * @see #setProperties * @see java.lang.SecurityException * @see java.lang.SecurityManager#checkPropertiesAccess() * @see java.util.Properties */ public static Properties getProperties() { SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPropertiesAccess(); } return props; } /** * Returns the system-dependent line separator string. It always * returns the same value - the initial value of the {@linkplain * #getProperty(String) system property} {@code line.separator}. * * &lt;p&gt;On UNIX systems, it returns {@code \"\\n\"}; on Microsoft * Windows systems it returns {@code \"\\r\\n\"}. * * @return the system-dependent line separator string * @since 1.7 */ public static String lineSeparator() { return lineSeparator; } private static String lineSeparator; /** * Sets the system properties to the &lt;code&gt;Properties&lt;/code&gt; * argument. * &lt;p&gt; * First, if there is a security manager, its * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called with no * arguments. This may result in a security exception. * &lt;p&gt; * The argument becomes the current set of system properties for use * by the {@link #getProperty(String)} method. If the argument is * &lt;code&gt;null&lt;/code&gt;, then the current set of system properties is * forgotten. * * @param props the new system properties. * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method doesn't allow access * to the system properties. * @see #getProperties * @see java.util.Properties * @see java.lang.SecurityException * @see java.lang.SecurityManager#checkPropertiesAccess() */ public static void setProperties(Properties props) { SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPropertiesAccess(); } if (props == null) { props = new Properties(); initProperties(props); } System.props = props; } /** * Gets the system property indicated by the specified key. * &lt;p&gt; * First, if there is a security manager, its * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method is called with the key as * its argument. This may result in a SecurityException. * &lt;p&gt; * If there is no current set of system properties, a set of system * properties is first created and initialized in the same manner as * for the &lt;code&gt;getProperties&lt;/code&gt; method. * * @param key the name of the system property. * @return the string value of the system property, * or &lt;code&gt;null&lt;/code&gt; if there is no property with that key. * * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn't allow * access to the specified system property. * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt;. * @exception IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty. * @see #setProperty * @see java.lang.SecurityException * @see java.lang.SecurityManager#checkPropertyAccess(java.lang.String) * @see java.lang.System#getProperties() */ public static String getProperty(String key) { checkKey(key); SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPropertyAccess(key); } return props.getProperty(key); } /** * Gets the system property indicated by the specified key. * &lt;p&gt; * First, if there is a security manager, its * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method is called with the * &lt;code&gt;key&lt;/code&gt; as its argument. * &lt;p&gt; * If there is no current set of system properties, a set of system * properties is first created and initialized in the same manner as * for the &lt;code&gt;getProperties&lt;/code&gt; method. * * @param key the name of the system property. * @param def a default value. * @return the string value of the system property, * or the default value if there is no property with that key. * * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn't allow * access to the specified system property. * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt;. * @exception IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty. * @see #setProperty * @see java.lang.SecurityManager#checkPropertyAccess(java.lang.String) * @see java.lang.System#getProperties() */ public static String getProperty(String key, String def) { checkKey(key); SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPropertyAccess(key); } return props.getProperty(key, def); } /** * Sets the system property indicated by the specified key. * &lt;p&gt; * First, if a security manager exists, its * &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method * is called with a &lt;code&gt;PropertyPermission(key, \"write\")&lt;/code&gt; * permission. This may result in a SecurityException being thrown. * If no exception is thrown, the specified property is set to the given * value. * &lt;p&gt; * * @param key the name of the system property. * @param value the value of the system property. * @return the previous value of the system property, * or &lt;code&gt;null&lt;/code&gt; if it did not have one. * * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPermission&lt;/code&gt; method doesn't allow * setting of the specified property. * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; or * &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. * @exception IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty. * @see #getProperty * @see java.lang.System#getProperty(java.lang.String) * @see java.lang.System#getProperty(java.lang.String, java.lang.String) * @see java.util.PropertyPermission * @see SecurityManager#checkPermission * @since 1.2 */ public static String setProperty(String key, String value) { checkKey(key); SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPermission(new PropertyPermission(key, SecurityConstants.PROPERTY_WRITE_ACTION)); } return (String) props.setProperty(key, value); } /** * Removes the system property indicated by the specified key. * &lt;p&gt; * First, if a security manager exists, its * &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method * is called with a &lt;code&gt;PropertyPermission(key, \"write\")&lt;/code&gt; * permission. This may result in a SecurityException being thrown. * If no exception is thrown, the specified property is removed. * &lt;p&gt; * * @param key the name of the system property to be removed. * @return the previous string value of the system property, * or &lt;code&gt;null&lt;/code&gt; if there was no property with that key. * * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn't allow * access to the specified system property. * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt;. * @exception IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty. * @see #getProperty * @see #setProperty * @see java.util.Properties * @see java.lang.SecurityException * @see java.lang.SecurityManager#checkPropertiesAccess() * @since 1.5 */ public static String clearProperty(String key) { checkKey(key); SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPermission(new PropertyPermission(key, \"write\")); } return (String) props.remove(key); } private static void checkKey(String key) { if (key == null) { throw new NullPointerException(\"key can't be null\"); } if (key.equals(\"\")) { throw new IllegalArgumentException(\"key can't be empty\"); } } /** * Gets the value of the specified environment variable. An * environment variable is a system-dependent external named * value. * * &lt;p&gt;If a security manager exists, its * {@link SecurityManager#checkPermission checkPermission} * method is called with a * &lt;code&gt;{@link RuntimePermission}(\"getenv.\"+name)&lt;/code&gt; * permission. This may result in a {@link SecurityException} * being thrown. If no exception is thrown the value of the * variable &lt;code&gt;name&lt;/code&gt; is returned. * * &lt;p&gt;&lt;a name=\"EnvironmentVSSystemProperties\"&gt;&lt;i&gt;System * properties&lt;/i&gt; and &lt;i&gt;environment variables&lt;/i&gt;&lt;/a&gt; are both * conceptually mappings between names and values. Both * mechanisms can be used to pass user-defined information to a * Java process. Environment variables have a more global effect, * because they are visible to all descendants of the process * which defines them, not just the immediate Java subprocess. * They can have subtly different semantics, such as case * insensitivity, on different operating systems. For these * reasons, environment variables are more likely to have * unintended side effects. It is best to use system properties * where possible. Environment variables should be used when a * global effect is desired, or when an external system interface * requires an environment variable (such as &lt;code&gt;PATH&lt;/code&gt;). * * &lt;p&gt;On UNIX systems the alphabetic case of &lt;code&gt;name&lt;/code&gt; is * typically significant, while on Microsoft Windows systems it is * typically not. For example, the expression * &lt;code&gt;System.getenv(\"FOO\").equals(System.getenv(\"foo\"))&lt;/code&gt; * is likely to be true on Microsoft Windows. * * @param name the name of the environment variable * @return the string value of the variable, or &lt;code&gt;null&lt;/code&gt; * if the variable is not defined in the system environment * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; * @throws SecurityException * if a security manager exists and its * {@link SecurityManager#checkPermission checkPermission} * method doesn't allow access to the environment variable * &lt;code&gt;name&lt;/code&gt; * @see #getenv() * @see ProcessBuilder#environment() */ public static String getenv(String name) { SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(\"getenv.\"+name)); } return ProcessEnvironment.getenv(name); } /** * Returns an unmodifiable string map view of the current system environment. * The environment is a system-dependent mapping from names to * values which is passed from parent to child processes. * * &lt;p&gt;If the system does not support environment variables, an * empty map is returned. * * &lt;p&gt;The returned map will never contain null keys or values. * Attempting to query the presence of a null key or value will * throw a {@link NullPointerException}. Attempting to query * the presence of a key or value which is not of type * {@link String} will throw a {@link ClassCastException}. * * &lt;p&gt;The returned map and its collection views may not obey the * general contract of the {@link Object#equals} and * {@link Object#hashCode} methods. * * &lt;p&gt;The returned map is typically case-sensitive on all platforms. * * &lt;p&gt;If a security manager exists, its * {@link SecurityManager#checkPermission checkPermission} * method is called with a * &lt;code&gt;{@link RuntimePermission}(\"getenv.*\")&lt;/code&gt; * permission. This may result in a {@link SecurityException} being * thrown. * * &lt;p&gt;When passing information to a Java subprocess, * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;/a&gt; * are generally preferred over environment variables. * * @return the environment as a map of variable names to values * @throws SecurityException * if a security manager exists and its * {@link SecurityManager#checkPermission checkPermission} * method doesn't allow access to the process environment * @see #getenv(String) * @see ProcessBuilder#environment() * @since 1.5 */ public static java.util.Map&lt;String,String&gt; getenv() { SecurityManager sm = getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(\"getenv.*\")); } return ProcessEnvironment.getenv(); } /** * Terminates the currently running Java Virtual Machine. The * argument serves as a status code; by convention, a nonzero status * code indicates abnormal termination. * &lt;p&gt; * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally. * &lt;p&gt; * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to * the call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().exit(n) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param status exit status. * @throws SecurityException * if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt; * method doesn't allow exit with the specified status. * @see java.lang.Runtime#exit(int) */ public static void exit(int status) { Runtime.getRuntime().exit(status); } /** * Runs the garbage collector. * &lt;p&gt; * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual * Machine expend effort toward recycling unused objects in order to * make the memory they currently occupy available for quick reuse. * When control returns from the method call, the Java Virtual * Machine has made a best effort to reclaim space from all discarded * objects. * &lt;p&gt; * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the * call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().gc() * &lt;/pre&gt;&lt;/blockquote&gt; * * @see java.lang.Runtime#gc() */ public static void gc() { Runtime.getRuntime().gc(); } /** * Runs the finalization methods of any objects pending finalization. * &lt;p&gt; * Calling this method suggests that the Java Virtual Machine expend * effort toward running the &lt;code&gt;finalize&lt;/code&gt; methods of objects * that have been found to be discarded but whose &lt;code&gt;finalize&lt;/code&gt; * methods have not yet been run. When control returns from the * method call, the Java Virtual Machine has made a best effort to * complete all outstanding finalizations. * &lt;p&gt; * The call &lt;code&gt;System.runFinalization()&lt;/code&gt; is effectively * equivalent to the call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().runFinalization() * &lt;/pre&gt;&lt;/blockquote&gt; * * @see java.lang.Runtime#runFinalization() */ public static void runFinalization() { Runtime.getRuntime().runFinalization(); } /** * Enable or disable finalization on exit; doing so specifies that the * finalizers of all objects that have finalizers that have not yet been * automatically invoked are to be run before the Java runtime exits. * By default, finalization on exit is disabled. * * &lt;p&gt;If there is a security manager, * its &lt;code&gt;checkExit&lt;/code&gt; method is first called * with 0 as its argument to ensure the exit is allowed. * This could result in a SecurityException. * * @deprecated This method is inherently unsafe. It may result in * finalizers being called on live objects while other threads are * concurrently manipulating those objects, resulting in erratic * behavior or deadlock. * @param value indicating enabling or disabling of finalization * @throws SecurityException * if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt; * method doesn't allow the exit. * * @see java.lang.Runtime#exit(int) * @see java.lang.Runtime#gc() * @see java.lang.SecurityManager#checkExit(int) * @since JDK1.1 */ @Deprecated public static void runFinalizersOnExit(boolean value) { Runtime.runFinalizersOnExit(value); } /** * Loads the native library specified by the filename argument. The filename * argument must be an absolute path name. * * If the filename argument, when stripped of any platform-specific library * prefix, path, and file extension, indicates a library whose name is, * for example, L, and a native library called L is statically linked * with the VM, then the JNI_OnLoad_L function exported by the library * is invoked rather than attempting to load a dynamic library. * A filename matching the argument does not have to exist in the * file system. * See the JNI Specification for more details. * * Otherwise, the filename argument is mapped to a native library image in * an implementation-dependent manner. * * &lt;p&gt; * The call &lt;code&gt;System.load(name)&lt;/code&gt; is effectively equivalent * to the call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().load(name) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param filename the file to load. * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkLink&lt;/code&gt; method doesn't allow * loading of the specified dynamic library * @exception UnsatisfiedLinkError if either the filename is not an * absolute path name, the native library is not statically * linked with the VM, or the library cannot be mapped to * a native library image by the host system. * @exception NullPointerException if &lt;code&gt;filename&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt; * @see java.lang.Runtime#load(java.lang.String) * @see java.lang.SecurityManager#checkLink(java.lang.String) */ @CallerSensitive public static void load(String filename) { Runtime.getRuntime().load0(Reflection.getCallerClass(), filename); } /** * Loads the native library specified by the &lt;code&gt;libname&lt;/code&gt; * argument. The &lt;code&gt;libname&lt;/code&gt; argument must not contain any platform * specific prefix, file extension or path. If a native library * called &lt;code&gt;libname&lt;/code&gt; is statically linked with the VM, then the * JNI_OnLoad_&lt;code&gt;libname&lt;/code&gt; function exported by the library is invoked. * See the JNI Specification for more details. * * Otherwise, the libname argument is loaded from a system library * location and mapped to a native library image in an implementation- * dependent manner. * &lt;p&gt; * The call &lt;code&gt;System.loadLibrary(name)&lt;/code&gt; is effectively * equivalent to the call * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().loadLibrary(name) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param libname the name of the library. * @exception SecurityException if a security manager exists and its * &lt;code&gt;checkLink&lt;/code&gt; method doesn't allow * loading of the specified dynamic library * @exception UnsatisfiedLinkError if either the libname argument * contains a file path, the native library is not statically * linked with the VM, or the library cannot be mapped to a * native library image by the host system. * @exception NullPointerException if &lt;code&gt;libname&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt; * @see java.lang.Runtime#loadLibrary(java.lang.String) * @see java.lang.SecurityManager#checkLink(java.lang.String) */ @CallerSensitive public static void loadLibrary(String libname) { Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname); } /** * Maps a library name into a platform-specific string representing * a native library. * * @param libname the name of the library. * @return a platform-dependent native library name. * @exception NullPointerException if &lt;code&gt;libname&lt;/code&gt; is * &lt;code&gt;null&lt;/code&gt; * @see java.lang.System#loadLibrary(java.lang.String) * @see java.lang.ClassLoader#findLibrary(java.lang.String) * @since 1.2 */ public static native String mapLibraryName(String libname); /** * Create PrintStream for stdout/err based on encoding. */ private static PrintStream newPrintStream(FileOutputStream fos, String enc) { if (enc != null) { try { return new PrintStream(new BufferedOutputStream(fos, 128), true, enc); } catch (UnsupportedEncodingException uee) {} } return new PrintStream(new BufferedOutputStream(fos, 128), true); } /** * Initialize the system class. Called after thread initialization. */ private static void initializeSystemClass() { // VM might invoke JNU_NewStringPlatform() to set those encoding // sensitive properties (user.home, user.name, boot.class.path, etc.) // during \"props\" initialization, in which it may need access, via // System.getProperty(), to the related system encoding property that // have been initialized (put into \"props\") at early stage of the // initialization. So make sure the \"props\" is available at the // very beginning of the initialization and all system properties to // be put into it directly. props = new Properties(); initProperties(props); // initialized by the VM // There are certain system configurations that may be controlled by // VM options such as the maximum amount of direct memory and // Integer cache size used to support the object identity semantics // of autoboxing. Typically, the library will obtain these values // from the properties set by the VM. If the properties are for // internal implementation use only, these properties should be // removed from the system properties. // // See java.lang.Integer.IntegerCache and the // sun.misc.VM.saveAndRemoveProperties method for example. // // Save a private copy of the system properties object that // can only be accessed by the internal implementation. Remove // certain system properties that are not intended for public access. sun.misc.VM.saveAndRemoveProperties(props); lineSeparator = props.getProperty(\"line.separator\"); sun.misc.Version.init(); FileInputStream fdIn = new FileInputStream(FileDescriptor.in); FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out); FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err); setIn0(new BufferedInputStream(fdIn)); setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\"))); setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\"))); // Load the zip library now in order to keep java.util.zip.ZipFile // from trying to use itself to load this library later. loadLibrary(\"zip\"); // Setup Java signal handlers for HUP, TERM, and INT (where available). Terminator.setup(); // Initialize any miscellenous operating system settings that need to be // set for the class libraries. Currently this is no-op everywhere except // for Windows where the process-wide error mode is set before the java.io // classes are used. sun.misc.VM.initializeOSEnvironment(); // The main thread is not added to its thread group in the same // way as other threads; we must do it ourselves here. Thread current = Thread.currentThread(); current.getThreadGroup().add(current); // register shared secrets setJavaLangAccess(); // Subsystems that are invoked during initialization can invoke // sun.misc.VM.isBooted() in order to avoid doing things that should // wait until the application class loader has been set up. // IMPORTANT: Ensure that this remains the last initialization action! sun.misc.VM.booted(); } private static void setJavaLangAccess() { // Allow privileged classes outside of java.lang sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess(){ public sun.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) { return klass.getConstantPool(); } public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) { return klass.casAnnotationType(oldType, newType); } public AnnotationType getAnnotationType(Class&lt;?&gt; klass) { return klass.getAnnotationType(); } public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) { return klass.getDeclaredAnnotationMap(); } public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) { return klass.getRawAnnotations(); } public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) { return klass.getRawTypeAnnotations(); } public byte[] getRawExecutableTypeAnnotations(Executable executable) { return Class.getExecutableTypeAnnotationBytes(executable); } public &lt;E extends Enum&lt;E&gt;&gt; E[] getEnumConstantsShared(Class&lt;E&gt; klass) { return klass.getEnumConstantsShared(); } public void blockedOn(Thread t, Interruptible b) { t.blockedOn(b); } public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) { Shutdown.add(slot, registerShutdownInProgress, hook); } public int getStackTraceDepth(Throwable t) { return t.getStackTraceDepth(); } public StackTraceElement getStackTraceElement(Throwable t, int i) { return t.getStackTraceElement(i); } public String newStringUnsafe(char[] chars) { return new String(chars, true); } public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) { return new Thread(target, acc); } public void invokeFinalize(Object o) throws Throwable { o.finalize(); } }); }}","link":"/2019/09/06/System类/"},{"title":"ace-combat7-skies-unknown","text":"ACE COMBAT™ 7: SKIES UNKNOWN 《皇牌空战7》是由万代南梦宫开发的皇牌空战系列的正统续作，游戏回归皇牌空战系列的虚构世界观，游戏平台为PS4,Xbox one和PC，支持PSVR操作。 ACE COMBAT系列，是能让玩家能化身为王牌驾驶员，驾驶爱机在追求拟真天空的美丽空间内，享受360度自由飞行的爽快感、让玩家亲自判断状况并选择敌人来破坏的痛快感、享受克服难关达成感的飞行射击游戏。 本作是系列最新作品，依然由「PROJECT ACES」来担任开发。本作的主题是「天空革新」，游戏内立体包覆天空的云层会扩散，气流与雷云等环境变化会晃动机体并扰乱HUD，能让玩家更加「体验天空」。在受环境影响的新缠斗世界中，体验系列作中最具魅力的空中战斗跟速度感吧。 最低配置:需要 64 位处理器和操作系统操作系统: Windows 7 / 8 / 8.1 / 10 (64-bit OS required)处理器: Intel Core i3-7100内存: 4 GB RAM显卡: NVIDIA GeForce GTX 750Ti(2GB)DirectX 版本: 11网络: 宽带互联网连接存储空间: 需要 50 GB 可用空间声卡: DirectX 11 sound card 推荐配置:需要 64 位处理器和操作系统操作系统: Windows 7 / 8 / 8.1 / 10 (64-bit OS required)处理器: Intel Core i5-7500内存: 8 GB RAM显卡: NVIDIA GeForce GTX 1060 (3GB)DirectX 版本: 11网络: 宽带互联网连接存储空间: 需要 50 GB 可用空间声卡: DirectX 11 sound card 传送门","link":"/2019/10/29/ace-combat7-skies-unknown/"},{"title":"TensorFlow 2.0 RC is available","text":"TensorFlow 2.0 RC工具探索可支持和加速 TensorFlow 工作流程的工具。 CoLabColaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您只需点击一下鼠标，即可在浏览器中执行 TensorFlow 代码。 TensorBoard一套可视化工具，用于理解、调试和优化TensorFlow程序。 What-If工具一种无代码的方式探究机器学习模型的工具，对模型的理解、调试和公平性很有用。可在TensorFlow和Jupyter或CoLab笔记本中使用。 ML Perf全面的机器学习基准测试套件，用于衡量机器学习软件框架、机器学习硬件加速器和机器学习云端平台的性能。 XLAXLA(加速线性代数)是一种特定领域的线性代数编译器，能够优化TensorFlow计算，它可以提高服务器和移动平台的运行速度改进内存使用情况和可移植性。 TensorFlow Playground在浏览器中设计神经网络。别担心，不会使浏览器崩溃。 TensorFlow Research Cloud加入TensorFlow Research Cloud（TFRC）计划后，研究人员可于申请访问Cloud TPU来加快实现下一波研究突破；我们免费提供1000个Cloud TPU.","link":"/2019/09/12/TensorFlow-2-0-RC-is-available/"},{"title":"android-fingerprint-security","text":"Android Fingerprint Security安全性一直是移动开发的关键部分，正确实现它绝非易事。智能手机最初使用4位PIN码进行破解，最多需要10,000次破解。然后是锁定模式，尽管基本的人性极大地降低了这个数字，但锁定模式却将标准提高到了惊人的389112种不同的模式。 与PIN和锁定模式不同，指纹身份验证要提前数年。一个人的指纹确实是独一无二的，无法猜测。这项技术在消费类设备上正变得越来越流行，并且使用棉花糖，比以往任何时候都更容易在您的应用程序中实现它。 然后除了我们已经写过的 iOS Touch ID之外，Android上指纹扫描的早期实现还不够。每个供应商都有其独特的方法来确保流程的安全性和实施，最重要的是，如何存储用户的私有数据。 现在随着棉花糖的到来，人们期待已久的通过标准API对指纹认证的本机支持。最终，Android开发人员被允许对解锁设备，Play Store和Android Pay购买的产品实施基于指纹的身份验证，并在移动银行等安全性高的应用程序中提供自定义身份验证。 Google首次在Nexus 5X和Nexus 6P上推出，并推出了快速安全的Nexus Imprint指纹传感器，该技术还带来了Android 6.0棉花糖指纹传感器API的首个实现。可以在不到600毫秒的时间内识别出指纹，从而提供快速舒适的用户体验。 指纹存储安全Android上的大多数存储策略都是不安全的，尤其是考虑到root用户访问权限的可能性时。但是Google已通过将所有打印数据操作移至可信执行环境 （TEE）并为制造商必须遵循的指纹数据存储提供了严格的指导方针，朝着正确的方向迈出了显着的一步。 三通TEE是智能手机主处理器的安全区域。它保证了内部加载的代码和数据的机密性和完整性。这种分离可实现安全性和保护，免受黑客，恶意软件和root用户访问。 所有指纹数据操作均在TEE中执行 必须将所有指纹数据保护在传感器硬件或受信任的内存中，以便无法访问指纹图像 指纹数据只能以加密形式存储在文件系统上，而不管文件系统本身是否已加密 删除用户必须导致删除用户现有的指纹数据 根访问不得破坏指纹数据 指纹模板指纹模板是原始指纹数据的已处理版本。为了遵守准则，必须对它们进行密码认证。这意味着必须使用专用于设备的私钥和足够的其他数据（绝对文件系统路径，finger ID和组）对它们进行签名，以明确定义它们的绑定关系。结果，如果将这些模板复制到另一个设备或另一个用户尝试使用它们，则这些模板将变得无用。 最后，指纹数据不会备份到用户的计算机或Google的服务器上。它不会被设备上的任何其他应用程序同步，共享或使用，也不会离开设备。应用程序收到的唯一信息是指纹是否已通过验证。这也意味着用户必须在每个新设备上设置指纹认证。 听起来不错，该如何实施？指纹认证无非就是数据加密。它涉及一个密钥，一个执行加密的密码以及一个处理整个过程的指纹管理器。从开发人员的角度来看，该过程有些广泛，但它包含相对简单的步骤。 在项目AndroidManifest文件中请求指纹身份验证权限。 启用任何锁定屏幕安全机制（PIN，图案或密码）。 在设备上注册至少一个指纹。 创建的实例FingerprintManager。 使用Keystore实例来访问Android Keystore容器。 使用KeyGenerator该类生成加密密钥，并将其存储在Keystore容器中。 Cipher使用先前生成的加密密钥初始化该类的实例。 使用Cipher实例创建一个CryptoObject并将其分配给实例化FingerprintManager。 调用实例的authenticate()方法FingerprintManager。 成功完成身份验证后处理回调，从而提供对受保护的内容或功能的访问。 Google提供了全面的指纹认证示例，并且在线提供了一些教程，可以助您一臂之力。 Android的指纹认证和支持实现的设计和执行非常好。将其用作任何形式的多因素身份验证的拥有元素，已足以为您提供快速，可靠和安全的身份验证体验。 您可以在科罗拉多州丹佛市举行的360andev会议上听到我们谈论指纹安全性和应用程序安全性最佳实践的信息。 那有什么收获呢？ 只有一个，并且其他所有方法都具有相同的缺陷。指纹认证只有一个故障点。就像用手指来解锁设备一样吸引人，您到处都是手指。潜在的攻击者可以毫不费力地举起您的指纹，然后使用它来控制您的设备和应用程序。 不幸的是，与密码不同，您的指纹显然是无法更改的。 传送门","link":"/2019/11/01/android-fingerprint-security/"},{"title":"asmttpd","text":"asmttpdWeb server for Linux written in amd64 assembly. Features: Multi-threaded. No libraries required ( only 64-bit Linux ). Very small binary, roughly 6 KB. Quite fast. What works: Serving files from specified document root. HEAD requests. 200, 206, 404, 400, 413, 416 Content-types: xml, html, xhtml, gif, png, jpeg, css, js, svg, and octet-stream. Planned Features: Directory listing. Current Limitations / Known Issues Sendfile can hang if GET is cancelled. InstallationRun make or make release for non-debug version. You will need yasm installed. Usage./asmttpd /path/to/web_root port_number Example: ./asmttpd ./web_root 8080 Changes2019-04-22 : asmttpd - 0.4.4 Added SVG support. 2019-01-24 : asmttpd - 0.4.3 Added port number as parameter. 2017-10-18 : asmttpd - 0.4.2 Set REUSEADDR. 2017-10-17 : asmttpd - 0.4.1 Stack address bug fix. 2016-10-31 : asmttpd - 0.4 HEAD support. 2014-07-14 : asmttpd - 0.3 Added default document support. 2014-02-10 : asmttpd - 0.2 Added 400, 413, 416 responses. Fixed header processing bug. 2014-02-07 : asmttpd - 0.1.1 Fixed 206 max length bug. Commented out simple request logging, uncomment in main.asm to enable. 2014-02-06 : asmttpd - 0.1 Fixed SIGPIPE when transfer is cancelled. Added a more useful error on bind failure. Fixed 206 size calculation. Combined seek &amp; get file size system calls. 2014-02-05 : asmttpd - 0.09 Issue #8 fix. Crashes on long request paths. 2014-02-04 : asmttpd - 0.08 Added TCP corking. 2014-02-04 : asmttpd - 0.07 Removed thread pool after benchmarking, changed to an accept-per-thread model. 2014-02-04 : asmttpd - 0.06 Worker thread stack corruption bug fix. 2014-02-04 : asmttpd - 0.05 Changed 200 and 206 implementation to use sendfile system call. Got rid of read/write buffer, changed request read buffer to standard 8KB. 2014-02-03 : asmttpd - 0.04 200 now streams full amount 2014-02-01 : asmttpd - 0.03 Files are split if too large to fit into buffer. Added 206 responses with Content-Range handling 2014-01-30 : asmttpd - 0.02 Added xml, xhtml, gif, png, jpeg, css, and javascript content types. Changed thread memory size to something reasonable. You can tweak it according to available memory. See comments in main.asm Added simple request logging. Added removal of ‘../‘ in URL.","link":"/2019/10/28/asmttpd/"},{"title":"b-tree","text":"B-TreeB-Tree 与 B+Tree在数据结构与算法/查找树 https://url.wx-coder.cn/9PnzG 一节中我们介绍了 B-Tree 的基本概念与实现，这里我们继续来分析下为何 B-Tree 相较于红黑树等二叉查找树会更适合于作为数据库索引的实现。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次 I/O。而检索的时候，一次检索最多需要 h-1 次 I/O（根节点常驻内存），其渐进复杂度为 ，实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。 B+Tree 是 的变种，有着比 B-Tree 更高的查询性能，其相较于 B-Tree 有了如下的变化： 有 m 个子树的节点包含有 m 个元素（B-Tree 中是 m-1）。 根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。 所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。 叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。 一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针： 如上图所示，在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。做这个优化的目的是为了提高区间访问的性能，例如下图中如果要查询 key 为从 3 到 8 的所有数据记录，当找到 3 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。 索引顺序B-Tree 索引可以很好地用于单行、范围或者前缀扫描，他们只有在查找使用了索引的最左前缀（Leftmost Prefix）的时候才有用。不过 B-Tree 索引存在一些限制： 如果查找不从索引列的最左边开始，索引就无法使用；同样，不能查找字符串结尾； 不能跳过索引中的列； 不能使用任何在第一个范围条件右边的列作为条件； 因此 B-Tree 的列顺序非常重要，上述使用规则都和列顺序有关。对于实际的应用，一般要根据具体的需求，创建不同列和不同列顺序的索引。假设有索引 Index(A,B,C): 12345678910111213# 使用索引A&gt;5 AND A&lt;10 - 最左前缀匹配A=5 AND B&gt;6 - 最左前缀匹配A=5 AND B=6 AND C=7 - 全列匹配A=5 AND B IN (2,3) AND C&gt;5 - 最左前缀匹配，填坑# 不能使用索引B&gt;5 - 没有包含最左前缀B=6 AND C=7 - 没有包含最左前缀# 使用部分索引A&gt;5 AND B=2 - 使用索引 A 列A=5 AND B&gt;6 AND C=2 - 使用索引的 A 和 B 列 复制代码使用索引对结果进行排序，需要索引的顺序和 ORDER BY 子句中的顺序一致，并且所有列的升降序一致(ASC/DESC)。如果查询连接了多个表，只有在 ORDER BY 的列引用的是第一个表才可以(需要按序 JOIN)。 123456789101112# 使用索引排序ORDER BY A - 最左前缀匹配WHERE A=5 ORDER BY B,C - 最左前缀匹配WHERE A=5 ORDER BY B DESC - 最左前缀匹配WHERE A&gt;5 ORDER BY A,B - 最左前缀匹配# 不能使用索引排序WHERE A=5 ORDER BY B DESC,C ASC - 升降序不一致WHERE A=5 ORDER BY B,D - D 不在索引中WHERE A=5 ORDER BY C - 没有包含最左前缀WHERE A&gt;5 ORDER BY B,C - 第一列是范围条件，无法使用 BC 排序WHERE A=5 AND B IN(1, 2) ORDER BY C - B 也是范围条件，无法用 C 排序","link":"/2019/11/04/b-tree/"},{"title":"count-file-lines","text":"命令行统计文件行数Linux 统计代码行数在 Linux 下这是一件很简单的事情： 123find . -name \"*.py\" | wc -lfind ./ -name \"*.py\" |xargs cat|grep -v ^$|wc -l 这行语句就可以很简单地统计出当前目录下所有py后缀文件的行数了。 Windows 统计代码行数这时我们就不能用cmd而是应当用PowerShell啦。 Powershell是Windows基于.NET开发的一个自动化配置框架。 （其实就是新版命令行） 然后我们可以输入： 12dir .\\ -Recurse *.py | Get-Content | Measure-Object 我们就可以看到输出： Count : 577966表示当前目录下py后缀文件一共有577966行。 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.io.*;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by 杨华彬 on 2016/12/19. */public class Main { public static void main(String[] args) { //输入路径,请在括号内输入路径。 File f = new File(\"D:\\\\程序文件\\\\IntelliJ IDEA\\\\Java\\\\JnaTest\"); Map map = new HashMap&lt;String, Integer&gt;(); //用来存放统计出来的行数 Plus(f, map); //输出统计的结果 getResult(map); } /* 遍历文件夹 */ public static void Plus(File f, Map map) { File[] files = f.listFiles();//获取传入路径的所有文件 //遍历这些文件,需求是CVS中的不统计，所以加判断 for (File a : files) { //如果文件名是CVS的就跳过 if (a.getName().equals(\"CVS\")) { continue; } else { //如果a是文件的话就进入下一级目录，否则就统计行数 if (a.isDirectory()) { Plus(a, map); } else {// if (a.getName().endsWith(\".java\")) map = lineNumber(a.getAbsolutePath(), map); //否者调方法统计行数 } } } } /* 统计相应文件的行数 */ public static Map&lt;String, Integer&gt; lineNumber(String f, Map map) { //定义字符流读取文件 FileReader fileReader = null; try { fileReader = new FileReader(f); } catch (IOException e) { e.printStackTrace(); System.out.println(\"输入的路径不正确\"); } BufferedReader bufferedReader = new BufferedReader(fileReader); //从字节流中升级为字符流，方便按行读取。 int index = 0; try { while (bufferedReader.readLine() != null) { index++; } map.put(f, index); //将结果放到map中 } catch (IOException e) { e.printStackTrace(); System.out.println(\"这个文件读不到！\"); } finally { if (fileReader != null) { try { fileReader.close(); } catch (IOException e) { e.printStackTrace(); } } return map; } } /* 将文件的行数存放在一个map中，然后输出行数的和 */ public static void getResult(Map map) { int sum = 0; //使用iterator遍历map集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry&lt;String, Integer&gt; entry = entries.next(); System.out.printf(\"%5d - %s\\n\", entry.getValue(), entry.getKey()); sum += entry.getValue(); } System.out.println(\"line num：\" + sum); }}","link":"/2019/11/09/count-file-lines/"},{"title":"copying-codes-from-stack-overflow","text":"从 Stack Overflow 复制代码导致 GitHub 项目漏洞多现在从网上找代码直接复制到项目中的做法成为程序员的一种常规操作，Stack Overflow 更是其中主要的代码来源。但是最近有研究显示，从 Stack Overflow 上复制代码凑到项目中会使出现漏洞的概率大大增加。 研究人员分析了 1325 个 Stack Overflow 帖子，并获取了其中 72 000 多段 C++ 代码，发现了其中包含有 29 种类型的 69 个漏洞。 这些漏洞出现在 2589 个 GitHub 仓库中，研究人员通知了受影响的 GitHub 项目作者，但只有少数人选择修复已知这些危险情况。 研究人员展示了含有漏洞的代码主要是以什么方式从 Stack Overflow 进入到 GitHub 中的，包括最经常发现的输入验证不正确、异常或异常情况的不正确检查与错误编码，比如复制代码不完整。 详情查看： https://fossbytes.com/copying-codes-from-stack-overflow-leads-to-vulnerable-github-project","link":"/2019/10/27/copying-codes-from-stack-overflow/"},{"title":"assembly language","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517================================================================MOV - Move:| Opcode | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description | 88 /r REX + 88 /r | MOV r/m8,r8 MOV r/m8***,r8*** | MR MR| Valid Valid| Valid N.E. | Move r8 to r/m8.Move r8 to r/m8. | 89 /r | MOV r/m16,r16 | MR | Valid | Valid | Move r16 to r/m16. | 89 /r | MOV r/m32,r32 | MR | Valid | Valid | Move r32 to r/m32. | REX.W + 89 /r | MOV r/m64,r64 | MR | Valid | N.E. | Move r64 to r/m64. | 8A /r | MOV r8,r/m8 | RM | Valid | Valid | Move r/m8 to r8. | REX + 8A /r | MOV r8***,r/m8*** | RM | Valid | N.E. | Move r/m8 to r8. | 8B /r | MOV r16,r/m16 | RM | Valid | Valid | Move r/m16 to r16. | 8B /r | MOV r32,r/m32 | RM | Valid | Valid | Move r/m32 to r32. | REX.W + 8B /r | MOV r64,r/m64 | RM | Valid | N.E. | Move r/m64 to r64. | 8C /r | MOV r/m16,Sreg** | MR | Valid | Valid | Move segment register to r/m16. | REX.W + 8C /r | MOV r/m64,Sreg** | MR | Valid | Valid | Move zero extended 16-bit segment register| | | | | | to r/m64. | 8E /r | MOV Sreg,r/m16** | RM | Valid | Valid | Move r/m16 to segment register. | REX.W + 8E /r | MOV Sreg,r/m64** | RM | Valid | Valid | Move lower 16 bits of r/m64 to segment | | | | | | register. | A0 | MOV AL,moffs8* | FD | Valid | Valid | Move byte at (seg:offset) to AL. | REX.W + A0 | MOV AL,moffs8* | FD | Valid | N.E. | Move byte at (offset) to AL. | A1 | MOV AX,moffs16* | FD | Valid | Valid | Move word at (seg:offset) to AX. | A1 | MOV EAX,moffs32* | FD | Valid | Valid | Move doubleword at (seg:offset) to EAX. | REX.W + A1 | MOV RAX,moffs64* | FD | Valid | N.E. | Move quadword at (offset) to RAX. | A2 REX.W + A2 | MOV moffs8,AL MOV moffs8***,AL| TD TD| Valid Valid| Valid N.E. | Move AL to (seg:offset).Move AL to | | | | | | (offset). | A3 | MOV moffs16*,AX | TD | Valid | Valid | Move AX to (seg:offset). | A3 | MOV moffs32*,EAX | TD | Valid | Valid | Move EAX to (seg:offset). | REX.W + A3 | MOV moffs64*,RAX | TD | Valid | N.E. | Move RAX to (offset). | B0+ rb ib REX + B0+ rb ib| MOV r8, imm8 MOV r8***, imm8 | OI OI| Valid Valid| Valid N.E. | Move imm8 to r8.Move imm8 to r8. | B8+ rw iw | MOV r16, imm16 | OI | Valid | Valid | Move imm16 to r16. | B8+ rd id | MOV r32, imm32 | OI | Valid | Valid | Move imm32 to r32. | REX.W + B8+ rd io | MOV r64, imm64 | OI | Valid | N.E. | Move imm64 to r64. | C6 /0 ib | MOV r/m8, imm8 | MI | Valid | Valid | Move imm8 to r/m8. | REX + C6 /0 ib | MOV r/m8***, imm8 | MI | Valid | N.E. | Move imm8 to r/m8. | C7 /0 iw | MOV r/m16, imm16 | MI | Valid | Valid | Move imm16 to r/m16. | C7 /0 id | MOV r/m32, imm32 | MI | Valid | Valid | Move imm32 to r/m32. | REX.W + C7 /0 io | MOV r/m64, imm32 | MI | Valid | N.E. | Move imm32 sign extended to 64-bits | | | | | | to r/m64. Notes:* The moffs8, moffs16, moffs32 and moffs64 operands specify a simpleoffset relative to the segment base, where 8, 16, 32 and 64 refer to the sizeof the data.The address-size attribute of the instruction determines the sizeof the offset, either 16, 32 or 64 bits.** In 32-bit mode, the assembler mayinsert the 16-bit operand-size prefix with this instruction (see the following“Description” section for further information).***In 64-bit mode, r/m8 cannot be encoded to access the following byte registers if a REX prefix is used:AH, BH, CH, DH.指令操作数编码：| Op/En| Operand 1 | Operand 2 | Operand 3| Operand 4| MR | ModRM:r/m (w) | ModRM:reg (r)| NA | NA | RM | ModRM:reg (w) | ModRM:r/m (r)| NA | NA | FD | AL/AX/EAX/RAX | Moffs | NA | NA | TD | Moffs (w) | AL/AX/EAX/RAX| NA | NA | OI | opcode + rd (w)| imm8/16/32/64| NA | NA | MI | ModRM:r/m (w) | imm8/16/32/64| NA | NA Description:Copies the second operand (source operand) to the first operand (destinationoperand).The source operand can be an immediate value, general-purpose register,segment register, or memory location; the destination register can be a general-purposeregister, segment register, or memory location.Both operands must be the samesize, which can be a byte, a word, a doubleword, or a quadword.The MOV instruction cannot be used to load the CS register.Attempting to doso results in an invalid opcode exception (#UD).To load the CS register, usethe far JMP, CALL, or RET instruction.If the destination operand is a segment register (DS, ES, FS, GS, or SS), thesource operand must be a valid segment selector.In protected mode, moving asegment selector into a segment register automatically causes the segment descriptorinformation associated with that segment selector to be loaded into the hidden(shadow) part of the segment register.While loading this information, the segmentselector and segment descriptor information is validated (see the “Operation”algorithm below).The segment descriptor data is obtained from the GDT or LDTentry for the specified segment selector.A NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS,and GS registers without causing a protection exception.However, any subsequentattempt to reference a segment whose corresponding segment register is loadedwith a NULL value causes a general protection exception (#GP) and no memoryreference occurs.Loading the SS register with a MOV instruction inhibits all interrupts untilafter the execution of the next instruction.This operation allows a stack pointerto be loaded into the ESP register with the next instruction (MOV ESP, stack-pointervalue) before an interrupt occurs1.Be aware that the LSS instruction offersa more efficient method of loading the SS and ESP registers.When operating in 32-bit mode and moving data between a segment register anda general-purpose register, the 32-bit IA-32 processors do not require the useof the 16-bit operand-size prefix (a byte with the value 66H) with| 1.| If a code instruction breakpoint (for | | debug) is placed on an instruction located | | immediately after a MOV SS instruction, | | the breakpoint may not be triggered. | | However, in a sequence of instructions | | that load the SS register, only the | | first instruction in the sequence is | | guaranteed to delay an interrupt.In | | the following sequence, interrupts may | | be recognized before MOV ESP, EBP executes:| | MOV SS, EDX MOV SS, EAX MOV ESP, EBP this instruction, but most assemblers will insert it if the standard form ofthe instruction is used (for example, MOV DS, AX).The processor will executethis instruction correctly, but it will usually require an extra clock.Withmost assemblers, using the instruction form MOV DS, EAX will avoid this unneeded66H prefix.When the processor executes the instruction with a 32-bit general-purposeregister, it assumes that the 16 least-significant bits of the general-purposeregister are the destination or source operand.If the register is a destinationoperand, the resulting value in the two high-order bytes of the register isimplementation dependent.For the Pentium 4, Intel Xeon, and P6 family processors,the two high-order bytes are filled with zeros; for earlier 32-bit IA-32 processors,the two high order bytes are undefined.In 64-bit mode, the instruction's default operation size is 32 bits.Use ofthe REX.R prefix permits access to additional registers (R8-R15).Use of theREX.W prefix promotes operation to 64 bits.See the summary chart at the beginningof this section for encoding data and limits.操作: DEST &lt;- SRC;Loading a segment register while in protected mode results in special checks and actions, as described in thefollowing listing.These checks are performed on the segment selector and the segment descriptor to which itpoints.IF SS is loaded THEN IF segment selector is NULL THEN #GP(0); FI; IF segment selector index is outside descriptor table limits or segment selector's RPL != CPL or segment is not a writable data segment or DPL != CPL THEN #GP(selector); FI; IF segment not marked present THEN #SS(selector); ELSE SS &lt;- segment selector; SS &lt;- segment descriptor; FI;FI;IF DS, ES, FS, or GS is loaded with non-NULL selectorTHEN IF segment selector index is outside descriptor table limits or segment is not a data or readable code segment or ((segment is a data or nonconforming code segment) or ((RPL &gt; DPL) and (CPL &gt; DPL)) THEN #GP(selector); FI; IF segment not marked present THEN #NP(selector); ELSE SegmentRegister &lt;- segment selector; SegmentRegister &lt;- segment descriptor; FI;FI;IF DS, ES, FS, or GS is loaded with NULL selector THEN SegmentRegister &lt;- segment selector; SegmentRegister &lt;- segment descriptor;FI;Flags Affected:None.保护模式：| #GP(0) | If attempt is made to load SS register | | with NULL segment selector.If the destination| | operand is in a non-writable segment. | | If a memory operand effective address | | is outside the CS, DS, ES, FS, or GS | | segment limit.If the DS, ES, FS, or | | GS register contains a NULL segment | | selector. | #GP(selector) | If segment selector index is outside | | descriptor table limits.If the SS register | | is being loaded and the segment selector's | | RPL and the segment descriptor's DPL | | are not equal to the CPL.If the SS | | register is being loaded and the segment | | pointed to is a non-writable data segment. | | If the DS, ES, FS, or GS register is | | being loaded and the segment pointed | | to is not a data or readable code segment. | | If the DS, ES, FS, or GS register is | | being loaded and the segment pointed | | to is a data or nonconforming code segment, | | but both the RPL and the CPL are greater | | than the DPL. | #SS(0) | If a memory operand effective address | | is outside the SS segment limit. | #SS(selector) | If the SS register is being loaded and | | the segment pointed to is marked not | | present. | #NP | If the DS, ES, FS, or GS register is | | being loaded and the segment pointed | | to is marked not present. | #PF(fault-code)| If a page fault occurs. | #AC(0) | If alignment checking is enabled and | | an unaligned memory reference is made | | while the current privilege level is | | 3. | #UD | If attempt is made to load the CS register. | | If the LOCK prefix is used. Real-地址模式异常: | #GP| If a memory operand effective address | | is outside the CS, DS, ES, FS, or GS | | segment limit. | #SS| If a memory operand effective address | | is outside the SS segment limit. | #UD| If attempt is made to load the CS register.| | If the LOCK prefix is used. Virtual-8086 模式异常: | #GP(0) | If a memory operand effective address | | is outside the CS, DS, ES, FS, or GS | | segment limit. | #SS(0) | If a memory operand effective address | | is outside the SS segment limit. | #PF(fault-code)| If a page fault occurs. | #AC(0) | If alignment checking is enabled and | | an unaligned memory reference is made. | #UD | If attempt is made to load the CS register.| | If the LOCK prefix is used. 兼容模式：Same exceptions as in protected mode.64-Bit 模式异常: | #GP(0) | If the memory address is in a non-canonical | | form.If an attempt is made to load | | SS register with NULL segment selector | | when CPL = 3.If an attempt is made | | to load SS register with NULL segment | | selector when CPL &lt; 3 and CPL != RPL. | #GP(selector) | If segment selector index is outside | | descriptor table limits.If the memory | | access to the descriptor table is non-canonical.| | If the SS register is being loaded and | | the segment selector's RPL and the segment | | descriptor's DPL are not equal to the | | CPL.If the SS register is being loaded | | and the segment pointed to is a nonwritable | | data segment.If the DS, ES, FS, or | | GS register is being loaded and the | | segment pointed to is not a data or | | readable code segment.If the DS, ES, | | FS, or GS register is being loaded and | | the segment pointed to is a data or | | nonconforming code segment, but both | | the RPL and the CPL are greater than | | the DPL. | #SS(0) | If the stack address is in a non-canonical | | form. | #SS(selector) | If the SS register is being loaded and | | the segment pointed to is marked not | | present. | #PF(fault-code)| If a page fault occurs. | #AC(0) | If alignment checking is enabled and | | an unaligned memory reference is made | | while the current privilege level is | | 3. | #UD | If attempt is made to load the CS register. | | If the LOCK prefix is used. MOV - Move to/from Control Registers:| Opcode/Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description | 0F 20/r MOV r32, CR0-CR7 | MR | N.E. | Valid | Move control register to r32. | 0F 20/r MOV r64, CR0-CR7 REX.R + 0F| MR MR| Valid Valid| N.E.N.E. | Move extended control register to r64.| 20 /0 MOV r64, CR8 | | | | Move extended CR8 to r64.1 | 0F 22 /r MOV CR0-CR7, r32 | RM | N.E. | Valid | Move r32 to control register. | 0F 22 /r MOV CR0-CR7, r64 | RM | Valid | N.E. | Move r64 to extended control register.| REX.R + 0F 22 /0 MOV CR8, r64 | RM | Valid | N.E. | Move r64 to extended CR8.1 NOTE::| 1.| MOV CR* instructions, except for MOV | | CR8, are serializing instructions.MOV| | CR8 is not architecturally defined as | | a serializing instruction.For more | | information, see Chapter 8 in Intel® | | 64 and IA-32 Architectures Software | | Developer's Manual, Volume 3A. 指令操作数编码：| Op/En| Operand 1 | Operand 2 | Operand 3| Operand 4| MR | ModRM:r/m (w)| ModRM:reg (r)| NA | NA | RM | ModRM:reg (w)| ModRM:r/m (r)| NA | NA Description:Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purposeregister or the contents of a general purpose register to a control register.The operand size for these instructions is always 32 bits in non-64-bit modes,regardless of the operand-size attribute.(See “Control Registers” in Chapter2 of the Intel®64 and IA-32 Architectures Software Developer's Manual, Volume3A, for a detailed description of the flags and fields in the control registers.)This instruction can be executed only when the current privilege level is 0.At the opcode level, the reg field within the ModR/M byte specifies which ofthe control registers is loaded or read.The 2 bits in the mod field are ignored.The r/m field specifies the general-purpose register loaded or read.Attemptsto reference CR1, CR5, CR6, CR7, and CR9-CR15 result in undefined opcode (#UD)exceptions.When loading control registers, programs should not attempt to change the reservedbits; that is, always set reserved bits to the value previously read.An attemptto change CR4's reserved bits will cause a general protection fault.Reservedbits in CR0 and CR3 remain clear after any load of those registers; attemptsto set them have no impact.On Pentium 4, Intel Xeon and P6 family processors,CR0.ET remains set after any load of CR0; attempts to clear this bit have noimpact.In certain cases, these instructions have the side effect of invalidating entriesin the TLBs and the paging-structure caches.See Section 4.10.4.1, “Operationsthat Invalidate TLBs and Paging-Structure Caches,” in the Intel® 64 and IA-32Architectures Software Developer's Manual, Volume 3A for details.The following side effects are implementation-specific for the Pentium 4, IntelXeon, and P6 processor family: when modifying PE or PG in register CR0, or PSEor PAE in register CR4, all TLB entries are flushed, including global entries.Software should not depend on this functionality in all Intel 64 or IA-32 processors.In 64-bit mode, the instruction's default operation size is 64 bits.The REX.Rprefix must be used to access CR8.Use of REX.B permits access to additionalregisters (R8-R15).Use of the REX.W prefix or 66H prefix is ignored.Use ofthe REX.R prefix to specify a register other than CR8 causes an invalid-opcodeexception.See the summary chart at the beginning of this section for encodingdata and limits.If CR4.PCIDE = 1, bit 63 of the source operand to MOV to CR3 determines whetherthe instruction invalidates entries in the TLBs and the paging-structure caches(see Section 4.10.4.1, “Operations that Invalidate TLBs and Paging-StructureCaches,” in the Intel® 64 and IA-32 Architectures Software Developer's Manual,Volume 3A).The instruction does not modify bit 63 of CR3, which is reservedand always 0.See “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume3C, for more information about the behavior of this instruction in VMX non-rootoperation.操作: DEST &lt;- SRC;Flags Affected:The OF, SF, ZF, AF, PF, and CF flags are undefined.保护模式：| #GP(0)| If the current privilege level is not | | 0.If an attempt is made to write invalid| | bit combinations in CR0 (such as setting | | the PG flag to 1 when the PE flag is | | set to 0, or setting the CD flag to | | 0 when the NW flag is set to 1).If | | an attempt is made to write a 1 to any | | reserved bit in CR4.If an attempt is | | made to write 1 to CR4.PCIDE.If any | | of the reserved bits are set in the | | page-directory pointers table (PDPT) | | and the loading of a control register | | causes the PDPT to be loaded into the | | processor. | #UD | If the LOCK prefix is used.If an attempt| | is made to access CR1, CR5, CR6, or | | CR7. Real-地址模式异常: | #GP| If an attempt is made to write a 1 to | | any reserved bit in CR4.If an attempt | | is made to write 1 to CR4.PCIDE.If | | an attempt is made to write invalid | | bit combinations in CR0 (such as setting | | the PG flag to 1 when the PE flag is | | set to 0). | #UD| 如果使用LOCK前缀.If an attempt| | is made to access CR1, CR5, CR6, or | | CR7. Virtual-8086 模式异常: | #GP(0)| These instructions cannot be executed| | in virtual-8086 mode. 兼容模式：| #GP(0)| If the current privilege level is not | | 0.If an attempt is made to write invalid| | bit combinations in CR0 (such as setting | | the PG flag to 1 when the PE flag is | | set to 0, or setting the CD flag to | | 0 when the NW flag is set to 1).If | | an attempt is made to change CR4.PCIDE | | from 0 to 1 while CR3[11:0] != 000H. | | If an attempt is made to clear CR0.PG[bit| | 31] while CR4.PCIDE = 1.If an attempt | | is made to write a 1 to any reserved | | bit in CR3.If an attempt is made to | | leave IA-32e mode by clearing CR4.PAE[bit| | 5]. | #UD | If the LOCK prefix is used.If an attempt| | is made to access CR1, CR5, CR6, or | | CR7. 64-Bit 模式异常: | #GP(0)| If the current privilege level is not | | 0.If an attempt is made to write invalid| | bit combinations in CR0 (such as setting | | the PG flag to 1 when the PE flag is | | set to 0, or setting the CD flag to | | 0 when the NW flag is set to 1).If | | an attempt is made to change CR4.PCIDE | | from 0 to 1 while CR3[11:0] != 000H. | | If an attempt is made to clear CR0.PG[bit| | 31].If an attempt is made to write | | a 1 to any reserved bit in CR4.If an | | attempt is made to write a 1 to any | | reserved bit in CR8.If an attempt is | | made to write a 1 to any reserved bit | | in CR3.If an attempt is made to leave | | IA-32e mode by clearing CR4.PAE[bit | | 5]. | #UD | If the LOCK prefix is used.If an attempt| | is made to access CR1, CR5, CR6, or | | CR7.If the REX.R prefix is used to | | specify a register other than CR8. MOV - Move to/from Debug Registers:| Opcode/Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description | 0F 21/r MOV r32, DR0-DR7 | MR | N.E. | Valid | Move debug register to r32. | 0F 21/r MOV r64, DR0-DR7 | MR | Valid | N.E. | Move extended debug register to r64.| 0F 23 /r MOV DR0-DR7, r32| RM | N.E. | Valid | Move r32 to debug register. | 0F 23 /r MOV DR0-DR7, r64| RM | Valid | N.E. | Move r64 to extended debug register.指令操作数编码：| Op/En| Operand 1 | Operand 2 | Operand 3| Operand 4| MR | ModRM:r/m (w)| ModRM:reg (r)| NA | NA | RM | ModRM:reg (w)| ModRM:r/m (r)| NA | NA Description:Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, orDR7) to a general-purpose register or vice versa.The operand size for theseinstructions is always 32 bits in non-64-bit modes, regardless of the operand-sizeattribute.(See Section 17.2, “Debug Registers”, of the Intel® 64 and IA-32Architectures Software Developer's Manual, Volume 3A, for a detailed descriptionof the flags and fields in the debug registers.)The instructions must be executed at privilege level 0 or in real-address mode.When the debug extension (DE) flag in register CR4 is clear, these instructionsoperate on debug registers in a manner that is compatible with Intel386 andIntel486 processors.In this mode, references to DR4 and DR5 refer to DR6 andDR7, respectively.When the DE flag in CR4 is set, attempts to reference DR4and DR5 result in an undefined opcode (#UD) exception.(The CR4 register wasadded to the IA-32 Architecture beginning with the Pentium processor.)At the opcode level, the reg field within the ModR/M byte specifies which ofthe debug registers is loaded or read.The two bits in the mod field are ignored.The r/m field specifies the general-purpose register loaded or read.In 64-bit mode, the instruction's default operation size is 64 bits.Use ofthe REX.B prefix permits access to additional registers (R8-R15).Use of theREX.W or 66H prefix is ignored.Use of the REX.R prefix causes an invalidopcodeexception.See the summary chart at the beginning of this section for encodingdata and limits.操作: IF ((DE = 1) and (SRC or DEST = DR4 or DR5)) THEN #UD; ELSE DEST &lt;- SRC;FI;Flags Affected:The OF, SF, ZF, AF, PF, and CF flags are undefined.保护模式：| #GP(0)| If the current privilege level is not | | 0. | #UD | If CR4.DE[bit 3] = 1 (debug extensions) | | and a MOV instruction is executed involving| | DR4 or DR5.If the LOCK prefix is used. | #DB | If any debug register is accessed while | | the DR7.GD[bit 13] = 1. Real-地址模式异常: | #UD| If CR4.DE[bit 3] = 1 (debug extensions) | | and a MOV instruction is executed involving| | DR4 or DR5.If the LOCK prefix is used. | #DB| If any debug register is accessed while | | the DR7.GD[bit 13] = 1. Virtual-8086 模式异常: | #GP(0)| The debug registers cannot be loaded| | or read when in virtual-8086 mode. 兼容模式：Same exceptions as in protected mode.64-Bit 模式异常: | #GP(0)| If the current privilege level is not | | 0.If an attempt is made to write a | | 1 to any of bits 63:32 in DR6.If an | | attempt is made to write a 1 to any | | of bits 63:32 in DR7. | #UD | If CR4.DE[bit 3] = 1 (debug extensions) | | and a MOV instruction is executed involving| | DR4 or DR5.If the LOCK prefix is used. | | If the REX.R prefix is used. | #DB | If any debug register is accessed while | | the DR7.GD[bit 13] = 1. ================================================================","link":"/2019/10/06/assembly-language/"},{"title":"cutter","text":"CutterCutter is a free and open-source reverse engineering framework powered by radare2 . Its goal is making an advanced, customizable and FOSS reverse-engineering platform while keeping the user experience at mind. Cutter is created by reverse engineers for reverse engineers. Learn more at https://cutter.re.Downloading a releaseCutter is available for all platforms (Linux, macOS, Windows).You can download the latest release here. macOS: Download the latest .dmg file or use Homebrew Cask brew cask install cutter. Windows: Download the latest Zip archive. Linux: Download the latest AppImage file. Then just make it executable and run it: chmod +x &lt;appimage_file&gt; ./&lt;appimage_file&gt; Building from sourcesTo build Cutter on your local machine, please follow this guide: Building from source DockerTo deploy cutter using a pre-built Dockerfile, it’s possible to use the provided configuration. The corresponding README.md file also contains instructions on how to get started using the docker image with minimal effort. DocumentationYou can find our documentation in our website. PluginsCutter supports both Python and Native C++ plugins. Want to extend Cutter with Plugins? Read the Plugins section on our documentation. Official and Community PluginsOur community built many plugins and useful scripts for Cutter such as the native integration of Ghidra decompiler or the plugin to visualize DynamoRIO code coverage. You can find more plugins in the following list. Don’t hesitate to extend it with your own plugins and scripts for Cutter. HelpThe best place to obtain help from Cutter developers and community is to contact us on: Telegram: https://t.me/r2cutter IRC: #cutter on irc.freenode.net Twitter: @r2gui","link":"/2019/10/31/cutter/"},{"title":"country","text":"国家和地区 国家是阶级统治的工具。 国家（States、Countries）是由领土、人民（民族，居民）、文化和政府四个要素组成的，国家也是政治地理学名词。从广义的角度，国家是指拥有共同的语言、文化、种族、血统、领土、政府或者历史的社会群体。从狭义的角度，国家是一定范围内的人群所形成的共同体形式。 在社会科学和人文地理范畴，国家是指被人民、文化、语言、地理区别出来的领土；被政治自治权区别出来的一块领地；一个领地或者邦国的人民；跟特定的人有关联的地区。 一般国家行政管理当局是国家的象征，它是一种拥有治理一个社会的权力的国家机构，在一定的领土内拥有外部和内部的主权。国家概念：区域划分，有行政合法性，也就是合法权力。一个国家合法性是指一个政权的理性标准。理性标准是指司法审核标准，法制建立标准，国家可以容纳多民族。 民族概念：已形成独特的文化，包括语言、文字、信仰、崇尚、习俗、服饰、佩饰、建筑风格、饮食习惯、忌讳等等。民族也可以国家化。 在外语中如英语或法语，国家一词有多种解释，例如地理层面，政治层面，民族层面，这三种层面各有代表国家的单词。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226AD The Principality of Andorra 安道尔AE United Arab Emirates 阿拉伯联合酋长国AF Afghanistan 阿富汗AL Albania 阿尔巴尼亚AG ANtigua and Barbuda 安提瓜和巴布达AI 安圭拉 [1] AM Armenia 亚美尼亚AN 安的列斯群岛 [1] AO Angola安哥拉AQ Antarctica南极洲AR Argentina阿根廷AS 美属萨摩亚群岛AT Austria奥地利AU Australia 澳大利亚AZ Azerbaijan 阿塞拜疆BB 巴巴多斯BS Bahamas 巴哈马BH Bahrain 巴林BD Bangladesh 孟加拉国BB Barbados 巴巴多斯BY Belarus 白俄罗斯BZ Belize 伯利兹BE Belgium 比利时BJ Benin 贝宁BM Bermuda 百慕大BT Bhutan 不丹BO Bolivia 玻利维亚BA Bosnia and Herzegovina 波斯尼亚和黑塞哥维那BW Botswana 博茨瓦纳BV Bouvet Island 布维岛BR Brazil 巴西BN Brunei Darussalam 文莱BG Bulgaria 保加利亚BF Burkina Faso 布基纳法索BI Burundi 布隆迪CM Cameroon 喀麦隆CA Canada 加拿大CV Cape Verde 佛得角CF The Central African Republic 中非共和国CL Chile 智利CN The People's Republic of China 中华人民共和国CX Christmas Island 圣诞岛CO Colombia 哥伦比亚CH Switzerland 瑞士CG Congo 刚果共和国Democratic Republic of the Congo 刚果民主共和国CK Cook Island 库克群岛CR Costa rica 哥斯达黎加CI Coate d'Ivorie 科特迪瓦CU Cuba 古巴CV 维德岛CY Cyprus塞浦路斯CZ Czech捷克DK Denmark丹麦DJ Djibouti吉布提DM The Commonwealth of Dominica多米尼克DE Germany德国DO The Dominican Republic多米尼加DZ Algeria阿尔及利亚EC Ecuador厄瓜多尔EG Egypt埃及EH West Sahara西撒哈拉ES Spain西班牙EE Estonia爱沙尼亚ET Ethiopia埃塞俄比亚ER Eritrea厄立特里亚FJ Fiji斐济FI Finland芬兰FR France法国FM Micronesia密克罗尼西亚联邦FO法罗群岛GA Gabon加蓬GQ Equatorial Guinea赤道几内亚GF French Guiana法属圭亚那GM Gambia冈比亚GE Georgia格鲁吉亚GH Ghana加纳GI Gibraltar直布罗陀GR Greece希腊GL Greenland格陵兰GD Grenada格林纳达GU Guam关岛GT Guatemala危地马拉GN Guinea几内亚GW Guinea-Bissau几内亚比绍GY Guyana圭亚那HR Croatia克罗地亚HT Haiti海地HN Honduras洪都拉斯HU Hungary匈牙利IS Iceland冰岛IN India印度ID Indonesia印度尼西亚IR Iran伊朗IQ Iraq伊拉克IE Ireland爱尔兰IL Israel以色列IT Italy意大利JM Jamaica牙买加JP Japan日本JO Jordan约旦KZ Kazakhstan哈萨克斯坦KE Kenya肯尼亚KI Kiribati基里巴斯KP North Korea朝鲜KR South Korea韩国KH Cambodia柬埔寨KM Comoros科摩罗KN Saint Kitts and Nevis圣基茨和尼维斯KG Kyrgyzstan吉尔吉斯斯坦KW Kuwait科威特KY Cayman Islands开曼群岛LA Laos老挝LK Sri Lanka斯里兰卡LV Latvia拉托维亚LB Lebanon黎巴嫩LS Lesotho莱索托LR Liberia利比里亚LY Libya利比亚LI Liechtenstein列支敦士登LT Lithuania立陶宛LU Luxembourg卢森堡LC St. Lucia圣卢西亚MG Madagascar马达加斯加MN Montenegro黑山MW Malawi马拉维MY Malaysia马来西亚MV Maldives马尔代夫ML Mali马里MK Macedonia马其顿MT Malta马耳他MH Marshall Islands马绍尔群岛MR Mauritania毛里塔尼亚MU Mauritius毛里求斯MX Mexico墨西哥MD Moldova摩尔多瓦MC Monaco摩纳哥MN Mongolia蒙古MS Montserrat蒙特塞拉特MA Morocco摩洛哥MZ Mozambique莫桑比克MM Burma缅甸MP Northern Mariana Islands北马里亚那群岛NA Namibia纳米比亚NR Nauru瑙鲁NP Nepal尼泊尔NL Netherlands荷兰NC New Caledonia新喀里多尼亚NZ New Zealand新西兰NI Nicaragua尼加拉瓜NE Niger尼日尔NG Nigeria尼日利亚NU Niue纽埃NF Norfolk Island诺福克岛NO Norway挪威OM Oman阿曼PK Pakistan巴基斯坦PF French Polynesia法属波利尼西亚PW Palau帕劳PA Panama巴拿马PG Papua New Guinea巴布亚新几内亚PY Paraguay巴拉圭PE Peru秘鲁PH Philippines菲律宾PM 圣皮埃尔和密克罗PN Pitcairn Islands皮特开恩群岛PL Poland波兰PT Portugal葡萄牙PS 巴勒斯坦PR Puerto Rico波多黎各（美）QA Qatar卡塔尔RO Romania罗马尼亚RU Russia俄罗斯联邦RW Rwanda卢旺达SV El Salvador萨尔瓦多SH St.Helena圣赫勒拿SM San Marino圣马力诺ST Sao Tome and Principe圣多美和普林西比SA Saudi Arabia沙特阿拉伯SN Senegal塞内加尔SC Seychelles塞舌尔SL Sierra leone塞拉利昂SR Serbia塞尔维亚SG Singapore新加坡SK Slovakia斯洛伐克SI Slovene斯洛文尼亚SB Solomon Islands所罗门群岛SO Somali索马里SD Sudan苏丹South Sudan 南苏丹SU Surinam苏里南SZ Swaziland斯威士兰SE Sweden瑞典SY Syria叙利亚TD Chad乍得TJ Tajikistan塔吉克斯坦TZ Tanzania坦桑尼亚TH Thailand泰国TG Togo多哥TK Tokela托克劳TO Tonga汤加TT Trinidad and Tobago特立尼达和多巴哥TN Tunisia突尼斯TR Turkey土耳其TP East Timor东帝汶TM Turkmenistan土库曼斯坦TC Turks and Caicos Islands特克斯和凯科斯群岛TV Tuvalu图瓦卢UG Uganda乌干达UA Ukraine乌克兰UK United Kingdom英国US United States of America美国UY Uruguay乌拉圭UZ Uzbekistan乌兹别克斯坦VA Vatican City梵蒂冈VC Saint Vincent and the Grenadines圣文森特和格林纳丁斯VE Venezuela [1] 委内瑞拉VN Vietnam [1] 越南VG Virgin Islands(British) [1] 英属维尔京群岛VI Vigin Islands(U.S.) [1] 美属维尔京群岛VU Republic of Vanuatu瓦努阿图共和国WS Western Samoa [1] 西萨摩亚YE Yemen [1] 也门ZA South Africa南非ZM Zambia赞比亚 [1] ZW Zimbabwe津巴布韦 [1] Reference[1] 245个国家和地区英文缩写对照 &gt;_ . [引用日期2019-11-6]","link":"/2019/11/06/country/"},{"title":"computer-vision-weekly-news-20191003","text":"计算机视觉开源周报20191003期 总结了过去一周CV领域的最新开源代码，发现本周出现多份很有价值的高质量、重量级工作，比如致力于使得图卷积网络更深的DeepGCNs、Mask引导的注意力网络大大改进了遮挡行人重识别、格灵深瞳轻量级人脸识别比赛冠军模型VarGFaceNet、比LSTM更优的新RNN模型IndRNN、还有异常强大的字符级文本识别CharNet。 一种web运行的半自动图像标注的灵活框架LOST（Label Objects and Save Time）LOST: A flexible framework for semi-automatic image annotationJonas Jäger, Gereon Reus, Joachim Denzler, Viviane Wolff, Klaus Fricke-Neuderthhttps://arxiv.org/abs/1910.07486v1https://github.com/l3p-cv/lost 对抗表示学习中的全局最优化问题On the Global Optima of Kernelized Adversarial Representation LearningBashir Sadeghi, Runyi Yu, Vishnu Naresh BoddetiICCV 2019https://arxiv.org/abs/1910.07423v1https://github.com/human-analysis/Kernel-ARL 学习泛化的全尺度表示，用于人员重识别，模型更小，精度更优Learning Generalisable Omni-Scale Representations for Person Re-IdentificationKaiyang Zhou, Xiatian Zhu, Yongxin Yang, Andrea Cavallaro, Tao XiangICCV 2019https://arxiv.org/abs/1910.06827v1https://github.com/KaiyangZhou/deep-person-reid 将ResNet和DenseNet引入到图卷积网络中，可以训练更深（达112层）的GCN，在多个任务中达到了更高的精度。DeepGCNs: Making GCNs Go as Deep as CNNsGuohao Li, Matthias Müller, Guocheng Qian, Itzel C. Delgadillo, Abdulellah Abualshour, Ali Thabet, Bernard GhanemICCV 2019https://arxiv.org/abs/1910.06849v1https://github.com/lightaime/deep_gcns_torchhttps://github.com/lightaime/deep_gcns 训练智能体玩“躲猫猫”游戏Visual Hide and SeekBoyuan Chen, Shuran Song, Hod Lipson, Carl Vondrickhttps://arxiv.org/abs/1910.07882v1http://www.cs.columbia.edu/~bchen/visualhideseek/ 掩膜引导的注意力网络，用于遮挡严重的行人检测，在多个数据集实现了更高的最好精度。CityPersons提升9.5%，Caltech提升5.0%。Mask-Guided Attention Network for Occluded Pedestrian DetectionYanwei Pang, Jin Xie, Muhammad Haris Khan, Rao Muhammad Anwer, Fahad Shahbaz Khan, Ling ShaoICCV 2019https://arxiv.org/abs/1910.06160v2https://github.com/Leotju/MGAN 一种几何启发的卷积操作，有效提升了消失点检测NeurVPS: Neural Vanishing Point Scanning via Conic ConvolutionYichao Zhou, Haozhi Qi, Jingwei Huang, Yi Mahttps://arxiv.org/abs/1910.06316v1https://github.com/zhou13/neurvps 单次神经架构搜索，基于自我评估模版网络，在CIFAR和ImageNet数据集达到最先进的性能One-Shot Neural Architecture Search via Self-Evaluated Template NetworkXuanyi Dong, Yi YangICCV 2019https://arxiv.org/abs/1910.05733v1https://github.com/D-X-Y/NAS-Projects 学习鉴别特征，用于非监督域适应Drop to Adapt: Learning Discriminative Features for Unsupervised Domain AdaptationSeungmin Lee, Dongwan Kim, Namil Kim, Seong-Gyun JeongICCV 2019https://arxiv.org/abs/1910.05562v1https://github.com/postBG/DTA.pytorch 可变组卷积神经网络，可以支持大规模人脸识别，同时减少计算成本和参数。获得格灵深瞳轻量级人脸识别挑战赛冠军！VarGFaceNet: An Efficient Variable Group Convolutional Neural Network for Lightweight Face RecognitionMengjia Yan, Mengao Zhao, Zining Xu, Qian Zhang, Guoli Wang, Zhizhong SuICCV 2019 Workshophttps://arxiv.org/abs/1910.04985v1https://github.com/zma-c-137/VarGFaceNet 发明一种称为Hadamard乘积的递归连接，构建了独立递归神经网络（IndRNN），其中同一层中的神经元彼此独立并且跨层连接。IndRNN可有效替代LSTM，精度更高的同时，速度是其10倍！Deep Independently Recurrent Neural Network (IndRNN)Shuai Li, Wanqing Li, Chris Cook, Yanbo Gao, Ce Zhuhttps://arxiv.org/abs/1910.06251v1https://github.com/Sunnydreamrain/IndRNN_pytorch 一种以字符为基本单元的单阶段文本检测识别网络，在三个标准基准上对CharNet结果显示，其结果以最先进的结果大大领先之前的算法，比如ICDAR 2015上从65.33％改进到71.08％，TotalText上从54.0％跃升至69.23％。Convolutional Character NetworksLinjie Xing, Zhi Tian, Weilin Huang, Matthew R. ScottICCV 2019https://arxiv.org/abs/1910.07954v1https://github.com/MalongTech/research-charnet 基于语音指令实现的自动驾驶Conditional Driving from Natural Language InstructionsJunha Roh, Chris Paxton, Andrzej Pronobis, Ali Farhadi, Dieter FoxCoRL 2019https://arxiv.org/abs/1910.07615v1https://sites.google.com/view/language-grounded-driving 医学图像域适应 | 提出了一种新型的无监督域自适应框架，称为协作特征集合自适应（CFEA），改进了眼底图像分割的精度CFEA: Collaborative Feature Ensembling Adaptation for Domain Adaptation in Unsupervised Optic Disc and Cup SegmentationPeng Liu, Bin Kong, Zhongyu Li, Shaoting Zhang, Ruogu FangMICCAI 2019https://arxiv.org/abs/1910.07638v1https://github.com/cswin/AWC","link":"/2019/10/21/computer-vision-weekly-news-20191003/"},{"title":"decompilation","text":"可以执行程序反编译为汇编程序 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int f(int a){ if(a==100) return 1; return 0;} int main(){ printf(\"Enter a num: \"); int a; scanf(\"%d\",&amp;a); printf(\"num is %d\\n\", a); // int code = 100; if(f(a)){ printf(\"code is true\\n\"); }else{ printf(\"code is false\\n\"); } scanf(\"%s\",&amp;a); return 0;} 使用x64dbg加载 main.exe 12345678910111213141516171819202122232425262728293031323334push ebpmov ebp,espand esp,FFFFFFF0sub esp,20call main.401A30mov dword ptr ss:[esp],main.405064call &lt;JMP.&amp;printf&gt;lea eax,dword ptr ss:[esp+1C]mov dword ptr ss:[esp+4],eaxmov dword ptr ss:[esp],main.405072call &lt;JMP.&amp;scanf&gt;mov eax,dword ptr ss:[esp+1C]mov dword ptr ss:[esp+4],eaxmov dword ptr ss:[esp],main.405075call &lt;JMP.&amp;printf&gt;mov eax,dword ptr ss:[esp+1C]mov dword ptr ss:[esp],eaxcall main.401460test eax,eaxje main.4014D7mov dword ptr ss:[esp],main.405080call &lt;JMP.&amp;puts&gt;jmp main.4014E3mov dword ptr ss:[esp],main.40508Dcall &lt;JMP.&amp;puts&gt;lea eax,dword ptr ss:[esp+1C]mov dword ptr ss:[esp+4],eaxmov dword ptr ss:[esp],main.40509Bcall &lt;JMP.&amp;scanf&gt;mov eax,0leave ret nop nop","link":"/2019/10/06/decompilation/"},{"title":"falling-stone","text":"陨石 很多人都知道现在陨石的价格节节攀升，价值堪比黄金、钻石，有的甚至远远超过。但是为什么陨石价值这么高呢？恐怕很多人仅仅只是认为陨石非常稀少所以才能卖的那么高。 是的，正是因为陨石的稀少才造成了它的天价，但那不是唯一的原因，陨石具有重要的研究价值，说陨石难得，因为每年落到地上来的陨石不多，被搜集到的就更少了。说它珍贵，因为它是我们能够接触到的、数量非常有限的天体实物标本，它可以为我们带来非常宝贵的情报和信息，而这些往往是用其他手段难以得到的，因此，尽管地上的实验室里已经有了从月球上取来的岩石，科学家们仍然十分重视研究这些自己“送上门来”的陨石标本。 陨石是起源于外太空，撞击到地球表面后残存的天然物体。当它还在陨石太空时称为流星体，当他进入大气层时，撞击压力使这个物体被加热和放射出光线，于是成为火球，即所谓的流星。火球这个名词显示这是来自地球之外并与地球碰撞的一个物体，或是极端明亮，类似火球这样的流星最终将撞击到地球的表面。 更通俗的说，陨石是来自太空中任何地方，落在表面上的自然天体。月球和火星上也发现到了陨石。陨石因为撞击或经过大气层时发光成为流星时被观测到而被寻获的称为墬落陨石，所有其它的陨石都称为发现陨石。陨石是石头，也是星星。 正是因为陨石的珍贵才造成了现在陨石的天价。早在1993年，苏富比拍卖行以44.25万美元拍成交一块0.33克的月球陨石，相当于每克100万美元;1998年5月，纽约菲利普斯拍卖行以7333美元拍过一块火星陨石，这个价钱相当于同样重量黄金的1000倍!2008年4月17日，巴黎佳士得以7.825万欧元成交一块43厘米、45千克的非洲纳米比亚陨石;2010年10月5日，巴黎苏富比拍卖的一块非洲纳米比亚陨石拍得2.235万欧元。2013年，在乌鲁木齐，一块“拳头大”的陨石，标出8千万的天价。陨石交易给收藏界带来的强大热流，简直令人震撼，这也暗示着陨石收藏走入人们的视线并荣升新宠。 陨石是人类直接认识太阳系各星体珍贵稀有的实物标本，极具收藏价值。陨石多半带有地球上没有或不常见的矿物组合，以及经过大气层高速燃烧的痕迹。至于太空人登上外星球，如月球，所带回来的则不叫陨石。而会称为月球矿石。据加拿大科学家10年的观测，每年降落到地球上的陨石有20多吨，大概有两万多块。 由于多数陨石落在海洋、荒草、森林和山地等人烟罕至地区，而被人发现并收集到手的陨石每年只有几十块，数量极少。 陨石是来自地球之外的“客人”。根据陨石本身所含的化学成分的不同，大致可分为三种类型： 1.铁陨石，也叫陨铁，它的主要成分是铁和镍； 2.石铁陨石，也叫陨铁石，这类陨石较少，其中 铁镍与硅酸盐大致各占一半； 3.石陨石，也叫陨石，主要成分是硅酸盐，这种陨石的数目最多。 Reference[1] 都说陨石价值过万，了解才知道原来真是这样 . 2019-11-10","link":"/2019/11/10/falling-stone/"},{"title":"exeinfo","text":"exeinfohttp://www.exeinfo.xn.pl/","link":"/2019/10/10/exeinfo/"},{"title":"git教程","text":"名称git - 愚蠢的内容跟踪器 概要git [--version] [ - help] [-C &lt;path&gt;] [-c &lt;name&gt; = &lt;value&gt;] [--exec-path [= &lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [ - no-replace-objects] [--bare] [--git-dir = &lt;path&gt;] [ - work-tree = &lt;path&gt;] [--namespace = &lt;name&gt;] [--super前缀= &lt;路径&gt;] &lt;command&gt; [&lt;args&gt;]描述Git是一个快速，可扩展的分布式版本控制系统，具有异常丰富的命令集，可提供高级操作和对内部的完全访问。 请参阅gittutorial [7]以开始使用，然后查看 giteveryday [7]以获取有用的最小命令集。在Git的用户手册有一个更深入的介绍。 掌握了基本概念后，您可以回到此页面了解Git提供的命令。您可以使用“git help command”了解有关各个Git命令的更多信息。 gitcli [7] 手册页概述了命令行命令语法。 可以在以下位置查看最新Git文档的格式化和超链接副本https://git.github.io/htmldocs/git.html。 OPTIONS 版打印git程序来自的Git套件版本。 救命打印概要和最常用命令的列表。如果选择–all或-a已给出，则打印所有可用命令。如果命名了Git命令，则此选项将显示该命令的手册页。 其他选项可用于控制手册页的显示方式。有关更多信息，请参阅git-help [1]，因为git –help …内部转换为git help …。 -C &lt;路径&gt;运行就好像git是在而不是当前工作目录中启动的。当-C给出多个选项时，-C 相对于前面的每个后续非绝对值被解释-C 。如果存在但是为空，例如-C “”，则保持当前工作目录不变。 此选项会影响预期的路径名的选项一样–git-dir，并 –work-tree在他们的路径名的解释，将相对于所造成的工作目录进行-C选择。例如，以下调用是等效的： git --git-dir = a.git --work-tree = b -C c status git --git-dir = c / a.git --work-tree = c / b status-c = 将配置参数传递给命令。给定的值将覆盖配置文件中的值。的格式与git config列出的格式相同 （以点分隔的子键）。 请注意，允许省略=in git -c foo.bar …并设置 foo.bar为布尔值true（就像[foo]bar在配置文件中一样）。包括equals但空值（如git -c foo.bar= …）设置foo.bar为git config –type=bool将转换为的空字符串false。 –exec路径[= &lt;路径&gt;]安装核心Git程序的路径。这也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径，git将打印当前设置然后退出。 –html路径打印路径，不带斜杠，安装Git的HTML文档并退出。 –man路径打印manpath（请参阅参考资料man(1)）获取此版本Git的手册页并退出。 –info路径打印安装记录此版本Git的Info文件的路径并退出。 -p–paginate如果标准输出是终端，则将所有输出传输到较少（或如果设置为$ PAGER）。这将覆盖pager. 配置选项（请参阅下面的“配置机制”部分）。 -P–no寻呼机不要将Git输出传输到寻呼机。 –git-DIR = &lt;路径&gt;设置存储库的路径。这也可以通过设置GIT_DIR环境变量来控制。它可以是当前工作目录的绝对路径或相对路径。 共同努力树= &lt;路径&gt;设置工作树的路径。它可以是绝对路径或相对于当前工作目录的路径。这也可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制（有关更详细的讨论，请参阅git-config [1]中的core.worktree ）。 –namespace = &lt;路径&gt;设置Git名称空间。有关更多详细信息，请参阅gitnamespaces [7]。相当于设置GIT_NAMESPACE环境变量。 –super前缀= &lt;路径&gt;目前仅供内部使用。设置一个前缀，该前缀提供从存储库上方到其根目录的路径。一个用途是给出调用它的超级项目的子模块上下文。 裸将存储库视为裸存储库。如果未设置GIT_DIR环境，则将其设置为当前工作目录。 –no替换对象不要使用替换引用来替换Git对象。有关更多信息，请参阅 git-replace [1]。 –literal按本义，pathspecs按字面意思处理pathspecs（即没有globbing，没有pathspec魔法）。这相当于将GIT_LITERAL_PATHSPECS环境变量设置为1。 –glob-pathspecs为所有pathspec添加“glob”魔法。这相当于将GIT_GLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( literal）”在各个pathspec上禁用通配符 –noglob-pathspecs为所有pathspec添加“literal”魔法。这相当于将GIT_NOGLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( glob）”在各个pathspec上启用globbing –icase-pathspecs为所有pathspec添加“icase”魔法。这相当于将GIT_ICASE_PATHSPECS环境变量设置为1。 –no-可选锁不要执行需要锁定的可选操作。这相当于设置GIT_OPTIONAL_LOCKS为0。 –list-CMDS =基团[，组…]按组列出命令。这是一个内部/实验选项，可能会在将来更改或删除。支持的组包括：builtins，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（所有其他命令$PATH都有git-前缀），list- （请参阅命令中的类别 - list.txt），nohelpers（排除帮助程序命令），别名和配置（从配置变量completion.commands检索命令列表）","link":"/2019/08/16/git教程/"},{"title":"graph-convolution","text":"图系列|从图(Graph)到图卷积(Graph Convolution): 漫谈图神经网络模型笔者最近看了一些图与图卷积神经网络的论文，深感其强大，但一些Survey或教程默认了读者对图神经网络背景知识的了解，对未学过信号处理的读者不太友好。同时，很多教程只讲是什么，不讲为什么，也没有梳理清楚不同网络结构的区别与设计初衷(Motivation)。 因此，本文试图沿着图神经网络的历史脉络，从最早基于不动点理论的图神经网络(Graph Neural Network， GNN)一步步讲到当前用得最火的图卷积神经网络(Graph Convolutional Neural Network， GCN)， 期望通过本文带给读者一些灵感与启示。 本文的提纲与叙述要点主要参考了2篇图神经网络的Survey，分别是来自IEEE Fellow的A Comprehensive Survey on Graph Neural Networks[1] 以及来自清华大学朱文武老师组的Deep Learning on Graphs: A Survey[7]， 在这里向两篇Survey的作者表示敬意。 同时，本文关于部分图卷积神经网络的理解很多都是受到知乎问题[8]高赞答案的启发，非常感谢他们的无私分享！ 最后，本文还引用了一些来自互联网的生动形象的图片，在这里也向这些图片的作者表示感谢。本文中未注明出处的图片均为笔者制作，如需转载或引用请联系本人。 历史脉络在开始正文之前，笔者先带大家回顾一下图神经网络的发展历史。不过，因为图神经网络的发展分支非常之多，笔者某些叙述可能并不全面，一家之言仅供各位读者参考： 图神经网络的概念最早在2005年提出。2009年Franco博士在其论文 [2]中定义了图神经网络的理论基础，笔者呆会要讲的第一种图神经网络也是基于这篇论文。 最早的GNN主要解决的还是如分子结构分类等严格意义上的图论问题。但实际上欧式空间(比如像图像 Image)或者是序列(比如像文本 Text)，许多常见场景也都可以转换成图(Graph)，然后就能使用图神经网络技术来建模。 2009年后图神经网络也陆续有一些相关研究，但没有太大波澜。直到2013年，在图信号处理(Graph Signal Processing)的基础上，Bruna(这位是LeCun的学生)在文献 [3]中首次提出图上的基于频域(Spectral-domain)和基于空域(Spatial-domain)的卷积神经网络。 其后至今，学界提出了很多基于空域的图卷积方式，也有不少学者试图通过统一的框架将前人的工作统一起来。而基于频域的工作相对较少，只受到部分学者的青睐。 值得一提的是，图神经网络与图表示学习(Represent Learning for Graph)的发展历程也惊人地相似。2014年，在word2vec [4]的启发下，Perozzi等人提出了DeepWalk [5]，开启了深度学习时代图表示学习的大门。更有趣的是，就在几乎一样的时间，Bordes等人提出了大名鼎鼎的TransE [6]，为知识图谱的分布式表示(Represent Learning for Knowledge Graph)奠定了基础。 图神经网络(Graph Neural Network)首先要澄清一点，除非特别指明，本文中所提到的图均指图论中的图(Graph)。它是一种由若干个结点(Node)及连接两个结点的边(Edge)所构成的图形，用于刻画不同结点之间的关系。下面是一个生动的例子，图片来自论文[7]: 状态更新与输出最早的图神经网络起源于Franco博士的论文[2], 它的理论基础是不动点理论。给定一张图 G，每个结点都有其自己的特征(feature), 本文中用xv表示结点v的特征；连接两个结点的边也有自己的特征，本文中用x(v,u)表示结点v与结点u之间边的特征；GNN的学习目标是获得每个结点的图感知的隐藏状态 hv(state embedding)，这就意味着：对于每个节点，它的隐藏状态包含了来自邻居节点的信息。那么，如何让每个结点都感知到图上其他的结点呢？GNN通过迭代式更新所有结点的隐藏状态来实现，在t+1时刻，结点v的隐藏状态按照如下方式更新： 1𝐡^{t+1}_𝑣=𝑓(𝐱_𝑣,𝐱_𝑐𝑜[𝑣],𝐡^{t}_𝑛𝑒[𝑣] ,𝐱_𝑛𝑒[𝑣]), 上面这个公式中的 f 就是隐藏状态的状态更新函数，在论文中也被称为局部转移函数(local transaction function)。公式中的xco[v]指的是与结点v相邻的边的特征，xne[v]指的是结点v的邻居结点的特征，htne[v]则指邻居结点在t时刻的隐藏状态。注意 f 是对所有结点都成立的，是一个全局共享的函数。那么怎么把它跟深度学习结合在一起呢？聪明的读者应该想到了，那就是利用神经网络(Neural Network)来拟合这个复杂函数 f。值得一提的是，虽然看起来 f 的输入是不定长参数，但在 f 内部我们可以先将不定长的参数通过一定操作变成一个固定的参数，比如说用所有隐藏状态的加和来代表所有隐藏状态。我们举个例子来说明一下： 假设结点5为中心结点，其隐藏状态的更新函数如图所示。这个更新公式表达的思想自然又贴切：不断地利用当前时刻邻居结点的隐藏状态作为部分输入来生成下一时刻中心结点的隐藏状态，直到每个结点的隐藏状态变化幅度很小，整个图的信息流动趋于平稳。至此，每个结点都“知晓”了其邻居的信息。状态更新公式仅描述了如何获取每个结点的隐藏状态，除它以外，我们还需要另外一个函数 g 来描述如何适应下游任务。举个例子，给定一个社交网络，一个可能的下游任务是判断各个结点是否为水军账号。 1𝐨_𝑣=𝑔(𝐡_𝑣,𝐱_𝑣) 在原论文中，g 又被称为局部输出函数(local output function)，与 f 类似，g 也可以由一个神经网络来表达，它也是一个全局共享的函数。那么，整个流程可以用下面这张图表达： 仔细观察两个时刻之间的连线，它与图的连线密切相关。比如说在 T1 时刻，结点 1 的状态接受来自结点 3 的上一时刻的隐藏状态，因为结点 1 与结点 3相邻。直到 Tn 时刻，各个结点隐藏状态收敛，每个结点后面接一个 g 即可得到该结点的输出 o。 对于不同的图来说，收敛的时刻可能不同，因为收敛是通过两个时刻p-范数的差值是否小于某个阈值 ϵ来判定的，比如： … 参考文献[1]. A Comprehensive Survey on Graph Neural Networks, https://arxiv.org/abs/1901.00596 [2]. The graph neural network model, https://persagen.com/files/misc/scarselli2009graph.pdf [3]. Spectral networks and locally connected networks on graphs, https://arxiv.org/abs/1312.6203 [4]. Distributed Representations of Words and Phrases and their Compositionality, http://papers.nips.cc/paper/5021-distributed-representations-of-words-andphrases [5]. DeepWalk: Online Learning of Social Representations, https://arxiv.org/abs/1403.6652 [6]. Translating Embeddings for Modeling Multi-relational Data, https://papers.nips.cc/paper/5071-translating-embeddings-for-modeling-multi-relational-data [7]. Deep Learning on Graphs: A Survey, https://arxiv.org/abs/1812.04202 [8]. 如何理解Graph Convolutional Network（GCN）? https://www.zhihu.com/question/54504471 [9]. Almeida–Pineda recurrent backpropagation, https://www.wikiwand.com/en/Almeida%E2%80%93Pineda_recurrent_backpropagation [10]. Gated graph sequence neural networks, https://arxiv.org/abs/1511.05493 [11]. Representing Schema Structure with Graph Neural Networks for Text-to-SQL Parsing, https://arxiv.org/abs/1905.06241 [12]. Spider1.0 Yale Semantic Parsing and Text-to-SQL Challenge, https://yale-lily.github.io/spider [13]. https://www.wikiwand.com/en/Laplacian_matrix 作者： SivilTaram出处：https://www.cnblogs.com/SivilTaram/p/graph_neural_network_1.html本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。","link":"/2019/11/11/graph-convolution/"},{"title":"forbes-global-ceo-conference","text":"Forbes Global CEO Conference: Key Insights And HighlightsThe 19th annual Forbes Global CEO Conference took place in Singapore Oct. 15 and Oct. 16, providing an unparalleled forum for discussion and debate among the 500 global CEOs, tycoons, entrepreneurs, capitalists and thought leaders who attended. Notable speakers at the event included: Lee Hsien Loong, Prime Minister of Singapore; Jack Ma, Founder, Jack Ma Foundation, United Nations Sustainable Development Goals Advocate, Partner, Alibaba Group; Eduardo Saverin, Cofounder and Partner of B Capital; and Steve Forbes, Chairman and Editor-in-Chief of Forbes Media. For a full list of speakers, please visit the conference website. Key insights and highlights from the conference can be found below. PROMOTED DBS Private Bank BRANDVOICE | Paid ProgramWhy ESG Matters Among Wealthy Investors UNICEF USA BRANDVOICE | Paid ProgramSaving Newborn Lives Is A Priority For UNICEF Civic Nation BRANDVOICE | Paid ProgramLearning From The #RealCollege Movement Singapore PM Warns Of Trade War’s Worldwide Impact At Forbes Global CEO Conference The trade war means “fewer opportunities for our companies to invest in China and export to America, or to invest in America and do business with China,” said Lee. “And these are all win-win opportunities, which is the essence of what international trade is, and it is how the world has prospered for many decades.” Jack Ma In Conversation With Steve Forbes: Alibaba Founder Talks Tech, Business And Philanthropy “The thing is that entrepreneurship in Africa is so different…Most entrepreneurs in other countries, they always want to [start an] enterprise, they want to go for IPO,” Ma said in Singapore. “ These people in Africa, they want to change Africa. They want to change their lives.” Capitalism 2.0: An Essay from Goh Hup Jin – Chairman, Nipsea Holdings International Ltd, Nipsea Pte Ltd We kind of think and say that the owners of capital have been “taking capital away from” society. That’s why we say “return it to society” when we engage in charity. The truth is capital never left the economic system. Buckle Up: Three Key Trends Driving Global Economic Turbulence uncaptionedThe global economy is beset by storms, bumps and risk aversion. Trade wars and escalating U.S.-China tensions are to blame. But they aren’t the only storms. Three deep trends will drive turbulence – and opportunity – for many years to come. References[1] Forbes Global CEO Conference: Key Insights And Highlights . 2019-11-9","link":"/2019/11/09/forbes-global-ceo-conference/"},{"title":"jna","text":"Java Native Access (JNA)The definitive JNA reference (including an overview and usage details) is in the JavaDoc. Please read the overview. Questions, comments, or exploratory conversations should begin on the mailing list, although you may find it easier to find answers to already-solved problems on StackOverflow. JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required. This functionality is comparable to Windows’ Platform/Invoke and Python’s ctypes. JNA allows you to call directly into native functions using natural Java method invocation. The Java call looks just like the call does in native code. Most calls require no special handling or configuration; no boilerplate or generated code is required. JNA uses a small JNI library stub to dynamically invoke native code. The developer uses a Java interface to describe functions and structures in the target native library. This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms. Read this more in-depth description. While significant attention has been paid to performance, correctness and ease of use take priority. In addition, JNA includes a platform library with many native functions already mapped as well as a set of utility interfaces that simplify native access. Projects Using JNAJNA is a mature library with dozens of contributors and hundreds of commercial and non-commercial projects that use it. If you’re using JNA, feel free to tell us about it. Include some details about your company, project name, purpose and size and tell us how you use the library. Apache Cassandra: Large-scale NoSQL data store. Rococoa: Java bindings to the Mac OS X Cocoa framework, by Duncan McGregor. jna-posix: Common POSIX Functions for Java. JNAerator: Pronounced “generator”, auto-generates JNA mappings from C headers, by Olivier Chafik. Freedom for Media in Java by Ken Larson/Dieter Krachtus. gstreamer for Java by Wayne Meissner. Videolan: JVLC Java Multimedia Library. SVNKit: Pure Java Subversion client library. OmegaT Computer-Aided Translation. IntelliJ IDEA by JetBrains. NetBeans IDE. Athena Backup by Doug Patriarche. FileBot Media Renamer by Reinhard Pointner. USB for Java by Mario Boikov. Waffle: Enables SSO on Windows in Java applications, by Daniel Doubrovkine. leveldb-jna: Cross-platform JNA based adapter for LevelDB (used in Keylord). bolt-jna: Cross-platform JNA based adapter for Bolt (used in Keylord). It is show how to use JNA for binding to Go library. JVM OpenVR Bindings. Apache Ignite: Direct IO plugin Domino JNA: Cross-platform access to HCL Notes/Domino C API methods from Java Interesting Investigations/Experiments Drive Lego Mindstorm NXT by Emmanuel Pirsch. Detect User Inactivity by Olivier Chafik. IAXClient Applet provides VOIP for Java, by Wolfgang Pichler. There are also a number of examples and projects within the contrib directory of the JNA project itself. Supported PlatformsJNA will build on most linux-like platforms with a reasonable set of GNU tools and a JDK. See the native Makefile for native configurations that have been built and tested. If your platform is supported by libffi, then chances are you can build JNA for it. Pre-built platform support may be found here. DownloadVersion 5.4.0 JNA&nbsp;jna-5.4.0.jar This is the core artifact of JNA and contains only the binding library and thecore helper classes. JNA Platform&nbsp;jna-platform-5.4.0.jar This artifact holds cross-platform mappings and mappings for a number of commonly used platformfunctions, including a large number of Win32 mappings as well as a set of utility classesthat simplify native access. The code is tested and the utility interfaces ensure thatnative memory management is taken care of correctly. See PlatformLibrary.md for details. Features Automatic mapping from Java to native functions, with simple mappings for all primitive data types Runs on most platforms which support Java Automatic conversion between C and Java strings, with customizable encoding/decoding Structure and Union arguments/return values, by reference and by value Function Pointers, (callbacks from native code to Java) as arguments and/or members of a struct Auto-generated Java proxies for native function pointers By-reference (pointer-to-type) arguments Java array and NIO Buffer arguments (primitive types and pointers) as pointer-to-buffer Nested structures and arrays Wide (wchar_t-based) strings Native long support (32- or 64-bit as appropriate) Demo applications/examples Supported on 1.4 or later JVMs, including JavaME (earlier VMs may work with stubbed NIO support) Customizable marshalling/unmarshalling (argument and return value conversions) Customizable mapping from Java method to native function name, and customizable invocation to simulate C preprocessor function macros Support for automatic Windows ASCII/UNICODE function mappings Varargs support Type-safety for native pointers VM crash protection (optional) Optimized direct mapping for high-performance applications. COM support for early and late binding. COM/Typelib java code generator. Community and SupportAll questions should be posted to the jna-users Google group. Issues can be submitted here on Github. When posting to the mailing list, please include the following: What OS/CPU/architecture you’re using (e.g. Windows 7 64-bit) Reference to your native interface definitions (i.e. C headers), if available The JNA mapping you’re trying to use VM crash logs, if any Example native usage, and your attempted Java usage It’s nearly impossible to indicate proper Java usage when there’s no nativereference to work from. For commercial support, please contact twalljava [at] java [dot] net. Using the Library Getting Started Functional Description. Mapping between Java and Native Using Pointers and Arrays Using Structures and Unions Using By-Reference Arguments Customization of Type Mapping Callbacks/Function Pointers/Closures Dynamically Typed Languages (JRuby/Jython) Platform Library Direct Method Mapping (Optimization) Frequently Asked Questions (FAQ) Avoiding Crashes Primary Documentation (JavaDoc)The definitive JNA reference is in the JavaDoc. Developers Contributing to JNA Setting up a Windows Development Environment Setting up an Android Development Environment Setting up a RaspberryPi Development Environment Setting up a Mac Development Environment Releasing JNA Publishing to Maven Central ContributingYou’re encouraged to contribute to JNA. Fork the code from https://github.com/java-native-access/jna and submit pull requests. For more information on setting up a development environment see Contributing to JNA. If you are interested in paid support, feel free to say so on the jna-users mailing list. Most simple questions will be answered on the list, but more complicated work, new features or target platforms can be negotiated with any of the JNA developers (this is how several of JNA’s features came into being). You may even encounter other users with the same need and be able to cost share the new development. LicenseThis library is licensed under the LGPL, version 2.1 or later, and (from version 4.0 onward) the Apache Software License, version 2.0. Commercial license arrangements are negotiable. NOTE: Oracle is not sponsoring this project, even though the package name (com.sun.jna) might imply otherwise.","link":"/2019/10/13/jna/"},{"title":"ICRUS","text":"A simple, delicate, and modern theme for the static site generator Hexo. Preview | Documentation | Download :cd: InstallationDownload &amp; extract or git clone Icarus from GitHub to your blog’s theme folder, and that’s it! 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Once started, Icarus will remind you of any missing dependencies and configuration files. :gift: FeaturesExtensive Plugin Support Icarus includes plentiful search, comment, sharing and other plugins out of the box. You can choose any of them to enrich yourblog experience, or build your own plugin easily referring to the existing Icarus plugins. Comment plugins Changyan Disqus Facebook Gitment Isso LiveRe Valine Search plugins Insight Search Google Custom Search Engine Baidu Site Search Share plugins AddThis AddToAny Baidu Share Share.js ShareThis Donation Buttons Alipay Wechat Paypal Patreon Other plugins Hexo Tag Plugin lightGallery &amp; Justified Gallery MathJax Site Analytics Rich Code Highlight Theme Choices Icarus directly import code highlight themes from the highlight.js package, and makes more than70 highlight themes available to you. Elastic Theme Configuration In addition to the minimalistic and easy-to-understand configuration design, Icarus allows you to set configurations on aper-page basis with the ability to merge and override partial configurations. _config.yml post.md menu: Archives: /archives Categories: /categories Tags: /tags About: /about title: A Simple Post menu: Go Home: /index.html --- # Here is some simple markdown. Responsive Layout No matter what modern browsering device your audiences are using, they can always get the best experience because Icarus’s responsivelayout across multiple viewpoints. :hammer: DevelopmentThis project is built with Hexo 3.7.1 Ejs Stylus Bulma 0.7.2 Please refer to the documentation for Icarus implementation details. :tada: ContributeIf you feel like to help us build a better Icarus, you can :electric_plug: Write a plugin |:black_nib: Submit a tutorial |:triangular_flag_on_post: Report a bug |:earth_asia: Add a translation :memo: LicenseThis project is licensed under the MIT License - see the LICENSE file for details.","link":"/2019/11/14/hexo-theme-icarus/"},{"title":"javamelody","text":"JavaMelody : monitoring of JavaEE applications The goal of JavaMelody is to monitor Java or Java EE applications in QA and production environments. It is not a tool to simulate requests from users, it is a tool to measure and calculate statistics on real operation of an application depending on the usage of the application by users. JavaMelody is opensource (ASL) and production ready: in production in an application of 25 person years. JavaMelody is easy to integrate in most applications and is lightweight (no profiling and no database). JavaMelody is mainly based on statistics of requests and on evolution charts. It allows to improve applications in QA and production and helps to: give facts about the average response times and number of executions make decisions when trends are bad, before problems become too serious optimize based on the more limiting response times find the root causes of response times verify the real improvement after optimizations It includes summary charts showing the evolution over time of the following indicators: Number of executions, mean execution times and percentage of errors of http requests, sql requests, jsf actions, struts actions, jsp pages or methods of business façades (if EJB3, Spring or Guice) Java memory Java CPU Number of user sessions Number of jdbc connections These charts can be viewed on the current day, week, month, year or custom period. JavaMelody includes statistics of predefined counters (currently http requests, sql requests, jsf actions, struts actions, jsp pages and methods of business façades if EJB3, Spring or Guice) with, for each counter : A summary indicating the overall number of executions, the average execution time, the cpu time and the percentage of errors. And the percentage of time spent in the requests for which the average time exceeds a configurable threshold. And the complete list of requests, aggregated without dynamic parameters with, for each, the number of executions, the mean execution time, the mean cpu time, the percentage of errors and an evolution chart of execution time over time. Furthermore, each http request indicates the size of the flow response, the mean number of sql executions and the mean sql time.It also includes statistics on http errors, on warnings and errors in logs, on data caches if ehcache and on batch jobs if quartz. An optional and independent collect server may be used if necessary to unload the application of storage management, and of report generation and to centralize the data of clustered applications or of several applications. See the online demo. Read the User’s guide to install JavaMelody. JavaMelody users’ group is at http://groups.google.com/group/javamelody (email: javamelody@googlegroups.com). There are a Jenkins plugin and a JIRA/Confluence/Bamboo/Bitbucket plugin and other plugins. Roots conference slides and video by David Karlsen","link":"/2019/11/08/javamelody/"},{"title":"lianhuafeng","text":"莲花峰（安徽境内山峰） 莲花峰，是黄山风景区境内第一高峰，为36大峰之首，海拔1864.8米。位于登山步道玉屏楼到鳌鱼峰之间。莲花峰登峰盘道5里，相对高度110米。1997年，莲花沟开辟500米登山新道，由蹬道、栈桥、观景台等组成。 莲花峰峻峭高耸，气势雄伟。因主峰突兀，小峰簇拥，俨若新莲初开，仰天怒放，故名“莲花峰”。“登峰起步缓坡称“莲梗”，中间穿过四个石洞，古人称“莲孔”。洞穴陡立，游人叠级而上，如在莲孔中穿行，恰似“倾曲作蚁旋出花萼中”。沿途风光奇绝，峰壁间有“真好造化”、“非人间也”、“名不虚传”、“天海奇观”等摩崖题刻。峰下有莲花洞、莲花源。 明代吴怅曾有诗赞曰：“一种青莲吐绛霞，亭亭玉立净无瑕。遥看天际浮云卷，露出峰顶十丈花。”清代吴梦印亦有诗云：“莲峰秀拔迥称尊，凡欲高呼达帝阍。举目江山如带砺，低头峦蚰似儿孙。风生绝献应回雁，日落悬岩不度猿。翠影岚光千万状，我虽能到未能言。”连接莲花岭和莲花峰的是一条长达一公里半的蜿蜒小道，在到达峰顶前要过四个洞穴。莲花峰上既有许多或似飞龙或似双龙的松树，也有著名的黄山杜鹃花 [1] 。","link":"/2019/10/24/lianhuafeng/"},{"title":"linux_so","text":"Linux下的静态库、动态库和动态加载库Linux库类型Linux下可以创建两种类型的库: 静态库(.a): 在链接期间被应用程序直接链接进可执行文件 动态链接库(.so): 动态库还分为两种用法: a) 应用程序运行期间链接动态库，但是在编译期间声明动态库的存在，也就是说这种动态库必须在编译时对编译器可见，但编译器却不将此种库编译进可执行文件; b) 在运行期间，动态加载和卸载的库，使用动态加载方法加载。这种库的形式跟动态链接没有本质区别，区别是在调用时，是由用户程序决定何时链接的，而不是由系统链接器自动链接 命名约定库需要以lib作为开头，而在指定链接命令行参数时，却无需包含开头和扩展名，例如： 1gcc src-file.c -lm -lpthread 这个例子中，链接了libmath.a和libpthread.a 静态库(.a)生成静态库的方法如下： 编译object文件。例如：cc -Wall -c ctest1.c ctest2.c，该命令会生成ctest1.o和ctest2.o(其中-Wall表示编译时输出警告)。 创建库文件。例如：ar -cvq libctest.a ctest1.o ctest2.o。该命令会得到一个libctest.a文件 可以通过ar -t查看.a文件中包含哪些.o。所以，实际上ar就是一个打包命令，类似tar 构建符号表。ranlib libctest.a用于为.a创建符号表。有些ar命令实际上已经集成了ranlib的功能 .a文件与windows下的.lib是相同的概念。 动态库(.so)生成动态库的方法如下： 编译object文件时使用-fPIC选项： 1gcc -Wall -fPIC -c *.c 这个选项的目的是让编译器生成地址无关(position independent)的代码，这是因为，动态库是在运行期间链接的，变量和函数的偏移量是事先不知道的，需要链接以后根据offset进行地址重定向。 使用-shared链接1gcc -shared -Wl,-soname,libctest.so.1 -o libctest.so.1.0 *.o -shared选项是让动态库得以在运行期间被动态链接;-Wl,options是设置传递给ld(链接器)的参数，在上面的例子中，当链接器在链接.o时会执行ld -soname ibctest.so.1 创建软链 上面的命令将最终输出一个动态库libctest.so.1.0，而出于习惯，会创建两个软链: 123mv libctest.so.1.0 /opt/libln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so.1ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so libctest.so用于在编译期间使用-lctest让编译器找到动态库，而libctest.so.1用于在运行期间链接 1gcc -Wall -I/path/to/include-files -L/path/to/libraries prog.c -lctest -o prog 查看依赖使用ldd命令来查看程序对动态库的依赖。例如： 12345ldd proglibctest.so.1 =&gt; /opt/lib/libctest.so.1 (0x00002aaaaaaac000)libc.so.6 =&gt; /lib64/tls/libc.so.6 (0x0000003aa4e00000)/lib64/ld-linux-x86-64.so.2 (0x0000003aa4c00000) obj文件obj文件的格式和组成可能是系统差异性的一大体现，比如windows下的PE、linux和一些unix下的elf、macos的mach-o、aix下的xcoff。 查看obj文件的符号表信息，可以通过nm objdump readelf等方法。 运行期间查找动态库运行期间，系统需要知道到哪里去查找动态库，这是通过/etc/ld.so.conf配置的。ldconfig用于配置运行时动态库查找路径，实际是更新/etc/ld.so.cache。另外一些环境变量也可以影响查找：(Linux/Solaris: LD_LIBRARY_PATH, SGI: LD_LIBRARYN32_PATH, AIX: LIBPATH, Mac OS X: DYLD_LIBRARY_PATH, HP-UX: SHLIB_PATH) 动态加载和卸载的库需要应用程序希望设计成插件化的架构，这就需要可以动态加载和卸载库的机制。与动态链接不同的是，动态加载的意思是，编译期间可以对动态库的存在一无所知，而是在运行期间通过用户程序尝试加载进来的。 通过dlfcn.h中的dlopen、dlsym和dlclose等函数实现此种功能。 另外，使用到dlfcn机制的可执行文件需要使用-rdynamic选项，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号，但不包括静态符号，比如被static修饰的函数）都添加到动态符号表（即.dynsym表）里。 GNU Libtool如今许多软件的编译都采用libtool工具，libtool是一个编译链接包装工具，实际只是一个脚本，用libtool编译和链接会产生类似.la的文件，.la这种文件其实是个文本文件，指向.a文件，并声明一些版本信息。 传送门","link":"/2019/10/14/linux-so/"},{"title":"lazydocker","text":"A simple terminal UI for both docker and docker-compose, written in Go with the gocui library. Demo Minor rant incoming: Something’s not working? Maybe a service is down. docker-compose ps. Yep, it’s that microservice that’s still buggy. No issue, I’ll just restart it: docker-compose restart. Okay now let’s try again. Oh wait the issue is still there. Hmm. docker-compose ps. Right so the service must have just stopped immediately after starting. I probably would have known that if I was reading the log stream, but there is a lot of clutter in there from other services. I could get the logs for just that one service with docker compose logs --follow myservice but that dies everytime the service dies so I’d need to run that command every time I restart the service. I could alternatively run docker-compose up myservice and in that terminal window if the service is down I could just up it again, but now I’ve got one service hogging a terminal window even after I no longer care about its logs. I guess when I want to reclaim the terminal realestate I can do ctrl+P,Q, but… wait, that’s not working for some reason. Should I use ctrl+C instead? I can’t remember if that closes the foreground process or kills the actual service. What a headache! Memorising docker commands is hard. Memorising aliases is slightly less hard. Keeping track of your containers across multiple terminal windows is near impossible. What if you had all the information you needed in one terminal window with every common command living one keypress away (and the ability to add custom commands as well). Lazydocker’s goal is to make that dream a reality. Requirements Installation Usage Keybindings Cool Features Contributing Video Tutorial Config Docs Twitch Stream FAQ Requirements Docker &gt;= 1.13 (API &gt;= 1.25) Docker-Compose &gt;= 1.23.2 (optional) InstallationHomebrewNormally lazydocker formula can be found in the Homebrew core but we suggest you to tap our formula to get frequently updated one. It works with Linux, too. Tap: 1brew install jesseduffield/lazydocker/lazydocker Core: 1brew install lazydocker Binary Release (Linux/OSX)You can manually download a binary release from the release page. Automated install/update, don’t forget to always verify what you’re piping into bash: 1curl https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh | bash GoRequired Go version &gt;= 1.8 1go get github.com/jesseduffield/lazydocker Arch Linux AURYou can install lazydocker using your AUR package manager of choice or by running: 123git clone https://aur.archlinux.org/lazydocker.git ~/lazydockercd ~/lazydockermakepkg --install A development version of the AUR package is also available Docker Click if you have an ARM device If you have a ARM 32 bit v6 architecture 12345docker build -t lazyteam/lazydocker \\--build-arg BASE_IMAGE_BUILDER=arm32v6/golang \\--build-arg GOARCH=arm \\--build-arg GOARM=6 \\https://github.com/jesseduffield/lazydocker.git If you have a ARM 32 bit v7 architecture 12345docker build -t lazyteam/lazydocker \\--build-arg BASE_IMAGE_BUILDER=arm32v7/golang \\--build-arg GOARCH=arm \\--build-arg GOARM=7 \\https://github.com/jesseduffield/lazydocker.git If you have a ARM 64 bit v8 architecture 1234docker build -t lazyteam/lazydocker \\--build-arg BASE_IMAGE_BUILDER=arm64v8/golang \\--build-arg GOARCH=arm64 \\https://github.com/jesseduffield/lazydocker.git Run the container 1234docker run --rm -it -v \\/var/run/docker.sock:/var/run/docker.sock \\-v /yourpath:/.config/jesseduffield/lazydocker \\lazyteam/lazydocker Don’t forget to change /yourpath to an actual path you created to store lazydocker’s config You can also use this docker-compose.yml You might want to create an alias, for example: 1echo \"alias lzd='docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock -v /yourpath/config:/.config/jesseduffield/lazydocker lazyteam/lazydocker'\" &gt;&gt; ~/.zshrc For development, you can build the image using: 1234567git clone https://github.com/jesseduffield/lazydocker.gitcd lazydockerdocker build -t lazyteam/lazydocker \\ --build-arg BUILD_DATE=`date -u +\"%Y-%m-%dT%H:%M:%SZ\"` \\ --build-arg VCS_REF=`git rev-parse --short HEAD` \\ --build-arg VERSION=`git describe --abbrev=0 --tag` \\ . If you encounter a compatibility issue with Docker bundled binary, try rebuildingthe image with the build argument --build-arg DOCKER_VERSION=&quot;v$(docker -v | cut -d&quot; &quot; -f3 | rev | cut -c 2- | rev)&quot;so that the bundled docker binary matches your host docker binary version. UsageCall lazydocker in your terminal. I personally use this a lot so I’ve made an alias for it like so: 1echo &quot;alias lzd=&apos;lazydocker&apos;&quot; &gt;&gt; ~/.zshrc (you can substitute .zshrc for whatever rc file you’re using) Basic video tutorial here. List of keybindingshere. Cool featureseverything is one keypress away (or one click away! Mouse support FTW): viewing the state of your docker or docker-compose container environment at a glance viewing logs for a container/service viewing ascii graphs of your containers’ metrics so that you can not only feel but also look like a developer customising those graphs to measure nearly any metric you want attaching to a container/service restarting/removing/rebuilding containers/services viewing the ancestor layers of a given image pruning containers, images, or volumes that are hogging up disk space ContributingThere is still a lot of work to go! Please check out the contributing guide.For contributor discussion about things not better discussed here in the repo, join the slack channel DonateIf you would like to support the development of lazydocker, please donate SocialIf you want to see what I (Jesse) am up to in terms of development, follow me ontwitter or watch me program ontwitch FAQHow do I edit my config?By opening lazydocker, clicking on the ‘project’ panel in the top left, and pressing ‘o’ (or ‘e’ if your editor is vim). See Config Docs How do I get text to wrap in my main panel?In the future I want to make this the default, but for now there are some CPU issues that arise with wrapping. If you want to enable wrapping, use gui.wrapMainPanel: true How do you select text?Because we support mouse events, you will need to hold option while dragging the mouse to indicate you’re trying to select text rather than click on something. Alternatively you can disable mouse events via the gui.ignoreMouseEvents config value Does this work with Windows?Currently not unless you use WSL. Instructions for setting up docker for WSL can be found here here Why can’t I see my container’s logs?By default we only show logs from the last hour, so that we’re not putting too much strain on the machine. This may be why you can’t see logs when you first start lazydocker. This can be overwritten in the config’s commandTemplates If you are running lazydocker in Docker container, it is a know bug, that you can’t see logs or CPU usage. Alternatives docui - Skanehira beat me to the punch on making a docker terminal UI, so definitely check out that repo as well! I think the two repos can live in harmony though: lazydocker is more about managing existing containers/services, and docui is more about creating and configuring them. Portainer - Portainer tries to solve the same problem but it’s accessed via your browser rather than your terminal. It also supports docker swarm.","link":"/2019/10/27/lazydocker/"},{"title":"md5-info","text":"MD5 MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。 C++实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;#define shift(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))//右移的时候，高位一定要补零，而不是补充符号位#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z))) #define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))#define A 0x67452301#define B 0xefcdab89#define C 0x98badcfe#define D 0x10325476//strBaye的长度unsigned int strlength;//A,B,C,D的临时变量unsigned int atemp;unsigned int btemp;unsigned int ctemp;unsigned int dtemp;//常量ti unsigned int(abs(sin(i+1))*(2pow32))const unsigned int k[]={ 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,0x698098d8, 0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193, 0xa679438e,0x49b40821,0xf61e2562,0xc040b340,0x265e5a51, 0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905, 0xfcefa3f8,0x676f02d9,0x8d2a4c8a,0xfffa3942,0x8771f681, 0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60, 0xbebfbc70,0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,0xf4292244, 0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92, 0xffeff47d,0x85845dd1,0x6fa87e4f,0xfe2ce6e0,0xa3014314, 0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391};//向左位移数const unsigned int s[]={7,12,17,22,7,12,17,22,7,12,17,22,7, 12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10, 15,21,6,10,15,21,6,10,15,21,6,10,15,21};const char str16[]=\"0123456789abcdef\";void mainLoop(unsigned int M[]){ unsigned int f,g; unsigned int a=atemp; unsigned int b=btemp; unsigned int c=ctemp; unsigned int d=dtemp; for (unsigned int i = 0; i &lt; 64; i++) { if(i&lt;16){ f=F(b,c,d); g=i; }else if (i&lt;32) { f=G(b,c,d); g=(5*i+1)%16; }else if(i&lt;48){ f=H(b,c,d); g=(3*i+5)%16; }else{ f=I(b,c,d); g=(7*i)%16; } unsigned int tmp=d; d=c; c=b; b=b+shift((a+f+k[i]+M[g]),s[i]); a=tmp; } atemp=a+atemp; btemp=b+btemp; ctemp=c+ctemp; dtemp=d+dtemp;}/**填充函数*处理后应满足bits≡448(mod512),字节就是bytes≡56（mode64)*填充方式为先加一个1,其它位补零*最后加上64位的原来长度*/unsigned int* add(string str){ unsigned int num=((str.length()+8)/64)+1;//以512位,64个字节为一组 unsigned int *strByte=new unsigned int[num*16]; //64/4=16,所以有16个整数 strlength=num*16; for (unsigned int i = 0; i &lt; num*16; i++) strByte[i]=0; for (unsigned int i=0; i &lt;str.length(); i++) { strByte[i&gt;&gt;2]|=(str[i])&lt;&lt;((i%4)*8);//一个整数存储四个字节，i&gt;&gt;2表示i/4 一个unsigned int对应4个字节，保存4个字符信息 } strByte[str.length()&gt;&gt;2]|=0x80&lt;&lt;(((str.length()%4))*8);//尾部添加1 一个unsigned int保存4个字符信息,所以用128左移 /* *添加原长度，长度指位的长度，所以要乘8，然后是小端序，所以放在倒数第二个,这里长度只用了32位 */ strByte[num*16-2]=str.length()*8; return strByte;}string changeHex(int a){ int b; string str1; string str=\"\"; for(int i=0;i&lt;4;i++) { str1=\"\"; b=((a&gt;&gt;i*8)%(1&lt;&lt;8))&amp;0xff; //逆序处理每个字节 for (int j = 0; j &lt; 2; j++) { str1.insert(0,1,str16[b%16]); b=b/16; } str+=str1; } return str;}string getMD5(string source){ atemp=A; //初始化 btemp=B; ctemp=C; dtemp=D; unsigned int *strByte=add(source); for(unsigned int i=0;i&lt;strlength/16;i++) { unsigned int num[16]; for(unsigned int j=0;j&lt;16;j++) num[j]=strByte[i*16+j]; mainLoop(num); } return changeHex(atemp).append(changeHex(btemp)).append(changeHex(ctemp)).append(changeHex(dtemp));}unsigned int main(){ string ss;// cin&gt;&gt;ss; string s=getMD5(\"abc\"); cout&lt;&lt;s; return 0;}","link":"/2019/11/05/md5-info/"},{"title":"minio","text":"MinIO Quickstart Guide MinIO is an object storage server released under Apache License v2.0. It is compatible with Amazon S3 cloud storage service. It is best suited for storing unstructured data such as photos, videos, log files, backups and container / VM images. Size of an object can range from a few KBs to a maximum of 5TB. MinIO server is light enough to be bundled with the application stack, similar to NodeJS, Redis and MySQL. Docker ContainerStable12docker pull minio/miniodocker run -p 9000:9000 minio/minio server /data Edge12docker pull minio/minio:edgedocker run -p 9000:9000 minio/minio:edge server /data Note: Docker will not display the default keys unless you start the container with the -it(interactive TTY) argument. Generally, it is not recommended to use default keys with containers. Please visit MinIO Docker quickstart guide for more information here macOSHomebrewInstall minio packages using Homebrew 12brew install minio/stable/miniominio server /data NOTE: If you previously installed minio using brew install minio then it is recommended that you reinstall minio from minio/stable/minio official repo instead. 12brew uninstall miniobrew install minio/stable/minio Binary Download Platform Architecture URL Apple macOS 64-bit Intel https://dl.min.io/server/minio/release/darwin-amd64/minio 12chmod 755 minio./minio server /data GNU/LinuxBinary Download Platform Architecture URL GNU/Linux 64-bit Intel https://dl.min.io/server/minio/release/linux-amd64/minio 123wget https://dl.min.io/server/minio/release/linux-amd64/miniochmod +x minio./minio server /data Platform Architecture URL GNU/Linux ppc64le https://dl.min.io/server/minio/release/linux-ppc64le/minio 123wget https://dl.min.io/server/minio/release/linux-ppc64le/miniochmod +x minio./minio server /data Microsoft WindowsBinary Download Platform Architecture URL Microsoft Windows 64-bit https://dl.min.io/server/minio/release/windows-amd64/minio.exe 1minio.exe server D:\\Photos FreeBSDPortInstall minio packages using pkg 1234pkg install miniosysrc minio_enable=yessysrc minio_disks=/home/user/Photosservice minio start Install from SourceSource installation is only intended for developers and advanced users. If you do not have a working Golang environment, please follow How to install Golang. Minimum version required is go1.12 1GO111MODULE=on go get github.com/minio/minio Allow port access for FirewallsBy default MinIO uses the port 9000 to listen for incoming connections. If your platform blocks the port by default, you may need to enable access to the port. iptablesFor hosts with iptables enabled (RHEL, CentOS, etc), you can use iptables command to enable all traffic coming to specific ports. Use below command to allowaccess to port 9000 12iptables -A INPUT -p tcp --dport 9000 -j ACCEPTservice iptables restart Below command enables all incoming traffic to ports ranging from 9000 to 9010. 12iptables -A INPUT -p tcp --dport 9000:9010 -j ACCEPTservice iptables restart ufwFor hosts with ufw enabled (Debian based distros), you can use ufw command to allow traffic to specific ports. Use below command to allow access to port 9000 1ufw allow 9000 Below command enables all incoming traffic to ports ranging from 9000 to 9010. 1ufw allow 9000:9010/tcp firewall-cmdFor hosts with firewall-cmd enabled (CentOS), you can use firewall-cmd command to allow traffic to specific ports. Use below commands to allow access to port 9000 1firewall-cmd --get-active-zones This command gets the active zone(s). Now, apply port rules to the relevant zones returned above. For example if the zone is public, use 1firewall-cmd --zone=public --add-port=9000/tcp --permanent Note that permanent makes sure the rules are persistent across firewall start, restart or reload. Finally reload the firewall for changes to take effect. 1firewall-cmd --reload Test using MinIO BrowserMinIO Server comes with an embedded web based object browser. Point your web browser to http://127.0.0.1:9000 ensure your server has started successfully. Test using MinIO Client mcmc provides a modern alternative to UNIX commands like ls, cat, cp, mirror, diff etc. It supports filesystems and Amazon S3 compatible cloud storage services. Follow the MinIO Client Quickstart Guide for further instructions. Pre-existing dataWhen deployed on a single drive, MinIO server lets clients access any pre-existing data in the data directory. For example, if MinIO is started with the command minio server /mnt/data, any pre-existing data in the /mnt/data directory would be accessible to the clients. The above statement is also valid for all gateway backends. Upgrading MinIOMinIO server supports rolling upgrades, i.e. you can update one MinIO instance at a time in a distributed cluster. This allows upgrades with no downtime. Upgrades can be done manually by replacing the binary with the latest release and restarting all servers in a rolling fashion. However, we recommend all our users to use mc admin update from the client. This will update all the nodes in the cluster and restart them, as shown in the following command from the MinIO client (mc): 1mc admin update &lt;minio alias, e.g., myminio&gt; Important things to remember during upgrades: mc admin update will only work if the user running MinIO has write access to the parent directory where the binary is located, for example if the current binary is at /usr/local/bin/minio, you would need write access to /usr/local/bin. In the case of federated setups mc admin update should be run against each cluster individually. Avoid updating mc until all clusters have been updated. If you are updating the server it is always recommended (unless explicitly mentioned in MinIO server release notes), to update mc once all the servers have been upgraded using mc update. mc admin update is disabled in docker/container environments, container environments provide their own mechanisms for updating running containers. If you are using Vault as KMS with MinIO, ensure you have followed the Vault upgrade procedure outlined here: https://www.vaultproject.io/docs/upgrading/index.html If you are using etcd with MinIO for the federation, ensure you have followed the etcd upgrade procedure outlined here: https://github.com/etcd-io/etcd/blob/master/Documentation/upgrades/upgrading-etcd.md Explore Further MinIO Erasure Code QuickStart Guide Use mc with MinIO Server Use aws-cli with MinIO Server Use s3cmd with MinIO Server Use minio-go SDK with MinIO Server The MinIO documentation website Contribute to MinIO ProjectPlease follow MinIO Contributor’s Guide CaveatsMinIO in its default mode doesn’t use MD5Sum checkums of incoming streams unless requested by the client in Content-Md5 header for validation. This may lead to incompatibility with rare S3 clients like s3ql which unfortunately do not set Content-Md5 but depend on hex MD5Sum for the stream to be calculated by the server. MinIO considers this as a bug in s3ql and should be fixed on the client side because MD5Sum is a poor way to checksum and validate the authenticity of the objects. Although MinIO provides a workaround until client applications are fixed use --compat option instead to start the server. 1./minio --compat server /data License","link":"/2019/11/12/minio/"},{"title":"nohup:在linux后台运行程序","text":"nohup:在linux后台运行程序今天在工作中，lz要在Linux系统上运行一个java程序，这个程序要在系统中持续运行。随后lz无意将ssh窗口关掉了，发现java程序停止了。原来，当使用ssh连接到系统运行程序的时候，该程序已经和你的ssh连接绑定了。如果你关闭连接，该程序就会停止。还有一个情景：如果要在后台运行多个java程序的时候，就需要启动多个ssh窗口，这样很麻烦。有没有方法来解决这个问题呢？答案是肯定的。 1.使用nohup来执行命令，它会把命令自动调到linux后台运行，不锁定当前ssh窗口，也不会被ctrl + c，alt + F4之类打断程序的动行。 1nohup java -jar test.jar &amp; 执行完该命令后，终端会显示如下信息： 12[1] 27945nohup: 忽略输入并把输出追加到&quot;nohup.out&quot; [1]：该后台任务的jobid27945：是该进程的pidnohup.out：是该任务的输出位置 2.要指定重定向的文件，如下： 1nohup java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp; 3.如果一个任务已经在前台执行，那就使用以下方法来将任务调整到后台： （1）首先，在正在执行任务的终端使用ctrl+z 1[1]+ 已停止 java -jar test.jar （2）使用bg命令将该任务调整至后台（fg与之相反，将后台任务调整至前台） 1bg %1(1是jobid) 如果不知道jobid，也可以使用jobs命令来查询。 但是任务的输出还是会打印到终端上的（具体怎么将输出重定向到别的地方，lz也不造）。而且，这时该任务还是与当前终端相关联的，关闭终端还是会断掉该任务的。使用下面命令来解决： 1disown -h %1 这样再也不用担心关掉终端会停止掉任务喽！！！ PS：再来说说nohup吧。nohup的意思是no hang up，就是说关掉终端是不会挂掉程序的。如果开始执行命令时只使用&amp;： 1java -jar test.jar &amp; 那么该任务也会在后台执行，但是一旦关掉终端该任务还是会挂掉，所以这就是nohup的用处了。 原文链接","link":"/2019/09/12/nohup-在linux后台运行程序/"},{"title":"network-security-industry-analyze","text":"2019中国信息安全自主可控行业政策盘点及网络安全行业分析中国作为一个崛起中的大国，国家安全至关重要。新一届中央高度重视信息安全自主可控的发展，重大会议以及演讲中多次强调网络安全问题。信息安全部署是国家重要战略，中兴、华为断供事件，无异于一场涅槃之火，互联网核心技术是我们最大的“命门”，核心技术受制于人是我们最大的隐患。棱镜门、信息泄露等安全事故的频发，网络安全环境日益复杂，没有网络安全就没有国家安全。 近年来我国不断完善立法，坚定不移的按照“国家主导、体系筹划、自主可控、跨越发展”的方针，在维护国家网络空间安全方面解决关键技术和设备上受制于人的问题，保障网络信息安全机制。本文将从国家信息安全政策及法规、中国网络安全行业分类以及网络安全发展现状等方面介绍2019中国信息安全自主可控行业概况。 一、盘点中国信息安全自主可控行业政策法规 2019年12月1日，等保2.0标准将正式实施，覆盖全社会各地区、各单位、各部门、各机构，涉及网络、信息系统、云平台、物联网、工控系统、大数据、移动互联等各类技术应用和场景。等保2.0控制措施对安全物理环境、安全通信网络、安全区域边界、安全计算环境、安全管理中心提出技术要求；对安全管理制度、安全管理机构、安全管理人员、安全建设管理、安全运维管理提出管理要求。对比等保1.0标准重点提出安全管理中心技术要求，具体包括系统管理、审计管理、集中管控、安全管理平台等，并明确要求对网络中的链路、安全设备、服务器、交换机等运营情况进行集中监测，对审计数据进行集中分析。 2.0标准让很多机构对等级保护建设工作一筹莫展，怎样的网络信息安全建设方案是各机构最好选择？一方面，机构都面临业务不断扩展、安全设备持续增加、运维人员有限等困难，选择简单有效、扩展性强、可开发的等级保护建设方案很重要。另一方面，云环境中网络虚拟化已成为信息技术演进的重要方向，虚拟化条件下的网络既面临传统网络中已存在的安全问题，也有引入虚拟化特性之后出现的一系列新的安全威胁，包括物理网络威胁、虚拟局域网威胁和虚拟网络威胁等。采用统一的安全管理平台，管理各种安全功能组件，针对网络安全风险，及时响应安全防护对策，开展安全运维十分重要。而等保2.0合规仅仅是基础，选择有效地检测并阻止安全威胁、可扩展并降低IT业务创新过程中的各种风险的网络安全管理方案，才能满足机构后续业务发展的各种安全需求，具备相应的安全能力，实现安全资源的弹性扩展和灵活调度，这也是机构进行网络安全防护的前提和关键。 随着等保2.0的正式发布，中国网络安全行业再次得到政策助推，进入快速上升轨道。当前网络安全的基础性、全局性问题已经充分呈现，未来五年，中国网络安全市场创新进入高峰阶段。 中国网络安全行业整体可划分为产品与服务两方面，下文将为大家呈现网络安全行业产品划分。 二、中国网络安全行业产品分类 数字经济迅猛发展，安全管理、网络管理、端点安全、安全开发、安全网关、应用安全、数据安全、身份与访问安全、安全业务是我国信息系统自主可控发展不可或缺的核心产品分类。 据中国互联网络信息中心（CNNIC）发布第44次《中国互联网络发展状况统计报告》显示，截止2019年6月，中国网民规模达8.54亿，互联网普及率达61.2%，占全球网民总数的五分之一，中国已成为名副其实的网络大国，而西方利用其高新技术对我实施的打压从未停止，我国的信息安全自主可控事业的起步，伴随着西方发达国家的技术封锁，但中华民族为了实现国家富强民族复兴而进行的技术探索绝不会止步。 三、国产化信息技术网络安全自主可控行业现状深度剖析1、贸易战凸显我国信息技术网络安全自主可控核心问题关键点在贸易摩擦纷争频现的大背景下，信息行业国产化及网络安全自主可控的需求鲜明凸显，自主可控是基础，是国产化信息技术网络安全的必要条件。自主可控的本质是打破国外公司在互联网架构上的垄断，防范软硬件设施存在影响我国网络安全的后门和漏洞。国与国之间都存在着不可逾越的“信任界线”，国家的高度重视必然推动国产化的信息技术和信息安全大幅增长和发展，这是机遇也是挑战。但我国信息技术产业核心软硬件产品受制于人的矛盾尖锐，棱镜门事件、中兴、华为断供事件影响恶劣且深远，扭转信息技术长期受制于人的格局，才能从根本解决国家信息安全的核心问题。 国内众多企业积极探索自主可控、网络安全的国产化软硬件，自主可控是一项系统工程，必须要有系统的思维来引导和设计生态。以中国电子、中电通信、航天科工为代表的国内央企集团已经能够提供完整的生态体系，能够提供从芯片、整机、网络设备到操作系统和系统集成全套的产品与服务。其中，航天科工建设的商密网已有两万余人使用。作为自主可控系统集成单位，有大格局，在处理器、操作系统、数据库等品牌众多的情况下，能以合作共赢为重，综合考虑生态建设的系统性、全局性、完整性和竞争性，构建可持续发展的生态体系，才能真正推动国内国产化替代工程的实施。 2、基于自主可控技术国产化替代框架进度及主流品牌分析（1）自主可控基础硬件受益于国家重大专项资金推动，成果显著 近年来，处理器、交换芯片、显示芯片等国产芯片产品已接近国外主流产品水平。中国CPU产品技术研发已进入多技术路线同步推进的高速发展阶段。国产处理器形成了以X86、MIPS、SPARC、ARM、ALPHA等架构为代表的系列化处理器产品，产品主频普遍为1.0GHz-1.5GHz。国产 CPU 技术正大步迈向新的阶段，美“芯”封喉的局面将得到极大扭转，为构建安全、自主、可控的国产化信息系统奠定了基础。基于国产CPU的整机及网络设备产品已经完全具备替代国外同类产品的能力，产品系列覆盖计算基础设施、信息安全、网络安全需求，具备系统性应用的条件。 （2）自主可控基础软件突破微软生态，基本已达国际水平 国产操作系统技术趋于成熟，中标麒麟、红旗Linux系统具有较高的实用性、稳定性和安全可控性。已覆盖服务器、桌面、移动和嵌入式等领域，产品大多采用开源技术。在系统的功能、性能，以及对设备、应用软件的支持方面也能满足用户的使用要求，可支持多种国产化处理器（方舟、龙芯等）架构，满足当前国产化的应用需求。国内多家自主知识产权的国产数据库（人大金仓、神州通用等）与国产处理器、操作系统可深入融合适配，支持商业化部署、容灾工具使用。如华为与神州信息共同发布的金融行业联合解决方案，依托华为公司TaiShan服务器以及Gauss数据库，实现神州信息的核心业务系统、数据平台、支付平台向华为的基础设施迁移。这套高度国产化（至CPU、数据库层面）的系统在性能上已经具备替代现有非底层国产化方案的能力，该案例为金融业IT解决方案提供了一套具备强竞争能力的高度国产化解决方案，十分具有里程碑式意义。国产中间件也已具备替代国外产品的能力，基于Java国际标准支持，国产中间件（东方通、金蝶等）与国产操作系统、数据库的兼容适配成效显著，并可实现深度定制化开发与优化。国产基础办公软件也已实现与国产操作系统的适配，对嵌入浏览器的支持、开发接口、界面风格、与office的兼容方面表现优越。 （3）自主可控应用软件在高精尖技术及实时性高要求领域得到应用 自主可控应用软件，已初步形成在国产化平台运行的办公自动化、企业管理、行业应用系统，部分产品在自主可控计算机示范应用工程中完成了迁移适配，可运行于主流自主可控平台，并已在通信、军事、航空、航天、政府等高精尖技术及实时性高要求的领域得到应用。 （4）自主可控网络安全管理领域成长机遇最大 国产基础软硬件迅速发展的过程中，也伴生了很多的问题，一方面，我国基础软硬件的体系复杂，相互之间的结合比较密切，含关键技术多；另一方面，国内现阶段处于去IOE过渡期，安全管理平台面临的重点问题在于既要适应所有的操作系统，如Windows、Linux、Unix、中标麒麟、红旗Linux等，还需同时监控众多网络设备生产厂商的产品和数据库、中间件应用服务等等。除此之外，我国网络设备部署越来越多，安全管理平台需求高速增长，安全管理平台要从整体上、系统化的帮助企业感知安全威胁，等保2.0控制措施对网络安全管理中心重点提出技术要求，赋能行业巨大的增长机遇。所以，对国内安全管理平台发展视角下的公司研究就非常有必要： 全面型企业：启明星辰、绿盟科技、蓝盾股份、奇安信（原360ESG）、天融信（南洋股份子公司）等企业，具备较为齐全的安全产品线，可依靠自有品牌产品对客户进行解决方案层面的构建，满足用户的整体安全需求。这些企业具备多元化的核心能力，包括网关能力、攻防能力、安全态势感知能力、安全运维能力等。 启明星辰：国内极具实力的网络安全综合解决方案提供商 拥有完全自主知识产权的网络安全产品、可信安全管理平台、安全服务与解决方案的综合提供商。国内入侵检测/入侵防御、统一威胁管理、安全管理平台、运维安全审计、数据审计与防护市场占有率第一位。 绿盟科技：强大自主开发防火墙 基于多年的安全攻防研究，绿盟科技在检测防御类、安全评估类、安全平台类、远程安全运维服务、安全SaaS服务等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估、Web安全防护等产品以及安全运营等专业安全服务。 蓝盾股份：聚焦安全产品、安全运营、安全集成、安全服务 蓝盾股份前身为广东天海威数码技术有限公司，聚焦安全产品、安全运营、安全集成、安全服务。 奇安信：国内网络安全领域中成长最快的企业 为政府、企业，教育、金融等机构和组织提供企业级网络安全技术、产品和服务的网络安全公司，相关产品和服务已覆盖90%以上的中央政府部门、中央企业和大型银行，已在印度尼西亚、新加坡、加拿大、中国香港等国家和地区开展了安全业务。 天融信：中国领先的网络安全、大数据与安全云服务提供商 基于创新的 “可信网络架构”以及业界领先的信息安全产品与服务，天融信致力于改善用户网络与应用的可视性、可用性、可控性和安全性，降低安全风险，创造业务价值。 专精型企业：除网关外的细分市场优质企业，包括北信源、智和信通、可信华泰、安恒信息、东软、格尔软件、卫士通、数字认证、中孚信息、恒安嘉新、安博通等，这些企业在细分领域均有明确的优势。这其中又可细分为完全兼容国产处理器、服务器、操作系统、数据库的专精型产品，包括智和网管平台SugarNMS、景云网络防病毒系统、北信源主机审计与监控系统、北信源身份鉴别系统等。 北信源：聚焦终端安全 北信源布局国产自主可控，终端信息安全市场。北信源主机审计与监控系统、北信源身份鉴别系统以及北信源旗下景云网络防病毒系统分别入选第一期国产化信息产品《适配名录》，主机安全产品线已经覆盖国产化、虚拟化、移动、工控等终端类型。 智和信通：首创开放式网管平台 北京智和信通公司专注网络管理运维、IT综合监控、网络管理平台、国产化安全软件、安全管控平台，智和网管平台SugarNMS采用“监控+展示+安管+开发”四合一平台模式，支持国产化平台，支持二次开发定制，具有可持续的功能扩展和开发集成能力，在军工集团科研院所、党政军、电信、金融、教育、医疗及企业中广泛应用。 可信华泰：计算产品整体解决方案提供商 北京可信华泰公司专注应用安全前沿趋势的研究和分析，安全产品包括可信软件、可信安全管理中心、可信支撑平台、可信移动终端、“白细胞”操作系统免疫平台等，满足各类型重要信息系统的计算环境的安全需求。 安恒信息：聚焦应用安全 安恒信息提供应用安全、数据库安全、网站安全监测、安全管理平台等整体解决方案，公司的产品及服务涉及应用安全、大数据安全、云安全、物联网安全、工业控制安全、工业互联网安全等领域。 东软：提供IT驱动的创新型解决方案与服务 东软提供应用开发和维护、ERP实施与咨询服务、专业测试及性能工程服务、软件全球化与本地化服务、IT基础设施服务、业务流程外包（BPO）、IT教育培训等。其安全管理平台将目前信息系统中各类数据孤立分析的形态转变为智能的关联分析，并借助平台实现技术人员（维护人员、应急小组）、操作过程（相应的管理制度和事件处理流程）和技术三者的融合。 格尔软件：加密认证全系列信息安全产品 中国较早研制和推出公钥基础设施PKI平台的厂商之一，是国内首批商用密码产品定点生产与销售单位之一。拥有全系列信息安全产品、安全服务和解决方案的提供能力。产品包括安全认证网关、可信边界安全网关、无线安全网关、电子签章系统、安全电子邮件系统、安全即时通系统、网络保险箱、终端保密系统、签名验证服务系统、局域网接入认证系统、打印管控系统、移动安全管理平台、云安全服务平台系统、移动介质管理系统等产品。 卫士通：聚焦加密及认证 成都卫士通为党政军用户、企业级用户和消费者提供专业自主的网络信息安全解决方案、产品和服务。公司致力于信息安全领域的技术研究和产品开发，从密码技术应用持续拓展，已形成密码产品、信息安全产品、安全信息系统三大信息安全产品体系。 数字认证：聚焦加密及认证 数字认证为用户提供涵盖电子认证服务和电子认证产品的整体解决方案。建立起覆盖全国的电子认证服务网络和较完善的电子认证产品体系。应用领域覆盖政府、金融、医疗卫生、彩票、电信等市场，在电子政务领域的市场占有率位居行业前列，并已在医疗信息化、网上保险、互联网彩票等重点新兴应用领域建立了市场领先优势。 中孚信息：聚焦加密和认证 中孚信息专业从事信息安全技术与产品研发、销售并提供行业解决方案和安全服务的高新技术企业。是国家商用密码产品定点生产和销售单位。公司拥有国家保密局颁发的国家涉密集成甲级****，具有工信部办法的信息系统集成资质。 恒安嘉新：聚焦网络空间安全综合治理 恒安嘉新专注于网络空间安全综合治理领域。主要采取直销模式向电信运营商、安全主管部门等政企客户提供服务。产品包括网络空间安全综合管理产品、移动互联网增值产品、通信网网络优化产品等。 安博通：网络安全系统平台和安全服务提供商 北京安博通是国内领先的网络安全系统平台和安全服务提供商。依托自主开发的应用层可视化安全网络安全技术，围绕核心ABT SPOS网络安全系统平台，为业界众多安全产品提供操作系统、业务组件、分析引擎、关键算法、特征库升级等软件支撑及相关的技术服务。 网关型企业：国产化进程阶段优先受益的分类，基础产品为主，产品线和技术能力聚焦边界防护、以各类网关为主体，包括华为、深信服、新华三、山石网科等。 华为：民族品牌 国之骄傲 全球领先的ICT（信息与通信）基础设施和智能终端提供商，在通信网络、IT、智能终端和云服务等领域为客户提供有竞争力、安全可信赖的产品、解决方案与服务，与生态伙伴开放合作。2018年销售收入7212亿RMB，净利润593亿RMB，经营活动现金流747亿RMB。 深信服：让IT更简单、更安全、更有价值 是一家专注于企业级安全、云计算及IT基础设施的产品和服务供应商，拥有智安全、云计算和新IT三大业务品牌，致力于让用户的IT更简单、更安全、更有价值。 新华三：融绘数字未来,共享美好生活 是业界领先的数字化解决方案领导者，致力于成为客户业务创新、产业升级可信赖的合作伙伴。拥有全系列服务器、存储、网络、安全、超融合系统和IT管理系统等产品，能够提供云计算、大数据、大互联、大安全和IT咨询与服务在内的数字化解决方案和产品的研发、生产、咨询、销售及服务。 山石网科：创新网络安全 专注于网络安全领域的前沿技术创新，为企业级和运营商用户提供智能化、高性能、高可靠、简单易用的网络安全解决方案。Hillstone以网络安全的需求变化为创新基点，立志为全球用户打造安全的网络环境，成为世界第一流的安全厂商。 国家多重利好政策下，国产信息化品牌迎来黄金时代。党政军、金融、电信、能源等中国重点领域及企业重新选择软硬件合作伙伴。 3、党政军领域国产化自主可控是必要条件中央军委印发《关于进一步加强军队信息安全工作的意见》，要求必须把信息安全工作作为网络强军的重要任务和军事斗争准备的保底工程，推进信息安全集中统管，构建与国家信息安全体系相衔接、与军事斗争准备要求相适应的军队信息安全防护体系。要全面推开信息安全等级保护和风险评估，规范信息安全建设和管理；强力推进国产自主化建设应用，夯实信息安全根基；创新发展信息安全技术防护体系，有效提升信息安全综合防御能力；扎实抓好信息安全防护力量建设，为信息安全建设管理提供人才支撑；坚决维护网上意识形态安全，严厉打击网上涉军违法犯罪活动；严格实施信息安全综合管控，确保重要人员、核心数据和关键设备安全；建立健全信息安全工作机制，形成齐抓共管、健康有序的工作局面。 综上所述，我国自主可控的发展，必将先从党政军领域开始。2017年-2020年，国家党政军队部门全面推行国产化方案，国产化信息安全自主可控行业年市场需求每年高达320亿元，如果实行党政军全替换国产化，需求将达每年504亿元。央企重点行业五年内替换比例将从早期的10%逐步增值到70%，自主可控整机将产生约300亿的市场需求，国产芯片市场空间近60亿元。金融领域5年内整机市场规模将达到185亿元，国产CPU市场空间近35亿元。 国产软硬件担负了“安全可控”的责任，让有网无防，有防不强的问题逐步解决。基础设施完成替换的同时，如智和网管平台SugarNMS、景云网络防病毒系统、北信源主机审计与监控系统、北信源身份鉴别系统等完全兼容国产处理器、服务器、操作系统、数据库的专精型产品也将迎来巨大的市场空间。 4、国产化市场前景广阔 2020年国产化扩展至重点行业及民用领域从市场角度看，国产自主可控软硬件并未有“市场可控”的生存条件。但国产化软硬件发展是大势所趋，如何布局是每个中国企业必须要考虑的现实问题。国产化软硬件成熟是本源，网络安全管理实现安全资源的弹性扩展和灵活调度是关键，满足企业后续业务长期发展的各类安全需求是发展之道。 华为的胜利，究其根本是企业家精神的胜利。中兴通讯的战略风险，绝不是一时之事，为何没有及早调整？一方面是公司高层决策缺乏安全监管机制，只求业绩发展，缺乏国家高度企业安全的长久战略考量。另一方面，早期国家网络安全审查机制不完善，一年进口芯片达2000多亿美元，网络安全隐患如何预防。无论国企、民企，缺乏真正为企业负责、为国家负责、为民族负责的企业家精神都难以长久发展。 我国加快核心技术攻研，推进网络安全自主可控，国产化采购是必然，2020年后国产化方案逐步向重点行业、民用领域扩展，国产自主可控系统市场空间可期。相信国家也会采取多种激励和支持措施加速去IOT进程。党政军民凝心聚力，共同攻坚克难，不忘初心，牢记使命，必将打赢网络强国之战，在新时代创造中华民族新的伟大奇迹！ *本文作者：蔚颖willing，来自FreeBuf.COM","link":"/2019/10/16/network-security-industry-analyze/"},{"title":"nlp","text":"自语言处理然 自语言处理然（英语：Natural Language Processing，缩写作 NLP）是人工智能和语言学领域的分支学科。此领域探讨如何处理及运用自然语言；自然语言处理包括多方面和步骤，基本有认知、理解、生成等部分。 自然语言认知和理解是让计算机把输入的语言变成有意思的符号和关系，然后根据目的再处理。自然语言生成系统则是把计算机数据转化为自然语言。 历史自然语言处理大体是从1950年代开始，虽然更早期也有作为。1950年，图灵发表论文“计算机器与智能”，提出现在所谓的“图灵测试”作为判断智能的条件。 1954年的乔治城实验涉及全部自动翻译超过60句俄文成为英文。研究人员声称三到五年之内即可解决机器翻译的问题。[1]不过实际进展远低于预期，1966年的ALPAC报告发现十年研究未达预期目标，机器翻译的研究经费遭到大幅削减。一直到1980年代末期，统计机器翻译系统发展出来，机器翻译的研究才得以更上一层楼。 1960年代发展特别成功的NLP系统包括SHRDLU——一个词汇设限、运作于受限如“积木世界”的一种自然语言系统，以及1964-1966年约瑟夫·维森鲍姆模拟“个人中心治疗”而设计的ELIZA——几乎未运用人类思想和感情的消息，有时候却能呈现令人讶异地类似人之间的交互。“病人”提出的问题超出ELIZA 极小的知识范围之时，可能会得到空泛的回答。例如问题是“我的头痛”，回答是“为什么说你头痛？” 1970年代，程序员开始设计“概念本体论”（conceptual ontologies）的程序，将现实世界的信息，架构成计算机能够理解的数据。实例有MARGIE、SAM、PAM、TaleSpin、QUALM、Politics以及Plot Unit。许多聊天机器人在这一时期写成，包括PARRY 、Racter 以及Jabberwacky 。 一直到1980年代，多数自然语言处理系统是以一套复杂、人工订定的规则为基础。不过从1980年代末期开始，语言处理引进了机器学习的算法，NLP产生革新。成因有两个：运算能力稳定增加（参见摩尔定律）；以及乔姆斯基 语言学理论渐渐丧失主导（例如转换-生成文法）。该理论的架构不倾向于语料库——机器学习处理语言所用方法的基础。有些最早期使用的机器学习算法，例如决策树，是硬性的、“如果-则”规则组成的系统，类似当时既有的人工订定的规则。不过词性标记将隐马尔可夫模型引入NLP，并且研究日益聚焦于软性的、以几率做决定的统计模型，基础是将输入数据里每一个特性赋予代表其分量的数值。许多语音识别现今依赖的缓存语言模型即是一种统计模型的例子。这种模型通常足以处理非预期的输入数据，尤其是输入有错误（真实世界的数据总免不了），并且在集成到包含多个子任务的较大系统时，结果比较可靠。 许多早期的成功属于机器翻译领域，尤其归功IBM的研究，渐次发展出更复杂的统计模型。这些系统得以利用加拿大和欧盟现有的语料库，因为其法律规定政府的会议必须翻译成所有的官方语言。不过，其他大部分系统必须特别打造自己的语料库，一直到现在这都是限制其成功的一个主要因素，于是大量的研究致力于从有限的数据更有效地学习。 近来的研究更加聚焦于非监督式学习和半监督学习的算法。这种算法，能够从没有人工注解理想答案的数据里学习。大体而言，这种学习比监督学习困难，并且在同量的数据下，通常产生的结果较不准确。不过没有注解的数据量极巨（包含了万维网），弥补了较不准确的缺点。 近年来, 深度学习技巧纷纷出炉[2][3] 在自然语言处理方面获得最尖端的成果，例如语言模型[4]、语法分析[5][6]等等。 自然语言处理的主要范畴 文本朗读（Text to speech）/语音合成（Speech synthesis） 语音识别（Speech recognition） 中文自动分词（Chinese word segmentation） 词性标注（Part-of-speech tagging） 句法分析（Parsing） 自然语言生成（Natural language generation） 文本分类（Text categorization） 信息检索（Information retrieval） 信息抽取（Information extraction） 文字校对（Text-proofing） 问答系统（Question answering） 给一句人类语言的问句，决定其答案。 典型问题有特定答案 (像是加拿大的首都- 叫什么?)，但也考虑些开放式问句(像是人生的意义是是什么?) 机器翻译（Machine translation） 将某种人类语言自动翻译至另一种语言 自动摘要（Automatic summarization）产生一段文字的大意，通常用于提供已知领域的文章摘要，例如产生报纸上某篇- - 文章之摘要 文字蕴涵（Textual entailment） 命名实体识别（Named entity recognition）","link":"/2019/10/07/nlp/"},{"title":"operating-system-knowledge-summary","text":"操作系统面试重难点总结 针对操作系统，根据面试重难点总结以及网络上的一些参考，对操作系统面试知识点的总结与学习。 一、操作系统知识点图谱 二、面试问题总结参考：面试复习重点——基础篇：操作系统、计算机网络、设计模式 1.操作系统的四个特性。2.操作系统的主要功能。3.进程的有哪几种状态，状态转换图，及导致转换的事件。4.进程与线程的区别。5.进程通信的几种方式。6.进程同步的几种方式7.用户态和核心态的区别。8.死锁的概念，导致死锁的原因.9.导致死锁的四个必要条件。10.处理死锁的四个方式。11.预防死锁的方法、避免死锁的方法。12.进程调度算法。13.内存连续分配方式采用的几种算法及各自优劣。14.基本分页储存管理方式。15.基本分段储存管理方式。16.分段分页方式的比较各自优缺点。17.几种页面置换算法，会算所需换页数18.虚拟内存的定义及实现方式。 三、重难点总结 操作系统的四个特性并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)共享：系统中的资源可以被内存中多个并发执行的进线程共同使用虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进 操作系统的主要功能处理机管理：处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度存储器管理（或者内存管理）：内存分配，内存保护，地址映射，内存扩充设备管理：管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用文件管理：管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护提供用户接口：程序接口（如API）和用户接口（如GUI） 进程的状态与转换 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。 就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。 运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。 运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。 阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。 进程与线程的区别进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。 线程：是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。 两者的对比： 调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销。 并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。 拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd） 系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。 进程通信进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。 共享存储 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。 消息传递 在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 1) 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。 2) 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。 管道通信 管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 进程同步多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性 同步机制需要遵循的原则： 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题 同步的解决方案：管程，信号量。 用户态和核心态 当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态； 反之，当程序运行在级特权级上时，就可以称之为运行在内核态。 虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。 当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 用户态切换到内核态的3种方式 1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 死锁死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。 死锁原因： 竞争资源：请求同一有限资源的进程数多于可用资源数进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链死锁产生的必要条件： 互斥条件:进程对所分配的资源进行排他性的使用请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链死锁处理： 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大 进程调度算法先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利； 短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ； 高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ; 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。 内存连续分配主要是指动态分区分配时所采用的几种算法。动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。 首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 基本分页储存管理方式把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。 由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。 在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。 12.基本分段储存管理方式分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。 访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。 分段分页方式的比较页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定 虚拟内存如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。 基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 虚拟存储器的特征： 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上 页面置换算法最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。 最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。 四、总结以上只是针对操作系统重点知识点的总结，如果没有相应的操作系统基础的话，可能不太好理解，下面推荐自己学习操作系统过程中参考的一些资料。 推荐课程：操作系统 传送门","link":"/2019/10/19/operating-system-knowledge-summary/"},{"title":"openssl","text":"OpenSSL下载安装1、下载OpenSSLOpenSSL下载地址：https://oomake.com/download/openssl 这个链接有Windows版和源码版最新版下载地址，可以满足Windows、LInux、Mac OS系统使用。 2、Windows系统安装OpenSSL到上面的链接下载OpenSSL Windows版本，注意32位和64位是不同的安装包， 下载之后是exe文件，双击按照提示一步步安装就可以了。 3、 Linux系统安装OpenSSL3.1 安装OpenSSL:1234567891011# tar -xzf openssl-1.0.2f.tar.gz# cd openssl-1.0.2f# mkdir /usr/local/openssl# ./config --prefix=/usr/local/openssl# make# make install 这样就安装完成了，接下来一些辅助步骤。 3.2 创建软连接123# which openssl/usr/local/openssl/bin/openssl 为了使用方便，以及以后版本更新方便，可以创建软连接，如下： 1# ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl 3.3 执行以下命令1234567891011121314151617# cd /usr/local/openssl# ldd /usr/local/openssl/bin/openssl linux-vdso.so.1 =&gt; (0x00007ffc63975000) libssl.so.1.1 =&gt; not found libcrypto.so.1.1 =&gt; not found libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f8d9da0f000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f8d9d7f3000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8d9d431000) /lib64/ld-linux-x86-64.so.2 (0x00007f8d9dc28000) 安装OK 3.4 查看版本123# openssl version/usr/local/openssl/bin/openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 找不到动态库libssl.so.1.1，小问题，执行如下命令： 1# vim /etc/ld.so.conf 在最后追加一行： 1/usr/local/openssl/lib 然后执行： 1234567# ldconfig /etc/ld.so.conf# openssl versionOpenSSL 1.1.0f 25 May 2017Done.","link":"/2019/11/02/openssl/"},{"title":"python style rules","text":"Python风格规范分号.. tip:: 不要在行尾加分号, 也不要用分号将两条命令放在同一行. .. _line_length: 行长度.. tip:: 每行不超过80个字符 例外: #. 长的导入模块语句 #. 注释里的URL 不要使用反斜杠连接行. Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 &lt;http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining&gt;_ , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号. .. code-block:: python Yes: foo_bar(self, width, height, color=&apos;black&apos;, design=None, x=&apos;foo&apos;, emphasis=None, highlight=0) if (width == 0 and height == 0 and color == &apos;red&apos; and emphasis == &apos;strong&apos;): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接: .. code-block:: python x = (&apos;This will build a very long long &apos; &apos;long long long long long long string&apos;)在注释中，如果必要，将长的URL放在一行上。 .. code-block:: python Yes: # See details at # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html.. code-block:: python No: # See details at # http://www.example.com/us/developer/documentation/api/content/\\ # v2.0/csv_file_name_extension_full_specification.html 注意上面例子中的元素缩进; 你可以在本文的 :ref:缩进 &lt;indentation&gt; 部分找到解释. 括号.. tip:: 宁缺毋滥的使用括号 除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的. .. code-block:: python Yes: if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): ... .. code-block:: python No: if (x): bar() if not(x): bar() return (foo).. _indentation: 缩进.. tip:: 用4个空格来缩进代码 绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 :ref:行长度 &lt;line_length&gt; 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数): .. code-block:: python Yes: # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... }.. code-block:: python No: # Stuff on first line forbidden foo = long_function_name(var_one, var_two, var_three, var_four) # 2-space hanging indent forbidden foo = long_function_name( var_one, var_two, var_three, var_four) # No hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... }空行.. tip:: 顶级定义之间空两行, 方法定义之间空一行 顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 空格.. tip:: 按照标准的排版规范来使用标点两边的空格 括号内不要有空格. .. code-block:: python Yes: spam(ham[1], {eggs: 2}, []).. code-block:: python No: spam( ham[ 1 ], { eggs: 2 }, [ ] )不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾). .. code-block:: python Yes: if x == 4: print x, y x, y = y, x.. code-block:: python No: if x == 4 : print x , y x , y = y , x参数列表, 索引或切片的左括号前不应加空格. .. code-block:: python Yes: spam(1).. code-block:: python no: spam (1).. code-block:: python Yes: dict[&apos;key&apos;] = list[index].. code-block:: python No: dict [&apos;key&apos;] = list [index] 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致. .. code-block:: python Yes: x == 1.. code-block:: python No: x&lt;1当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格. .. code-block:: python Yes: def complex(real, imag=0.0): return magic(r=real, i=imag).. code-block:: python No: def complex(real, imag = 0.0): return magic(r = real, i = imag)不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等): .. code-block:: python Yes: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = { &quot;foo&quot;: 1, &quot;long_name&quot;: 2, }.. code-block:: python No: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = { &quot;foo&quot; : 1, &quot;long_name&quot;: 2, }Shebang.. tip:: 大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 &lt;http://www.python.org/dev/peps/pep-0394/&gt;_ , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始. (译者注: 在计算机科学中, Shebang &lt;http://en.wikipedia.org/wiki/Shebang_(Unix)&gt;_ (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序.) #!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!. .. _comments: 注释.. tip:: 确保对模块, 函数, 方法和行内注释使用正确的风格 文档字符串 Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号&quot;&quot;&quot;( `PEP-257 &lt;http://www.python.org/dev/peps/pep-0257/&gt;`_ ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.函数和方法 下文所指的函数,包括函数, 方法, 以及生成器. 一个函数必须要有文档字符串, 除非它满足以下条件: #. 外部不可见 #. 非常短小 #. 简单明了 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&quot;怎么做&quot;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格. Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar. Returns: (或者 Yields: 用于生成器) 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略. Raises: 列出与接口有关的所有异常. .. code-block:: python def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): &quot;&quot;&quot;Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {&apos;Serak&apos;: (&apos;Rigel VII&apos;, &apos;Preparer&apos;), &apos;Zim&apos;: (&apos;Irk&apos;, &apos;Invader&apos;), &apos;Lrrr&apos;: (&apos;Omicron Persei 8&apos;, &apos;Emperor&apos;)} If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. &quot;&quot;&quot; pass类 类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. .. code-block:: python class SampleClass(object): &quot;&quot;&quot;Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. &quot;&quot;&quot; def __init__(self, likes_spam=False): &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot; self.likes_spam = likes_spam self.eggs = 0 def public_method(self): &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;块注释和行注释 最需要写注释的是代码中那些技巧性的部分. 如果你在下次 `代码审查 &lt;http://en.wikipedia.org/wiki/Code_review&gt;`_ 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. .. code-block:: python # We use a weighted dictionary search to find out where i is in # the array. We extrapolate position based on the largest num # in the array and the array size and then do binary search to # get the exact number. if i &amp; (i-1) == 0: # True if i is 0 or a power of 2. 为了提高可读性, 注释应该至少离开代码2个空格. 另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. .. code-block:: python # BAD COMMENT: Now go through the b array and make sure whenever i occurs # the next element is i+1类.. tip:: 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样. .. code-block:: python Yes: class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): &quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;.. code-block:: python No: class SampleClass: pass class OuterClass: class InnerClass: pass继承自 object 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 PEP-3000 &lt;http://www.python.org/dev/peps/pep-3000/&gt;_ 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ . 字符串.. tip:: 即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定. .. code-block:: python Yes: x = a + b x = &apos;%s, %s!&apos; % (imperative, expletive) x = &apos;{}, {}!&apos;.format(imperative, expletive) x = &apos;name: %s; score: %d&apos; % (name, n) x = &apos;name: {}; score: {}&apos;.format(name, n).. code-block:: python No: x = &apos;%s%s&apos; % (a, b) # use + in this case x = &apos;{}{}&apos;.format(a, b) # use + in this case x = imperative + &apos;, &apos; + expletive + &apos;!&apos; x = &apos;name: &apos; + name + &apos;; score: &apos; + str(n)避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.) .. code-block:: python Yes: items = [&apos;&lt;table&gt;&apos;] for last_name, first_name in employee_list: items.append(&apos;&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;&apos; % (last_name, first_name)) items.append(&apos;&lt;/table&gt;&apos;) employee_table = &apos;&apos;.join(items).. code-block:: python No: employee_table = &apos;&lt;table&gt;&apos; for last_name, first_name in employee_list: employee_table += &apos;&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;&apos; % (last_name, first_name) employee_table += &apos;&lt;/table&gt;&apos;在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. GPyLint已经加入了这一检查. (译者注:GPyLint疑为笔误, 应为PyLint.) .. code-block:: python Yes: Python(‘Why are you hiding your eyes?’) Gollum(“I’m scared of lint errors.”) Narrator(‘“Good!” thought a happy Python reviewer.’) .. code-block:: python No: Python(“Why are you hiding your eyes?”) Gollum(‘The lint. It burns. It burns us.’) Gollum(“Always the great lint. Watching. Watching.”) 为多行字符串使用三重双引号”””而非三重单引号’’’. 当且仅当项目中使用单引号’来引用字符串时, 才可能会使用三重’’’为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号”””. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致. .. code-block:: python Yes: print (&quot;This is much nicer.\\n&quot; &quot;Do it this way.\\n&quot;).. code-block:: python No: print &quot;&quot;&quot;This is pretty ugly. Don&apos;t do this. &quot;&quot;&quot;文件和sockets.. tip:: 在文件和sockets结束时, 显式的关闭它. 除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如: #. 它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽. #. 持有文件将会阻止对于文件的其他诸如移动、删除之类的操作. #. 仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来. 而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因: #. 没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长. #. 对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等). 推荐使用 &quot;with&quot;语句 &lt;http://docs.python.org/reference/compound_stmts.html#the-with-statement&gt;_ 以管理文件: .. code-block:: python with open(&quot;hello.txt&quot;) as hello_file: for line in hello_file: print line对于不支持使用”with”语句的类似文件的对象,使用 contextlib.closing(): .. code-block:: python import contextlib with contextlib.closing(urllib.urlopen(&quot;http://www.python.org/&quot;)) as front_page: for line in front_page: print lineLegacy AppEngine 中Python 2.5的代码如使用”with”语句, 需要添加 “from future import with_statement”. TODO注释.. tip:: 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了. TODO注释应该在所有开头处包含”TODO”字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字. .. code-block:: python # TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition. # TODO(Zeke) Change this to use relations.如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”). 导入格式.. tip:: 每个导入应该独占一行 .. code-block:: python Yes: import os import sys.. code-block:: python No: import os, sys导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: #. 标准库导入 #. 第三方库导入 #. 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写. .. code-block:: python import foo from foo import bar from foo.bar import baz from foo.bar import Quux from Foob import ar语句.. tip:: 通常每个语句应该独占一行 不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 try/except 这样做, 因为try和except不能放在同一行. .. code-block:: python Yes: if foo: bar(foo).. code-block:: python No: if foo: bar(foo) else: baz(foo) try: bar(foo) except ValueError: baz(foo) try: bar(foo) except ValueError: baz(foo)访问控制.. tip:: 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性. (译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化. 命名.. tip:: module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name. 应该避免的名称 #. 单字符名称, 除了计数器和迭代器. #. 包/模块名中的连字符(-) #. 双下划线开头并结尾的名称(Python保留, 例如__init__)命名约定 #. 所谓&quot;内部(Internal)&quot;表示仅模块内可用, 或者, 在类内是保护或私有的. #. 用单下划线(_)开头表示模块变量或函数是protected的(使用from module import \\*时不会包含). #. 用双下划线(__)开头的实例变量或方法表示类内私有. #. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. #. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Python之父Guido推荐的规范 =========================== ==================== ======================================================================Type Public Internal=========================== ==================== ======================================================================Modules lower_with_under _lower_with_underPackages lower_with_underClasses CapWords _CapWordsExceptions CapWordsFunctions lower_with_under() _lower_with_under()Global/Class Constants CAPS_WITH_UNDER _CAPS_WITH_UNDERGlobal/Class Variables lower_with_under _lower_with_underInstance Variables lower_with_under _lower_with_under (protected) or __lower_with_under (private)Method Names lower_with_under() _lower_with_under() (protected) or __lower_with_under() (private)Function/Method Parameters lower_with_underLocal Variables lower_with_under=========================== ==================== ====================================================================== .. _main: Main.. tip:: 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中. 在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 if __name__ == '__main__' , 这样当模块被导入时主程序就不会被执行. .. code-block:: python def main(): ... if __name__ == &apos;__main__&apos;: main()所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.","link":"/2019/09/28/python-style-rules/"},{"title":"os.py","text":"os.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078r\"\"\"OS routines for NT or Posix depending on what system we're on.This exports: - all functions from posix or nt, e.g. unlink, stat, etc. - os.path is either posixpath or ntpath - os.name is either 'posix' or 'nt' - os.curdir is a string representing the current directory (always '.') - os.pardir is a string representing the parent directory (always '..') - os.sep is the (or a most common) pathname separator ('/' or '\\\\') - os.extsep is the extension separator (always '.') - os.altsep is the alternate pathname separator (None or '/') - os.pathsep is the component separator used in $PATH etc - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n') - os.defpath is the default search path for executables - os.devnull is the file path of the null device ('/dev/null', etc.)Programs that import and use 'os' stand a better chance of beingportable between different platforms. Of course, they must thenonly use functions that are defined by all platforms (e.g., unlinkand opendir), and leave all pathname manipulation to os.path(e.g., split and join).\"\"\"#'import abcimport sysimport stat as st_names = sys.builtin_module_names# Note: more names are added to __all__ later.__all__ = [\"altsep\", \"curdir\", \"pardir\", \"sep\", \"pathsep\", \"linesep\", \"defpath\", \"name\", \"path\", \"devnull\", \"SEEK_SET\", \"SEEK_CUR\", \"SEEK_END\", \"fsencode\", \"fsdecode\", \"get_exec_path\", \"fdopen\", \"popen\", \"extsep\"]def _exists(name): return name in globals()def _get_exports_list(module): try: return list(module.__all__) except AttributeError: return [n for n in dir(module) if n[0] != '_']# Any new dependencies of the os module and/or changes in path separator# requires updating importlib as well.if 'posix' in _names: name = 'posix' linesep = '\\n' from posix import * try: from posix import _exit __all__.append('_exit') except ImportError: pass import posixpath as path try: from posix import _have_functions except ImportError: pass import posix __all__.extend(_get_exports_list(posix)) del posixelif 'nt' in _names: name = 'nt' linesep = '\\r\\n' from nt import * try: from nt import _exit __all__.append('_exit') except ImportError: pass import ntpath as path import nt __all__.extend(_get_exports_list(nt)) del nt try: from nt import _have_functions except ImportError: passelse: raise ImportError('no os specific module found')sys.modules['os.path'] = pathfrom os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull)del _namesif _exists(\"_have_functions\"): _globals = globals() def _add(str, fn): if (fn in _globals) and (str in _have_functions): _set.add(_globals[fn]) _set = set() _add(\"HAVE_FACCESSAT\", \"access\") _add(\"HAVE_FCHMODAT\", \"chmod\") _add(\"HAVE_FCHOWNAT\", \"chown\") _add(\"HAVE_FSTATAT\", \"stat\") _add(\"HAVE_FUTIMESAT\", \"utime\") _add(\"HAVE_LINKAT\", \"link\") _add(\"HAVE_MKDIRAT\", \"mkdir\") _add(\"HAVE_MKFIFOAT\", \"mkfifo\") _add(\"HAVE_MKNODAT\", \"mknod\") _add(\"HAVE_OPENAT\", \"open\") _add(\"HAVE_READLINKAT\", \"readlink\") _add(\"HAVE_RENAMEAT\", \"rename\") _add(\"HAVE_SYMLINKAT\", \"symlink\") _add(\"HAVE_UNLINKAT\", \"unlink\") _add(\"HAVE_UNLINKAT\", \"rmdir\") _add(\"HAVE_UTIMENSAT\", \"utime\") supports_dir_fd = _set _set = set() _add(\"HAVE_FACCESSAT\", \"access\") supports_effective_ids = _set _set = set() _add(\"HAVE_FCHDIR\", \"chdir\") _add(\"HAVE_FCHMOD\", \"chmod\") _add(\"HAVE_FCHOWN\", \"chown\") _add(\"HAVE_FDOPENDIR\", \"listdir\") _add(\"HAVE_FDOPENDIR\", \"scandir\") _add(\"HAVE_FEXECVE\", \"execve\") _set.add(stat) # fstat always works _add(\"HAVE_FTRUNCATE\", \"truncate\") _add(\"HAVE_FUTIMENS\", \"utime\") _add(\"HAVE_FUTIMES\", \"utime\") _add(\"HAVE_FPATHCONF\", \"pathconf\") if _exists(\"statvfs\") and _exists(\"fstatvfs\"): # mac os x10.3 _add(\"HAVE_FSTATVFS\", \"statvfs\") supports_fd = _set _set = set() _add(\"HAVE_FACCESSAT\", \"access\") # Some platforms don't support lchmod(). Often the function exists # anyway, as a stub that always returns ENOSUP or perhaps EOPNOTSUPP. # (No, I don't know why that's a good design.) ./configure will detect # this and reject it--so HAVE_LCHMOD still won't be defined on such # platforms. This is Very Helpful. # # However, sometimes platforms without a working lchmod() *do* have # fchmodat(). (Examples: Linux kernel 3.2 with glibc 2.15, # OpenIndiana 3.x.) And fchmodat() has a flag that theoretically makes # it behave like lchmod(). So in theory it would be a suitable # replacement for lchmod(). But when lchmod() doesn't work, fchmodat()'s # flag doesn't work *either*. Sadly ./configure isn't sophisticated # enough to detect this condition--it only determines whether or not # fchmodat() minimally works. # # Therefore we simply ignore fchmodat() when deciding whether or not # os.chmod supports follow_symlinks. Just checking lchmod() is # sufficient. After all--if you have a working fchmodat(), your # lchmod() almost certainly works too. # # _add(\"HAVE_FCHMODAT\", \"chmod\") _add(\"HAVE_FCHOWNAT\", \"chown\") _add(\"HAVE_FSTATAT\", \"stat\") _add(\"HAVE_LCHFLAGS\", \"chflags\") _add(\"HAVE_LCHMOD\", \"chmod\") if _exists(\"lchown\"): # mac os x10.3 _add(\"HAVE_LCHOWN\", \"chown\") _add(\"HAVE_LINKAT\", \"link\") _add(\"HAVE_LUTIMES\", \"utime\") _add(\"HAVE_LSTAT\", \"stat\") _add(\"HAVE_FSTATAT\", \"stat\") _add(\"HAVE_UTIMENSAT\", \"utime\") _add(\"MS_WINDOWS\", \"stat\") supports_follow_symlinks = _set del _set del _have_functions del _globals del _add# Python uses fixed values for the SEEK_ constants; they are mapped# to native constants if necessary in posixmodule.c# Other possible SEEK values are directly imported from posixmodule.cSEEK_SET = 0SEEK_CUR = 1SEEK_END = 2# Super directory utilities.# (Inspired by Eric Raymond; the doc strings are mostly his)def makedirs(name, mode=0o777, exist_ok=False): \"\"\"makedirs(name [, mode=0o777][, exist_ok=False]) Super-mkdir; create a leaf directory and all intermediate ones. Works like mkdir, except that any intermediate path segment (not just the rightmost) will be created if it does not exist. If the target directory already exists, raise an OSError if exist_ok is False. Otherwise no exception is raised. This is recursive. \"\"\" head, tail = path.split(name) if not tail: head, tail = path.split(head) if head and tail and not path.exists(head): try: makedirs(head, exist_ok=exist_ok) except FileExistsError: # Defeats race condition when another thread created the path pass cdir = curdir if isinstance(tail, bytes): cdir = bytes(curdir, 'ASCII') if tail == cdir: # xxx/newdir/. exists if xxx/newdir exists return try: mkdir(name, mode) except OSError: # Cannot rely on checking for EEXIST, since the operating system # could give priority to other errors like EACCES or EROFS if not exist_ok or not path.isdir(name): raisedef removedirs(name): \"\"\"removedirs(name) Super-rmdir; remove a leaf directory and all empty intermediate ones. Works like rmdir except that, if the leaf directory is successfully removed, directories corresponding to rightmost path segments will be pruned away until either the whole path is consumed or an error occurs. Errors during this latter phase are ignored -- they generally mean that a directory was not empty. \"\"\" rmdir(name) head, tail = path.split(name) if not tail: head, tail = path.split(head) while head and tail: try: rmdir(head) except OSError: break head, tail = path.split(head)def renames(old, new): \"\"\"renames(old, new) Super-rename; create directories as necessary and delete any left empty. Works like rename, except creation of any intermediate directories needed to make the new pathname good is attempted first. After the rename, directories corresponding to rightmost path segments of the old name will be pruned until either the whole path is consumed or a nonempty directory is found. Note: this function can fail with the new directory structure made if you lack permissions needed to unlink the leaf directory or file. \"\"\" head, tail = path.split(new) if head and tail and not path.exists(head): makedirs(head) rename(old, new) head, tail = path.split(old) if head and tail: try: removedirs(head) except OSError: pass__all__.extend([\"makedirs\", \"removedirs\", \"renames\"])def walk(top, topdown=True, onerror=None, followlinks=False): \"\"\"Directory tree generator. For each directory in the directory tree rooted at top (including top itself, but excluding '.' and '..'), yields a 3-tuple dirpath, dirnames, filenames dirpath is a string, the path to the directory. dirnames is a list of the names of the subdirectories in dirpath (excluding '.' and '..'). filenames is a list of the names of the non-directory files in dirpath. Note that the names in the lists are just names, with no path components. To get a full path (which begins with top) to a file or directory in dirpath, do os.path.join(dirpath, name). If optional arg 'topdown' is true or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top down). If topdown is false, the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom up). When topdown is true, the caller can modify the dirnames list in-place (e.g., via del or slice assignment), and walk will only recurse into the subdirectories whose names remain in dirnames; this can be used to prune the search, or to impose a specific order of visiting. Modifying dirnames when topdown is false is ineffective, since the directories in dirnames have already been generated by the time dirnames itself is generated. No matter the value of topdown, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated. By default errors from the os.scandir() call are ignored. If optional arg 'onerror' is specified, it should be a function; it will be called with one argument, an OSError instance. It can report the error to continue with the walk, or raise the exception to abort the walk. Note that the filename is available as the filename attribute of the exception object. By default, os.walk does not follow symbolic links to subdirectories on systems that support them. In order to get this functionality, set the optional argument 'followlinks' to true. Caution: if you pass a relative pathname for top, don't change the current working directory between resumptions of walk. walk never changes the current directory, and assumes that the client doesn't either. Example: import os from os.path import join, getsize for root, dirs, files in os.walk('python/Lib/email'): print(root, \"consumes\", end=\"\") print(sum([getsize(join(root, name)) for name in files]), end=\"\") print(\"bytes in\", len(files), \"non-directory files\") if 'CVS' in dirs: dirs.remove('CVS') # don't visit CVS directories \"\"\" top = fspath(top) dirs = [] nondirs = [] walk_dirs = [] # We may not have read permission for top, in which case we can't # get a list of the files the directory contains. os.walk # always suppressed the exception then, rather than blow up for a # minor reason when (say) a thousand readable directories are still # left to visit. That logic is copied here. try: # Note that scandir is global in this module due # to earlier import-*. scandir_it = scandir(top) except OSError as error: if onerror is not None: onerror(error) return with scandir_it: while True: try: try: entry = next(scandir_it) except StopIteration: break except OSError as error: if onerror is not None: onerror(error) return try: is_dir = entry.is_dir() except OSError: # If is_dir() raises an OSError, consider that the entry is not # a directory, same behaviour than os.path.isdir(). is_dir = False if is_dir: dirs.append(entry.name) else: nondirs.append(entry.name) if not topdown and is_dir: # Bottom-up: recurse into sub-directory, but exclude symlinks to # directories if followlinks is False if followlinks: walk_into = True else: try: is_symlink = entry.is_symlink() except OSError: # If is_symlink() raises an OSError, consider that the # entry is not a symbolic link, same behaviour than # os.path.islink(). is_symlink = False walk_into = not is_symlink if walk_into: walk_dirs.append(entry.path) # Yield before recursion if going top down if topdown: yield top, dirs, nondirs # Recurse into sub-directories islink, join = path.islink, path.join for dirname in dirs: new_path = join(top, dirname) # Issue #23605: os.path.islink() is used instead of caching # entry.is_symlink() result during the loop on os.scandir() because # the caller can replace the directory entry during the \"yield\" # above. if followlinks or not islink(new_path): yield from walk(new_path, topdown, onerror, followlinks) else: # Recurse into sub-directories for new_path in walk_dirs: yield from walk(new_path, topdown, onerror, followlinks) # Yield after recursion if going bottom up yield top, dirs, nondirs__all__.append(\"walk\")if {open, stat} &lt;= supports_dir_fd and {scandir, stat} &lt;= supports_fd: def fwalk(top=\".\", topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None): \"\"\"Directory tree generator. This behaves exactly like walk(), except that it yields a 4-tuple dirpath, dirnames, filenames, dirfd `dirpath`, `dirnames` and `filenames` are identical to walk() output, and `dirfd` is a file descriptor referring to the directory `dirpath`. The advantage of fwalk() over walk() is that it's safe against symlink races (when follow_symlinks is False). If dir_fd is not None, it should be a file descriptor open to a directory, and top should be relative; top will then be relative to that directory. (dir_fd is always supported for fwalk.) Caution: Since fwalk() yields file descriptors, those are only valid until the next iteration step, so you should dup() them if you want to keep them for a longer period. Example: import os for root, dirs, files, rootfd in os.fwalk('python/Lib/email'): print(root, \"consumes\", end=\"\") print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]), end=\"\") print(\"bytes in\", len(files), \"non-directory files\") if 'CVS' in dirs: dirs.remove('CVS') # don't visit CVS directories \"\"\" if not isinstance(top, int) or not hasattr(top, '__index__'): top = fspath(top) # Note: To guard against symlink races, we use the standard # lstat()/open()/fstat() trick. if not follow_symlinks: orig_st = stat(top, follow_symlinks=False, dir_fd=dir_fd) topfd = open(top, O_RDONLY, dir_fd=dir_fd) try: if (follow_symlinks or (st.S_ISDIR(orig_st.st_mode) and path.samestat(orig_st, stat(topfd)))): yield from _fwalk(topfd, top, isinstance(top, bytes), topdown, onerror, follow_symlinks) finally: close(topfd) def _fwalk(topfd, toppath, isbytes, topdown, onerror, follow_symlinks): # Note: This uses O(depth of the directory tree) file descriptors: if # necessary, it can be adapted to only require O(1) FDs, see issue # #13734. scandir_it = scandir(topfd) dirs = [] nondirs = [] entries = None if topdown or follow_symlinks else [] for entry in scandir_it: name = entry.name if isbytes: name = fsencode(name) try: if entry.is_dir(): dirs.append(name) if entries is not None: entries.append(entry) else: nondirs.append(name) except OSError: try: # Add dangling symlinks, ignore disappeared files if entry.is_symlink(): nondirs.append(name) except OSError: pass if topdown: yield toppath, dirs, nondirs, topfd for name in dirs if entries is None else zip(dirs, entries): try: if not follow_symlinks: if topdown: orig_st = stat(name, dir_fd=topfd, follow_symlinks=False) else: assert entries is not None name, entry = name orig_st = entry.stat(follow_symlinks=False) dirfd = open(name, O_RDONLY, dir_fd=topfd) except OSError as err: if onerror is not None: onerror(err) continue try: if follow_symlinks or path.samestat(orig_st, stat(dirfd)): dirpath = path.join(toppath, name) yield from _fwalk(dirfd, dirpath, isbytes, topdown, onerror, follow_symlinks) finally: close(dirfd) if not topdown: yield toppath, dirs, nondirs, topfd __all__.append(\"fwalk\")# Make sure os.environ exists, at leasttry: environexcept NameError: environ = {}def execl(file, *args): \"\"\"execl(file, *args) Execute the executable file with argument list args, replacing the current process. \"\"\" execv(file, args)def execle(file, *args): \"\"\"execle(file, *args, env) Execute the executable file with argument list args and environment env, replacing the current process. \"\"\" env = args[-1] execve(file, args[:-1], env)def execlp(file, *args): \"\"\"execlp(file, *args) Execute the executable file (which is searched for along $PATH) with argument list args, replacing the current process. \"\"\" execvp(file, args)def execlpe(file, *args): \"\"\"execlpe(file, *args, env) Execute the executable file (which is searched for along $PATH) with argument list args and environment env, replacing the current process. \"\"\" env = args[-1] execvpe(file, args[:-1], env)def execvp(file, args): \"\"\"execvp(file, args) Execute the executable file (which is searched for along $PATH) with argument list args, replacing the current process. args may be a list or tuple of strings. \"\"\" _execvpe(file, args)def execvpe(file, args, env): \"\"\"execvpe(file, args, env) Execute the executable file (which is searched for along $PATH) with argument list args and environment env , replacing the current process. args may be a list or tuple of strings. \"\"\" _execvpe(file, args, env)__all__.extend([\"execl\",\"execle\",\"execlp\",\"execlpe\",\"execvp\",\"execvpe\"])def _execvpe(file, args, env=None): if env is not None: exec_func = execve argrest = (args, env) else: exec_func = execv argrest = (args,) env = environ if path.dirname(file): exec_func(file, *argrest) return saved_exc = None path_list = get_exec_path(env) if name != 'nt': file = fsencode(file) path_list = map(fsencode, path_list) for dir in path_list: fullname = path.join(dir, file) try: exec_func(fullname, *argrest) except (FileNotFoundError, NotADirectoryError) as e: last_exc = e except OSError as e: last_exc = e if saved_exc is None: saved_exc = e if saved_exc is not None: raise saved_exc raise last_excdef get_exec_path(env=None): \"\"\"Returns the sequence of directories that will be searched for the named executable (similar to a shell) when launching a process. *env* must be an environment variable dict or None. If *env* is None, os.environ will be used. \"\"\" # Use a local import instead of a global import to limit the number of # modules loaded at startup: the os module is always loaded at startup by # Python. It may also avoid a bootstrap issue. import warnings if env is None: env = environ # {b'PATH': ...}.get('PATH') and {'PATH': ...}.get(b'PATH') emit a # BytesWarning when using python -b or python -bb: ignore the warning with warnings.catch_warnings(): warnings.simplefilter(\"ignore\", BytesWarning) try: path_list = env.get('PATH') except TypeError: path_list = None if supports_bytes_environ: try: path_listb = env[b'PATH'] except (KeyError, TypeError): pass else: if path_list is not None: raise ValueError( \"env cannot contain 'PATH' and b'PATH' keys\") path_list = path_listb if path_list is not None and isinstance(path_list, bytes): path_list = fsdecode(path_list) if path_list is None: path_list = defpath return path_list.split(pathsep)# Change environ to automatically call putenv(), unsetenv if they exist.from _collections_abc import MutableMappingclass _Environ(MutableMapping): def __init__(self, data, encodekey, decodekey, encodevalue, decodevalue, putenv, unsetenv): self.encodekey = encodekey self.decodekey = decodekey self.encodevalue = encodevalue self.decodevalue = decodevalue self.putenv = putenv self.unsetenv = unsetenv self._data = data def __getitem__(self, key): try: value = self._data[self.encodekey(key)] except KeyError: # raise KeyError with the original key value raise KeyError(key) from None return self.decodevalue(value) def __setitem__(self, key, value): key = self.encodekey(key) value = self.encodevalue(value) self.putenv(key, value) self._data[key] = value def __delitem__(self, key): encodedkey = self.encodekey(key) self.unsetenv(encodedkey) try: del self._data[encodedkey] except KeyError: # raise KeyError with the original key value raise KeyError(key) from None def __iter__(self): # list() from dict object is an atomic operation keys = list(self._data) for key in keys: yield self.decodekey(key) def __len__(self): return len(self._data) def __repr__(self): return 'environ({{{}}})'.format(', '.join( ('{!r}: {!r}'.format(self.decodekey(key), self.decodevalue(value)) for key, value in self._data.items()))) def copy(self): return dict(self) def setdefault(self, key, value): if key not in self: self[key] = value return self[key]try: _putenv = putenvexcept NameError: _putenv = lambda key, value: Noneelse: if \"putenv\" not in __all__: __all__.append(\"putenv\")try: _unsetenv = unsetenvexcept NameError: _unsetenv = lambda key: _putenv(key, \"\")else: if \"unsetenv\" not in __all__: __all__.append(\"unsetenv\")def _createenviron(): if name == 'nt': # Where Env Var Names Must Be UPPERCASE def check_str(value): if not isinstance(value, str): raise TypeError(\"str expected, not %s\" % type(value).__name__) return value encode = check_str decode = str def encodekey(key): return encode(key).upper() data = {} for key, value in environ.items(): data[encodekey(key)] = value else: # Where Env Var Names Can Be Mixed Case encoding = sys.getfilesystemencoding() def encode(value): if not isinstance(value, str): raise TypeError(\"str expected, not %s\" % type(value).__name__) return value.encode(encoding, 'surrogateescape') def decode(value): return value.decode(encoding, 'surrogateescape') encodekey = encode data = environ return _Environ(data, encodekey, decode, encode, decode, _putenv, _unsetenv)# unicode environenviron = _createenviron()del _createenvirondef getenv(key, default=None): \"\"\"Get an environment variable, return None if it doesn't exist. The optional second argument can specify an alternate default. key, default and the result are str.\"\"\" return environ.get(key, default)supports_bytes_environ = (name != 'nt')__all__.extend((\"getenv\", \"supports_bytes_environ\"))if supports_bytes_environ: def _check_bytes(value): if not isinstance(value, bytes): raise TypeError(\"bytes expected, not %s\" % type(value).__name__) return value # bytes environ environb = _Environ(environ._data, _check_bytes, bytes, _check_bytes, bytes, _putenv, _unsetenv) del _check_bytes def getenvb(key, default=None): \"\"\"Get an environment variable, return None if it doesn't exist. The optional second argument can specify an alternate default. key, default and the result are bytes.\"\"\" return environb.get(key, default) __all__.extend((\"environb\", \"getenvb\"))def _fscodec(): encoding = sys.getfilesystemencoding() errors = sys.getfilesystemencodeerrors() def fsencode(filename): \"\"\"Encode filename (an os.PathLike, bytes, or str) to the filesystem encoding with 'surrogateescape' error handler, return bytes unchanged. On Windows, use 'strict' error handler if the file system encoding is 'mbcs' (which is the default encoding). \"\"\" filename = fspath(filename) # Does type-checking of `filename`. if isinstance(filename, str): return filename.encode(encoding, errors) else: return filename def fsdecode(filename): \"\"\"Decode filename (an os.PathLike, bytes, or str) from the filesystem encoding with 'surrogateescape' error handler, return str unchanged. On Windows, use 'strict' error handler if the file system encoding is 'mbcs' (which is the default encoding). \"\"\" filename = fspath(filename) # Does type-checking of `filename`. if isinstance(filename, bytes): return filename.decode(encoding, errors) else: return filename return fsencode, fsdecodefsencode, fsdecode = _fscodec()del _fscodec# Supply spawn*() (probably only for Unix)if _exists(\"fork\") and not _exists(\"spawnv\") and _exists(\"execv\"): P_WAIT = 0 P_NOWAIT = P_NOWAITO = 1 __all__.extend([\"P_WAIT\", \"P_NOWAIT\", \"P_NOWAITO\"]) # XXX Should we support P_DETACH? I suppose it could fork()**2 # and close the std I/O streams. Also, P_OVERLAY is the same # as execv*()? def _spawnvef(mode, file, args, env, func): # Internal helper; func is the exec*() function to use if not isinstance(args, (tuple, list)): raise TypeError('argv must be a tuple or a list') if not args or not args[0]: raise ValueError('argv first element cannot be empty') pid = fork() if not pid: # Child try: if env is None: func(file, args) else: func(file, args, env) except: _exit(127) else: # Parent if mode == P_NOWAIT: return pid # Caller is responsible for waiting! while 1: wpid, sts = waitpid(pid, 0) if WIFSTOPPED(sts): continue elif WIFSIGNALED(sts): return -WTERMSIG(sts) elif WIFEXITED(sts): return WEXITSTATUS(sts) else: raise OSError(\"Not stopped, signaled or exited???\") def spawnv(mode, file, args): \"\"\"spawnv(mode, file, args) -&gt; integerExecute file with arguments from args in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return _spawnvef(mode, file, args, None, execv) def spawnve(mode, file, args, env): \"\"\"spawnve(mode, file, args, env) -&gt; integerExecute file with arguments from args in a subprocess with thespecified environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return _spawnvef(mode, file, args, env, execve) # Note: spawnvp[e] isn't currently supported on Windows def spawnvp(mode, file, args): \"\"\"spawnvp(mode, file, args) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return _spawnvef(mode, file, args, None, execvp) def spawnvpe(mode, file, args, env): \"\"\"spawnvpe(mode, file, args, env) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return _spawnvef(mode, file, args, env, execvpe) __all__.extend([\"spawnv\", \"spawnve\", \"spawnvp\", \"spawnvpe\"])if _exists(\"spawnv\"): # These aren't supplied by the basic Windows code # but can be easily implemented in Python def spawnl(mode, file, *args): \"\"\"spawnl(mode, file, *args) -&gt; integerExecute file with arguments from args in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return spawnv(mode, file, args) def spawnle(mode, file, *args): \"\"\"spawnle(mode, file, *args, env) -&gt; integerExecute file with arguments from args in a subprocess with thesupplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" env = args[-1] return spawnve(mode, file, args[:-1], env) __all__.extend([\"spawnl\", \"spawnle\"])if _exists(\"spawnvp\"): # At the moment, Windows doesn't implement spawnvp[e], # so it won't have spawnlp[e] either. def spawnlp(mode, file, *args): \"\"\"spawnlp(mode, file, *args) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return spawnvp(mode, file, args) def spawnlpe(mode, file, *args): \"\"\"spawnlpe(mode, file, *args, env) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the process's exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it. \"\"\" env = args[-1] return spawnvpe(mode, file, args[:-1], env) __all__.extend([\"spawnlp\", \"spawnlpe\"])# Supply os.popen()def popen(cmd, mode=\"r\", buffering=-1): if not isinstance(cmd, str): raise TypeError(\"invalid cmd type (%s, expected string)\" % type(cmd)) if mode not in (\"r\", \"w\"): raise ValueError(\"invalid mode %r\" % mode) if buffering == 0 or buffering is None: raise ValueError(\"popen() does not support unbuffered streams\") import subprocess, io if mode == \"r\": proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, bufsize=buffering) return _wrap_close(io.TextIOWrapper(proc.stdout), proc) else: proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, bufsize=buffering) return _wrap_close(io.TextIOWrapper(proc.stdin), proc)# Helper for popen() -- a proxy for a file whose close waits for the processclass _wrap_close: def __init__(self, stream, proc): self._stream = stream self._proc = proc def close(self): self._stream.close() returncode = self._proc.wait() if returncode == 0: return None if name == 'nt': return returncode else: return returncode &lt;&lt; 8 # Shift left to match old behavior def __enter__(self): return self def __exit__(self, *args): self.close() def __getattr__(self, name): return getattr(self._stream, name) def __iter__(self): return iter(self._stream)# Supply os.fdopen()def fdopen(fd, *args, **kwargs): if not isinstance(fd, int): raise TypeError(\"invalid fd type (%s, expected integer)\" % type(fd)) import io return io.open(fd, *args, **kwargs)# For testing purposes, make sure the function is available when the C# implementation exists.def _fspath(path): \"\"\"Return the path representation of a path-like object. If str or bytes is passed in, it is returned unchanged. Otherwise the os.PathLike interface is used to get the path representation. If the path representation is not str or bytes, TypeError is raised. If the provided path is not str, bytes, or os.PathLike, TypeError is raised. \"\"\" if isinstance(path, (str, bytes)): return path # Work from the object's type to match method resolution of other magic # methods. path_type = type(path) try: path_repr = path_type.__fspath__(path) except AttributeError: if hasattr(path_type, '__fspath__'): raise else: raise TypeError(\"expected str, bytes or os.PathLike object, \" \"not \" + path_type.__name__) if isinstance(path_repr, (str, bytes)): return path_repr else: raise TypeError(\"expected {}.__fspath__() to return str or bytes, \" \"not {}\".format(path_type.__name__, type(path_repr).__name__))# If there is no C implementation, make the pure Python version the# implementation as transparently as possible.if not _exists('fspath'): fspath = _fspath fspath.__name__ = \"fspath\"class PathLike(abc.ABC): \"\"\"Abstract base class for implementing the file system path protocol.\"\"\" @abc.abstractmethod def __fspath__(self): \"\"\"Return the file system path representation of the object.\"\"\" raise NotImplementedError @classmethod def __subclasshook__(cls, subclass): return hasattr(subclass, '__fspath__')","link":"/2019/09/27/os-py/"},{"title":"paper-e-database","text":"写论文不用愁，50个全球免费电子数据库了解下（纯文字版） 最近人民日报小编很给力，整理了50个找文献资料的中外全球电子数据库，无论你是写毕业论文还是学术论文，总有一款适合你，快先收藏起来，查尔斯沃思小编将其整理成纯文字，方便作者检索，码字不易，多行点赞鼓励下吧！ 中文数据库 国家哲学社会科学文献中心(上线文献数据超过1000万条）http://www.ncpssd.org 中西文科技文献服务平台http://lib.sstir.cn/ 中国科技论文在线精品论文(自然科学领域的论文成果）http://highlights.paper.edu.cn/ 中国国家图书馆馆藏中文图书数字化资源库（提供17万多种各学科的图书，可在线阅读）http://mylib.nlc.cn/web/guest/zhongwentushu 汉斯出版社中文学术期刊(提供125本国际开源中文期刊的免费下载阅读）http://www.hanspub.org 全国图书馆参考咨询联盟(绝大多数文献需要用邮箱传递）http://www.ucdrs.superlib.net/ 国家科技图书文献中心(现有期刊资源6908本，会议资源1506个）http://www.nstl.gov.cn/ 国家哲学社会科学学术期刊数据库(国内最大的公益性社科精品期刊数据库，收录精品学术期刊600多种，论文近300万篇）http://www.nssd.org/articles/articlesearch.aspx 中国科学院文献情报中心(国家科学图书馆）http://www.las.ac.cn/ CALIS 高校学位论文库(免费文摘）http://opac.calis.edu.cn 中国国家数据(中国国家统计局提供的海量数据查询和下载的数据库，内容包含各个地区和国家的数据）http://data.stats.gov.cn/index.htm 中国国家图书馆(中国国家图书馆数字平台）http://www.nlc.gov.cn/ 外文数据库 ERIC 教育资源信息中心(教育资源数据库，部分资源可查找到全文）http://www.eric.ed.gov/ Blackwell电子期刊(国际性期刊800余种，涵盖十多个学科，部分期刊提供全文）http://www.blackwell-synergy.com/ 加拿大 AMICUS 学位论文(收录加拿大1300多个图书馆的学位论文信息）http://www.collectionscanada.gc.ca/theses-canada/index-e.html 欧洲学位论文库(收录来自欧洲28个国家的563所大学的开放学术资源）http://www.dart-europe.eu/basic-search.php Project Gutenberg(提供超过5万本免费电子书籍）http://www.gutenberg.org/ 澳洲数字论文计划(包含澳洲40余所大学的15440篇硕博论文，涵盖各个学科）http://adt.caul.edu.au 北卡罗来纳州州立大学(3937篇免费博硕论文，涵盖化学、物理学、电子电气、核能、机械、材料、食品、林业、土壤等学科）https://repository.lib.ncsu.edu/handle/1840.20/23 加州大学学者文库(图书资源分对校内和校外两部分开放，著作新，制作质量高。普通读物、学术读物均有收录）http://publishing.cdlib.org/ucpressebooks/ Directory of Open Access Journals(免费的全文科技学术期刊。现有2752种期刊，其中830种可以全文搜索。）http://www.doaj.org/ Upcoming Conference(国内外学术会议论文）http://www.ourglocal.com/ 俄亥俄州立大学电子学位论文(索引更新及时，可在线翻译成中文。涵盖机械、电子、管理、哲学、化学、环境学、材料、数学、物理等学科）http://www.ohiolink.edu/etd/search.cgi 美国密西根大学论文库(2万多篇期刊论文、技术报告、评论等文献全文）https://deepblue.lib.umich.edu/ 开放存取资源图书馆(提供400多万篇免费使用下载的英文期刊论文，涵盖所有学科〉http://www.oalib.com Bioline International(提供发展中国家出版的高质量期刊）http://www.bioline.org.br 诺丁汉大学论文库(提供诺丁汉大学博士、硕士的研究、会议论文）http://eprints.nottingham.ac.uk/ HINARI(世界卫生组织建立，提供生物医学与卫生文献的项目，包括3280种期刊）http://www.who.int/hinari/en/ HighWire 出版社电子期刊(美国斯坦福大学著名的学术出版商，其中将近240万篇文章可免费获得全文）http://highwire.stanford.edu/lists/freeart.dtl 美国科学院院报(世界上被引用次数最多的综合学科刊物之一，继Nature、Science之后，在SCI综合学科类排名第三位）http://www.pnas.org/ 科研出版社 OA 资源(共有180多种期刊的电子版本，文章超过10000篇）http://www.scirp.org/journal/ Science Direct(SCI论文检索，收录超过25万篇论文）https://www.sciencedirect.com/ 33 .华盛顿大学学位论文库(提供免费的电子书籍、论文、期刊，全文免费下载）https://library.wustl.edu/ 加拿大国家研究委员会（ NRC) 0A 期刊(农业科学、生物信息学、生命科学、环境、纳米技术、分子科学、光电子科学等领域的学术性期刊）http://www.nrcresearchpress.com/ Socolar(整理了世界上重要的0A期刊10000多种和1000多种0A仓贮资源）http://www.socolar.com/ 加利福尼亚大学国际和区域数字馆藏(已出版的期刊论文、未出版的研究手稿、会议文献以及其他出版物上的文章1万多篇，均可免费阅读）http://repositories.cdlib.org/escholarship/ 剑桥大学机构知识库(提供剑桥大学相关的期刊、学术论文、学位论文等电子资源）http://www.dspace.cam.ac.uk/ Electronic library(提供超过270万本图书，超过5千万篇论文）http://b-ok.org/ 39.Science 数据库(权威科研杂志《Science》官方网站，免费注册后可下载1997年以前的论文全文）http://www.sciencemag.org/ CERN Document Server(主要覆盖物理学及相关学科，提供36万多篇全文文献）http://cdsweb.cern.ch/ 康奈尔大学ArXiv(面向物理学、数学、非线性科学、计算机科学和定量生物学等学科，提供16种免费电子期刊的访问）http://arxiv.org Energy Citations Database(提供美国能源部的科技信息摘要）http://www.osti.gov/energycitations/ 约翰威立国际出版公司(收录了来自1500余种期刊、10000多本在线图书以及数百种多卷册的参考工具书、丛书系列、手册和辞典、实验室指南和数据库的400多万篇文章）http://onlinelibrary.wiley.com/ 伍斯特工学院数据库(670余篇学位论文 ，其 中有550多篇全文。涵盖生物、电子、计算机、材料、物理、机械等学科）http://www.wpi.edu/Pubs/ETD/ nature官网网站(在《 nature 》上在线发表的论文可以免费查看）https://www.nature.com/ Social Science Research Network(社会科学（经济类）研究论文数据库，部分提供全文）http://www.ssrn.com/ 美国医学学术资料网站(由美国国家医学图书馆和国立卫生研究院建立一个医学学术资料网站。生物医学文献超过2100万，包括论文参考文献，生命科学期刊，在线图书）https://www.ncbi.nlm.nih.gov/pubmed 世界数字图书馆(以多语种形式免费提供源于世界各地各文化的重要原始材料）http://www.wdl.org/zh/ Manybooks(国外大量免费电子图书，可下载）http://manybooks.net/ Aminer(收集了300万篇论文信息、3700多万引用关系以及8000多个会议信息）https://cn.aminer.org/ 以上内容来源人民日报，查尔斯沃思作者服务将图片转换文字，转载需注明原作者及整理者。","link":"/2019/10/25/paper-e-database/"},{"title":"search_engine","text":"全球十大搜索引擎 百度属于搜索引擎的其中之一，这个大家想必都知道。尤其对于做网络和媒体的人来说，你必须知道如何与搜索引擎打交道。但是你知道除了百度，世界上还有哪些好用的搜索引擎吗？ NO.1 Google（谷歌） ：18亿www.google.com 全球第一搜索引擎，不解释。 NO.2 Bing（必应） ：5亿www.bing.com Bing是微软旗下的搜索引擎，感觉它的搜索界面背景图非常美，是谷歌最好的替代品，备胎中的战斗机。 NO.3 Yahoo!（雅虎） ：4.9亿www.search.yahoo.com 在搜索方面，雅虎表现中规中矩，网页搜索表现不错，但死链率较高而且缺少一些应有的高级搜索功能。 NO.4 Baidu（百度）：4.8亿www.baidu.com 全球最大的中文搜索引擎，不解释。 NO.5 Ask ：3亿www.ask.com Ask搜索引擎是国外比较出名的一款搜索引擎，其规模虽不大，但很有特色。Ask是DirectHit的母公司，于2001年收购Teoma搜索引擎，并全部采用Teoma搜索结果。是支持自然提问的搜索引擎，其数据库里储存了超过1000万个问题的答案，只要用户用英文直接输入一个问题，它就会给出问题答案，如果用户的问题答案不在其数据库中，那么它会列出一串跟用户的问题类似的问题和含有答案的链接，供用户选择。 NO.6 Aol ：2亿www.search.aol.com Aol Search是美国在线旗下搜索引擎网站。Aol Search为用户提供快速、方便地访问相关视频、图片、本地地图、新闻、股市行情和更全面的网页搜索结果。Aol Search的搜索技术服务是由谷歌提供的。 NO.7 DuckDuckGo ：1.5亿www.duckduckgo.com DuckDuckGo是一个很特殊的网络搜索引擎，他和Google、Bing 这些不一样，他不会追踪、搜寻用户的信息，这对用户来说可以安个心了。 NO.8 WolframAlpha ：0.35亿www.wolframalpha.com 与其他搜索引擎不同，WolframAlpha其实是一个计算知识引擎，它真正的创新之处在于能够马上理解问题，并给出答案。它可以进行各种算术，还有数据分析，物理，艺术等等各个行业的查询。 比如你查询一个城市，它会出来和这个城市相关数据，它在地图上显示位置，人口，机场，著名的公司，它就像一个只能的机器人，你想知道有关一个东西的所有信息，它都能告诉你。 NO.9 Яндексwww.yandex.com Yandex搜索引擎是俄罗斯第一大搜索引擎，创建于1997年，目前已经发展成为一个提供搜索、图片共享、社交网络、网络支付、免费网站托管、以及其它服务的门户网站。因为份额太小，我们就不放数字了。 NO.10 webcrawlerwww.webcrawler.com WebCrawler是一个融合来自谷歌搜索和雅虎搜索等世界著名的搜索结果的元搜索引擎。WebCrawler为用户提供搜索图片、音频、视频、新闻、黄页和白页的选项卡。 传送门","link":"/2019/10/05/search-engine/"},{"title":"tabnine","text":"TabNineThis is the repository for the backend of TabNine, the all-language autocompleter.There are no source files here because the backend is closed source. You can make feature requests by filing an issue. You are also welcome to make pull requests for changes to the configuration files. languages.yml determines which file extensions are considered part of the same language. (For example, identifiers from .c files will be suggested in .h files.) language_tokenization.json determines how languages are tokenized. For example, identifiers can contain dashes in Lisp, but not in Java. If your feature request is specific to a particular editor’s TabNine client, please file an issue in one of these repositories: VS Code Sublime Text Vim Atom You may be interested in these TabNine clients written by third parties: Emacs Vim (Deoplete) ChangelogsIf new features don’t work for you, check that you have the most recent version by typing TabNine::version into your text editor. If you don’t have the most recent version, try restarting your editor. 2.0.11 (August 24, 2019) TabNine Local is now enabled by default 2.0.0 — 2.0.10 (July 15 — August 20, 2019) Deep TabNine Can download and run TabNine Local models Can connect to TabNine Cloud Simplified bracket pairing logic Simplified filesystem event handling Added a configuration panel for viewing settings and logs which can be accessed by typing TabNine::config 1.0.14 (May 16, 2019) TabNine no longer watches for filesystem events in ignored directories (closes #43). TabNine now waits until a completion is requested to start the language server (closes #50). Files with the .d extension are now recognized as D source files (closes #56). Added LSP default configuration for PureScript. Fixed a logic error that caused index size to be tracked incorrectly in some cases. 1.0.10 (December 1, 2018) Fixed an internal logic error which could put indexing threads into a bad state, leading to an infinite loop (might close #24, we’ll see). TabNine now considers a wider range of possibilities when completing in a zero-char context (i.e. when there are no characters immediately before the cursor). TabNine now includes - in identifiers when parsing Racket code. 1.0.9 (November 27, 2018) TabNine now uses the context after the cursor to filter its suggestions. For example, if there are tokens on the same line as the cursor, TabNine will not make a suggestion ending in a semicolon (unless there are already instances in the codebase of semicolons occurring in the middle of a line). TabNine removes tokens matching the regex \\d.*[a-zA-Z].*\\d.*[a-zA-Z] from the project index. This is supposed to prevent long keys or base64 literals from occurring in autocompletion suggestions. The tokens are not filtered from the directory index or the file index. TabNine now recognizes .tsx files as TypeScript rather than .xml (closes #21). TabNine only checks its version directory, not its target directory, when auto-updating or writing registration keys. (This fixes an issue associated with DOS path shortening.) 1.0.7 (November 20, 2018) Semantic completion is added! This allows TabNine to integrate with any language server that implements the Language Server Protocol. TabNine will integrate the language server’s suggestions with its own. For example, TabNine can suggest multi-token completions where the first token is provided by the language server. TabNine queries the language server asynchronously. So, if the language server is slow, you will see TabNine’s results only. Continue typing to see the language server’s results. TabNine passes along any type information or documentation provided by the language server. (The Sublime and VS Code clients are not yet updated to display the documentation; this is coming soon.) See the semantic completion guide for configuration help. Paid index size limit increased to 100 MB (from 15 MB). Free index size limit increased to 400 KB (from 200 KB). Improved indexing performance. Increased license price to $49/$99 personal/business (from $29/$89). TabNine now provides closing brackets for its suggestions (so if it suggests foo( it will additionally insert ) to the right of the cursor once the suggestion is accepted). The editor clients do not support this yet as it requires an upgrade to the communication protocol with TabNine; this is coming soon. Closes #11 as this is no longer an issue with the TabNine backend. TabNine now searches all parents to find the project root rather than stopping at the first .git. This permits nested Git repositories (closes #5). TabNine provides an API call to get the regex it uses to find identifiers (closes #7). TabNine no longer indexes files in .git (closes #8). TabNine now respects .tabnineignore files (closes #15). TabNine allows disabling auto-update by typing TabNine::disable_auto_update into your text editor (closes #14). TabNine no longer stores registration keys and config in same directory where it is installed. This should prevent registration keys and config from being overwritten by client updates (closes #10). You can type TabNine::config_dir to see where config files are being stored.","link":"/2019/10/30/tabnine/"},{"title":"rsa-info","text":"RSA算法详解 前言总括： 本文详细讲述了RSA算法详解，包括内部使用数学原理以及产生的过程。 原文博客地址：RSA算法详解 知乎专栏&amp;&amp;简书专题：前端进击者（知乎）&amp;&amp;前端进击者（简书） 博主博客地址：Damonare的个人博客 相濡以沫。到底需要爱淡如水。 正文之前写过一篇文章SSL协议之数据加密过程，里面详细讲述了数据加密的过程以及需要的算法。SSL协议很巧妙的利用对称加密和非对称加密两种算法来对数据进行加密。这篇文章主要是针对一种最常见的非对称加密算法——RSA算法进行讲解。其实也就是对私钥和公钥产生的一种方式进行描述。首先先来了解下这个算法的历史： RSA算法的历史RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 但实际上，在1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个相同的算法，但他的发现被列入机密，一直到1997年才被发表。 所以谁是RSA算法的发明人呢？不好说，就好像贝尔并不是第一个发明电话的人但大家都记住的是贝尔一样，这个地方我们作为旁观者倒不用较真，重要的是这个算法的内容： RSA算法的过程RSA算法用到的数学知识特别多，所以在中间介绍这个算法生成私钥和公钥的过程中会穿插一些数学知识。生成步骤如下： 寻找两个不相同的质数随意选择两个大的质数p和q，p不等于q，计算N=p*q; 什么是质数?我想可能会有一部分人已经忘记了，定义如下： 除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1该数本身两个正因数]的数）。 比如2，3，5，7这些都是质数，9就不是了，因为3*3=9了 根据欧拉函数获取rr = φ(N) = φ(p)φ(q) = (p-1)(q-1)。 这里的数学概念就是什么是欧拉函数了，什么是欧拉函数呢？ 欧拉函数的定义： 欧拉函数 φ(n)是小于或等于n的正整数中与n互质的数的数目。 互质的定义： 如果两个或两个以上的整数的最大公约数是 1，则称它们为互质 例如：φ(8) = 4，因为1,3,5,7均和8互质。 推导欧拉函数: （1）如果n = 1, φ(1) = 1；(小于等于1的正整数中唯一和1互质的数就是1本身)； （2）如果n为质数，φ(n) = n - 1；因为质数和每一个比它小的数字都互质。比如5，比它小的正整数1,2,3,4都和他互质； (3) 如果n是a的k次幂，则 φ(n) = φ(a^k) = a^k - a^(k-1) = (a-1)a^(k-1)； (4) 若m,n互质，则φ(mn) = φ(m)φ(n) 证明：设A, B, C是跟m, n, mn互质的数的集，据中国剩余定理(经常看数学典故的童鞋应该了解，剩余定理又叫韩信点兵，也叫孙子定理)，A*B和C可建立双射一一对应)的关系。（或者也可以从初等代数角度给出欧拉函数积性的简单证明） 因此的φ(n)值使用算术基本定理便知。（来自维基百科） 选择一个小于r并与r互质的整数e选择一个小于r并与r互质的整数e，求得e关于r的模反元素，命名为d（ed = 1(mod r)模反元素存在，当且仅当e与r互质），e我们通常取65537。 模反元素： 如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。 比如3和5互质，3关于5的模反元素就可能是2，因为32-1=5可以被5整除。所以很明显模反元素不止一个，2加减5的整数倍都是3关于5的模反元素{…-3, 2,7,12…}* 放在公式里就是3*2 = 1 (mod 5) 上面所提到的欧拉函数用处实际上在于欧拉定理： 欧拉定理： 如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立： a^φ(n) = 1(mod n) 由此可得：a的φ(n - 1)次方肯定是a关于n的模反元素。 欧拉定理就可以用来证明模反元素必然存在。 由模反元素的定义和欧拉定理我们知道，a的φ(n)次方减去1，可以被n整除。比如，3和5互质，而5的欧拉函数φ(5)等于4，所以3的4次方(81)减去1，可以被5整除（80/5=16）。 小费马定理： 假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成 a^(p-1) = 1 (mod p) 这其实是欧拉定理的一个特例。 销毁p和q此时我们的(N , e)是公钥，(N, d)为私钥，爱丽丝会把公钥(N, e)传给鲍勃，然后将(N, d)自己藏起来。一对公钥和私钥就产生了，然后具体的使用方法呢？请看：SSL协议之数据加密过程详解 RSA算法的安全性我们知道像RSA这种非对称加密算法很安全，那么到底为啥子安全呢？ 我们来看看上面这几个过程产生的几个数字： p,q：我们随机挑选的两个大质数；N：是由两个大质数p和q相乘得到的。N = p * q；r：由欧拉函数得到的N的值，r = φ(N) = φ(p)φ(q) = (p-1)(q-1)。e：随机选择和和r互质的数字，实际中通常选择65537；d： d是以欧拉定理为基础求得的e关于r的模反元素，ed = 1 (mod r)；N和e我们都会公开使用，最为重要的就是私钥中的d，d一旦泄露，加密也就失去了意义。那么得到d的过程是如何的呢？如下: 比如知道e和r，因为d是e关于r的模反元素；r是φ(N) 的值而φ(N)=(p-1)(q-1)，所以知道p和q我们就能得到d;N = pq，从公开的数据中我们只知道N和e，所以问题的关键就是对N做因式分解能不能得出p和q所以得出了在上篇博客说到的结论，非对称加密的原理： 将a和b相乘得出乘积c很容易，但要是想要通过乘积c推导出a和b极难。即对一个大数进行因式分解极难 目前公开破译的位数是768位，实际使用一般是1024位或是2048位，所以理论上特别的安全。 后记RSA算法的核心就是欧拉定理，根据它我们才能得到私钥，从而保证整个通信的安全。","link":"/2019/11/03/rsa-info/"},{"title":"spring-boot","text":"Spring BootSpring Boot makes it easy to create Spring-powered, production-grade applications andservices with absolute minimum fuss. It takes an opinionated view of the Spring platformso that new and existing users can quickly get to the bits they need. You can use Spring Boot to create stand-alone Java applications that can be started usingjava -jar or more traditional WAR deployments. We also provide a command line toolthat runs spring scripts. Our primary goals are: Provide a radically faster and widely accessible getting started experience for allSpring development Be opinionated out of the box, but get out of the way quickly as requirements start todiverge from the defaults Provide a range of non-functional features that are common to large classes of projects(e.g. embedded servers, security, metrics, health checks, externalized configuration) Absolutely no code generation and no requirement for XML configuration == Installation and Getting StartedThe {docs}/html/[reference documentation] includes detailed{docs}/html/getting-started.html#getting-started-installing-spring-boot[installationinstructions] as well as a comprehensive{docs}/html/getting-started.html#getting-started-first-application[getting started]guide. Here is a quick teaser of a complete Spring Boot application in Java: 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@SpringBootApplicationpublic class Example { @RequestMapping(\"/\") String home() { return \"Hello World!\"; } public static void main(String[] args) { SpringApplication.run(Example.class, args); }} Getting helpHaving trouble with Spring Boot? We’d like to help! Check the {docs}/html/[reference documentation], especially the{docs}/html/howto.html#howto[How-to’s] – they provide solutions to the most commonquestions. Learn the Spring basics – Spring Boot builds on many other Spring projects, checkthe https://spring.io[spring.io] web-site for a wealth of reference documentation. Ifyou are just starting out with Spring, try one of the https://spring.io/guides[guides]. If you are upgrading, read the {github}/wiki[release notes] for upgrade instructions and“new and noteworthy” features. Ask a question - we monitor https://stackoverflow.com[stackoverflow.com] for questionstagged with https://stackoverflow.com/tags/spring-boot[`spring-boot`]. You can also chatwith the community on https://gitter.im/spring-projects/spring-boot[Gitter]. Report bugs with Spring Boot at {github}/issues[github.com/spring-projects/spring-boot/issues]. Reporting IssuesSpring Boot uses GitHub’s integrated issue tracking system to record bugs and featurerequests. If you want to raise an issue, please follow the recommendations below: Before you log a bug, please search the {github}/issues[issue tracker] to see if someonehas already reported the problem. If the issue doesn’t already exist, {github}/issues/new[create a new issue]. Please provide as much information as possible with the issue report, we like to knowthe version of Spring Boot that you are using, as well as your Operating System andJVM version. If you need to paste code, or include a stack trace use Markdown +++escapes1234567891011121314 before and after your text.* If possible try to create a test-case or project that replicates the problem and attach it to the issue.# Building from SourceYou don&apos;t need to build from source to use Spring Boot (binaries inhttps://repo.spring.io[repo.spring.io]), but if you want to try out the latest andgreatest, Spring Boot can be easily built with thehttps://github.com/takari/maven-wrapper[maven wrapper]. You also need JDK 1.8.```bash $ ./mvnw clean install If you want to build with the regular mvn command, you will needhttps://maven.apache.org/run-maven/index.html[Maven v3.5.0 or above]. NOTE: You may need to increase the amount of memory available to Maven by settinga MAVEN_OPTS environment variable with the value -Xmx512m. Rememberto set the corresponding property in your IDE as well if you are building and runningtests there (e.g. in Eclipse go to Preferences-&gt;Java-&gt;Installed JREs and edit theJRE definition so that all processes are launched with those arguments). This propertyis automatically set if you use the maven wrapper. Also see link:CONTRIBUTING.adoc[CONTRIBUTING.adoc] if you wish to submit pull requests,and in particular please fill out thehttps://support.springsource.com/spring_committer_signup[Contributor's Agreement]before your first change, however trivial. === Building reference documentation First of all, make sure you have built the project: 1$ ./mvnw clean install The reference documentation requires the documentation of the Maven plugin to beavailable so you need to build that first since it’s not generated by default. 1$ ./mvnw clean install -pl spring-boot-project/spring-boot-tools/spring-boot-maven-plugin -Pdefault,full The documentation also includes auto-generated information about the starters. You mighthave that in your local repository already (per the first step) but if you want to refreshit: 1$ ./mvnw clean install -f spring-boot-project/spring-boot-starters Once this is done, you can build the reference documentation with the command below: 1$ ./mvnw clean prepare-package -pl spring-boot-project/spring-boot-docs -Pdefault,full TIP: The generated documentation is available from spring-boot-project/spring-boot-docs/target/generated-docs/reference/html ModulesThere are a number of modules in Spring Boot, here is a quick overview: spring-bootThe main library providing features that support the other parts of Spring Boot,these include: The SpringApplication class, providing static convenience methods that make it easyto write a stand-alone Spring Application. Its sole job is to create and refresh anappropriate Spring ApplicationContext Embedded web applications with a choice of container (Tomcat, Jetty or Undertow) First class externalized configuration support Convenience ApplicationContext initializers, including support for sensible loggingdefaults spring-boot-autoconfigureSpring Boot can configure large parts of common applications based on the contentof their classpath. A single @EnableAutoConfiguration annotation triggersauto-configuration of the Spring context. Auto-configuration attempts to deduce which beans a user might need. For example, ifHSQLDB is on the classpath, and the user has not configured any database connections,then they probably want an in-memory database to be defined. Auto-configuration willalways back away as the user starts to define their own beans. spring-boot-startersStarters are a set of convenient dependency descriptors that you can include inyour application. You get a one-stop-shop for all the Spring and related technologythat you need without having to hunt through sample code and copy paste loads ofdependency descriptors. For example, if you want to get started using Spring and JPA fordatabase access just include the spring-boot-starter-data-jpa dependency in yourproject, and you are good to go. spring-boot-cliThe Spring command line application compiles and runs Groovy source, making it supereasy to write the absolute minimum of code to get an application running. Spring CLIcan also watch files, automatically recompiling and restarting when they change. spring-boot-actuatorActuator endpoints let you monitor and interact with your application.Spring Boot Actuator provides the infrastructure required for actuator endpoints. It containsannotation support for actuator endpoints. Out of the box, this module provides a number of endpointsincluding the HealthEndpoint, EnvironmentEndpoint, BeansEndpoint and many more. spring-boot-actuator-autoconfigureThis provides auto-configuration for actuator endpoints based on the content of the classpath and a set of properties.For instance, if Micrometer is on the classpath, it will auto-configure the MetricsEndpoint.It contains configuration to expose endpoints over HTTP or JMX.Just like Spring Boot AutoConfigure, this will back away as the user starts to define their own beans. spring-boot-testThis module contains core items and annotations that can be helpful when testing your application. spring-boot-test-autoconfigureLike other Spring Boot auto-configuration modules, spring-boot-test-autoconfigure, provides auto-configurationfor tests based on the classpath. It includes a number of annotations that can be used to automaticallyconfigure a slice of your application that needs to be tested. spring-boot-loaderSpring Boot Loader provides the secret sauce that allows you to build a single jar filethat can be launched using java -jar. Generally you will not need to usespring-boot-loader directly, but instead work with thelink:spring-boot-project/spring-boot-tools/spring-boot-gradle-plugin[Gradle] orlink:spring-boot-project/spring-boot-tools/spring-boot-maven-plugin[Maven] plugin. spring-boot-devtoolsThe spring-boot-devtools module provides additional development-time features such as automatic restarts,for a smoother application development experience. Developer tools are automatically disabled whenrunning a fully packaged application. SamplesGroovy samples for use with the command line application are available inlink:spring-boot-project/spring-boot-cli/samples[spring-boot-cli/samples]. To run the CLI samples typespring run &lt;sample&gt;.groovy from samples directory. GuidesThe https://spring.io/[spring.io] site contains several guides that show how to use SpringBoot step-by-step: https://spring.io/guides/gs/spring-boot/[Building an Application with Spring Boot] is avery basic guide that shows you how to create a simple application, run it and add somemanagement services. https://spring.io/guides/gs/actuator-service/[Building a RESTful Web Service with SpringBoot Actuator] is a guide to creating a REST web service and also shows how the servercan be configured. https://spring.io/guides/gs/convert-jar-to-war/[Converting a Spring Boot JAR Applicationto a WAR] shows you how to run applications in a web server as a WAR file. LicenseSpring Boot is Open Source software released under thehttps://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 license].","link":"/2019/11/07/spring-boot/"},{"title":"vue_route","text":"vue自动化路由目的解放双手，从此不用配置路由。当你看到项目中大批量的路由思考是拆分维护业务路由还是统一入口维护时，无需多虑，router-auto是你的最优选择，它帮你解决路由的维护成本，你只需要创建相应的文件夹，路由就能动态生成，路由拦截你可以在main.js中去拦截他，总之比你想象的开发还要简单。 router-auto github地址有帮助的可以star一下 router-auto npm地址欢迎提issue 实现效果 简要用法具体用法请实时查看github或者npm，下面做一些简要用法介绍 引用12345678910const RouterAuto = require('router-auto')module.exports = { entry: '...', output: {}, module: {}, plugin:[ new RouterAuto() ]} 项目结构 package.json 等等文件与目录 src 项目目录 page 页面目录 helloworld Index.vue 页面入口 hello.vue 业务组件 router.js 额外配置 demo test Index.vue 页面入口 test.vue 业务组件 Index.vue 页面入口 home Index.vue 页面入口 上面的目录结构生成的路由结构为 123456789101112131415161718192021222324252627282930import Vue from 'vue'import Router from 'vue-router'import helloworld from '@/page/helloworld/Index.vue'import demo from '@/page/demo/Index.vue'import demo_test from '@/page/demo/test/Index.vue'import home from '@/page/home/Index.vue' Vue.use(Router) export default new Router({ mode:'history', base:'/auto/', routes:[{ path: '/helloworld/index', name: 'helloworld', component: helloworld },{ path: '/demo/index', name: 'demo', component: demo },{ path: '/demo/test/index', name: 'demo_test', component: demo_test },{ path: '/home/index', name: 'home', component: home }]}) 作者：ngaiwe链接：https://juejin.im/post/5d90798151882576e44088e8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/09/29/vue-route/"},{"title":"warplane","text":"全世界十大顶级战机排行第一名：F-22“猛禽”战机F-22是世界上致命打击性能最好的战斗机，是美国空军的最重要机种，F-22“猛禽”是一款第五代战斗机，以其高机动性、传感器融合性、超音速巡航和致命攻击能力成为了世界上最顶级战机。F-22“猛禽”是一种由美国洛克希德·马丁、波音和通用动力等公司联合为美国空军设计的重型隐身战斗机，主要任务是取得并确保战区的制空权。目前唯一现役 的第五代战斗机。 第二名：俄罗斯第五代战机T-50俄罗斯第五代战机T-50为单座双发重型战机，具备隐身性能好、起降距离短、超机动性能、超音速巡航等特点。其超音速巡航速度可达每小时1450千米，作战半径1100千米，战斗负荷可达6吨，内置3个武器舱，能实现飞行性能和隐身性能的良好结合。 第三名：F-35战机F-35“闪电II”是一款由美国洛克希德·马丁公司设计生产的单座单发动机多用途战机，能够负担近空支援、F-35闪电II(19张)目标轰炸、防空截击等多种任务。 美国的F-35“闪电2”有“史上最昂贵战斗机”之称。美军的“通用低成本轻型战斗机”和“联合先进攻击技术”的新战机理念在洛·马－诺·格公司联合研制 的X-35上初现，美军便选中它并命名为F-35联合打击战斗机（JSF）。 第四名：苏-30/35战机苏-35是第4.5代重型战机，具有远程，多用途，空优和打击等特性。 和苏-30有同样血统设计，有相似性能特征和零件；也可说是苏-30的一种特制版。更助长了苏-35BM型的研发。目前苏-35只有少量的五架服役于俄罗斯空军。苏-35/苏恺35 (北约代号：Flanker-E)）是第4.5代重型战机，具有远程，多用途，空优和打击等特性。 第五名：F/A-18“大黄蜂”战机F/A-18“大黄蜂”战机是一种具备最好气动性能和大攻角能力的多用途战术飞机，被誉为“美国尊严守护者”。这架战机率先使用数字复用航空总线和多功能显示器，可使飞行员在瞬息万变的战斗环境中更加灵活的执行动作。 第六名：“阵风”战机“阵风”战机具备众所周知的空对空战斗能力，是一种占尽空中优势的战斗机。 “阵风”战机由法国军机、商务机生产商达索(Dassault)飞机公司设计开发。 这款飞机支持“光谱”电子战系统，可抵御地面和空中的威胁。 第七名：“鹰狮”战斗机“鹰狮”战斗机具有八个可装载导弹和炸弹的挂载点，是一种轻型战机，以其鸭式三角翼设计和高机动性着称。这架战机支持一个复杂的PS-05A型脉冲多普勒X射线雷达，可以侦测120公里外的目标。“鹰狮”也可以通过发射空空导弹进行超视距攻击。JAS-39“鹰狮”是瑞典萨伯公司研制的单座全天候全高度战斗/攻击/侦察机，用以在90年代取代瑞典空军的Saab-37“雷”式战斗机。 第八名：台风战斗机台风战斗机是欧洲战斗机公司(英、德、意和西班牙4国合作)研制的新型单（双）座双发超音速战斗机，主要用于防空和空中优势任务，兼具对地攻击能力。1984年德、英、法、意和西班牙五团达成协议、提出“欧洲战斗机”计划(EFA)，中途法国退出。事过10年，1994年3月27日，英、德、意和西班牙四国联合研制的 EF2000战斗机原型机实现了第—次试—览。 第九名：米格-35战机米格-35是一款4++代喷气式战斗机，因其独特的光学定位系统而着称；该系统可使飞机减少对地面控制截击系统(GCI)的依赖，可帮助其独立进行多角色任务。在飞机每个翼尖上都安装有激光发射探测器(LED)，可帮助战机侦测即将到来的危险，并且可通过红外线波段抵消危险。 第十名：歼-10战机歼-10战机有一个更出名的名字叫“大力龙”，它由成都飞机工业公司为中国人民解放军空军设计研发，是一种全天候多用途战斗机。歼-10的11外部挂载点 至少能够携带6000千克武器，而且在进气口左舷下装备有23毫米双管机关炮。成飞设计的这款飞机用于执行空对地和空对空的双重任务。","link":"/2019/10/18/warplane/"},{"title":"windows.edb_mv","text":"【Win10瘦身技巧】把索引文件Windows.edb移动到非系统盘 先介绍Windows.edb是什么东东，很奇怪的后缀名哦。其实它就是Windows10为加快搜索速度而建立的索引文件，所以还是很有用的，但是看看它的体积，你就会觉得也太占系统盘的空间了。Windows.edb文件所在的路径为： 1C:\\ProgramData\\Microsoft\\Search\\Data\\Applications\\Windows 虽然我们可以删除该文件，但正像前面说过的，它还是比较有用的（并且删除后，再次使用搜索功能后，它还会生成的），所以我们最好保留着它，但可以移动一下Windows.edb文件的位置，把它移动到非系统盘。方法如下： 在Win10任务栏的Cortana搜索框中输入“索引选项”，点击搜索结果中的“索引选项（控制面板）”打开“索引选项”窗口。 点击窗口底部的“高级”按钮，打开“高级选项”窗口。 在“索引位置”区域点击右下角的“选择新位置”按钮，为Windows.edb选择非系统盘的路径即可。最后点击“确定”，重启电脑后生效。","link":"/2019/10/25/windows-edb-mv/"},{"title":"weilibipei","text":"违例匹配“掷”出一个违例后，违例控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为违例已得到控制，不再进行更多的搜索工作。 在违例和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个控制器相配，如下例所示： 1234567891011121314151617//: Human.java// Catching Exception Hierarchiesclass Annoyance extends Exception {}class Sneeze extends Annoyance {}public class Human { public static void main(String[] args) { try { throw new Sneeze(); } catch(Sneeze s) { System.out.println(&quot;Caught Sneeze&quot;); } catch(Annoyance a) { System.out.println(&quot;Caught Annoyance&quot;); } }} ///:~ Sneeze违例会被相符的第一个catch从句捕获。当然，这只是第一个。然而，假如我们删除第一个catch从句： 12345try { throw new Sneeze();} catch(Annoyance a) { System.out.println(&quot;Caught Annoyance&quot;);} 那么剩下的catch从句依然能够工作，因为它捕获的是Sneeze的基础类。换言之，catch(Annoyance e)能捕获一个Annoyance以及从它衍生的任何类。这一点非常重要，因为一旦我们决定为一个方法添加更多的违例，而且它们都是从相同的基础类继承的，那么客户程序员的代码就不需要更改。至少能够假定它们捕获的是基础类。 若将基础类捕获从句置于第一位，试图“屏蔽”衍生类违例，就象下面这样： 1234567try { throw new Sneeze();} catch(Annoyance a) { System.out.println(&quot;Caught Annoyance&quot;);} catch(Sneeze s) { System.out.println(&quot;Caught Sneeze&quot;);} 则编译器会产生一条出错消息，因为它发现永远不可能抵达Sneeze捕获从句。 9.8.1 违例准则 用违例做下面这些事情： (1) 解决问题并再次调用造成违例的方法。 (2) 平息事态的发展，并在不重新尝试方法的前提下继续。 (3) 计算另一些结果，而不是希望方法产生的结果。 (4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。 (5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。 (6) 中止程序执行。 (7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。 (8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）","link":"/2019/10/22/weilibipei/"},{"title":"x64dbg","text":"x64dbg An open-source binary debugger for Windows, aimed at malware analysis and reverse engineering of executables you do not have the source code for. There are many features available and a comprehensive plugin system to add your own. You can find more information on the blog! Screenshots Installation &amp; Usage Download a snapshot from GitHub, SourceForge or OSDN and extract it in a location your user has write access to. Optionally use x96dbg.exe to register a shell extension and add shortcuts to your desktop. You can now run x32\\x32dbg.exe if you want to debug a 32-bit executable or x64\\x64dbg.exe to debug a 64-bit executable! If you are unsure you can always run x96dbg.exe and chose your architecture there. You can also compile x64dbg yourself with a few easy steps! ContributingThis is a community effort and we accept pull requests! See the CONTRIBUTING document for more information. If you have any questions you can always contact us or open an issue. You can take a look at the easy issues to get started. Credits Debugger core by TitanEngine Community Edition Disassembly powered by Zydis Assembly powered by XEDParse and asmjit Import reconstruction powered by Scylla JSON powered by Jansson Database compression powered by lz4 Bug icon by VisualPharm Interface icons by Fugue Website by tr4ceflow Developers mrexodia Sigma tr4ceflow Dreg Nukem Herz3h torusrxxx Code contributionsYou can find an exhaustive list of GitHub contributers here. Special Thanks Sigma for developing the initial GUI All the donators! Everybody adding issues! People I forgot to add to this list Writers of the blog! EXETools community Tuts4You community ReSharper Coverity acidflash cyberbob cypher Teddy Rogers TEAM DVT DMichael Artic ahmadmansoor _pusher_ firelegend kao sstrato kobalicek athre0z ZehMatt Without the help of many people and other open source projects it would not have been possible to make x64dbg what is it today, thank you!","link":"/2019/10/05/x64dbg/"},{"title":"三阶魔方解法","text":"三阶魔方解法预备篇：三阶魔方相关知识在本教程中，统一使用官方配色（上黄、下白、左橙、右红、前蓝、后绿），并在还原的过程中，白色作为底色。 下图中，A、B、C分别表示顶层、中层、底层；D为中心块，在还原的过程中以此作为参照色（即该面所最终还原的颜色）；E为棱块，每块有两个颜色；F为角块，每块有三个颜色。 在本教程中，分别用Front、Back、Left、Right、Up、Down的首字母表示前面、后面、左面、右面、上面、下面的顺时针90度旋转，带撇号的为逆时针90度逆转，带数字2的为180度旋转。 第一步：完成底层四棱子步骤一：拼成黄心白瓣小花如下图①所示，我们只要在黄色中心块的四周的棱块都挨着白色即可。 对于在中层的白色棱，如②所示，只需转一个90度即可将白色朝上；对于在顶层、底层朝外的白色棱，如③所示，先在白色所在面转动90度后变成②的情况再处理；而在底层朝下的白色棱，如④所示，则通过180度旋转即可将白色朝上。 值得留意的是⑤之类的情况，如果直接转90度将中层白色块朝上，那么会破坏掉上方原先已有的白色块。此时要先转动顶层（此例为U’），将空位转到对应位置，方可使该白色块转上去。 子步骤二：找到相应颜色并掉落花瓣先随意选定一个白色棱（下图以白红棱为例），转动顶层（或扭转中底层），直到该棱侧面的颜色与中心块吻合时，以该中心块为轴转动180度，使其落到白色中心旁边。用同样的方法处理其他三个棱之后，在底层会形成白色的十字，棱的侧面也与中心块相连。 第二步：完成底层四角这一步我们不仅要让白色的四角全都聚集在下面，还要留意其角块侧面的颜色也要吻合。 如下图的上半部分所示，我们先在顶层寻找含白色的角块，同时观察该角块另外两种颜色，转动顶层（或扭转中底层），使之处在相应颜色的两个中心块之间。 当角块转到相应位置后，观察白色的朝向，做相应的公式： ①为白色朝右，做U’ F’ U F；②为白色朝前，做U R U’ R’；③为白色朝上，做三遍的公式①。当顶层无任何白色角块时，此时再观察底层有无错误朝向或位置的白色角块： ④在底层，白色朝右，做两遍的公式①；⑤在底层，白色朝前，做两遍的公式②；⑥在底层，错误位置角块，先做公式①将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个角之后，底面为全白色，侧面会形成倒T字。 第三步：完成中层四棱如下图的上半部分所示，我们先在顶层寻找不含黄色的棱块，同时观察该棱块另外两种颜色，转动顶层（或扭转中底层），使之朝外的颜色与中心块相吻合。 当棱块转到相应位置后，观察最终所归的空位，并将空位置于右前方，做相应的公式（前面的公式①与②，在这里称为甲与乙）： ①情况做U’ F’ U F U R U’ R’（先甲后乙）；②情况做U R U’ R’ U’ F’ U F（先乙后甲）；当顶层全为有黄色的棱块时，此时再观察中层有无错误朝向或位置的棱块： ③与④情况，先做甲+乙将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个棱之后，第二层即完成。 第四步：完成顶面十字现在观察顶面的棱与中心块所构成的图形（忽视角块黄色是否朝上与否）分为“点、线、拐、十字”四种情况。找到相应的情况并按图示朝向摆放后，按照下流程图每次做R’ U’ F’ U F R（R’+甲+R）直到变成十字为止。其中“线”的情况还有一条捷径，即F R U R’ U’ F’。 Cube solve 7a.png 第五步：调整顶棱顺序先转动顶层（或扭转中底层），直到至少有两个棱侧面的颜色与中心块吻合。 现在观察另外两个错误的棱处于相邻还是相对位置，如果没有，则此步跳过；如果是相邻的，则将两个错误的置一前一右，做丙公式U’ F’ U’ F U’ F’ U2 F；如果是相对的，则将两个错误的置一左一后，先做丙公式，然后转下顶层变为相邻的，再置一前一右做丙公式完成。 Cube solve 8.png 第六步：调整顶角顺序观察顶角，找到在正确位置的一个角（朝向是否正确暂时不考虑）。如果四角都在正确位置，则此步跳过；如果只有一个，则将正确的角置于左前方，做丁公式U’ L’ U R U’ L U R’（做一遍仍未成功则再做第二遍）；如果没有一个角在正确位置，则先做丁公式然后变成有一个角在正确位置再相应处理。 Cube solve 9.png 第七步：调整顶角朝向此时我们统一将蓝色中心块保持前面放置，需要注意的是在操作的过程中魔方的底层会被暂时性打乱，不过不要紧，只要正确操作完后魔方会正常还原。 观察顶层前右方的角块的黄色朝向，做戊公式F’ R F R’二或四遍使黄色朝上。完成一个角块的朝向处理之后，要转动顶层（U、U’、U2），并保持蓝色中心块在前面不动，再处理其他角块朝向。(在每一角落都要扭) Cube solve 10.png 维基百科","link":"/2019/09/12/三阶魔方解法/"},{"title":"你也能懂相对论","text":"相对论 光线在通过强引力场附近时会发生弯曲，这是广义相对论的重要预言之一 如果我说，相对论与日常生用息息相关，你会信吗？或许就算我是一位知名的物理学教授，说服力相信也不会大得多少。以下我将要用比较浅白简单的文字和少许初等代数，说明并说服大家，相对论并不难懂，而且它在日常经验中是如此的明显、如此的必要！ 1905 年被称为爱因斯坦的「奇迹年」，爱因斯坦向世界提出了一套非常明显、非常合理，但却一直不为人所理解的理论狭义相对论(special relativity)。被称为「狭义」是因为这个理论只在惯性座标系中适用；换句话说，即是在所有没有加速度的系统中都适用。狭义相对论建基于两大假设： 在所有的惯性系统中，所有有物理定律保持不变。 对于所有系统中的所有观测者，光速永远不变，而且不是无限快的。 假设(一)「所有自然定律不变」一般被称为相对性原理(principle of relativity)，明显比较合理，也比较容易理解。而乍看之下，光速相对于所有人都不变，而不论那人正在高速奔跑或者静止不动都没有关系，就显得较为奇怪了。要理解这一点，我们需要由速度的意义说起。速度，就是在说「每单位时间内走了多远」。说得再浅白一点，可以想像为「每秒走了多少米(m/s)」。但这只是惯用单位的问题，你当然可以想成「每小时走了多少公里(km/h)」，这正是司机们惯用的单位。在科学中，单位是至关重要的，因为不同单位的东西就是不同性质的东西，不可以混为一谈的比较，好像一个苹果永远不会等于一个橙。 假设(二)「光速相对所有人都不变」，就是说相对于所有人，光在每单位时间内走的距离都一样。就是说，当你向着一道光奔跑，「直觉上」你会认为你所看到的光速比起你在静止不动时快，因为在你向光跑去的「同时」，光亦向着你冲去。换成数学上的表达，就是说如果你用速度 v 向着光冲去，而我们用 c 代表你在静止时看到的光速，那你看到的光速就会变成了c + v。这就是所谓的伽俐略变换，亦被一般人叫做「常识」。当然了啊，两个物件互相冲去，当然会比其中一个不动、或两者互相远离快啊。但是，爱因斯坦却说不论你用什么速度，向着光或离开光移动，你到的光速都仍然为 c，不多也不少！ 你会说：「这怎可能！这是违反常识的！」我的回答是，一般人的常识存在非常明显的漏洞，可是在爱因斯坦之前却一直没有人留意到这个严重的错误！这个错误就是「同时」这一概念的演绎。什么是「同时」？就是说大家的时钟显示的时间都一样啊！对，这也是爱因斯坦对「同时」的理解。但现在要再问一道问题，如何知道两个时钟的时间一样？ 问题到肉了，可是你会觉得很无聊：「说什么废话！只要我看到两个钟的指针拍着的时间就是了！」好，停一停，想一想：我们能「看」到东西，是因为光进入到我们的眼球穿过水晶体折射后投影在视网膜上。总言之，我们能看到东西，是因为有光。光以一定的速度前进，而且因为光速有限，因此在不同距离发出的光相对于同一个观测者而言，会在不同时间到达。试想像，两个人相距非常远，而两个人都带着一个时钟，那么当然，任何一方都会觉得对方那个时钟所发出的光，会比自己手上的时钟所发出的光要用更多时间才能进入你的眼睛吧！好了，我希望大家想想，究竟事先要如何调整两个时钟，才能使你和对方都看到两个时钟是同步的呢？当然，这是办不到的！因为两个时钟相距两个人的距离都不同。若然你看到它们是同步的，对方就会看到他手上的走得较快，反之亦然。 如果你不太理解的话，请从头思考一次，先不要跳过读下去，因为刚才所说的就是相对论的精髓所在。重点是，要知道世界上并没有「对所有人都同时」这个概念存在，因此也可以说，「同时」这个概念对每个人都不同；说「对大家来说都是同时」就是错误的，没有可能发生。这是非常明显的，但却一直被我们所忽略。这完全是因为对于人类的感觉来说，光速(每秒三十万公里，能够环绕地球七个半圈) 实在是太快、太快了。 好了，接下来我要介绍相对论导致的两个非常重要的结果，这些结果令人类对时间及空间的概念有了根本上的改变：时间及空间其实是互相纠缠、难分难离的。在这部分我会以数学论证，狭义相对论所涉及的数学都只是基本数学运算以及向量微积分，相信对有会考物理根基的朋友来说不会太难。 在我们生活的三维空间中，每一件事件都可以用座标系的四个变量决定，就是(长，阔，高，时间)，数学表达为( x , y , z , t )。假设在座标系 S 中有一原点 O，在 S 内观测的人都会对每一件事件测得一组座标( x , y , z , t )；而现在有另一座标系S’正在相对S以速度 v 向右移动，它的原点 O’ 在时间 t = 0的时候刚好与 O重叠，而在S’内观测的人都会对每一件事件测得一组座标( x’ , y’ , z’ , t’ )。那么，在我们的「常识」中， ( x , y , z , t )与 ( x’ , y’ , z’ , t’ )的关系就是由伽俐略变换来决定： 这就是我们认为的「常识」的数学表达方法。留意当中t’ = t，因为在传统的观念里，「同时」这概念仍然存在。明显地，在伽俐略变换当中，时间是独立地流逝的，与空间( x , y , z )无关。可是，在上文中我们知道「同时」是不存在的。 想像小明站在一节正在行进的列车车厢正中间，在车头及车尾都摆放了感应器。他向左右同时照射出两道光束。对小明来说，车厢并没有移动，所以他会看到两道光束同时到达感应器。可是，对于一位站在月台上的人来说，因为列车正在向右移动，右边的感应器不断远离光束，而左边的就不断靠边光束。所以他会看到左边那道光束首先到达感应器。因此，时间会因为观测者的运动状态不同而有所分别，而且这是非常明显的！请注意，上述两种情况都是正确的，没有谁对谁错，完全因为观点与角度而已。回到 S 和 S’ 座标系的讨论，因为两个座标系的运动状态不同，所以伽俐略变换就不是正确的描述了，我们必须改用另外一种座标变换方法，名为洛伦兹变换( Lorentz Transformation)： 有关这组公式的推导过程，有兴趣的朋友可以参考任何相对论课本。在这里我们有兴趣的是：如果时间及空间确实根据以上方程组变换的话，会有什么有趣的事情发生？ 首先，考虑一个「光钟」，这是一个纯粹由两块互相平行的平面镜组成的计时器，有一束光在两块镜之间来回反弹。然后我们定义这束光来回反弹一次的时间Δ t = 2 h / c 为一个时间单位，故此我们就有了这样一种有趣的计时器。 现在，我们让这个光钟在S座标系中以水平方向向右以均速 v 移动。所以我们就知道，如果我们称光钟为S’ 座标系，就有Δ t’ = 2 h / c。在S 座标系当中，光就是以斜线行进的，根据毕氐定理，我们得到 使用简单代数运算求得Δ t： 因为v &lt; c，所以分母必定小于1 ，故此Δ t’ &lt; Δ t。换句话说，移动中的座标系的时间流逝得比较慢。这就是著名的时间迟滞(Time Dilation) 。 除了移动中的人的时间在其他人眼中会变慢之外，移动中的物体看起来也会变短。这叫做长度收缩(Length Contraction)。如果L 0 是物体静止时的长度，L是物体相对于观测者以速度 v移动时的长度，那么我们就会得到 公式(3) 的推导过程与公式(2) 差不多，只要把光钟转个直角再考虑水平移动就可以了，有兴趣的朋友可以自己当做练习试试推导。 以上两个「违反直觉」的现象都已经被实验观测所证实了。其中一个重要的证明是关于宇宙射线的问题。每分每秒都有大量的宇宙射线攻击着地球，这些射线多是带电粒子诸如质子及电子等等，能量很高。幸好地球有磁场以及大气层的保护，不然地球上就不可能有生命存在了。 一些粒子与大气粒子碰撞后，会产生许多不同种类的粒子，向各个方向散射。这些粒子的寿命一般都非常短暂，就算在产生的一刻开始已经用接近光速前进，在它再衰变成其他粒子之前，前进的距离最多也只得几百米。但是，虽然地球的大气层厚度约为100公里，设置在地面上的仪器却可以探测到它们！这完全是因为这些粒子以接近光速行进，相对论的效应就会变得很大。如果在静止时这些粒子的寿命是 T，那么根据时间迟滞现象，地面上的人就会测得它们的寿命为 其中 v 是粒子的速度。明显地，当 v 非常接近 c 的时候，T’ 就会变得非常大，所以它们有足够的时间可以穿过厚厚的大气层落到地面。 我最后想介绍的是著名的爱因斯坦速度相加法则。在早前的讨论中，我们已经明白到，在光速不是无限快的条件下，时间必须是「相对」的。亦即是说，对于不同运动状态的观测者，时间的流逝速率各有不同。同样地对于空间来说也是如此。因此，我们就不能说两个互相靠近的人的相对速度 v’，会简单地为 v’ = v 1 + v 2，其中 v 1 和 v 2 分别为两个人的速度。那么 v’ 应该如何表达才对呢？其实简单得很，只要把洛伦兹公式对时间微分就可以了。详细的做法可以参考教科书，其结果为 因此可以看到在相对论下，相对速度 v’ 比较小。如果代入文章开头的例子，你和光束互相冲向对方，就有 所以你会惊讶地发现，c + v 仍然是 c！这是当然的，因为相对论本身必须符合它的假设：光速不变。 其实狭义相对论还有许多有趣的题目可以讨论的，例如著名的质能公式E = mc^2、双生子悖论、能量-动量四维向量、以及相对论性电磁场理论等等，或许在以后我会和大家深入讨论。而爱因斯坦在1916 年提出的广义相对论(general relativity)，则是一套把重力与加速度都包含在内的时空理论，能够非常准确地描述我们身处的宇宙。广义相对论所涉及的数学非常深奥，需要使用到十分抽象的黎曼几何以及张量的概念，确实并非每个学生也能明白。在以后我会试试为大家说明广义相对论的重要性。总而言之，在这篇文章中，我希望大家明白的事，是相对论其实并非一般人想像的那么深奥难懂。至少，就狭义相对论而言，只需要中学程度的物理及数学知识就可以了。 原文链接","link":"/2019/09/08/你也能懂相对论/"},{"title":"x64dbg破解code","text":"x64dbg破解code121075248.PAR pp.las ppcheck.scr ppcheck_A.exe* 新建文本文档.txt1075248.SET pp.pwd ppcheck.txt PPM1828.DAT 将后缀是.par .set的文件名称修改为想要查询的序列号，后缀要保留。 点击PPCHUCK_A.EXE的执行文件执行，选择适当的机器型号，选择需要查询的选项，回车执行，选择三种润滑方式任意一种。执行。 x64dbg加载ppcheck_A.exe 设置断点，运行程序，进行测试。 CALL 过程调用相同 1call 0x0040ACE6 分析核心代码。。。 模拟程序执行过程 Please enter a serial number: 输入 num 输入的数据存入内存 0x42A708 0x00429374 选择后Enter 1Code to turn on TSC： 742 汇编代码执行到 推测，计算code的程序在打印头部信息 HAAS 与 打印 Code 之间 存储 TSC code 的地址为 0x0042F26C 16进制表示： 000002E6 总结执行步骤 输入num 选择型号（三次选择） 打印对应参数的code 在汇编程序中的输入num的内存地址与code的值得内存地址都可以找到，而且程序执行中均已常数形式存在，推测在（三次选择）结束后，所有参数对应的code值均计算后，以常数形式保存在，之后的程序判断将部分的参数对应的code值打印出。","link":"/2019/10/05/x64dbg破解code/"},{"title":"天平砝码摆放问题","text":"题目一个天平上有6个位置，左右各三个位置，有6个砝码，分别是1、2、3、4、5、6克重。要使天平平衡，有多少种方法？（对称摆放算作一种方法） 题解暴力求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { int t = 6; int count = 0; vector&lt;string&gt; v; for (int i = 1; i &lt;= t; ++i) { for (int j = 1; j &lt;= t; ++j) { for (int k = 1; k &lt;= t; ++k) { for (int l = 1; l &lt;= t; ++l) { for (int m = 1; m &lt;= t; ++m) { for (int n = 1; n &lt;= t; ++n) { if (i == j || i == k || j == k || i == l || j == l || k == l || i == m || j == m || k == m || l == m || i == n || j == n || k == n || l == n || m == n) continue; if ((3 * i + 2 * j + k) == (l + 2 * m + 3 * n)) { string s = to_string(i) + to_string(j) + to_string(k) + to_string(l) + to_string(m) + to_string(n); int te = 0; if (v.size() &gt; 0) { string tem = s; reverse(tem.begin(), tem.end()); vector&lt;string&gt;::iterator it; for (it = v.begin(); it != v.end(); it++) { if (*it == tem) { //cout&lt;&lt;tem&lt;&lt;endl; te = 1; break; } } } if (te == 0) { v.push_back(s); count++; printf(\" %d %d %d | %d %d %d\\n\", i, j, k, l, m, n); } } } } } } } } cout &lt;&lt; count &lt;&lt; endl; return 0;} 1234567891011121314151617181 4 6 | 5 3 21 5 6 | 2 4 31 5 6 | 3 2 41 6 4 | 3 5 21 6 5 | 2 3 42 4 6 | 1 5 32 4 6 | 3 1 52 6 3 | 4 1 52 6 4 | 1 3 53 2 6 | 5 1 43 4 5 | 2 1 63 5 4 | 1 2 63 6 2 | 1 5 44 2 6 | 1 3 54 3 5 | 1 2 65 2 4 | 3 1 65 4 2 | 1 3 617","link":"/2019/09/02/天平砝码摆放问题/"},{"title":"客户端面试","text":"100级台阶，每次上一步或两步，有多少种走法。 57314784401381708410121 如果200级，你估计有多少种走法（不用编程）。 45397369416530795319729696969741061923382642 不用编程，估算 123456789101112131415161718import java.math.BigInteger;public class Main { public static void main(String[] args) { int n = 200; BigInteger a = BigInteger.ONE; BigInteger b = BigInteger.ONE; BigInteger res = BigInteger.ZERO; for (int i = 2; i &lt;= n; i++) { res = a.add(b); a = b; b = res; } System.out.println(res); System.out.println(res.toString().length()); }} 给出一个数组，找出两个数[a,b]和为n，不存在则返回[-1,-1]。写出两种解法，不能暴力穷举。 讲讲面向过程、面向对象、面向切面。 指针和数组的关系和区别。 讲讲Android handler。 队列和栈的区别和用途。 两个栈实现队列。 输入Url到浏览器显示过程。 http请求方法。 get和post区别。 surficeView和view的区别。 app从点击图标开始的启动全过程。 什么是线程安全。 线程安全有哪些机制。 如何保证 int加加（加号打不出来）线程安全。 Android线程间通信有哪些机制。 cpu调度方式有哪些。 空间局部性和时间局部性。 数据库乐观锁和悲观锁。 数据库索引作用，优缺点。 TCP拥塞控制。 https加密传输过程。 java内存模型。 java垃圾回收算法有哪些。 讲讲标记清除算法。 java四中引用。","link":"/2019/09/21/客户端面试/"},{"title":"判断素数","text":"素数 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。 0和1既不是质数也不是合数，最小的质数是2 最直观，但效率最低的写法 这里特殊处理了一下小于等于3的数，因为小于等于3的自然数只有2和3是质数。 然后，我们只需要从2开始，一直到小于其自身，依次判断能否被n整除即可，能够整除则不是质数，否则是质数。 1234567891011public static boolean isPrime(int n){ if (n &lt;= 3) { return n &gt; 1; } for(int i = 2; i &lt; n; i++){ if (n % i == 0) { return false; } } return true;} 优化 我们继续分析，其实质数还有一个特点，就是它总是等于 6x-1 或者 6x+1，其中 x 是大于等于1的自然数。 如何论证这个结论呢，其实不难。首先 6x 肯定不是质数，因为它能被 6 整除；其次 6x+2 肯定也不是质数，因为它还能被2整除；依次类推，6x+3 肯定能被 3 整除；6x+4 肯定能被 2 整除。那么，就只有 6x+1 和 6x+5 (即等同于6x-1) 可能是质数了。所以循环的步长可以设为 6，然后每次只判断 6 两侧的数即可。 12345678910111213141516public static boolean isPrime(int num) { if (num &lt;= 3) { return num &gt; 1; } // 不在6的倍数两侧的一定不是质数 if (num % 6 != 1 &amp;&amp; num % 6 != 5) { return false; } int sqrt = (int) Math.sqrt(num); for (int i = 5; i &lt;= sqrt; i += 6) { if (num % i == 0 || num % (i + 2) == 0) { return false; } } return true;} 性能对比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;public class Main { public static void main(String[] args) { // Scanner in = new Scanner(System.in); // int n = in.nextInt(); // in.close(); Stack&lt;Integer&gt; a = new Stack&lt;&gt;(), b = new Stack&lt;&gt;(); int n = 100000; long s = System.currentTimeMillis(), e; for (int i = 1; i &lt; n; i++) { if (f(i)) a.push(i); } e = System.currentTimeMillis(); System.out.println(e - s + \" ms\"); s = System.currentTimeMillis(); for (int i = 1; i &lt; n; i++) { if (func(i)) b.push(i); } e = System.currentTimeMillis(); System.out.println(e - s + \" ms\"); System.gc(); } static boolean f(int n) { if (n &lt;= 3) return n &gt; 1; for (int i = 2; i &lt; n; i++) { if (n % i == 0) { return false; } } return true; } static boolean func(int n) { if (n &lt;= 3) return n &gt; 1; if (n % 6 != 1 &amp;&amp; n % 6 != 5) { return false; } int tem = (int) Math.sqrt(n); for (int i = 5; i &lt;= tem; i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; }} 121392 ms5 ms","link":"/2019/09/06/判断素数/"},{"title":"数据库备份恢复容器化项目实践经验总结","text":"数据库备份恢复容器化项目实践经验总结 本文分享了唯品会数据库Docker的异地容灾项目实践经验，项目中针对用户数据库的异地恢复场景的需求进行开发和测试，整合了网络，存储、调度、监控，镜像等多个模块。在实施完成后，从技术上总结关于选型、开发、踩坑、测试等方面的经验。 项目背景数据库Docker的异地备份恢复容灾项目，针对用户数据库的异地备份恢复场景的需求进行开发和测试，整合了容器网络、存储、调度、监控、镜像等多个模块。同时针对数据库的日常运维工作开发了监控、资源调度、日志、Puppet自动推送等工具。 通过Docker天生隔离性和快速部署等特点，实现在单台物理机上运行多个数据库备份/恢复实例，大大提高服务器使用率，节省大量成本。通过对Docker本身和相关组件的研究和改造，从普通开源产品落地到公司内部生产环境，积累宝贵的开发经验。通过对Docker已经在其上层运行的数据库日常运维和监控，也积累宝贵的Docker运维经验，为更大规模推广容器提供基础。 关于容器技术通过实践，证明容器技术在易用性，可管理性，快速部署具备天然的优势。在资源利用率方面，容器部署在上百个物理节点上，提供约500多个数据库灾备实例，提升了硬件资源的利用率，节约了约400台物理机的采购成本。这些是容器技术带来的实实在在收益。在资源分配与隔离方面，又不输于虚拟机。CPU、内存、磁盘IO、网络IO限流等技术的应用，保证了资源的合理使用，从机制上阻止了单一实例的资源过分消耗的问题。 稳定性是使用容器技术非常关注的一个点，也是基石。MySQL备份/恢复属于CPU密集 + 磁盘IO密集 + 网络IO密集型业务，对于Docker daemon是个较大的考验。就目前来看，限制每台宿主机的容器数量（5个左右）的情况下，集群跑了三个多月没有出现因为容器负载过大导致的crash现象，还是值得信赖的。遇到的唯一相关问题是Docker daemon挂死，具体现象是docker info、docker ps没有响应，docker volume、docker images 正常，下面的容器运行正常。这是偶发事件，无法重现，以后需要继续观察。 由于容器以进程方式存在，体现出几乎与物理机上相当的性能，Overheads极低（低于10%）。从数据抽取任务的结果来看，与物理机相比，使用容器对成功率没有影响，效率也差不多。这也很符合最初预想，不管跑容器还是外部服务从物理机角度来说它们之间是没有什么区别的，都是一个进程，唯一不同是父进程不一样而已。 以上是容器“RUN”带来的好处，通过统一开发流程，应用微服务化，CI/CD等方面的改进，能够进一步利用容器“BUILD”、“SHIP” 优势，容器技术还来的潜力是巨大的。要说容器技术的缺点，还真的不明显。硬要提的话一个是需要一定的学习成本，改变开发流程与方式，一个是开发人员对容器技术的接受程度。这个项目仅用了不到二百人/天，对于一个采用新技术的项目来说，真的是很低的了。一开始我们也担心因为采用新技术导致开发推广有困难，后来实际能通过技术上解决问题，打消了大部分用户对使用Docker的疑虑，反而有助于该技术的普遍应用。 关于Docker daemon版本的选择，我们之前是有过一些讨论的。现在Docker社区非常活跃，当时我们用1.10.3， 到现在已经出了两个新版本了。在功能满足的前提下，稳定性是第一考量。Docker自1.9.0引入CNM网络模型，1.10算是比较成熟。CNM是我们希望在这个项目尝试的一部分。网络与Volume插件功能与稳定性的提升，开始支持磁盘IO读写限速，Device Mapper的支持，等等，都是选择了这个版本的原因。另外，Docker插件的引入，很好地解耦了Docker与底层模块的关系，使我们可以专注于底层（网络、存储）实现而不需要修改Docker daemon本身，同时避免产生升级依赖。 关于容器存储容器外部卷使用Convoy，以插件的形式支持容器持久化数据。容器本身与外部卷均使用Device Mapper作为底层。没有选择分布式存储原因，主要是为了简化实现，更稳定。通过限制每个容器的BlkioDeviceReadBps、BlkioDeviceWriteBps、BlkioDeviceReadIOps、BlkioDeviceWriteIOps，使磁盘IO稳定地达到相当于95%物理机性能。 对于Device Mapper，因为是红帽推荐的，而OS又是用的CentOS7.2, 所以就用了它。测试过程中发现Device Mapper健壮性不是很好，仅仅在低并发下，也会出现容器删除失败的情况，容器并发启停偶尔出现找不到设备的情况。这种使用映射关系的设备，功能是丰富，实现上过于复杂，每次对设备的修改都需要额外去更新Metadata，并发场景出错的机会就大了。让我再选的话我会考虑Overlay这种更简单的driver。 对于Convoy，是来自Rancher的产品，Go语言，仍然处于未成熟阶段，版本号0.5, 并没有完全实现Volume Plugin接口。相比其它模块它的问题也是最多的，例如Volume创建失败，无法删除，UNIX Socket泄漏，重名冲突，异常自动退出等。属于能用，但未完善的状态，你自己得有一定开发调试能力去解决发现的问题。其它几个存储插件情况也差不多，Flocker、Blockbridge、Horcrux等等，有的连第一个正式发布版都还没有，Convoy反而相对好点，有点烂柿子堆里挑的感觉。 关于容器监控容器监控在这个项目里还可以有很大的空间可以改进。项目里用的是cAdvisor，容器内top、free、iostat命令劫持，基于已有的Zabbix体系作数据收集与展示。结论是Zabbix完全不合适做容器监控，数据收集密度，展示质量，灵活度都没能满足需求。 后来在测试中尝试使用Telegraf + InfluxDB + Grafana。 只需要Grafana简单的配置，能够帮忙我们清晰地展示容器及服务进程CPU、内存、网络、磁盘等情况。Grafana上SQL查询语句的调试与开发，确实需要不少的时间，但这个工作量是一次性的。因为是Go写的，Telegraf CPU占用属于比较低的水平（0.4 – 5%）。功能上比较丰富，同时支持外部进程与容器的数据收集，多达55种数据源插件，有它就不需要布cAdvisor了，个人比较推荐。需要告警的同学，可以考虑把influxDB改成Prometheus。它包含Alertmanager实现Email、PagerDuty等消息通知。数据Backend可以选择自带的DB，也可以外接influxDB、Graphite、OpenTSDB等流行方案。 监控领域业界已经有很多开源方案可以参考，以下是要衡量的标准：易扩展、开销低、入侵小、大集中、易部署、实时性、展现清晰灵活。这方面希望与各位有更多的交流。","link":"/2019/09/08/数据库备份恢复容器化项目实践经验总结/"},{"title":"技术栈","text":"HTML / CSS 【HTML】HTML，即超文本标记语言（Hyper Text Markup Language） 【HTML5】HTML5 是下一代 HTML 标准 【CSS】层叠样式表（Cascading StyleSheet） 【CSS3】CSS3是CSS技术的升级版本 【Bootstrap3】Bootstrap，来自 Twitter，是目前最受欢迎的前端框架 【Bootstrap4】Bootstrap4 目前是 Bootstrap 的最新版本 【Font Awesome】Font Awesome 是一套绝佳的图标字体库和CSS框架。 【Foundation】Foundation 用于开发响应式的 HTML, CSS and JavaScript 框架JavaScript 【JavaScript】JavaScript 是 Web 的编程语言 【HTML DOM】HTML DOM 定义了访问和操作 HTML 文档的标准方法 【jQuery】jQuery 是一个 JavaScript 库 【AngularJS】AngularJS 通过新的属性和表达式扩展了 HTML 【AngularJS2】AngularJS2 是一款开源JavaScript库，由Google维护。 【Vue.js】Vue.js 是一套构建用户界面的渐进式框架。 【React】React 是一个用于构建用户界面的 JAVASCRIPT 库 【TypeScript】TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准 【jQuery UI】jQuery UI 是建立在 jQuery上的一组用户界面交互、特效、小部件及主题 【jQuery EasyUI 】jQuery EasyUI 是一个基于 jQuery 的框架，集成了各种用户界面插件 【Node.js】Node.js 是运行在服务端的 JavaScript 【AJAX】AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） 【JSON】JSON 是存储和交换文本信息的语法 【Highcharts】Highcharts 是一个用纯JavaScript编写的一个图表库 【Google 地图】Google 地图接口使用说明 服务端 【PHP】PHP 是一种通用开源脚本语言 【Python】Python 是一种面向对象、解释型计算机程序设计语言 【Python3】Python 升级版，变化较大 【Django】Django是一个开放源代码的Web应用框架，由Python写成 【Linux】Linux是一套免费使用和自由传播的类Unix操作系统 【Docker】Docker 是一个开源的应用容器引擎，基于 Go 语言 【Ruby】一种为简单快捷的面向对象编程（面向对象程序设计）而创的脚本语言 【Java】一种可以撰写跨平台应用软件的面向对象的程序设计语言 【C】一门通用计算机编程语言 【C++】C++是在C语言的基础上开发的一种通用编程语言 【Perl】Perl 是高级、通用、直译式、动态的程序语言 【Servlet 】运行在 Web 服务器或应用服务器上的程序 【JSP】JSP与PHP、ASP、ASP.NET等语言类似，运行在服务端的语言 【Lua】Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放 【Scala】Scala 是一门多范式（multi-paradigm）的编程语言。 【Go】Go语言是谷歌推出的一种全新的编程语言 【设计模式】设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用 【正则表达式】正则表达式是对字符串操作的一种逻辑公式 【Maven】Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 【NumPy】NumPy 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算。 【ASP】ASP（Active Server Pages 动态服务器页面）是一种生成动态交互性网页的强有力工具 【AppML】AppML 是一个为web应用程序设计的HTML扩展框 【VBScript】一种微软环境下的轻量级的解释型语言 数据库 【SQL】结构化查询语言(Structured Query Language) 【Mysql】MySQL是一个关系型数据库管理系统 【PostgreSQL】PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS) 【SQLite】一款轻型的数据库 【MongoDB】Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql) 【Redis】一个高性能的key-value数据库 【Memcached】Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。 移动端 【Android】Android 是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备 【Swift】Swift 是一种支持多编程范式和编译式的编程语言,用于开发 iOS，OS X 和 watchOS应用程序。 【jQuery Mobile】jQuery Mobile是jQuery 在手机上和平板设备上的版本 【ionic】ionic 是一个强大的 HTML5 应用程序开发框架(HTML5 Hybrid Mobile App Framework ) 【Kotlin】在 Java 虚拟机上运行的静态类型编程语言，Android 官方开发语言 XML 教程 【XML】XML 被设计用来传输和存储数据 【DTD】DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块 【XML DOM】XML DOM 定义访问和操作XML文档的标准方法 【XSLT】XSL 是一个 XML 文档的样式表语言，XSLT 指 XSL 转换 【XPath】XPath 是一门在 XML 文档中查找信息的语言 【XQuery】XQuery 被设计用来查询 XML 数据 【XLink】XLink 定义在 XML 文档中创建超级链接的标准方法 【XPointer】XPointer是在可扩展标志语言（XML）文件中定位数据的一种语言 【XML Schema】XML Schema 描述了 XML文档的结构 【XSL-FO】XSL-FO 指可扩展样式表语言格式化对象 【SVG】SVG 使用 XML 格式定义图像 ASP.NET 【ASP.NET】ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架 【C#】C# 是一个简单的、现代的、通用的、面向对象的编程语言 【Web Pages】Web Pages 是三种网页编程模型中的一种，用于创建网站和web 应用程序 【Razor】Razor 是一种标记语法，可以让您将基于服务器的代码（Visual Basic 和 C#）嵌入到网页中 【MVC】MVC（Model View Controller 模型-视图-控制器） 【Web Forms】Web Forms 是三种创建 ASP.NET 网站和 Web 应用程序的编程模式中的一种 Web Service 【Web Service】Web Service 脚本平台需支持 XML + HTTP 【WSDL】WSDL是一门基于 XML 的语言，用于描述 Web Service 以及如何对它们进行访问 【SOAP】SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息 【RSS】RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议 【RDF】DF(资源描述框架)是描述网络资源的 W3C 标准 开发工具 【Eclipse】Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台 【Git】Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 【Svn】SVN 是一个开放源代码的版本控制系统 【Markdown】Markdown 是一种轻量级标记语 网站建设 【HTTP】HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议 【网站建设指南】网站建设指导课程 【浏览器信息】对于网站开发人员来说，浏览器信息和统计数据都是非常重要的 【网站主机教程】如果您希望向全世界发布自己的网站，那么您的网站就需要被放置于一个 WEB 服务器 【TCP/IP】TCP/IP 是因特网的通信协议 【W3C】W3C 让每个人都能在互联网上分享资源 【网站品质】何创建高质量的web网站 菜鸟教程","link":"/2019/08/18/技术栈/"},{"title":"晨间日记","text":"投资/理财/金钱** 最宝贵的金融资产就是赚钱的本领 ** 财富阅读 这天学到了 这天记账了么 这天的思考 梦想/创意/灵感/成绩/错误** 建立灯塔与修正方向的地方 ** 今天我要尝试的是 做本月总结 灵感涂鸭 昨天的进步是 昨天的不足是 每天向前走一步，Think Big Do Small ** 成功五事** 自信积极，积累成功 ** 昨天最成功的五件事 成功在哪里/一些感言 我的一天·创意人生** 助人助己，追求卓越 ** 财富 时间 思维 感悟和收获 日历** 鼠年x岁 ** 天气 什么日子 生日 纪念日 命运日 相遇日 起床时间 睡觉日间 体重 体温 心情 亲人爱人友人-五件小事** 越是持久的关系，越需要不断的储蓄 ** 特殊的人 朋友们 家人 昨天的情感收获 健康一生·坚持为胜** 睡眠·饮食·锻炼 ** 生理周期 身体异样 锻炼项目 排便 饮食 对身体的关注和健康的理解 学无止境·参悟一生** 每周阅读一轮回，每天阅读两小时 ** 社会·环境 个体·发展 文化·兴趣 其一·它二 体会感悟 专业关注** 博大精深我在其中 ** 专业关注一 专业关注二 专业关注三 其一·它二 体会感悟","link":"/2019/11/14/晨间日记/"},{"title":"深入理解Node.js 中的进程与线程","text":"前言进程与线程是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解进程与线程，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用。 面试会问 Node.js是单线程吗？ Node.js 做耗时的计算时候，如何避免阻塞？ Node.js如何实现多进程的开启和关闭？ Node.js可以创建线程吗？ 你们开发过程中如何实现进程守护的？ 除了使用第三方模块，你们自己是否封装过一个多进程架构? 进程进程Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 1234567const http = require('http');const server = http.createServer();server.listen(3000,()=&gt;{ process.title='程序员成长指北测试进程'; console.log('进程id',process.pid)}) 运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663 线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。 单线程单线程就是一个进程只开一个线程 Javascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。 123456789101112131415161718192021222324const http = require('http');const longComputation = () =&gt; { let sum = 0; for (let i = 0; i &lt; 1e10; i++) { sum += i; }; return sum;};const server = http.createServer();server.on('request', (req, res) =&gt; { if (req.url === '/compute') { console.info('计算开始',new Date()); const sum = longComputation(); console.info('计算结束',new Date()); return res.end(`Sum is ${sum}`); } else { res.end('Ok') }});server.listen(3000);//打印结果//计算开始 2019-07-28T07:08:49.849Z//计算结束 2019-07-28T07:09:04.522Z 查看打印结果，当我们调用127.0.0.1:3000/compute的时候，如果想要调用其他的路由地址比如127.0.0.1/大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。 单线程的一些说明 Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。 当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。 Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。 单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。","link":"/2019/09/05/深入理解Node-js-中的进程与线程/"},{"title":"树的高度（小米2017秋招真题）","text":"树的高度（小米2017秋招真题）题目题目描述 现在有一棵合法的二叉树，树的节点都是用数字表示，现在给定这棵树上所有的父子关系，求这棵树的高度 时间限制C/C++语言：1000MS 其它语言：3000MS 内存限制C/C++语言：65536KB 其它语言：589824KB 输入 输入的第一行表示节点的个数n（1&lt;=n&lt;=1000，节点的编号为0到n-1）组成，下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号 输出 输出树的高度，为一个整数 样例输入 1234550 10 21 31 4 样例输出 13 题解java 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = -1; } for (int i = 0; i &lt; n - 1; i++) { int a = sc.nextInt(); int b = sc.nextInt(); parent[b] = a; } int h = 0; for (int i = 0; i &lt; n; i++) { int max = 1; int j = i; while (parent[j] != -1) { j = parent[j]; max++; } h = max &gt; h ? max : h; } System.out.println(h); }} python 1234567891011121314import sysdef get(x): try: return 1 + get(dic_s[x]) except KeyError: return 1n = int(sys.stdin.readline().strip())dic_s = {}for i in range(int(n)-1): j_1,j_2 = sys.stdin.readline().strip().split() dic_s[j_2] = j_1print max([get(i) for i in set(dic_s.keys()) - set(dic_s.values())]) if n&gt;1 else 1 javascript 12345678910111213141516var n=readInt(),rec={},dps={},rs=1while(n--&gt;1) { var a=readInt(),b=readInt() rec[a]=rec[a]||[] rec[a].push(b)}for(var k in rec) rs=Math.max(rs,maxDps(k))print(rs)function maxDps(n){ if(!rec[n]) return 1 if(dps[n]) return dps[n] var r=1 for(var x of rec[n]) r=Math.max(r,maxDps(x)+1) dps[n]=r return dps[n]}","link":"/2019/09/05/树的高度（小米2017秋招真题）/"},{"title":"狂野飙车9","text":"兰博基尼 法拉利 布加迪 迈凯伦 兰博基尼 风神","link":"/2019/09/05/狂野飙车9/"},{"title":"灭霸脚本","text":"Thanos.shThis command could delete list half your files randomly. don’t use it at home and other places. this is a real gun, use it wisely… feel free to post your story on waiting.12345678910111213141516# 灭霸脚本这个命令会随机“删掉”您一半的文件。。请不要在家里或其他地方使用。这是真家伙，要小心…你可以在```Story.md```文件里发布你的故事，期待中… ## 特别说明 &gt; 1. 支持mac系统，但是需要使用到```gshuf```命令，需要通过```brew```安装,安装命令如下：```shell #安装brew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; #安装gshuf brew install coreutils` 此脚本只会列出当前目录一半的文件。并且。。。总之小心点。。。 Invoke-Thanos.ps1Invokes Thanos to remove each object with probability 1/2. It works with files, registry, environment variables, functions, variables, aliases and certificates. For help, use Get-Help .\\Invoke-Thanos.ps1. Be sure to not actually invoke it! 123456789101112131415#!/bin/shlet \"i=`find . -type f | wc -l`/2\";if [[ uname==\"Darwin\" ]]; then find . -not -name \"Thanos.sh\" -type f -print0 | gshuf -z -n $i | xargs -0 -- cat;else find . -not -name \"Thanos.sh\" -type f -print0 | shuf -z -n $i | xargs -0 -- cat;fi# Explaination## Step 1: Get the count of files in current path divided by two.## Step 2: Get all the files in current path and print in one line.## Step 3: Turn half of the second step output into standard input randomly.## Step 4: Show half of the files in terminal.# Key Point## If you want to make delete, what you need to do is turn 'cat' into 'rm'. 本人在线上服务器上运行了一次，…","link":"/2019/09/09/灭霸脚本/"},{"title":"面试笔记","text":"牛客许愿的小米一面，贡献面经1许愿能挺进二面，加油，向着目标冲呀~~~~ ——java集合相关 object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（） hashmap的put过程 主要就是根据自己看过的源码说一下流程ArrayList LinkList的特点 ——多线程相关 synchronized reettrantLock 除了可重入还有什么关键特性 threadLocal threadLocal 会造成什么问题 为什么会造成内存泄漏 单例模式 synchronized实现懒汉模式 答 内部类 为什么用内部类是线程安全的？ ——数据库相关 添加索引的时候要注意什么 索引优化以及在使用索引的时候要注意什么 redis的键的淘汰策略，会达成了redis缓存的淘汰策略 ——网络相关 tcp四次握手，最后的状态是什么，回答等待2MSL 为什么要等着2MSL，等待多了会造成什么 http请求的报文结构，keep-alive是用来做什么的 ——spring spingboot spring中对象增强如何实现 回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程 ——口述算法思路 给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1） 之前一直没明白是要做什么，后来想到做过类似的题。幸好只是说思路，没有要手写，那个时候已经被前面几个回答的不太好的问题难的很紧张，说做个简单的算法题的时候，我的心紧紧一颤，心想，你确定会简单，还好，还好，结果下来没那么难 ——网络编程 哪几种IO类型 还有一个问题 有点忘了，这一块在简历上写了，不过掌握的不是很好 ——JVM 类加载机制——回答了一下双亲委派模型相关的内容 ——有什么想问我的 面试官蛮年轻，真的很好，一直在引导我回答问题，不会的也没有揪着不放很喜欢说，我们接下来问一个简单的问题，哈哈哈，简单简单着就变得不简单了 是自己比较满意的一次面试 既展示了自己所掌握的知识，也暴露了掌握知识中的问题，给自己后面的复习有了一定的指引 感谢CYC大佬的秘籍1234最后，重要的话再来几次许愿能挺进二面，加油，向着目标冲呀~~~~ 许愿能挺进二面，加油，向着目标冲呀1许愿能挺进二面，加油，向着目标冲呀","link":"/2019/09/18/面试笔记/"},{"title":"骨传导","text":"骨传导 骨传导是一种声音传导方式，即通过将声音转化为不同频率的机械振动，通过人的颅骨、骨迷路、内耳淋巴液传递、螺旋器、听神经、听觉中枢来传递声波。相对于通过振膜产生声波的经典声音传导方式，骨传导省去了许多声波传递的步骤，能在嘈杂的环境中实现清晰的声音还原，而且声波也不会因为在空气中扩散而影响到他人。 骨传导技术分为骨传导扬声器技术和骨传导麦克风技术： 骨传导扬声器技术 用于受话，受话即听取声音。气导扬声器是把电信号转化为的声波（振动信号传至听神经。而骨传导扬声器则是电信号转化的声波（振动信号）直接通过骨头传至听神经。声波（振动信号）的传递介质不同。 骨传导麦克风技术 用于送话，送话即收集声音。气导送话是声波通过空气传至麦克风，而骨传导送话则直接通过骨头传递。 利用这些骨传导技术制造的耳机，称之为骨传导耳机，也被称作骨导耳机、骨感耳机、骨传耳机和骨传感耳机。 原文链接","link":"/2019/09/12/骨传导/"},{"title":"面试红黑树","text":"什么是红黑树红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。 它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。 由于 TreeMap 就是由红黑树实现的，因此本文将使用 TreeMap 的相关操作的代码进行分析、论证。 黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。 红黑树的 5 个特性 红黑树在原有的二叉查找树基础上增加了如下几个要求： Every node is either red or black. The root is black. Every leaf (NIL) is black. If a node is red, then both its children are black. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. 中文意思是： 每个节点要么是红色，要么是黑色； 根节点永远是黑色的； 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）； 每个红色节点的两个子节点一定都是黑色； 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点； 注意：性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。 性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。 性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。 红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。 红黑树的左旋右旋 红黑树的左右旋是比较重要的操作，左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。 比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。 我们以 Java 集合框架中的 TreeMap 中的代码来看下左右旋的具体操作方法： 指定节点 x 的左旋 (右图转成左图)： 123456789101112131415161718 //这里 p 代表 xprivate void rotateLeft(Entry p) { if (p != null) { Entry r = p.right; // p 是上图中的 x，r 就是 y p.right = r.left; // 左旋后，x 的右子树变成了 y 的左子树 β if (r.left != null) r.left.parent = p; //β 确认父亲为 x r.parent = p.parent; //y 取代 x 的第一步：认 x 的父亲为爹 if (p.parent == null) //要是 x 没有父亲，那 y 就是最老的根节点 root = r; else if (p.parent.left == p) //如果 x 有父亲并且是它父亲的左孩子，x 的父亲现在认 y 为左孩子，不要 x 了 p.parent.left = r; else //如果 x 是父亲的右孩子，父亲就认 y 为右孩子，抛弃 x p.parent.right = r; r.left = p; //y 逆袭成功，以前的爸爸 x 现在成了它的左孩子 p.parent = r; }} 可以看到，x 节点的左旋就是把 x 变成 右孩子 y 的左孩子，同时把 y 的左孩子送给 x 当右子树。 简单点记就是：左旋把右子树里的一个节点（上图 β）移动到了左子树。 指定节点 y 的右旋（左图转成右图）： 123456789101112131415private void rotateRight(Entry p) { if (p != null) { Entry l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; }} 同理，y 节点的右旋就是把 y 变成 左孩子 x 的右孩子，同时把 x 的右孩子送给 x 当左子树。 简单点记就是：右旋把左子树里的一个节点（上图 β）移动到了右子树。 了解左旋、右旋的方法及意义后，就可以了解红黑树的主要操作：插入、删除。 总结红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。 红黑树的插入、删除调整逻辑比较复杂，但最终目的是满足红黑树的 5 个特性，尤其是 4 和 5。 在插入调整时为了简化操作我们直接把插入的节点涂成红色，这样只要保证插入节点的父节点不是红色就可以了。 而在删除后的调整中，针对删除黑色节点，所在子树缺少一个节点，需要进行弥补或者对别人造成一个黑色节点的伤害。具体调整方法取决于兄弟节点所在子树的情况。 红黑树的插入、删除在树形数据结构中算比较复杂的，理解起来比较难，但只要记住，红黑树有其特殊的平衡规则，而我们为了维持平衡，根据邻树的状况进行旋转或者涂色。 红黑树这么难理解，必定有其过人之处。它的有序、快速特性在很多场景下都有用到，比如 Java 集合框架的 TreeMap, TreeSet 等。","link":"/2019/09/08/面试红黑树/"},{"title":"Airbnb JavaScript 代码规范() {","text":"Airbnb JavaScript 代码规范() {一种写JavaScript更合理的代码风格。 Note: 本指南假设你使用了 Babel, 并且要求你使用 babel-preset-airbnb 或者其他同等资源。 并且假设你在你的应用中安装了 shims/polyfills ，使用airbnb-browser-shims 或者相同功能。 其他代码风格指南 ES5 (Deprecated) React CSS-in-JavaScript CSS &amp; Sass Ruby 目录 类型 引用 对象 数组 解构 字符 方法 箭头函数 类和构造器 模块 迭代器和发生器 属性 变量 提升 比较运算符和等号 块 控制语句 注释 空白 逗号 分号 类型转换和强制类型转换 命名规范 存取器 事件 jQuery ECMAScript 5 兼容性 ECMAScript 6+ (ES 2015+) 风格 标准库 测试 性能 资源 JavaScript风格指南的指南 许可证 修正案 类型 1.1 原始值: 当你访问一个原始类型的时候，你可以直接使用它的值。 string number boolean null undefined symbol 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 Symbols cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don’t support them natively. 1.2 复杂类型: 当你访问一个复杂类型的时候，你需要一个值得引用。 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 返回目录 引用 2.1 使用 const 定义你的所有引用；避免使用 var。 eslint: prefer-const, no-const-assign 为什么? 这样能够确保你不能从新分配你的引用，否则可能导致错误或者产生难以理解的代码。. 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 如果你必须重新分配你的引用， 使用 let 代替 var。 eslint: no-var 为什么? let 是块级作用域，而不像 var 是函数作用域. 1234567891011// badvar count = 1;if (true) { count += 1;}// good, use the let.let count = 1;if (true) { count += 1;} 2.3 注意，let 和 const 都是块级范围的。 1234567// const 和 let 只存在于他们定义的块中。{ let a = 1; const b = 1;}console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError ⬆ 返回目录 对象 3.1 使用字面语法来创建对象。 eslint: no-new-object 12345// badconst item = new Object();// goodconst item = {}; 3.2 在创建具有动态属性名称的对象时使用计算属性名。 为什么? 它允许你在一个地方定义对象的所有属性。 123456789101112131415161718function getKey(k) { return `a key named ${k}`;}// badconst obj = { id: 5, name: 'San Francisco',};obj[getKey('enabled')] = true;// goodconst obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true,}; 3.3 使用对象方法的缩写。 eslint: object-shorthand 1234567891011121314151617// badconst atom = { value: 1, addValue: function (value) { return atom.value + value; },};// goodconst atom = { value: 1, addValue(value) { return atom.value + value; },}; 3.4 使用属性值的缩写。 eslint: object-shorthand 为什么? 它的写法和描述较短。 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = { lukeSkywalker: lukeSkywalker,};// goodconst obj = { lukeSkywalker,}; 3.5 在对象声明的时候将简写的属性进行分组。 为什么? 这样更容易的判断哪些属性使用的简写。 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,};// goodconst obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,}; 3.6 只使用引号标注无效标识符的属性。 eslint: quote-props 为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。 12345678910111213// badconst bad = { 'foo': 3, 'bar': 4, 'data-blah': 5,};// goodconst good = { foo: 3, bar: 4, 'data-blah': 5,}; 3.7 不能直接调用 Object.prototype 的方法，如： hasOwnProperty 、 propertyIsEnumerable 和 isPrototypeOf。 为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 { hasOwnProperty: false } - 或者，对象是一个空对象 (Object.create(null))。 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // 在模块范围内的缓存中查找一次/* or */import has from 'has'; // https://www.npmjs.com/package/has// ...console.log(has.call(object, key)); 3.8 更喜欢对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。 1234567891011121314// very badconst original = { a: 1, b: 2 };const copy = Object.assign(original, { c: 3 }); // 变异的 `original` ಠ_ಠdelete copy.a; // 这....// badconst original = { a: 1, b: 2 };const copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2, c: 3 }// goodconst original = { a: 1, b: 2 };const copy = { ...original, c: 3 }; // copy =&gt; { a: 1, b: 2, c: 3 }const { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 } ⬆ 返回目录 数组 4.1 使用字面语法创建数组。 eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 4.2 使用 Array#push 取代直接赋值来给数组添加项。 1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 使用数组展开方法 ... 来拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) { itemsCopy[i] = items[i];}// goodconst itemsCopy = [...items]; 4.4 将一个类数组对象转换成一个数组， 使用展开方法 ... 代替 Array.from。 1234567const foo = document.querySelectorAll('.foo');// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; 4.5 对于对迭代器的映射，使用 Array.from 替代展开方法 ... ， 因为它避免了创建中间数组。 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); 4.6 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 8.2。 eslint: array-callback-return 1234567891011121314151617181920212223242526272829303132333435363738394041// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map(x =&gt; x + 1);// bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item); acc[index] = flatten;});// good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item); acc[index] = flatten; return flatten;});// badinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } else { return false; }});// goodinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } return false;}); 4.7 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。 12345678910111213141516171819202122232425262728293031// badconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [{ id: 1,}, { id: 2,}];const numberInArray = [ 1, 2,];// goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [ { id: 1, }, { id: 2, },];const numberInArray = [ 1, 2,]; ⬆ 返回目录 解构 5.1 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: prefer-destructuring 为什么? 解构可以避免为这些属性创建临时引用。 123456789101112131415161718// badfunction getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`;}// goodfunction getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`;}// bestfunction getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`;} 5.2 使用数组解构。 eslint: prefer-destructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 对于多个返回值使用对象解构，而不是数组解构。 为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。 1234567891011121314151617// badfunction processInput(input) { // 处理代码... return [left, right, top, bottom];}// 调用者需要考虑返回数据的顺序。const [left, __, top] = processInput(input);// goodfunction processInput(input) { // 处理代码... return { left, right, top, bottom };}// 调用者只选择他们需要的数据。const { left, top } = processInput(input); ⬆ 返回目录 字符 6.1 使用单引号 '' 定义字符串。 eslint: quotes 12345678// badconst name = \"Capt. Janeway\";// bad - 模板文字应该包含插值或换行。const name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 6.2 使行超过100个字符的字符串不应使用字符串连接跨多行写入。 为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; 6.3 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: prefer-template template-curly-spacing 为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。 12345678910111213141516171819// badfunction sayHi(name) { return 'How are you, ' + name + '?';}// badfunction sayHi(name) { return ['How are you, ', name, '?'].join();}// badfunction sayHi(name) { return `How are you, ${ name }?`;}// goodfunction sayHi(name) { return `How are you, ${name}?`;} 6.4 不要在字符串上使用 eval() ，它打开了太多漏洞。 eslint: no-eval 6.5 不要转义字符串中不必要的字符。 eslint: no-useless-escape 为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `my name is '${name}'`; ⬆ 返回目录 方法 7.1 使用命名的函数表达式代替函数声明。 eslint: func-style 为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (Discussion) 123456789101112131415// badfunction foo() { // ...}// badconst foo = function () { // ...};// good// 从变量引用调用中区分的词汇名称const short = function longUniqueMoreDescriptiveLexicalFoo() { // ...}; 7.2 Wrap立即调用函数表达式。 eslint: wrap-iife 为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。 1234// immediately-invoked function expression (IIFE) 立即调用的函数表达式(function () { console.log('Welcome to the Internet. Please follow me.');}()); 7.3 切记不要在非功能块中声明函数 (if, while, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: no-loop-func 7.4 注意: ECMA-262 将 block 定义为语句列表。 函数声明不是语句。 1234567891011121314// badif (currentUser) { function test() { console.log('Nope.'); }}// goodlet test;if (currentUser) { test = () =&gt; { console.log('Yup.'); };} 7.5 永远不要定义一个参数为 arguments。 这将会优先于每个函数给定范围的 arguments 对象。 123456789// badfunction foo(name, options, arguments) { // ...}// goodfunction foo(name, options, args) { // ...} 7.6 不要使用 arguments, 选择使用 rest 语法 ... 代替。 eslint: prefer-rest-params 为什么? ... 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 arguments 。 12345678910// badfunction concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join('');}// goodfunction concatenateAll(...args) { return args.join('');} 7.7 使用默认的参数语法，而不是改变函数参数。 123456789101112131415161718192021// really badfunction handleThings(opts) { // No! We shouldn’t mutate function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || {}; // ...}// still badfunction handleThings(opts) { if (opts === void 0) { opts = {}; } // ...}// goodfunction handleThings(opts = {}) { // ...} 7.8 避免使用默认参数的副作用。 为什么? 他们很容易混淆。 123456789var b = 1;// badfunction count(a = b++) { console.log(a);}count(); // 1count(); // 2count(3); // 3count(); // 3 7.9 总是把默认参数放在最后。 123456789// badfunction handleThings(opts = {}, name) { // ...}// goodfunction handleThings(name, opts = {}) { // ...} 7.10 永远不要使用函数构造器来创建一个新函数。 eslint: no-new-func 为什么? 以这种方式创建一个函数将对一个类似于 eval() 的字符串进行计算，这将打开漏洞。 12345// badvar add = new Function('a', 'b', 'return a + b');// still badvar subtract = Function('a', 'b', 'return a - b'); 7.11 函数签名中的间距。 eslint: space-before-function-paren space-before-blocks 为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。 12345678// badconst f = function(){};const g = function (){};const h = function() {};// goodconst x = function () {};const y = function a() {}; 7.12 没用变异参数。 eslint: no-param-reassign 为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。 123456789// badfunction f1(obj) { obj.key = 1;}// goodfunction f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;} 7.13 不要再分配参数。 eslint: no-param-reassign 为什么? 重新分配参数会导致意外的行为，尤其是在访问 arguments 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。 1234567891011121314151617181920// badfunction f1(a) { a = 1; // ...}function f2(a) { if (!a) { a = 1; } // ...}// goodfunction f3(a) { const b = a || 1; // ...}function f4(a = 1) { // ...} 7.14 优先使用扩展运算符 ... 来调用可变参数函数。 eslint: prefer-spread 为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 apply 来 new 。 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));// goodnew Date(...[2016, 8, 5]); 7.15 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: function-paren-newline 123456789101112131415161718192021222324252627// badfunction foo(bar, baz, quux) { // ...}// goodfunction foo( bar, baz, quux,) { // ...}// badconsole.log(foo, bar, baz);// goodconsole.log( foo, bar, baz,); ⬆ 返回目录 箭头函数 8.1 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: prefer-arrow-callback, arrow-spacing 为什么? 它创建了一个在 this 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。 为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。 1234567891011// bad[1, 2, 3].map(function (x) { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.2 如果函数体包含一个单独的语句，返回一个没有副作用的 expression ， 省略括号并使用隐式返回。否则，保留括号并使用 return 语句。 eslint: arrow-parens, arrow-body-style 为什么? 语法糖。 多个函数被链接在一起时，提高可读性。 12345678910111213141516171819202122232425262728293031323334353637// bad[1, 2, 3].map(number =&gt; { const nextNumber = number + 1; `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map(number =&gt; `A string containing the ${number}.`);// good[1, 2, 3].map((number) =&gt; { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map((number, index) =&gt; ({ [index]: number,}));// 没有副作用的隐式返回function foo(callback) { const val = callback(); if (val === true) { // 如果回调返回 true 执行 }}let bool = false;// badfoo(() =&gt; bool = true);// goodfoo(() =&gt; { bool = true;}); 8.3 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。 为什么? 它清楚地显示了函数的起点和终点。 1234567891011121314// bad['get', 'post', 'put'].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ));// good['get', 'post', 'put'].map(httpMethod =&gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ))); 8.4 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 “always” option 来配置 eslint. eslint: arrow-parens 为什么? 减少视觉上的混乱。 12345678910111213141516171819202122// bad[1, 2, 3].map((x) =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(number =&gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.5 避免箭头函数符号 (=&gt;) 和比较运算符 (&lt;=, &gt;=) 的混淆。 eslint: no-confusing-arrow 1234567891011121314// badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);// goodconst itemHeight = (item) =&gt; { const { height, largeSize, smallSize } = item; return height &gt; 256 ? largeSize : smallSize;}; 8.6 注意带有隐式返回的箭头函数函数体的位置。 eslint: implicit-arrow-linebreak 12345678910111213// bad(foo) =&gt; bar;(foo) =&gt; (bar);// good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; ( bar) ⬆ 返回目录 类和构造器 9.1 尽量使用 class. 避免直接操作 prototype . 为什么? class 语法更简洁，更容易推理。 123456789101112131415161718192021// badfunction Queue(contents = []) { this.queue = [...contents];}Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value;};// goodclass Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; }} 9.2 使用 extends 来扩展继承。 为什么? 它是一个内置的方法，可以在不破坏 instanceof 的情况下继承原型功能。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) { Queue.apply(this, contents);}inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () { return this.queue[0];};// goodclass PeekableQueue extends Queue { peek() { return this.queue[0]; }} 9.3 方法返回了 this 来供其内部方法调用。 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function () { this.jumping = true; return true;};Jedi.prototype.setHeight = function (height) { this.height = height;};const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; }}const luke = new Jedi();luke.jump() .setHeight(20); 9.4 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 toString() 方法也是可以的。 12345678910111213class Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; }} 9.5 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: no-useless-constructor 1234567891011121314151617181920212223// badclass Jedi { constructor() {} getName() { return this.name; }}// badclass Rey extends Jedi { constructor(...args) { super(...args); }}// goodclass Rey extends Jedi { constructor(...args) { super(...args); this.name = 'Rey'; }} 9.6 避免定义重复的类成员。 eslint: no-dupe-class-members 为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。 123456789101112131415// badclass Foo { bar() { return 1; } bar() { return 2; }}// goodclass Foo { bar() { return 1; }}// goodclass Foo { bar() { return 2; }} ⬆ 返回目录 模块 10.1 你可能经常使用模块 (import/export) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。 为什么? 模块是未来的趋势，让我们拥抱未来。 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport { es6 } from './AirbnbStyleGuide';export default es6; 10.2 不要使用通配符导入。 为什么? 这确定你有一个单独的默认导出。 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 不要直接从导入导出。 为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。 12345678// bad// filename es6.jsexport { es6 as default } from './AirbnbStyleGuide';// good// filename es6.jsimport { es6 } from './AirbnbStyleGuide';export default es6; 10.4 只从一个路径导入所有需要的东西。eslint: no-duplicate-imports 为什么? 从同一个路径导入多个行，使代码更难以维护。 12345678910111213// badimport foo from 'foo';// … 其他导入 … //import { named1, named2 } from 'foo';// goodimport foo, { named1, named2 } from 'foo';// goodimport foo, { named1, named2,} from 'foo'; 10.5 不要导出可变的引用。eslint: import/no-mutable-exports 为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。 1234567// badlet foo = 3;export { foo };// goodconst foo = 3;export { foo }; 10.6 在单个导出的模块中，选择默认模块而不是指定的导出。eslint: import/prefer-default-export 为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。 12345// badexport function foo() {}// goodexport default function foo() {} 10.7 将所有的 imports 语句放在所有非导入语句的上边。eslint: import/first 为什么? 由于所有的 imports 都被提前，保持他们在顶部是为了防止意外发生。 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 10.8 多行导入应该像多行数组和对象一样缩进。 为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。 1234567891011// badimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';// goodimport { longNameA, longNameB, longNameC, longNameD, longNameE,} from 'path'; 10.9 在模块导入语句中禁止使用 Webpack 加载器语法。eslint: import/no-webpack-loader-syntax 为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 webpack.config.js 中使用加载器语法。 1234567// badimport fooSass from 'css!sass!foo.scss';import barCss from 'style!css!bar.css';// goodimport fooSass from 'foo.scss';import barCss from 'bar.css'; ⬆ 返回目录 迭代器和发生器 11.1 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of。 eslint: no-iterator no-restricted-syntax 为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。 使用 map() / every() / filter() / find() / findIndex() / reduce() / some() / … 遍历数组， 和使用 Object.keys() / Object.values() / Object.entries() 迭代你的对象生成数组。 12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) { sum += num;}sum === 15;// goodlet sum = 0;numbers.forEach((num) =&gt; { sum += num;});sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15;// badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) { increasedByOne.push(numbers[i] + 1);}// goodconst increasedByOne = [];numbers.forEach((num) =&gt; { increasedByOne.push(num + 1);});// best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1); 11.2 不要使用发生器。 为什么? They don’t transpile well to ES5. 11.3 如果你必须使用发生器或者无视 我们的建议，请确保他们的函数签名是正常的间隔。 eslint: generator-star-spacing 为什么? function 和 * 是同一个概念关键字的一部分 - * 不是 function 的修饰符， function* 是一个不同于 function 的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badfunction * foo() { // ...}// badconst bar = function * () { // ...};// badconst baz = function *() { // ...};// badconst quux = function*() { // ...};// badfunction*foo() { // ...}// badfunction *foo() { // ...}// very badfunction*foo() { // ...}// very badconst wat = function*() { // ...};// goodfunction* foo() { // ...}// goodconst foo = function* () { // ...}; ⬆ 返回目录 属性 12.1 访问属性时使用点符号。 eslint: dot-notation 12345678910const luke = { jedi: true, age: 28,};// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 使用变量访问属性时，使用 []表示法。 12345678910const luke = { jedi: true, age: 28,};function getProp(prop) { return luke[prop];}const isJedi = getProp('jedi'); 12.3 计算指数时，可以使用 ** 运算符。 eslint: no-restricted-properties. 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; ⬆ 返回目录 变量 13.1 使用 const 或者 let 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 使用 const 或者 let 声明每一个变量。 eslint: one-var 为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 ; 还是使用 , 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 把 const 声明的放在一起，把 let 声明的放在一起。. 为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 在你需要的使用定义变量，但是要把它们放在一个合理的地方。 为什么? let 和 const 是块级作用域而不是函数作用域。 12345678910111213141516171819202122232425262728293031// bad - 不必要的函数调用function checkName(hasName) { const name = getName(); if (hasName === 'test') { return false; } if (name === 'test') { this.setName(''); return false; } return name;}// goodfunction checkName(hasName) { if (hasName === 'test') { return false; } const name = getName(); if (name === 'test') { this.setName(''); return false; } return name;} 13.5 不要链式变量赋值。 eslint: no-multi-assign 为什么? 链式变量赋值会创建隐式全局变量。 123456789101112131415161718192021222324// bad(function example() { // JavaScript 把它解释为 // let a = ( b = ( c = 1 ) ); // let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。 let a = b = c = 1;}());console.log(a); // throws ReferenceErrorconsole.log(b); // 1console.log(c); // 1// good(function example() { let a = 1; let b = a; let c = a;}());console.log(a); // throws ReferenceErrorconsole.log(b); // throws ReferenceErrorconsole.log(c); // throws ReferenceError// 对于 `const` 也一样 13.6 避免使用不必要的递增和递减 (++, --)。 eslint no-plusplus 为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 num += 1 这样的语句来改变您的值，而不是使用 num++ 或 num ++ 。不允许不必要的增量和减量语句也会使您无法预先递增/预递减值，这也会导致程序中的意外行为。 1234567891011121314151617181920212223242526// badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) { let value = array[i]; sum += value; if (value) { truthyCount++; }}// goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; 13.7 避免在赋值语句 = 前后换行。如果你的代码违反了 max-len， 使用括号包裹。 eslint operator-linebreak. 为什么? 在 = 前后换行，可能混淆分配的值。 123456789101112131415// badconst foo = superLongLongLongLongLongLongLongLongFunctionName();// badconst foo = 'superLongLongLongLongLongLongLongLongString';// goodconst foo = ( superLongLongLongLongLongLongLongLongFunctionName());// goodconst foo = 'superLongLongLongLongLongLongLongLongString'; ⬆ 返回目录 提升 14.1 var 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。const 和 let 声明的变量受到一个称之为 Temporal Dead Zones (TDZ) 的新概念保护。 知道为什么 typeof 不在安全 是很重要的。 1234567891011121314151617181920212223242526// 我们知道这个行不通 (假设没有未定义的全局变量)function example() { console.log(notDefined); // =&gt; throws a ReferenceError}// 在引用变量后创建变量声明将会因变量提升而起作用。// 注意: 真正的值 `true` 不会被提升。function example() { console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;}// 解释器将变量提升到函数的顶部// 这意味着我们可以将上边的例子重写为：function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;}// 使用 const 和 letfunction example() { console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;} 14.2 匿名函数表达式提升变量名，而不是函数赋值。 123456789function example() { console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); };} 14.3 命名函数表达式提升的是变量名，而不是函数名或者函数体。 12345678910111213141516171819202122function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); };}// 当函数名和变量名相同时也是如此。function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() { console.log('named'); };} 14.4 函数声明提升其名称和函数体。 1234567function example() { superPower(); // =&gt; Flying function superPower() { console.log('Flying'); }} 更多信息请参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。 ⬆ 返回目录 比较运算符和等号 15.1 使用 === 和 !== 而不是 == 和 !=。 eslint: eqeqeq 15.2 条件语句，例如 if 语句使用 ToBoolean 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则： Objects 的取值为： true Undefined 的取值为： false Null 的取值为： false Booleans 的取值为： 布尔值的取值 Numbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true Strings 的取值为: 如果是一个空字符串 '' 值为 false 否则为 true 1234if ([0] &amp;&amp; []) { // true // 一个数组（既是是空的）是一个对象，对象的取值为 true} 15.3 对于布尔值使用简写，但是对于字符串和数字进行显式比较。 1234567891011121314151617181920212223242526272829// badif (isValid === true) { // ...}// goodif (isValid) { // ...}// badif (name) { // ...}// goodif (name !== '') { // ...}// badif (collection.length) { // ...}// goodif (collection.length &gt; 0) { // ...} 15.4 获取更多信息请查看 Angus Croll 的 Truth Equality and JavaScript 。 15.5 在 case 和 default 的子句中，如果存在声明 (例如. let, const, function, 和 class)，使用大括号来创建块 。 eslint: no-case-declarations 为什么? 语法声明在整个 switch 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 case 条件达到才会发生。 当多个 case 语句定义相同的东西是，这会导致问题问题。 12345678910111213141516171819202122232425262728293031323334353637383940// badswitch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {}}// goodswitch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} }} 15.6 三目表达式不应该嵌套，通常是单行表达式。 eslint: no-nested-ternary 123456789101112131415// badconst foo = maybe1 &gt; maybe2 ? \"bar\" : value1 &gt; value2 ? \"baz\" : null;// 分离为两个三目表达式const maybeNull = value1 &gt; value2 ? 'baz' : null;// betterconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 15.7 避免不必要的三目表达式。 eslint: no-unneeded-ternary 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 15.8 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (+, -, *, &amp; /) 因为他们的优先级被广泛理解。 eslint: no-mixed-operators 为什么? 这能提高可读性并且表明开发人员的意图。 12345678910111213141516171819202122232425// badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;// badconst bar = a ** b - 5 % d;// bad// 可能陷入一种 (a || b) &amp;&amp; c 的思考if (a || b &amp;&amp; c) { return d;}// goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);// goodconst bar = (a ** b) - (5 % d);// goodif (a || (b &amp;&amp; c)) { return d;}// goodconst bar = a + b / c * d; ⬆ 返回目录 块 16.1 当有多行代码块的时候，使用大括号包裹。 eslint: nonblock-statement-body-position 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) { return false;}// badfunction foo() { return false; }// goodfunction bar() { return false;} 16.2 如果你使用的是 if 和 else 的多行代码块，则将 else 语句放在 if 块闭括号同一行的位置。 eslint: brace-style 12345678910111213141516// badif (test) { thing1(); thing2();}else { thing3();}// goodif (test) { thing1(); thing2();} else { thing3();} 16.3 如果一个 if 块总是执行一个 return 语句，那么接下来的 else 块就没有必要了。 如果一个包含 return 语句的 else if 块，在一个包含了 return 语句的 if 块之后，那么可以拆成多个 if 块。 eslint: no-else-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// badfunction foo() { if (x) { return x; } else { return y; }}// badfunction cats() { if (x) { return x; } else if (y) { return y; }}// badfunction dogs() { if (x) { return x; } else { if (y) { return y; } }}// goodfunction foo() { if (x) { return x; } return y;}// goodfunction cats() { if (x) { return x; } if (y) { return y; }}// goodfunction dogs(x) { if (x) { if (z) { return y; } } else { return z; }} ⬆ 返回目录 控制语句 17.1 如果你的控制语句 (if, while 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。 为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// badif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( (foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// goodif (foo === 123 &amp;&amp; bar === 'abc') { thing1();} 17.2 不要使用选择操作符代替控制语句。 1234567// bad!isRunning &amp;&amp; startRunning();// goodif (!isRunning) { startRunning();} ⬆ 返回目录 注释 18.1 使用 /** ... */ 来进行多行注释。 123456789101112131415161718192021222324// bad// make() returns a new element// based on the passed in tag name//// @param {String} tag// @return {Element} elementfunction make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.2 使用 // 进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// goodfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// also goodfunction getType() { // set the default type to 'no type' const type = this.type || 'no type'; return type;} 18.3 用一个空格开始所有的注释，使它更容易阅读。 eslint: spaced-comment 12345678910111213141516171819202122232425262728293031// bad//is current tabconst active = true;// good// is current tabconst active = true;// bad/** *make() returns a new element *based on the passed-in tag name */function make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.4 使用 FIXME 或者 TODO 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 FIXME: -- 需要解决这个问题 或者 TODO: -- 需要被实现。 18.5 使用 // FIXME: 注释一个问题。 12345678class Calculator extends Abacus { constructor() { super(); // FIXME: 这里不应该使用全局变量 total = 0; }} 18.6 使用 // TODO: 注释解决问题的方法。 12345678class Calculator extends Abacus { constructor() { super(); // TODO: total 应该由一个 param 的选项配置 this.total = 0; }} ⬆ 返回目录 空白 19.1 使用 tabs (空格字符) 设置为 2 个空格。 eslint: indent 1234567891011121314// badfunction foo() {∙∙∙∙let name;}// badfunction bar() {∙let name;}// goodfunction baz() {∙∙let name;} 19.2 在主体前放置一个空格。 eslint: space-before-blocks 123456789101112131415161718192021// badfunction test(){ console.log('test');}// goodfunction test() { console.log('test');}// baddog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog',});// gooddog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog',}); 19.3 在控制语句（if, while 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: keyword-spacing 12345678910111213141516171819// badif(isJedi) { fight ();}// goodif (isJedi) { fight();}// badfunction fight () { console.log ('Swooosh!');}// goodfunction fight() { console.log('Swooosh!');} 19.4 用空格分离操作符。 eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; 19.5 使用单个换行符结束文件。 eslint: eol-last 1234// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6; 12345// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵↵ 1234// goodimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵ 19.6 在使用长方法连滴啊用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: newline-per-chained-call no-whitespace-before-property 12345678910111213141516171819202122232425262728293031323334353637// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led').data(data); 19.7 在块和下一个语句之前留下一空白行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// badif (foo) { return bar;}return baz;// goodif (foo) { return bar;}return baz;// badconst obj = { foo() { }, bar() { },};return obj;// goodconst obj = { foo() { }, bar() { },};return obj;// badconst arr = [ function foo() { }, function bar() { },];return arr;// goodconst arr = [ function foo() { }, function bar() { },];return arr; 19.8 不要在块的开头使用空白行。 eslint: padded-blocks 1234567891011121314151617181920212223242526272829303132333435// badfunction bar() { console.log(foo);}// badif (baz) { console.log(qux);} else { console.log(foo);}// badclass Foo { constructor(bar) { this.bar = bar; }}// goodfunction bar() { console.log(foo);}// goodif (baz) { console.log(qux);} else { console.log(foo);} 19.9 不要在括号内添加空格。 eslint: space-in-parens 12345678910111213141516171819// badfunction bar( foo ) { return foo;}// goodfunction bar(foo) { return foo;}// badif ( foo ) { console.log(foo);}// goodif (foo) { console.log(foo);} 19.10 不要在中括号中添加空格。 eslint: array-bracket-spacing 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]);// goodconst foo = [1, 2, 3];console.log(foo[0]); 19.11 在花括号内添加空格。 eslint: object-curly-spacing 12345// badconst foo = {clark: 'kent'};// goodconst foo = { clark: 'kent' }; 19.12 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 约束，长字符串可免除此规定，不应分解。 eslint: max-len 为什么? 这样能够确保可读性和可维护性。 12345678910111213141516171819202122// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// good$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' },}) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); 19.13 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: block-spacing 1234567// badfunction foo() {return true;}if (foo) { bar = 0;}// goodfunction foo() { return true; }if (foo) { bar = 0; } 19.14 逗号之前避免使用空格，逗号之后需要使用空格。eslint: comma-spacing 1234567// badvar foo = 1,bar = 2;var arr = [1 , 2];// goodvar foo = 1, bar = 2;var arr = [1, 2]; 19.15 在计算属性之间强化间距。eslint: computed-property-spacing 1234567891011// badobj[foo ]obj[ 'foo']var x = {[ b ]: a}obj[foo[ bar ]]// goodobj[foo]obj['foo']var x = { [b]: a }obj[foo[bar]] 19.16 在函数和它的调用之间强化间距。 eslint: func-call-spacing 12345678// badfunc ();func();// goodfunc(); 19.17 在对象的属性和值之间强化间距。 eslint: key-spacing 123456// badvar obj = { \"foo\" : 42 };var obj2 = { \"foo\":42 };// goodvar obj = { \"foo\": 42 }; 19.18 在行的末尾避免使用空格。 eslint: no-trailing-spaces 19.19 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: no-multiple-empty-lines 1234567891011// badvar x = 1;var y = 2;// goodvar x = 1;var y = 2; ⬆ 返回目录 逗号 20.1 逗号前置： 不行 eslint: comma-style 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'};// goodconst hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',}; 20.2 添加尾随逗号： 可以 eslint: comma-dangle 为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 尾随逗号问题 。 1234567891011121314// bad - 没有尾随逗号的 git 差异const hero = { firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']};// good - 有尾随逗号的 git 差异const hero = { firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// badconst hero = { firstName: 'Dana', lastName: 'Scully'};const heroes = [ 'Batman', 'Superman'];// goodconst hero = { firstName: 'Dana', lastName: 'Scully',};const heroes = [ 'Batman', 'Superman',];// badfunction createHero( firstName, lastName, inventorOf) { // does nothing}// goodfunction createHero( firstName, lastName, inventorOf,) { // does nothing}// good (注意逗号不能出现在 \"rest\" 元素后边)function createHero( firstName, lastName, inventorOf, ...heroArgs) { // does nothing}// badcreateHero( firstName, lastName, inventorOf);// goodcreateHero( firstName, lastName, inventorOf,);// good (注意逗号不能出现在 \"rest\" 元素后边)createHero( firstName, lastName, inventorOf, ...heroArgs); ⬆ 返回目录 分号 21.1 对 eslint: semi 为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 Automatic Semicolon Insertion 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。 123456789101112131415161718192021222324252627282930313233343536// bad - 可能异常const luke = {}const leia = {}[luke, leia].forEach(jedi =&gt; jedi.father = 'vader')// bad - 可能异常const reaction = \"No! That's impossible!\"(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}())// bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生function foo() { return 'search your feelings, you know it to be foo'}// goodconst luke = {};const leia = {};[luke, leia].forEach((jedi) =&gt; { jedi.father = 'vader';});// goodconst reaction = \"No! That's impossible!\";(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}());// goodfunction foo() { return 'search your feelings, you know it to be foo';} 更多信息. ⬆ 返回目录 类型转换和强制类型转换 22.1 在语句开始前进行类型转换。 22.2 字符类型： eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is \"object\" not \"string\"// badconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string// goodconst totalScore = String(this.reviewScore); 22.3 数字类型：使用 Number 进行类型铸造和 parseInt 总是通过一个基数来解析一个字符串。 eslint: radix no-new-wrappers 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 22.4 如果出于某种原因，你正在做一些疯狂的事情，而 parseInt 是你的瓶颈，并且出于 性能问题 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。 123456// good/** * parseInt 使我的代码变慢。 * 位运算将一个字符串转换成数字更快。 */const val = inputValue &gt;&gt; 0; 22.5 注意： 当你使用位运算的时候要小心。 数字总是被以 64-bit 值 的形式表示，但是位运算总是返回一个 32-bit 的整数 (来源)。 对于大于 32 位的整数值，位运算可能会导致意外行为。讨论。 最大的 32 位整数是： 2,147,483,647。 1232147483647 &gt;&gt; 0; // =&gt; 21474836472147483648 &gt;&gt; 0; // =&gt; -21474836482147483649 &gt;&gt; 0; // =&gt; -2147483647 22.6 布尔类型： eslint: no-new-wrappers 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; ⬆ 返回目录 命名规范 23.1 避免单字母的名字。用你的命名来描述功能。 eslint: id-length 123456789// badfunction q() { // ...}// goodfunction query() { // ...} 23.2 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: camelcase 12345678// badconst OBJEcttsssss = {};const this_is_my_object = {};function c() {}// goodconst thisIsMyObject = {};function thisIsMyFunction() {} 23.3 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: new-cap 12345678910111213141516171819// badfunction user(options) { this.name = options.name;}const bad = new user({ name: 'nope',});// goodclass User { constructor(options) { this.name = options.name; }}const good = new User({ name: 'yup',}); 23.4 不要使用前置或者后置下划线。 eslint: no-underscore-dangle 为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。 123456789101112// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda';// 好，在 WeakMapx 可用的环境中// see https://kangax.github.io/compat-table/es6/#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, 'Panda'); 23.5 不要保存 this 的引用。 使用箭头函数或者 函数#bind。 12345678910111213141516171819202122// badfunction foo() { const self = this; return function () { console.log(self); };}// badfunction foo() { const that = this; return function () { console.log(that); };}// goodfunction foo() { return () =&gt; { console.log(this); };} 23.6 文件名应该和默认导出的名称完全匹配。 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox { // ...}export default CheckBox;// file 2 contentsexport default function fortyTwo() { return 42; }// file 3 contentsexport default function insideDirectory() {}// in some other file// badimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filenameimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase exportimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export// badimport CheckBox from './check_box'; // PascalCase import/export, snake_case filenameimport forty_two from './forty_two'; // snake_case import/filename, camelCase exportimport inside_directory from './inside_directory'; // snake_case import, camelCase exportimport index from './inside_directory/index'; // requiring the index file explicitlyimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly// goodimport CheckBox from './CheckBox'; // PascalCase export/import/filenameimport fortyTwo from './fortyTwo'; // camelCase export/import/filenameimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"// ^ supports both insideDirectory.js and insideDirectory/index.js 23.7 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。 12345function makeStyleGuide() { // ...}export default makeStyleGuide; 23.8 当你导出一个构造器 / 类 / 单例 / 函数库 / 暴露的对象时应该使用帕斯卡命名法。 123456const AirbnbStyleGuide = { es6: { },};export default AirbnbStyleGuide; 23.9 缩略词和缩写都必须是全部大写或者全部小写。 为什么? 名字是为了可读性，不是为了满足计算机算法。 12345678910111213141516171819202122232425262728// badimport SmsContainer from './containers/SmsContainer';// badconst HttpRequests = [ // ...];// goodimport SMSContainer from './containers/SMSContainer';// goodconst HTTPRequests = [ // ...];// also goodconst httpRequests = [ // ...];// bestimport TextMessageContainer from './containers/TextMessageContainer';// bestconst requests = [ // ...]; 23.10 你可以大写一个常亮，如果它：（1）被导出，（2）使用 const 定义（不能被重新分配），（3）程序员可以信任它（以及其嵌套的属性）是不变的。 为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。 是否是对所有的 const 定义的变量？ - 这个是没哟必要的，不应该在文件中使用大学。但是，它应该用于导出常量。 导出对象呢？ - 在顶级导出属性 (e.g. EXPORTED_OBJECT.key) 并且保持所有嵌套属性不变。 12345678910111213141516171819202122232425262728// badconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';// badexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';// badexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';// ---// 允许，但是不提供语义值export const apiKey = 'SOMEKEY';// 多数情况下，很好export const API_KEY = 'SOMEKEY';// ---// bad - 不必要大写 key 没有增加语义值export const MAPPING = { KEY: 'value'};// goodexport const MAPPING = { key: 'value'}; ⬆ 返回目录 存取器 24.1 对于属性的的存取函数不是必须的。 24.2 不要使用 JavaScript 的 getters/setters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 getVal() 和 setVal('hello')。 123456789101112131415161718192021// badclass Dragon { get age() { // ... } set age(value) { // ... }}// goodclass Dragon { getAge() { // ... } setAge(value) { // ... }} 24.3 如果属性/方法是一个 boolean 值，使用 isVal() 或者 hasVal()。 123456789// badif (!dragon.age()) { return false;}// goodif (!dragon.hasAge()) { return false;} 24.4 可以创建 get() 和 set() 方法，但是要保证一致性。 1234567891011121314class Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; }} ⬆ 返回目录 事件 25.1 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);// ...$(this).on('listingUpdated', (e, listingID) =&gt; { // do something with listingID}); 更好的写法： 12345678// good$(this).trigger('listingUpdated', { listingID: listing.id });// ...$(this).on('listingUpdated', (e, data) =&gt; { // do something with data.listingID}); ⬆ 返回目录 jQuery 26.1 对于 jQuery 对象的变量使用 $ 作为前缀。 12345678// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar');// goodconst $sidebarBtn = $('.sidebar-btn'); 26.2 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() { $('.sidebar').hide(); // ... $('.sidebar').css({ 'background-color': 'pink', });}// goodfunction setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ... $sidebar.css({ 'background-color': 'pink', });} 26.3 对于 DOM 查询使用层叠 $('.sidebar ul') 或 父元素 &gt; 子元素 $('.sidebar &gt; ul') 的格式。 jsPerf 26.4 对于有作用域的 jQuery 对象查询使用 find 。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 返回目录 ECMAScript 5 兼容性 27.1 参考 Kangax的 ES5 兼容性表格。 ⬆ 返回目录 ECMAScript 6+ (ES 2015+) Styles 28.1 这是一个链接到各种 ES6+ 特性的集合。 箭头函数 类 对象简写 对象简洁 对象计算属性 字符串模板 解构 默认参数 Rest 数组展开 Let 和 Const 求幂运算符 迭代器和发生器 模块 28.2 不要使用尚未达到第3阶段的 TC39 建议。 为什么? 它们没有最终确定， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。 ⬆ 返回目录 标准库 标准库 包含功能已损坏的实用工具，但因为遗留原因而保留。 29.1 使用 Number.isNaN 代替全局的 isNaN.eslint: no-restricted-globals 为什么? 全局的 isNaN 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。 如果需要这种行为，请明确说明。 1234567// badisNaN('1.2'); // falseisNaN('1.2.3'); // true// goodNumber.isNaN('1.2.3'); // falseNumber.isNaN(Number('1.2.3')); // true 29.2 使用 Number.isFinite 代替全局的 isFinite.eslint: no-restricted-globals 为什么? 全局的 isFinite 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。 如果需要这种行为，请明确说明。 123456// badisFinite('2e3'); // true// goodNumber.isFinite('2e3'); // falseNumber.isFinite(parseInt('2e3', 10)); // true ⬆ 返回目录 Testing 30.1 是的. 123function foo() { return true;} 30.2 没有，但是认真: 无论你使用那种测试框架，都应该编写测试！ 努力写出许多小的纯函数，并尽量减少发生错误的地方。 对于静态方法和 mock 要小心—-它们会使你的测试更加脆弱。 我们主要在 Airbnb 上使用 mocha 和 jest 。 tape 也会用在一些小的独立模块上。 100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。 无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。 ⬆ 返回目录 性能 On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are Javascript functions like map(), reduce(), and filter() optimized for traversing arrays? Loading… ⬆ 返回目录 资源学习 ES6+ Latest ECMA spec ExploringJS ES6 Compatibility Table Comprehensive Overview of ES6 Features 读这个 Standard ECMA-262 工具 Code Style Linters ESlint - Airbnb Style .eslintrc JSHint - Airbnb Style .jshintrc Neutrino preset - neutrino-preset-airbnb-base 其他编码规范 Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript StandardJS 其他风格 Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on GitHub - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman 进一步阅读 Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock 书籍 JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS: ES6 &amp; Beyond - Kyle Simpson 博客 JavaScript Weekly JavaScript, JavaScript… Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy nettuts 播客 JavaScript Air JavaScript Jabber ⬆ 返回目录 JavaScript风格指南的指南 Reference 许可证(The MIT License) Copyright (c) 2012 康兵奎 Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions: The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ⬆ 返回目录 修正案我们鼓励您使用此指南并更改规则以适应您的团队的风格指南。下面，你可以列出一些对风格指南的修正。这允许您定期更新您的样式指南，而不必处理合并冲突。 };","link":"/2019/09/08/Airbnb-JavaScript-代码规范/"},{"title":"BigInteger类","text":"BigInteger类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package java.math;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.ObjectStreamField;import java.io.StreamCorruptedException;import java.io.ObjectInputStream.GetField;import java.io.ObjectOutputStream.PutField;import java.util.Arrays;import java.util.Objects;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;import jdk.internal.HotSpotIntrinsicCandidate;import jdk.internal.misc.Unsafe;public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; { final int signum; final int[] mag; private int bitCountPlusOne; private int bitLengthPlusOne; private int lowestSetBitPlusTwo; private int firstNonzeroIntNumPlusTwo; static final long LONG_MASK = 4294967295L; private static final int MAX_MAG_LENGTH = 67108864; private static final int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000; private static final int KARATSUBA_THRESHOLD = 80; private static final int TOOM_COOK_THRESHOLD = 240; private static final int KARATSUBA_SQUARE_THRESHOLD = 128; private static final int TOOM_COOK_SQUARE_THRESHOLD = 216; static final int BURNIKEL_ZIEGLER_THRESHOLD = 80; static final int BURNIKEL_ZIEGLER_OFFSET = 40; private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20; private static final int MULTIPLY_SQUARE_THRESHOLD = 20; private static final int MONTGOMERY_INTRINSIC_THRESHOLD = 512; private static long[] bitsPerDigit = new long[]{0L, 0L, 1024L, 1624L, 2048L, 2378L, 2648L, 2875L, 3072L, 3247L, 3402L, 3543L, 3672L, 3790L, 3899L, 4001L, 4096L, 4186L, 4271L, 4350L, 4426L, 4498L, 4567L, 4633L, 4696L, 4756L, 4814L, 4870L, 4923L, 4975L, 5025L, 5074L, 5120L, 5166L, 5210L, 5253L, 5295L}; private static final int SMALL_PRIME_THRESHOLD = 95; private static final int DEFAULT_PRIME_CERTAINTY = 100; private static final BigInteger SMALL_PRIME_PRODUCT = valueOf(152125131763605L); private static final int MAX_CONSTANT = 16; private static BigInteger[] posConst = new BigInteger[17]; private static BigInteger[] negConst = new BigInteger[17]; private static volatile BigInteger[][] powerCache; private static final double[] logCache; private static final double LOG_TWO = Math.log(2.0D); public static final BigInteger ZERO; public static final BigInteger ONE; public static final BigInteger TWO; private static final BigInteger NEGATIVE_ONE; public static final BigInteger TEN; static int[] bnExpModThreshTable; private static String[] zeros; private static int[] digitsPerLong; private static BigInteger[] longRadix; private static int[] digitsPerInt; private static int[] intRadix; private static final long serialVersionUID = -8287574255936472291L; private static final ObjectStreamField[] serialPersistentFields; public BigInteger(byte[] val, int off, int len) { if (val.length == 0) { throw new NumberFormatException(\"Zero length BigInteger\"); } else { Objects.checkFromIndexSize(off, len, val.length); if (val[off] &lt; 0) { this.mag = makePositive(val, off, len); this.signum = -1; } else { this.mag = stripLeadingZeroBytes(val, off, len); this.signum = this.mag.length == 0 ? 0 : 1; } if (this.mag.length &gt;= 67108864) { this.checkRange(); } } } public BigInteger(byte[] val) { this((byte[])val, 0, val.length); } private BigInteger(int[] val) { if (val.length == 0) { throw new NumberFormatException(\"Zero length BigInteger\"); } else { if (val[0] &lt; 0) { this.mag = makePositive(val); this.signum = -1; } else { this.mag = trustedStripLeadingZeroInts(val); this.signum = this.mag.length == 0 ? 0 : 1; } if (this.mag.length &gt;= 67108864) { this.checkRange(); } } } public BigInteger(int signum, byte[] magnitude, int off, int len) { if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) { Objects.checkFromIndexSize(off, len, magnitude.length); this.mag = stripLeadingZeroBytes(magnitude, off, len); if (this.mag.length == 0) { this.signum = 0; } else { if (signum == 0) { throw new NumberFormatException(\"signum-magnitude mismatch\"); } this.signum = signum; } if (this.mag.length &gt;= 67108864) { this.checkRange(); } } else { throw new NumberFormatException(\"Invalid signum value\"); } } public BigInteger(int signum, byte[] magnitude) { this(signum, magnitude, 0, magnitude.length); } private BigInteger(int signum, int[] magnitude) { this.mag = stripLeadingZeroInts(magnitude); if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) { if (this.mag.length == 0) { this.signum = 0; } else { if (signum == 0) { throw new NumberFormatException(\"signum-magnitude mismatch\"); } this.signum = signum; } if (this.mag.length &gt;= 67108864) { this.checkRange(); } } else { throw new NumberFormatException(\"Invalid signum value\"); } } public BigInteger(String val, int radix) { int cursor = 0; int len = val.length(); if (radix &gt;= 2 &amp;&amp; radix &lt;= 36) { if (len == 0) { throw new NumberFormatException(\"Zero length BigInteger\"); } else { int sign = 1; int index1 = val.lastIndexOf(45); int index2 = val.lastIndexOf(43); if (index1 &gt;= 0) { if (index1 != 0 || index2 &gt;= 0) { throw new NumberFormatException(\"Illegal embedded sign character\"); } sign = -1; cursor = 1; } else if (index2 &gt;= 0) { if (index2 != 0) { throw new NumberFormatException(\"Illegal embedded sign character\"); } cursor = 1; } if (cursor == len) { throw new NumberFormatException(\"Zero length BigInteger\"); } else { while(cursor &lt; len &amp;&amp; Character.digit(val.charAt(cursor), radix) == 0) { ++cursor; } if (cursor == len) { this.signum = 0; this.mag = ZERO.mag; } else { int numDigits = len - cursor; this.signum = sign; long numBits = ((long)numDigits * bitsPerDigit[radix] &gt;&gt;&gt; 10) + 1L; if (numBits + 31L &gt;= 4294967296L) { reportOverflow(); } int numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5; int[] magnitude = new int[numWords]; int firstGroupLen = numDigits % digitsPerInt[radix]; if (firstGroupLen == 0) { firstGroupLen = digitsPerInt[radix]; } String group = val.substring(cursor, cursor += firstGroupLen); magnitude[numWords - 1] = Integer.parseInt(group, radix); if (magnitude[numWords - 1] &lt; 0) { throw new NumberFormatException(\"Illegal digit\"); } else { int superRadix = intRadix[radix]; boolean var16 = false; while(cursor &lt; len) { group = val.substring(cursor, cursor += digitsPerInt[radix]); int groupVal = Integer.parseInt(group, radix); if (groupVal &lt; 0) { throw new NumberFormatException(\"Illegal digit\"); } destructiveMulAdd(magnitude, superRadix, groupVal); } this.mag = trustedStripLeadingZeroInts(magnitude); if (this.mag.length &gt;= 67108864) { this.checkRange(); } } } } } } else { throw new NumberFormatException(\"Radix out of range\"); } } BigInteger(char[] val, int sign, int len) { int cursor; for(cursor = 0; cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0; ++cursor) { } if (cursor == len) { this.signum = 0; this.mag = ZERO.mag; } else { int numDigits = len - cursor; this.signum = sign; int numWords; if (len &lt; 10) { numWords = 1; } else { long numBits = ((long)numDigits * bitsPerDigit[10] &gt;&gt;&gt; 10) + 1L; if (numBits + 31L &gt;= 4294967296L) { reportOverflow(); } numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5; } int[] magnitude = new int[numWords]; int firstGroupLen = numDigits % digitsPerInt[10]; if (firstGroupLen == 0) { firstGroupLen = digitsPerInt[10]; } magnitude[numWords - 1] = this.parseInt(val, cursor, cursor += firstGroupLen); while(cursor &lt; len) { int groupVal = this.parseInt(val, cursor, cursor += digitsPerInt[10]); destructiveMulAdd(magnitude, intRadix[10], groupVal); } this.mag = trustedStripLeadingZeroInts(magnitude); if (this.mag.length &gt;= 67108864) { this.checkRange(); } } } private int parseInt(char[] source, int start, int end) { int result = Character.digit(source[start++], 10); if (result == -1) { throw new NumberFormatException(new String(source)); } else { for(int index = start; index &lt; end; ++index) { int nextVal = Character.digit(source[index], 10); if (nextVal == -1) { throw new NumberFormatException(new String(source)); } result = 10 * result + nextVal; } return result; } } private static void destructiveMulAdd(int[] x, int y, int z) { long ylong = (long)y &amp; 4294967295L; long zlong = (long)z &amp; 4294967295L; int len = x.length; long product = 0L; long carry = 0L; for(int i = len - 1; i &gt;= 0; --i) { product = ylong * ((long)x[i] &amp; 4294967295L) + carry; x[i] = (int)product; carry = product &gt;&gt;&gt; 32; } long sum = ((long)x[len - 1] &amp; 4294967295L) + zlong; x[len - 1] = (int)sum; carry = sum &gt;&gt;&gt; 32; for(int i = len - 2; i &gt;= 0; --i) { sum = ((long)x[i] &amp; 4294967295L) + carry; x[i] = (int)sum; carry = sum &gt;&gt;&gt; 32; } } public BigInteger(String val) { this((String)val, 10); } public BigInteger(int numBits, Random rnd) { this(1, (byte[])randomBits(numBits, rnd)); } private static byte[] randomBits(int numBits, Random rnd) { if (numBits &lt; 0) { throw new IllegalArgumentException(\"numBits must be non-negative\"); } else { int numBytes = (int)(((long)numBits + 7L) / 8L); byte[] randomBits = new byte[numBytes]; if (numBytes &gt; 0) { rnd.nextBytes(randomBits); int excessBits = 8 * numBytes - numBits; randomBits[0] = (byte)(randomBits[0] &amp; (1 &lt;&lt; 8 - excessBits) - 1); } return randomBits; } } public BigInteger(int bitLength, int certainty, Random rnd) { if (bitLength &lt; 2) { throw new ArithmeticException(\"bitLength &lt; 2\"); } else { BigInteger prime = bitLength &lt; 95 ? smallPrime(bitLength, certainty, rnd) : largePrime(bitLength, certainty, rnd); this.signum = 1; this.mag = prime.mag; } } public static BigInteger probablePrime(int bitLength, Random rnd) { if (bitLength &lt; 2) { throw new ArithmeticException(\"bitLength &lt; 2\"); } else { return bitLength &lt; 95 ? smallPrime(bitLength, 100, rnd) : largePrime(bitLength, 100, rnd); } } private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) { int magLen = bitLength + 31 &gt;&gt;&gt; 5; int[] temp = new int[magLen]; int highBit = 1 &lt;&lt; (bitLength + 31 &amp; 31); int highMask = (highBit &lt;&lt; 1) - 1; BigInteger p; do { long r; do { for(int i = 0; i &lt; magLen; ++i) { temp[i] = rnd.nextInt(); } temp[0] = temp[0] &amp; highMask | highBit; if (bitLength &gt; 2) { temp[magLen - 1] |= 1; } p = new BigInteger(temp, 1); if (bitLength &lt;= 6) { break; } r = p.remainder(SMALL_PRIME_PRODUCT).longValue(); } while(r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L); if (bitLength &lt; 4) { return p; } } while(!p.primeToCertainty(certainty, rnd)); return p; } private static BigInteger largePrime(int bitLength, int certainty, Random rnd) { BigInteger p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1); int[] var10000 = p.mag; int var10001 = p.mag.length - 1; var10000[var10001] &amp;= -2; int searchLen = getPrimeSearchLen(bitLength); BitSieve searchSieve = new BitSieve(p, searchLen); BigInteger candidate; for(candidate = searchSieve.retrieve(p, certainty, rnd); candidate == null || candidate.bitLength() != bitLength; candidate = searchSieve.retrieve(p, certainty, rnd)) { p = p.add(valueOf((long)(2 * searchLen))); if (p.bitLength() != bitLength) { p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1); } var10000 = p.mag; var10001 = p.mag.length - 1; var10000[var10001] &amp;= -2; searchSieve = new BitSieve(p, searchLen); } return candidate; } public BigInteger nextProbablePrime() { if (this.signum &lt; 0) { throw new ArithmeticException(\"start &lt; 0: \" + this); } else if (this.signum != 0 &amp;&amp; !this.equals(ONE)) { BigInteger result = this.add(ONE); if (result.bitLength() &lt; 95) { if (!result.testBit(0)) { result = result.add(ONE); } while(true) { while(true) { if (result.bitLength() &gt; 6) { long r = result.remainder(SMALL_PRIME_PRODUCT).longValue(); if (r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L) { result = result.add(TWO); continue; } } if (result.bitLength() &lt; 4) { return result; } if (result.primeToCertainty(100, (Random)null)) { return result; } result = result.add(TWO); } } } else { if (result.testBit(0)) { result = result.subtract(ONE); } int searchLen = getPrimeSearchLen(result.bitLength()); while(true) { BitSieve searchSieve = new BitSieve(result, searchLen); BigInteger candidate = searchSieve.retrieve(result, 100, (Random)null); if (candidate != null) { return candidate; } result = result.add(valueOf((long)(2 * searchLen))); } } } else { return TWO; } } private static int getPrimeSearchLen(int bitLength) { if (bitLength &gt; 500000001) { throw new ArithmeticException(\"Prime search implementation restriction on bitLength\"); } else { return bitLength / 20 * 64; } } boolean primeToCertainty(int certainty, Random random) { int rounds = false; int n = (Math.min(certainty, 2147483646) + 1) / 2; int sizeInBits = this.bitLength(); byte rounds; int rounds; if (sizeInBits &lt; 100) { rounds = 50; rounds = n &lt; rounds ? n : rounds; return this.passesMillerRabin(rounds, random); } else { if (sizeInBits &lt; 256) { rounds = 27; } else if (sizeInBits &lt; 512) { rounds = 15; } else if (sizeInBits &lt; 768) { rounds = 8; } else if (sizeInBits &lt; 1024) { rounds = 4; } else { rounds = 2; } rounds = n &lt; rounds ? n : rounds; return this.passesMillerRabin(rounds, random) &amp;&amp; this.passesLucasLehmer(); } } private boolean passesLucasLehmer() { BigInteger thisPlusOne = this.add(ONE); int d; for(d = 5; jacobiSymbol(d, this) != -1; d = d &lt; 0 ? Math.abs(d) + 2 : -(d + 2)) { } BigInteger u = lucasLehmerSequence(d, thisPlusOne, this); return u.mod(this).equals(ZERO); } private static int jacobiSymbol(int p, BigInteger n) { if (p == 0) { return 0; } else { int j = 1; int u = n.mag[n.mag.length - 1]; int t; if (p &lt; 0) { p = -p; t = u &amp; 7; if (t == 3 || t == 7) { j = -j; } } while((p &amp; 3) == 0) { p &gt;&gt;= 2; } if ((p &amp; 1) == 0) { p &gt;&gt;= 1; if (((u ^ u &gt;&gt; 1) &amp; 2) != 0) { j = -j; } } if (p == 1) { return j; } else { if ((p &amp; u &amp; 2) != 0) { j = -j; } for(u = n.mod(valueOf((long)p)).intValue(); u != 0; u %= t) { while((u &amp; 3) == 0) { u &gt;&gt;= 2; } if ((u &amp; 1) == 0) { u &gt;&gt;= 1; if (((p ^ p &gt;&gt; 1) &amp; 2) != 0) { j = -j; } } if (u == 1) { return j; } assert u &lt; p; t = u; u = p; p = t; if ((u &amp; t &amp; 2) != 0) { j = -j; } } return 0; } } } private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) { BigInteger d = valueOf((long)z); BigInteger u = ONE; BigInteger v = ONE; for(int i = k.bitLength() - 2; i &gt;= 0; --i) { BigInteger u2 = u.multiply(v).mod(n); BigInteger v2 = v.square().add(d.multiply(u.square())).mod(n); if (v2.testBit(0)) { v2 = v2.subtract(n); } v2 = v2.shiftRight(1); u = u2; v = v2; if (k.testBit(i)) { u2 = u2.add(v2).mod(n); if (u2.testBit(0)) { u2 = u2.subtract(n); } u2 = u2.shiftRight(1); v2 = v2.add(d.multiply(u)).mod(n); if (v2.testBit(0)) { v2 = v2.subtract(n); } v2 = v2.shiftRight(1); u = u2; v = v2; } } return u; } private boolean passesMillerRabin(int iterations, Random rnd) { BigInteger thisMinusOne = this.subtract(ONE); int a = thisMinusOne.getLowestSetBit(); BigInteger m = thisMinusOne.shiftRight(a); if (rnd == null) { rnd = ThreadLocalRandom.current(); } for(int i = 0; i &lt; iterations; ++i) { BigInteger b; do { do { b = new BigInteger(this.bitLength(), (Random)rnd); } while(b.compareTo(ONE) &lt;= 0); } while(b.compareTo(this) &gt;= 0); int j = 0; for(BigInteger z = b.modPow(m, this); (j != 0 || !z.equals(ONE)) &amp;&amp; !z.equals(thisMinusOne); z = z.modPow(TWO, this)) { if (j &gt; 0 &amp;&amp; z.equals(ONE)) { return false; } ++j; if (j == a) { return false; } } } return true; } BigInteger(int[] magnitude, int signum) { this.signum = magnitude.length == 0 ? 0 : signum; this.mag = magnitude; if (this.mag.length &gt;= 67108864) { this.checkRange(); } } private BigInteger(byte[] magnitude, int signum) { this.signum = magnitude.length == 0 ? 0 : signum; this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length); if (this.mag.length &gt;= 67108864) { this.checkRange(); } } private void checkRange() { if (this.mag.length &gt; 67108864 || this.mag.length == 67108864 &amp;&amp; this.mag[0] &lt; 0) { reportOverflow(); } } private static void reportOverflow() { throw new ArithmeticException(\"BigInteger would overflow supported range\"); } public static BigInteger valueOf(long val) { if (val == 0L) { return ZERO; } else if (val &gt; 0L &amp;&amp; val &lt;= 16L) { return posConst[(int)val]; } else { return val &lt; 0L &amp;&amp; val &gt;= -16L ? negConst[(int)(-val)] : new BigInteger(val); } } private BigInteger(long val) { if (val &lt; 0L) { val = -val; this.signum = -1; } else { this.signum = 1; } int highWord = (int)(val &gt;&gt;&gt; 32); if (highWord == 0) { this.mag = new int[1]; this.mag[0] = (int)val; } else { this.mag = new int[2]; this.mag[0] = highWord; this.mag[1] = (int)val; } } private static BigInteger valueOf(int[] val) { return val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val); } public BigInteger add(BigInteger val) { if (val.signum == 0) { return this; } else if (this.signum == 0) { return val; } else if (val.signum == this.signum) { return new BigInteger(add(this.mag, val.mag), this.signum); } else { int cmp = this.compareMagnitude(val); if (cmp == 0) { return ZERO; } else { int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag); resultMag = trustedStripLeadingZeroInts(resultMag); return new BigInteger(resultMag, cmp == this.signum ? 1 : -1); } } } BigInteger add(long val) { if (val == 0L) { return this; } else if (this.signum == 0) { return valueOf(val); } else if (Long.signum(val) == this.signum) { return new BigInteger(add(this.mag, Math.abs(val)), this.signum); } else { int cmp = this.compareMagnitude(val); if (cmp == 0) { return ZERO; } else { int[] resultMag = cmp &gt; 0 ? subtract(this.mag, Math.abs(val)) : subtract(Math.abs(val), this.mag); resultMag = trustedStripLeadingZeroInts(resultMag); return new BigInteger(resultMag, cmp == this.signum ? 1 : -1); } } } private static int[] add(int[] x, long val) { long sum = 0L; int xIndex = x.length; int highWord = (int)(val &gt;&gt;&gt; 32); int[] result; if (highWord == 0) { result = new int[xIndex]; --xIndex; sum = ((long)x[xIndex] &amp; 4294967295L) + val; result[xIndex] = (int)sum; } else { if (xIndex == 1) { result = new int[2]; sum = val + ((long)x[0] &amp; 4294967295L); result[1] = (int)sum; result[0] = (int)(sum &gt;&gt;&gt; 32); return result; } result = new int[xIndex]; --xIndex; sum = ((long)x[xIndex] &amp; 4294967295L) + (val &amp; 4294967295L); result[xIndex] = (int)sum; --xIndex; sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)highWord &amp; 4294967295L) + (sum &gt;&gt;&gt; 32); result[xIndex] = (int)sum; } boolean carry; for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) { --xIndex; } while(xIndex &gt; 0) { --xIndex; result[xIndex] = x[xIndex]; } if (carry) { int[] bigger = new int[result.length + 1]; System.arraycopy(result, 0, bigger, 1, result.length); bigger[0] = 1; return bigger; } else { return result; } } private static int[] add(int[] x, int[] y) { if (x.length &lt; y.length) { int[] tmp = x; x = y; y = tmp; } int xIndex = x.length; int yIndex = y.length; int[] result = new int[xIndex]; long sum = 0L; if (yIndex == 1) { --xIndex; sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)y[0] &amp; 4294967295L); result[xIndex] = (int)sum; } else { while(yIndex &gt; 0) { --xIndex; long var10000 = (long)x[xIndex] &amp; 4294967295L; --yIndex; sum = var10000 + ((long)y[yIndex] &amp; 4294967295L) + (sum &gt;&gt;&gt; 32); result[xIndex] = (int)sum; } } boolean carry; for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) { --xIndex; } while(xIndex &gt; 0) { --xIndex; result[xIndex] = x[xIndex]; } if (carry) { int[] bigger = new int[result.length + 1]; System.arraycopy(result, 0, bigger, 1, result.length); bigger[0] = 1; return bigger; } else { return result; } } private static int[] subtract(long val, int[] little) { int highWord = (int)(val &gt;&gt;&gt; 32); int[] result; if (highWord == 0) { result = new int[]{(int)(val - ((long)little[0] &amp; 4294967295L))}; return result; } else { result = new int[2]; long difference; if (little.length == 1) { difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L); result[1] = (int)difference; boolean borrow = difference &gt;&gt; 32 != 0L; if (borrow) { result[0] = highWord - 1; } else { result[0] = highWord; } return result; } else { difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[1] &amp; 4294967295L); result[1] = (int)difference; difference = ((long)highWord &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L) + (difference &gt;&gt; 32); result[0] = (int)difference; return result; } } } private static int[] subtract(int[] big, long val) { int highWord = (int)(val &gt;&gt;&gt; 32); int bigIndex = big.length; int[] result = new int[bigIndex]; long difference = 0L; if (highWord == 0) { --bigIndex; difference = ((long)big[bigIndex] &amp; 4294967295L) - val; result[bigIndex] = (int)difference; } else { --bigIndex; difference = ((long)big[bigIndex] &amp; 4294967295L) - (val &amp; 4294967295L); result[bigIndex] = (int)difference; --bigIndex; difference = ((long)big[bigIndex] &amp; 4294967295L) - ((long)highWord &amp; 4294967295L) + (difference &gt;&gt; 32); result[bigIndex] = (int)difference; } for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) { --bigIndex; } while(bigIndex &gt; 0) { --bigIndex; result[bigIndex] = big[bigIndex]; } return result; } public BigInteger subtract(BigInteger val) { if (val.signum == 0) { return this; } else if (this.signum == 0) { return val.negate(); } else if (val.signum != this.signum) { return new BigInteger(add(this.mag, val.mag), this.signum); } else { int cmp = this.compareMagnitude(val); if (cmp == 0) { return ZERO; } else { int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag); resultMag = trustedStripLeadingZeroInts(resultMag); return new BigInteger(resultMag, cmp == this.signum ? 1 : -1); } } } private static int[] subtract(int[] big, int[] little) { int bigIndex = big.length; int[] result = new int[bigIndex]; int littleIndex = little.length; long difference; for(difference = 0L; littleIndex &gt; 0; result[bigIndex] = (int)difference) { --bigIndex; long var10000 = (long)big[bigIndex] &amp; 4294967295L; --littleIndex; difference = var10000 - ((long)little[littleIndex] &amp; 4294967295L) + (difference &gt;&gt; 32); } for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) { --bigIndex; } while(bigIndex &gt; 0) { --bigIndex; result[bigIndex] = big[bigIndex]; } return result; } public BigInteger multiply(BigInteger val) { return this.multiply(val, false); } private BigInteger multiply(BigInteger val, boolean isRecursion) { if (val.signum != 0 &amp;&amp; this.signum != 0) { int xlen = this.mag.length; if (val == this &amp;&amp; xlen &gt; 20) { return this.square(); } else { int ylen = val.mag.length; if (xlen &gt;= 80 &amp;&amp; ylen &gt;= 80) { if (xlen &lt; 240 &amp;&amp; ylen &lt; 240) { return multiplyKaratsuba(this, val); } else { if (!isRecursion &amp;&amp; (long)(bitLength(this.mag, this.mag.length) + bitLength(val.mag, val.mag.length)) &gt; 2147483648L) { reportOverflow(); } return multiplyToomCook3(this, val); } } else { int resultSign = this.signum == val.signum ? 1 : -1; if (val.mag.length == 1) { return multiplyByInt(this.mag, val.mag[0], resultSign); } else if (this.mag.length == 1) { return multiplyByInt(val.mag, this.mag[0], resultSign); } else { int[] result = multiplyToLen(this.mag, xlen, val.mag, ylen, (int[])null); result = trustedStripLeadingZeroInts(result); return new BigInteger(result, resultSign); } } } } else { return ZERO; } } private static BigInteger multiplyByInt(int[] x, int y, int sign) { if (Integer.bitCount(y) == 1) { return new BigInteger(shiftLeft(x, Integer.numberOfTrailingZeros(y)), sign); } else { int xlen = x.length; int[] rmag = new int[xlen + 1]; long carry = 0L; long yl = (long)y &amp; 4294967295L; int rstart = rmag.length - 1; for(int i = xlen - 1; i &gt;= 0; --i) { long product = ((long)x[i] &amp; 4294967295L) * yl + carry; rmag[rstart--] = (int)product; carry = product &gt;&gt;&gt; 32; } if (carry == 0L) { rmag = Arrays.copyOfRange(rmag, 1, rmag.length); } else { rmag[rstart] = (int)carry; } return new BigInteger(rmag, sign); } } BigInteger multiply(long v) { if (v != 0L &amp;&amp; this.signum != 0) { if (v == -9223372036854775808L) { return this.multiply(valueOf(v)); } else { int rsign = v &gt; 0L ? this.signum : -this.signum; if (v &lt; 0L) { v = -v; } long dh = v &gt;&gt;&gt; 32; long dl = v &amp; 4294967295L; int xlen = this.mag.length; int[] value = this.mag; int[] rmag = dh == 0L ? new int[xlen + 1] : new int[xlen + 2]; long carry = 0L; int rstart = rmag.length - 1; int i; long product; for(i = xlen - 1; i &gt;= 0; --i) { product = ((long)value[i] &amp; 4294967295L) * dl + carry; rmag[rstart--] = (int)product; carry = product &gt;&gt;&gt; 32; } rmag[rstart] = (int)carry; if (dh != 0L) { carry = 0L; rstart = rmag.length - 2; for(i = xlen - 1; i &gt;= 0; --i) { product = ((long)value[i] &amp; 4294967295L) * dh + ((long)rmag[rstart] &amp; 4294967295L) + carry; rmag[rstart--] = (int)product; carry = product &gt;&gt;&gt; 32; } rmag[0] = (int)carry; } if (carry == 0L) { rmag = Arrays.copyOfRange(rmag, 1, rmag.length); } return new BigInteger(rmag, rsign); } } else { return ZERO; } } private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) { multiplyToLenCheck(x, xlen); multiplyToLenCheck(y, ylen); return implMultiplyToLen(x, xlen, y, ylen, z); } @HotSpotIntrinsicCandidate private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) { int xstart = xlen - 1; int ystart = ylen - 1; if (z == null || z.length &lt; xlen + ylen) { z = new int[xlen + ylen]; } long carry = 0L; int i = ystart; int j; for(j = ystart + 1 + xstart; i &gt;= 0; --j) { long product = ((long)y[i] &amp; 4294967295L) * ((long)x[xstart] &amp; 4294967295L) + carry; z[j] = (int)product; carry = product &gt;&gt;&gt; 32; --i; } z[xstart] = (int)carry; for(i = xstart - 1; i &gt;= 0; --i) { carry = 0L; j = ystart; for(int k = ystart + 1 + i; j &gt;= 0; --k) { long product = ((long)y[j] &amp; 4294967295L) * ((long)x[i] &amp; 4294967295L) + ((long)z[k] &amp; 4294967295L) + carry; z[k] = (int)product; carry = product &gt;&gt;&gt; 32; --j; } z[i] = (int)carry; } return z; } private static void multiplyToLenCheck(int[] array, int length) { if (length &gt; 0) { Objects.requireNonNull(array); if (length &gt; array.length) { throw new ArrayIndexOutOfBoundsException(length - 1); } } } private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) { int xlen = x.mag.length; int ylen = y.mag.length; int half = (Math.max(xlen, ylen) + 1) / 2; BigInteger xl = x.getLower(half); BigInteger xh = x.getUpper(half); BigInteger yl = y.getLower(half); BigInteger yh = y.getUpper(half); BigInteger p1 = xh.multiply(yh); BigInteger p2 = xl.multiply(yl); BigInteger p3 = xh.add(xl).multiply(yh.add(yl)); BigInteger result = p1.shiftLeft(32 * half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32 * half).add(p2); return x.signum != y.signum ? result.negate() : result; } private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) { int alen = a.mag.length; int blen = b.mag.length; int largest = Math.max(alen, blen); int k = (largest + 2) / 3; int r = largest - 2 * k; BigInteger a2 = a.getToomSlice(k, r, 0, largest); BigInteger a1 = a.getToomSlice(k, r, 1, largest); BigInteger a0 = a.getToomSlice(k, r, 2, largest); BigInteger b2 = b.getToomSlice(k, r, 0, largest); BigInteger b1 = b.getToomSlice(k, r, 1, largest); BigInteger b0 = b.getToomSlice(k, r, 2, largest); BigInteger v0 = a0.multiply(b0, true); BigInteger da1 = a2.add(a0); BigInteger db1 = b2.add(b0); BigInteger vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true); da1 = da1.add(a1); db1 = db1.add(b1); BigInteger v1 = da1.multiply(db1, true); BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(db1.add(b2).shiftLeft(1).subtract(b0), true); BigInteger vinf = a2.multiply(b2, true); BigInteger t2 = v2.subtract(vm1).exactDivideBy3(); BigInteger tm1 = v1.subtract(vm1).shiftRight(1); BigInteger t1 = v1.subtract(v0); t2 = t2.subtract(t1).shiftRight(1); t1 = t1.subtract(tm1).subtract(vinf); t2 = t2.subtract(vinf.shiftLeft(1)); tm1 = tm1.subtract(t2); int ss = k * 32; BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0); return a.signum != b.signum ? result.negate() : result; } private BigInteger getToomSlice(int lowerSize, int upperSize, int slice, int fullsize) { int len = this.mag.length; int offset = fullsize - len; int start; int end; if (slice == 0) { start = 0 - offset; end = upperSize - 1 - offset; } else { start = upperSize + (slice - 1) * lowerSize - offset; end = start + lowerSize - 1; } if (start &lt; 0) { start = 0; } if (end &lt; 0) { return ZERO; } else { int sliceSize = end - start + 1; if (sliceSize &lt;= 0) { return ZERO; } else if (start == 0 &amp;&amp; sliceSize &gt;= len) { return this.abs(); } else { int[] intSlice = new int[sliceSize]; System.arraycopy(this.mag, start, intSlice, 0, sliceSize); return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1); } } } private BigInteger exactDivideBy3() { int len = this.mag.length; int[] result = new int[len]; long borrow = 0L; for(int i = len - 1; i &gt;= 0; --i) { long x = (long)this.mag[i] &amp; 4294967295L; long w = x - borrow; if (borrow &gt; x) { borrow = 1L; } else { borrow = 0L; } long q = w * 2863311531L &amp; 4294967295L; result[i] = (int)q; if (q &gt;= 1431655766L) { ++borrow; if (q &gt;= 2863311531L) { ++borrow; } } } result = trustedStripLeadingZeroInts(result); return new BigInteger(result, this.signum); } private BigInteger getLower(int n) { int len = this.mag.length; if (len &lt;= n) { return this.abs(); } else { int[] lowerInts = new int[n]; System.arraycopy(this.mag, len - n, lowerInts, 0, n); return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1); } } private BigInteger getUpper(int n) { int len = this.mag.length; if (len &lt;= n) { return ZERO; } else { int upperLen = len - n; int[] upperInts = new int[upperLen]; System.arraycopy(this.mag, 0, upperInts, 0, upperLen); return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1); } } private BigInteger square() { return this.square(false); } private BigInteger square(boolean isRecursion) { if (this.signum == 0) { return ZERO; } else { int len = this.mag.length; if (len &lt; 128) { int[] z = squareToLen(this.mag, len, (int[])null); return new BigInteger(trustedStripLeadingZeroInts(z), 1); } else if (len &lt; 216) { return this.squareKaratsuba(); } else { if (!isRecursion &amp;&amp; (long)bitLength(this.mag, this.mag.length) &gt; 1073741824L) { reportOverflow(); } return this.squareToomCook3(); } } } private static final int[] squareToLen(int[] x, int len, int[] z) { int zlen = len &lt;&lt; 1; if (z == null || z.length &lt; zlen) { z = new int[zlen]; } implSquareToLenChecks(x, len, z, zlen); return implSquareToLen(x, len, z, zlen); } private static void implSquareToLenChecks(int[] x, int len, int[] z, int zlen) throws RuntimeException { if (len &lt; 1) { throw new IllegalArgumentException(\"invalid input length: \" + len); } else if (len &gt; x.length) { throw new IllegalArgumentException(\"input length out of bound: \" + len + \" &gt; \" + x.length); } else if (len * 2 &gt; z.length) { throw new IllegalArgumentException(\"input length out of bound: \" + len * 2 + \" &gt; \" + z.length); } else if (zlen &lt; 1) { throw new IllegalArgumentException(\"invalid input length: \" + zlen); } else if (zlen &gt; z.length) { throw new IllegalArgumentException(\"input length out of bound: \" + len + \" &gt; \" + z.length); } } @HotSpotIntrinsicCandidate private static final int[] implSquareToLen(int[] x, int len, int[] z, int zlen) { int lastProductLowWord = 0; int i = 0; int offset; for(offset = 0; i &lt; len; ++i) { long piece = (long)x[i] &amp; 4294967295L; long product = piece * piece; z[offset++] = lastProductLowWord &lt;&lt; 31 | (int)(product &gt;&gt;&gt; 33); z[offset++] = (int)(product &gt;&gt;&gt; 1); lastProductLowWord = (int)product; } i = len; for(offset = 1; i &gt; 0; offset += 2) { int t = x[i - 1]; t = mulAdd(z, x, offset, i - 1, t); addOne(z, offset - 1, i, t); --i; } primitiveLeftShift(z, zlen, 1); z[zlen - 1] |= x[len - 1] &amp; 1; return z; } private BigInteger squareKaratsuba() { int half = (this.mag.length + 1) / 2; BigInteger xl = this.getLower(half); BigInteger xh = this.getUpper(half); BigInteger xhs = xh.square(); BigInteger xls = xl.square(); return xhs.shiftLeft(half * 32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half * 32).add(xls); } private BigInteger squareToomCook3() { int len = this.mag.length; int k = (len + 2) / 3; int r = len - 2 * k; BigInteger a2 = this.getToomSlice(k, r, 0, len); BigInteger a1 = this.getToomSlice(k, r, 1, len); BigInteger a0 = this.getToomSlice(k, r, 2, len); BigInteger v0 = a0.square(true); BigInteger da1 = a2.add(a0); BigInteger vm1 = da1.subtract(a1).square(true); da1 = da1.add(a1); BigInteger v1 = da1.square(true); BigInteger vinf = a2.square(true); BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true); BigInteger t2 = v2.subtract(vm1).exactDivideBy3(); BigInteger tm1 = v1.subtract(vm1).shiftRight(1); BigInteger t1 = v1.subtract(v0); t2 = t2.subtract(t1).shiftRight(1); t1 = t1.subtract(tm1).subtract(vinf); t2 = t2.subtract(vinf.shiftLeft(1)); tm1 = tm1.subtract(t2); int ss = k * 32; return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0); } public BigInteger divide(BigInteger val) { return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideBurnikelZiegler(val) : this.divideKnuth(val); } private BigInteger divideKnuth(BigInteger val) { MutableBigInteger q = new MutableBigInteger(); MutableBigInteger a = new MutableBigInteger(this.mag); MutableBigInteger b = new MutableBigInteger(val.mag); a.divideKnuth(b, q, false); return q.toBigInteger(this.signum * val.signum); } public BigInteger[] divideAndRemainder(BigInteger val) { return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideAndRemainderBurnikelZiegler(val) : this.divideAndRemainderKnuth(val); } private BigInteger[] divideAndRemainderKnuth(BigInteger val) { BigInteger[] result = new BigInteger[2]; MutableBigInteger q = new MutableBigInteger(); MutableBigInteger a = new MutableBigInteger(this.mag); MutableBigInteger b = new MutableBigInteger(val.mag); MutableBigInteger r = a.divideKnuth(b, q); result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1); result[1] = r.toBigInteger(this.signum); return result; } public BigInteger remainder(BigInteger val) { return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.remainderBurnikelZiegler(val) : this.remainderKnuth(val); } private BigInteger remainderKnuth(BigInteger val) { MutableBigInteger q = new MutableBigInteger(); MutableBigInteger a = new MutableBigInteger(this.mag); MutableBigInteger b = new MutableBigInteger(val.mag); return a.divideKnuth(b, q).toBigInteger(this.signum); } private BigInteger divideBurnikelZiegler(BigInteger val) { return this.divideAndRemainderBurnikelZiegler(val)[0]; } private BigInteger remainderBurnikelZiegler(BigInteger val) { return this.divideAndRemainderBurnikelZiegler(val)[1]; } private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) { MutableBigInteger q = new MutableBigInteger(); MutableBigInteger r = (new MutableBigInteger(this)).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q); BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(this.signum * val.signum); BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(this.signum); return new BigInteger[]{qBigInt, rBigInt}; } public BigInteger pow(int exponent) { if (exponent &lt; 0) { throw new ArithmeticException(\"Negative exponent\"); } else if (this.signum == 0) { return exponent == 0 ? ONE : this; } else { BigInteger partToSquare = this.abs(); int powersOfTwo = partToSquare.getLowestSetBit(); long bitsToShiftLong = (long)powersOfTwo * (long)exponent; if (bitsToShiftLong &gt; 2147483647L) { reportOverflow(); } int bitsToShift = (int)bitsToShiftLong; int remainingBits; if (powersOfTwo &gt; 0) { partToSquare = partToSquare.shiftRight(powersOfTwo); remainingBits = partToSquare.bitLength(); if (remainingBits == 1) { if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) { return NEGATIVE_ONE.shiftLeft(bitsToShift); } return ONE.shiftLeft(bitsToShift); } } else { remainingBits = partToSquare.bitLength(); if (remainingBits == 1) { if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) { return NEGATIVE_ONE; } return ONE; } } long scaleFactor = (long)remainingBits * (long)exponent; if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62L) { int newSign = this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1 ? -1 : 1; long result = 1L; long baseToPow2 = (long)partToSquare.mag[0] &amp; 4294967295L; int workingExponent = exponent; while(workingExponent != 0) { if ((workingExponent &amp; 1) == 1) { result *= baseToPow2; } if ((workingExponent &gt;&gt;&gt;= 1) != 0) { baseToPow2 *= baseToPow2; } } if (powersOfTwo &gt; 0) { if ((long)bitsToShift + scaleFactor &lt;= 62L) { return valueOf((result &lt;&lt; bitsToShift) * (long)newSign); } else { return valueOf(result * (long)newSign).shiftLeft(bitsToShift); } } else { return valueOf(result * (long)newSign); } } else { if ((long)this.bitLength() * (long)exponent / 32L &gt; 67108864L) { reportOverflow(); } BigInteger answer = ONE; int workingExponent = exponent; while(workingExponent != 0) { if ((workingExponent &amp; 1) == 1) { answer = answer.multiply(partToSquare); } if ((workingExponent &gt;&gt;&gt;= 1) != 0) { partToSquare = partToSquare.square(); } } if (powersOfTwo &gt; 0) { answer = answer.shiftLeft(bitsToShift); } if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) { return answer.negate(); } else { return answer; } } } } public BigInteger sqrt() { if (this.signum &lt; 0) { throw new ArithmeticException(\"Negative BigInteger\"); } else { return (new MutableBigInteger(this.mag)).sqrt().toBigInteger(); } } public BigInteger[] sqrtAndRemainder() { BigInteger s = this.sqrt(); BigInteger r = this.subtract(s.square()); assert r.compareTo(ZERO) &gt;= 0; return new BigInteger[]{s, r}; } public BigInteger gcd(BigInteger val) { if (val.signum == 0) { return this.abs(); } else if (this.signum == 0) { return val.abs(); } else { MutableBigInteger a = new MutableBigInteger(this); MutableBigInteger b = new MutableBigInteger(val); MutableBigInteger result = a.hybridGCD(b); return result.toBigInteger(1); } } static int bitLengthForInt(int n) { return 32 - Integer.numberOfLeadingZeros(n); } private static int[] leftShift(int[] a, int len, int n) { int nInts = n &gt;&gt;&gt; 5; int nBits = n &amp; 31; int bitsInHighWord = bitLengthForInt(a[0]); if (n &lt;= 32 - bitsInHighWord) { primitiveLeftShift(a, len, nBits); return a; } else { int[] result; if (nBits &lt;= 32 - bitsInHighWord) { result = new int[nInts + len]; System.arraycopy(a, 0, result, 0, len); primitiveLeftShift(result, result.length, nBits); return result; } else { result = new int[nInts + len + 1]; System.arraycopy(a, 0, result, 0, len); primitiveRightShift(result, result.length, 32 - nBits); return result; } } } static void primitiveRightShift(int[] a, int len, int n) { int n2 = 32 - n; int i = len - 1; for(int c = a[i]; i &gt; 0; --i) { int b = c; c = a[i - 1]; a[i] = c &lt;&lt; n2 | b &gt;&gt;&gt; n; } a[0] &gt;&gt;&gt;= n; } static void primitiveLeftShift(int[] a, int len, int n) { if (len != 0 &amp;&amp; n != 0) { int n2 = 32 - n; int i = 0; int c = a[i]; for(int m = i + len - 1; i &lt; m; ++i) { int b = c; c = a[i + 1]; a[i] = b &lt;&lt; n | c &gt;&gt;&gt; n2; } a[len - 1] &lt;&lt;= n; } } private static int bitLength(int[] val, int len) { return len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(val[0]); } public BigInteger abs() { return this.signum &gt;= 0 ? this : this.negate(); } public BigInteger negate() { return new BigInteger(this.mag, -this.signum); } public int signum() { return this.signum; } public BigInteger mod(BigInteger m) { if (m.signum &lt;= 0) { throw new ArithmeticException(\"BigInteger: modulus not positive\"); } else { BigInteger result = this.remainder(m); return result.signum &gt;= 0 ? result : result.add(m); } } public BigInteger modPow(BigInteger exponent, BigInteger m) { if (m.signum &lt;= 0) { throw new ArithmeticException(\"BigInteger: modulus not positive\"); } else if (exponent.signum == 0) { return m.equals(ONE) ? ZERO : ONE; } else if (this.equals(ONE)) { return m.equals(ONE) ? ZERO : ONE; } else if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0) { return ZERO; } else if (this.equals(negConst[1]) &amp;&amp; !exponent.testBit(0)) { return m.equals(ONE) ? ZERO : ONE; } else { boolean invertResult; if (invertResult = exponent.signum &lt; 0) { exponent = exponent.negate(); } BigInteger base = this.signum &gt;= 0 &amp;&amp; this.compareTo(m) &lt; 0 ? this : this.mod(m); BigInteger result; if (m.testBit(0)) { result = base.oddModPow(exponent, m); } else { int p = m.getLowestSetBit(); BigInteger m1 = m.shiftRight(p); BigInteger m2 = ONE.shiftLeft(p); BigInteger base2 = this.signum &gt;= 0 &amp;&amp; this.compareTo(m1) &lt; 0 ? this : this.mod(m1); BigInteger a1 = m1.equals(ONE) ? ZERO : base2.oddModPow(exponent, m1); BigInteger a2 = base.modPow2(exponent, p); BigInteger y1 = m2.modInverse(m1); BigInteger y2 = m1.modInverse(m2); if (m.mag.length &lt; 33554432) { result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m); } else { MutableBigInteger t1 = new MutableBigInteger(); (new MutableBigInteger(a1.multiply(m2))).multiply(new MutableBigInteger(y1), t1); MutableBigInteger t2 = new MutableBigInteger(); (new MutableBigInteger(a2.multiply(m1))).multiply(new MutableBigInteger(y2), t2); t1.add(t2); MutableBigInteger q = new MutableBigInteger(); result = t1.divide(new MutableBigInteger(m), q).toBigInteger(); } } return invertResult ? result.modInverse(m) : result; } } private static int[] montgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) { implMontgomeryMultiplyChecks(a, b, n, len, product); if (len &gt; 512) { product = multiplyToLen(a, len, b, len, product); return montReduce(product, n, len, (int)inv); } else { return implMontgomeryMultiply(a, b, n, len, inv, materialize(product, len)); } } private static int[] montgomerySquare(int[] a, int[] n, int len, long inv, int[] product) { implMontgomeryMultiplyChecks(a, a, n, len, product); if (len &gt; 512) { product = squareToLen(a, len, product); return montReduce(product, n, len, (int)inv); } else { return implMontgomerySquare(a, n, len, inv, materialize(product, len)); } } private static void implMontgomeryMultiplyChecks(int[] a, int[] b, int[] n, int len, int[] product) throws RuntimeException { if (len % 2 != 0) { throw new IllegalArgumentException(\"input array length must be even: \" + len); } else if (len &lt; 1) { throw new IllegalArgumentException(\"invalid input length: \" + len); } else if (len &gt; a.length || len &gt; b.length || len &gt; n.length || product != null &amp;&amp; len &gt; product.length) { throw new IllegalArgumentException(\"input array length out of bound: \" + len); } } private static int[] materialize(int[] z, int len) { if (z == null || z.length &lt; len) { z = new int[len]; } return z; } @HotSpotIntrinsicCandidate private static int[] implMontgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) { product = multiplyToLen(a, len, b, len, product); return montReduce(product, n, len, (int)inv); } @HotSpotIntrinsicCandidate private static int[] implMontgomerySquare(int[] a, int[] n, int len, long inv, int[] product) { product = squareToLen(a, len, product); return montReduce(product, n, len, (int)inv); } private BigInteger oddModPow(BigInteger y, BigInteger z) { if (y.equals(ONE)) { return this; } else if (this.signum == 0) { return ZERO; } else { int[] base = (int[])this.mag.clone(); int[] exp = y.mag; int[] mod = z.mag; int modLen = mod.length; if ((modLen &amp; 1) != 0) { int[] x = new int[modLen + 1]; System.arraycopy(mod, 0, x, 1, modLen); mod = x; ++modLen; } int wbits = 0; int ebits = bitLength(exp, exp.length); if (ebits != 17 || exp[0] != 65537) { while(ebits &gt; bnExpModThreshTable[wbits]) { ++wbits; } } int tblmask = 1 &lt;&lt; wbits; int[][] table = new int[tblmask][]; for(int i = 0; i &lt; tblmask; ++i) { table[i] = new int[modLen]; } long n0 = ((long)mod[modLen - 1] &amp; 4294967295L) + (((long)mod[modLen - 2] &amp; 4294967295L) &lt;&lt; 32); long inv = -MutableBigInteger.inverseMod64(n0); int[] a = leftShift(base, base.length, modLen &lt;&lt; 5); MutableBigInteger q = new MutableBigInteger(); MutableBigInteger a2 = new MutableBigInteger(a); MutableBigInteger b2 = new MutableBigInteger(mod); b2.normalize(); MutableBigInteger r = a2.divide(b2, q); table[0] = r.toIntArray(); int[] t; if (table[0].length &lt; modLen) { int offset = modLen - table[0].length; t = new int[modLen]; System.arraycopy(table[0], 0, t, offset, table[0].length); table[0] = t; } int[] b = montgomerySquare(table[0], mod, modLen, inv, (int[])null); t = Arrays.copyOf(b, modLen); int bitpos; for(bitpos = 1; bitpos &lt; tblmask; ++bitpos) { table[bitpos] = montgomeryMultiply(t, table[bitpos - 1], mod, modLen, inv, (int[])null); } bitpos = 1 &lt;&lt; (ebits - 1 &amp; 31); int buf = 0; int elen = exp.length; int eIndex = 0; int multpos; for(multpos = 0; multpos &lt;= wbits; ++multpos) { buf = buf &lt;&lt; 1 | ((exp[eIndex] &amp; bitpos) != 0 ? 1 : 0); bitpos &gt;&gt;&gt;= 1; if (bitpos == 0) { ++eIndex; bitpos = -2147483648; --elen; } } --ebits; boolean isone = true; for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) { buf &gt;&gt;&gt;= 1; } int[] mult = table[buf &gt;&gt;&gt; 1]; buf = 0; if (multpos == ebits) { isone = false; } while(true) { --ebits; buf &lt;&lt;= 1; if (elen != 0) { buf |= (exp[eIndex] &amp; bitpos) != 0 ? 1 : 0; bitpos &gt;&gt;&gt;= 1; if (bitpos == 0) { ++eIndex; bitpos = -2147483648; --elen; } } if ((buf &amp; tblmask) != 0) { for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) { buf &gt;&gt;&gt;= 1; } mult = table[buf &gt;&gt;&gt; 1]; buf = 0; } if (ebits == multpos) { if (isone) { b = (int[])mult.clone(); isone = false; } else { a = montgomeryMultiply(b, mult, mod, modLen, inv, a); t = a; a = b; b = t; } } if (ebits == 0) { int[] t2 = new int[2 * modLen]; System.arraycopy(b, 0, t2, modLen, modLen); b = montReduce(t2, mod, modLen, (int)inv); t2 = Arrays.copyOf(b, modLen); return new BigInteger(1, t2); } if (!isone) { a = montgomerySquare(b, mod, modLen, inv, a); t = a; a = b; b = t; } } } } private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) { int c = 0; int len = mlen; int offset = 0; do { int nEnd = n[n.length - 1 - offset]; int carry = mulAdd(n, mod, offset, mlen, inv * nEnd); c += addOne(n, offset, mlen, carry); ++offset; --len; } while(len &gt; 0); while(c &gt; 0) { c += subN(n, mod, mlen); } while(intArrayCmpToLen(n, mod, mlen) &gt;= 0) { subN(n, mod, mlen); } return n; } private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) { for(int i = 0; i &lt; len; ++i) { long b1 = (long)arg1[i] &amp; 4294967295L; long b2 = (long)arg2[i] &amp; 4294967295L; if (b1 &lt; b2) { return -1; } if (b1 &gt; b2) { return 1; } } return 0; } private static int subN(int[] a, int[] b, int len) { long sum = 0L; while(true) { --len; if (len &lt; 0) { return (int)(sum &gt;&gt; 32); } sum = ((long)a[len] &amp; 4294967295L) - ((long)b[len] &amp; 4294967295L) + (sum &gt;&gt; 32); a[len] = (int)sum; } } static int mulAdd(int[] out, int[] in, int offset, int len, int k) { implMulAddCheck(out, in, offset, len, k); return implMulAdd(out, in, offset, len, k); } private static void implMulAddCheck(int[] out, int[] in, int offset, int len, int k) { if (len &gt; in.length) { throw new IllegalArgumentException(\"input length is out of bound: \" + len + \" &gt; \" + in.length); } else if (offset &lt; 0) { throw new IllegalArgumentException(\"input offset is invalid: \" + offset); } else if (offset &gt; out.length - 1) { throw new IllegalArgumentException(\"input offset is out of bound: \" + offset + \" &gt; \" + (out.length - 1)); } else if (len &gt; out.length - offset) { throw new IllegalArgumentException(\"input len is out of bound: \" + len + \" &gt; \" + (out.length - offset)); } } @HotSpotIntrinsicCandidate private static int implMulAdd(int[] out, int[] in, int offset, int len, int k) { long kLong = (long)k &amp; 4294967295L; long carry = 0L; offset = out.length - offset - 1; for(int j = len - 1; j &gt;= 0; --j) { long product = ((long)in[j] &amp; 4294967295L) * kLong + ((long)out[offset] &amp; 4294967295L) + carry; out[offset--] = (int)product; carry = product &gt;&gt;&gt; 32; } return (int)carry; } static int addOne(int[] a, int offset, int mlen, int carry) { offset = a.length - 1 - mlen - offset; long t = ((long)a[offset] &amp; 4294967295L) + ((long)carry &amp; 4294967295L); a[offset] = (int)t; if (t &gt;&gt;&gt; 32 == 0L) { return 0; } else { do { --mlen; if (mlen &lt; 0) { return 1; } --offset; if (offset &lt; 0) { return 1; } int var10002 = a[offset]++; } while(a[offset] == 0); return 0; } } private BigInteger modPow2(BigInteger exponent, int p) { BigInteger result = ONE; BigInteger baseToPow2 = this.mod2(p); int expOffset = 0; int limit = exponent.bitLength(); if (this.testBit(0)) { limit = p - 1 &lt; limit ? p - 1 : limit; } while(expOffset &lt; limit) { if (exponent.testBit(expOffset)) { result = result.multiply(baseToPow2).mod2(p); } ++expOffset; if (expOffset &lt; limit) { baseToPow2 = baseToPow2.square().mod2(p); } } return result; } private BigInteger mod2(int p) { if (this.bitLength() &lt;= p) { return this; } else { int numInts = p + 31 &gt;&gt;&gt; 5; int[] mag = new int[numInts]; System.arraycopy(this.mag, this.mag.length - numInts, mag, 0, numInts); int excessBits = (numInts &lt;&lt; 5) - p; mag[0] = (int)((long)mag[0] &amp; (1L &lt;&lt; 32 - excessBits) - 1L); return mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1); } } public BigInteger modInverse(BigInteger m) { if (m.signum != 1) { throw new ArithmeticException(\"BigInteger: modulus not positive\"); } else if (m.equals(ONE)) { return ZERO; } else { BigInteger modVal = this; if (this.signum &lt; 0 || this.compareMagnitude(m) &gt;= 0) { modVal = this.mod(m); } if (modVal.equals(ONE)) { return ONE; } else { MutableBigInteger a = new MutableBigInteger(modVal); MutableBigInteger b = new MutableBigInteger(m); MutableBigInteger result = a.mutableModInverse(b); return result.toBigInteger(1); } } } public BigInteger shiftLeft(int n) { if (this.signum == 0) { return ZERO; } else if (n &gt; 0) { return new BigInteger(shiftLeft(this.mag, n), this.signum); } else { return n == 0 ? this : this.shiftRightImpl(-n); } } private static int[] shiftLeft(int[] mag, int n) { int nInts = n &gt;&gt;&gt; 5; int nBits = n &amp; 31; int magLen = mag.length; int[] newMag = null; int[] newMag; if (nBits == 0) { newMag = new int[magLen + nInts]; System.arraycopy(mag, 0, newMag, 0, magLen); } else { int i = 0; int nBits2 = 32 - nBits; int highBits = mag[0] &gt;&gt;&gt; nBits2; if (highBits != 0) { newMag = new int[magLen + nInts + 1]; newMag[i++] = highBits; } else { newMag = new int[magLen + nInts]; } int j; for(j = 0; j &lt; magLen - 1; newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2) { } newMag[i] = mag[j] &lt;&lt; nBits; } return newMag; } public BigInteger shiftRight(int n) { if (this.signum == 0) { return ZERO; } else if (n &gt; 0) { return this.shiftRightImpl(n); } else { return n == 0 ? this : new BigInteger(shiftLeft(this.mag, -n), this.signum); } } private BigInteger shiftRightImpl(int n) { int nInts = n &gt;&gt;&gt; 5; int nBits = n &amp; 31; int magLen = this.mag.length; int[] newMag = null; if (nInts &gt;= magLen) { return this.signum &gt;= 0 ? ZERO : negConst[1]; } else { int newMagLen; int i; int nBits2; int[] newMag; if (nBits == 0) { newMagLen = magLen - nInts; newMag = Arrays.copyOf(this.mag, newMagLen); } else { newMagLen = 0; i = this.mag[0] &gt;&gt;&gt; nBits; if (i != 0) { newMag = new int[magLen - nInts]; newMag[newMagLen++] = i; } else { newMag = new int[magLen - nInts - 1]; } nBits2 = 32 - nBits; for(int j = 0; j &lt; magLen - nInts - 1; newMag[newMagLen++] = this.mag[j++] &lt;&lt; nBits2 | this.mag[j] &gt;&gt;&gt; nBits) { } } if (this.signum &lt; 0) { boolean onesLost = false; i = magLen - 1; for(nBits2 = magLen - nInts; i &gt;= nBits2 &amp;&amp; !onesLost; --i) { onesLost = this.mag[i] != 0; } if (!onesLost &amp;&amp; nBits != 0) { onesLost = this.mag[magLen - nInts - 1] &lt;&lt; 32 - nBits != 0; } if (onesLost) { newMag = this.javaIncrement(newMag); } } return new BigInteger(newMag, this.signum); } } int[] javaIncrement(int[] val) { int lastSum = 0; for(int i = val.length - 1; i &gt;= 0 &amp;&amp; lastSum == 0; --i) { lastSum = ++val[i]; } if (lastSum == 0) { val = new int[val.length + 1]; val[0] = 1; } return val; } public BigInteger and(BigInteger val) { int[] result = new int[Math.max(this.intLength(), val.intLength())]; for(int i = 0; i &lt; result.length; ++i) { result[i] = this.getInt(result.length - i - 1) &amp; val.getInt(result.length - i - 1); } return valueOf(result); } public BigInteger or(BigInteger val) { int[] result = new int[Math.max(this.intLength(), val.intLength())]; for(int i = 0; i &lt; result.length; ++i) { result[i] = this.getInt(result.length - i - 1) | val.getInt(result.length - i - 1); } return valueOf(result); } public BigInteger xor(BigInteger val) { int[] result = new int[Math.max(this.intLength(), val.intLength())]; for(int i = 0; i &lt; result.length; ++i) { result[i] = this.getInt(result.length - i - 1) ^ val.getInt(result.length - i - 1); } return valueOf(result); } public BigInteger not() { int[] result = new int[this.intLength()]; for(int i = 0; i &lt; result.length; ++i) { result[i] = ~this.getInt(result.length - i - 1); } return valueOf(result); } public BigInteger andNot(BigInteger val) { int[] result = new int[Math.max(this.intLength(), val.intLength())]; for(int i = 0; i &lt; result.length; ++i) { result[i] = this.getInt(result.length - i - 1) &amp; ~val.getInt(result.length - i - 1); } return valueOf(result); } public boolean testBit(int n) { if (n &lt; 0) { throw new ArithmeticException(\"Negative bit address\"); } else { return (this.getInt(n &gt;&gt;&gt; 5) &amp; 1 &lt;&lt; (n &amp; 31)) != 0; } } public BigInteger setBit(int n) { if (n &lt; 0) { throw new ArithmeticException(\"Negative bit address\"); } else { int intNum = n &gt;&gt;&gt; 5; int[] result = new int[Math.max(this.intLength(), intNum + 2)]; for(int i = 0; i &lt; result.length; ++i) { result[result.length - i - 1] = this.getInt(i); } result[result.length - intNum - 1] |= 1 &lt;&lt; (n &amp; 31); return valueOf(result); } } public BigInteger clearBit(int n) { if (n &lt; 0) { throw new ArithmeticException(\"Negative bit address\"); } else { int intNum = n &gt;&gt;&gt; 5; int[] result = new int[Math.max(this.intLength(), (n + 1 &gt;&gt;&gt; 5) + 1)]; for(int i = 0; i &lt; result.length; ++i) { result[result.length - i - 1] = this.getInt(i); } result[result.length - intNum - 1] &amp;= ~(1 &lt;&lt; (n &amp; 31)); return valueOf(result); } } public BigInteger flipBit(int n) { if (n &lt; 0) { throw new ArithmeticException(\"Negative bit address\"); } else { int intNum = n &gt;&gt;&gt; 5; int[] result = new int[Math.max(this.intLength(), intNum + 2)]; for(int i = 0; i &lt; result.length; ++i) { result[result.length - i - 1] = this.getInt(i); } result[result.length - intNum - 1] ^= 1 &lt;&lt; (n &amp; 31); return valueOf(result); } } public int getLowestSetBit() { int lsb = this.lowestSetBitPlusTwo - 2; if (lsb == -2) { int lsb = 0; if (this.signum == 0) { lsb = lsb - 1; } else { int i; int b; for(i = 0; (b = this.getInt(i)) == 0; ++i) { } lsb = lsb + (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b); } this.lowestSetBitPlusTwo = lsb + 2; } return lsb; } public int bitLength() { int n = this.bitLengthPlusOne - 1; if (n == -1) { int[] m = this.mag; int len = m.length; if (len == 0) { n = 0; } else { int magBitLength = (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]); if (this.signum &gt;= 0) { n = magBitLength; } else { boolean pow2 = Integer.bitCount(this.mag[0]) == 1; for(int i = 1; i &lt; len &amp;&amp; pow2; ++i) { pow2 = this.mag[i] == 0; } n = pow2 ? magBitLength - 1 : magBitLength; } } this.bitLengthPlusOne = n + 1; } return n; } public int bitCount() { int bc = this.bitCountPlusOne - 1; if (bc == -1) { bc = 0; int magTrailingZeroCount; for(magTrailingZeroCount = 0; magTrailingZeroCount &lt; this.mag.length; ++magTrailingZeroCount) { bc += Integer.bitCount(this.mag[magTrailingZeroCount]); } if (this.signum &lt; 0) { magTrailingZeroCount = 0; int j; for(j = this.mag.length - 1; this.mag[j] == 0; --j) { magTrailingZeroCount += 32; } magTrailingZeroCount += Integer.numberOfTrailingZeros(this.mag[j]); bc += magTrailingZeroCount - 1; } this.bitCountPlusOne = bc + 1; } return bc; } public boolean isProbablePrime(int certainty) { if (certainty &lt;= 0) { return true; } else { BigInteger w = this.abs(); if (w.equals(TWO)) { return true; } else { return w.testBit(0) &amp;&amp; !w.equals(ONE) ? w.primeToCertainty(certainty, (Random)null) : false; } } } public int compareTo(BigInteger val) { if (this.signum == val.signum) { switch(this.signum) { case -1: return val.compareMagnitude(this); case 1: return this.compareMagnitude(val); default: return 0; } } else { return this.signum &gt; val.signum ? 1 : -1; } } final int compareMagnitude(BigInteger val) { int[] m1 = this.mag; int len1 = m1.length; int[] m2 = val.mag; int len2 = m2.length; if (len1 &lt; len2) { return -1; } else if (len1 &gt; len2) { return 1; } else { for(int i = 0; i &lt; len1; ++i) { int a = m1[i]; int b = m2[i]; if (a != b) { return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1; } } return 0; } } final int compareMagnitude(long val) { assert val != -9223372036854775808L; int[] m1 = this.mag; int len = m1.length; if (len &gt; 2) { return 1; } else { if (val &lt; 0L) { val = -val; } int highWord = (int)(val &gt;&gt;&gt; 32); int a; int b; if (highWord == 0) { if (len &lt; 1) { return -1; } else if (len &gt; 1) { return 1; } else { a = m1[0]; b = (int)val; if (a != b) { return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1; } else { return 0; } } } else if (len &lt; 2) { return -1; } else { a = m1[0]; if (a != highWord) { return ((long)a &amp; 4294967295L) &lt; ((long)highWord &amp; 4294967295L) ? -1 : 1; } else { a = m1[1]; b = (int)val; if (a != b) { return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1; } else { return 0; } } } } } public boolean equals(Object x) { if (x == this) { return true; } else if (!(x instanceof BigInteger)) { return false; } else { BigInteger xInt = (BigInteger)x; if (xInt.signum != this.signum) { return false; } else { int[] m = this.mag; int len = m.length; int[] xm = xInt.mag; if (len != xm.length) { return false; } else { for(int i = 0; i &lt; len; ++i) { if (xm[i] != m[i]) { return false; } } return true; } } } } public BigInteger min(BigInteger val) { return this.compareTo(val) &lt; 0 ? this : val; } public BigInteger max(BigInteger val) { return this.compareTo(val) &gt; 0 ? this : val; } public int hashCode() { int hashCode = 0; for(int i = 0; i &lt; this.mag.length; ++i) { hashCode = (int)((long)(31 * hashCode) + ((long)this.mag[i] &amp; 4294967295L)); } return hashCode * this.signum; } public String toString(int radix) { if (this.signum == 0) { return \"0\"; } else { if (radix &lt; 2 || radix &gt; 36) { radix = 10; } if (this.mag.length &lt;= 20) { return this.smallToString(radix); } else { StringBuilder sb = new StringBuilder(); if (this.signum &lt; 0) { toString(this.negate(), sb, radix, 0); sb.insert(0, '-'); } else { toString(this, sb, radix, 0); } return sb.toString(); } } } private String smallToString(int radix) { if (this.signum == 0) { return \"0\"; } else { int maxNumDigitGroups = (4 * this.mag.length + 6) / 7; String[] digitGroup = new String[maxNumDigitGroups]; BigInteger tmp = this.abs(); int numGroups; BigInteger q2; for(numGroups = 0; tmp.signum != 0; tmp = q2) { BigInteger d = longRadix[radix]; MutableBigInteger q = new MutableBigInteger(); MutableBigInteger a = new MutableBigInteger(tmp.mag); MutableBigInteger b = new MutableBigInteger(d.mag); MutableBigInteger r = a.divide(b, q); q2 = q.toBigInteger(tmp.signum * d.signum); BigInteger r2 = r.toBigInteger(tmp.signum * d.signum); digitGroup[numGroups++] = Long.toString(r2.longValue(), radix); } StringBuilder buf = new StringBuilder(numGroups * digitsPerLong[radix] + 1); if (this.signum &lt; 0) { buf.append('-'); } buf.append(digitGroup[numGroups - 1]); for(int i = numGroups - 2; i &gt;= 0; --i) { int numLeadingZeros = digitsPerLong[radix] - digitGroup[i].length(); if (numLeadingZeros != 0) { buf.append(zeros[numLeadingZeros]); } buf.append(digitGroup[i]); } return buf.toString(); } } private static void toString(BigInteger u, StringBuilder sb, int radix, int digits) { int i; if (u.mag.length &gt; 20) { int b = u.bitLength(); i = (int)Math.round(Math.log((double)b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0D); BigInteger v = getRadixConversionCache(radix, i); BigInteger[] results = u.divideAndRemainder(v); int expectedDigits = 1 &lt;&lt; i; toString(results[0], sb, radix, digits - expectedDigits); toString(results[1], sb, radix, expectedDigits); } else { String s = u.smallToString(radix); if (s.length() &lt; digits &amp;&amp; sb.length() &gt; 0) { for(i = s.length(); i &lt; digits; ++i) { sb.append('0'); } } sb.append(s); } } private static BigInteger getRadixConversionCache(int radix, int exponent) { BigInteger[] cacheLine = powerCache[radix]; if (exponent &lt; cacheLine.length) { return cacheLine[exponent]; } else { int oldLength = cacheLine.length; cacheLine = (BigInteger[])Arrays.copyOf(cacheLine, exponent + 1); for(int i = oldLength; i &lt;= exponent; ++i) { cacheLine[i] = cacheLine[i - 1].pow(2); } BigInteger[][] pc = powerCache; if (exponent &gt;= pc[radix].length) { pc = (BigInteger[][])pc.clone(); pc[radix] = cacheLine; powerCache = pc; } return cacheLine[exponent]; } } public String toString() { return this.toString(10); } public byte[] toByteArray() { int byteLen = this.bitLength() / 8 + 1; byte[] byteArray = new byte[byteLen]; int i = byteLen - 1; int bytesCopied = 4; int nextInt = 0; for(int var6 = 0; i &gt;= 0; --i) { if (bytesCopied == 4) { nextInt = this.getInt(var6++); bytesCopied = 1; } else { nextInt &gt;&gt;&gt;= 8; ++bytesCopied; } byteArray[i] = (byte)nextInt; } return byteArray; } public int intValue() { int result = false; int result = this.getInt(0); return result; } public long longValue() { long result = 0L; for(int i = 1; i &gt;= 0; --i) { result = (result &lt;&lt; 32) + ((long)this.getInt(i) &amp; 4294967295L); } return result; } public float floatValue() { if (this.signum == 0) { return 0.0F; } else { int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1; if (exponent &lt; 63) { return (float)this.longValue(); } else if (exponent &gt; 127) { return this.signum &gt; 0 ? 1.0F / 0.0 : -1.0F / 0.0; } else { int shift = exponent - 24; int nBits = shift &amp; 31; int nBits2 = 32 - nBits; int twiceSignifFloor; if (nBits == 0) { twiceSignifFloor = this.mag[0]; } else { twiceSignifFloor = this.mag[0] &gt;&gt;&gt; nBits; if (twiceSignifFloor == 0) { twiceSignifFloor = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits; } } int signifFloor = twiceSignifFloor &gt;&gt; 1; signifFloor &amp;= 8388607; boolean increment = (twiceSignifFloor &amp; 1) != 0 &amp;&amp; ((signifFloor &amp; 1) != 0 || this.abs().getLowestSetBit() &lt; shift); int signifRounded = increment ? signifFloor + 1 : signifFloor; int bits = exponent + 127 &lt;&lt; 23; bits += signifRounded; bits |= this.signum &amp; -2147483648; return Float.intBitsToFloat(bits); } } } public double doubleValue() { if (this.signum == 0) { return 0.0D; } else { int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1; if (exponent &lt; 63) { return (double)this.longValue(); } else if (exponent &gt; 1023) { return this.signum &gt; 0 ? 1.0D / 0.0 : -1.0D / 0.0; } else { int shift = exponent - 53; int nBits = shift &amp; 31; int nBits2 = 32 - nBits; int highBits; int lowBits; if (nBits == 0) { highBits = this.mag[0]; lowBits = this.mag[1]; } else { highBits = this.mag[0] &gt;&gt;&gt; nBits; lowBits = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits; if (highBits == 0) { highBits = lowBits; lowBits = this.mag[1] &lt;&lt; nBits2 | this.mag[2] &gt;&gt;&gt; nBits; } } long twiceSignifFloor = ((long)highBits &amp; 4294967295L) &lt;&lt; 32 | (long)lowBits &amp; 4294967295L; long signifFloor = twiceSignifFloor &gt;&gt; 1; signifFloor &amp;= 4503599627370495L; boolean increment = (twiceSignifFloor &amp; 1L) != 0L &amp;&amp; ((signifFloor &amp; 1L) != 0L || this.abs().getLowestSetBit() &lt; shift); long signifRounded = increment ? signifFloor + 1L : signifFloor; long bits = (long)(exponent + 1023) &lt;&lt; 52; bits += signifRounded; bits |= (long)this.signum &amp; -9223372036854775808L; return Double.longBitsToDouble(bits); } } } private static int[] stripLeadingZeroInts(int[] val) { int vlen = val.length; int keep; for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) { } return Arrays.copyOfRange(val, keep, vlen); } private static int[] trustedStripLeadingZeroInts(int[] val) { int vlen = val.length; int keep; for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) { } return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen); } private static int[] stripLeadingZeroBytes(byte[] a, int off, int len) { int indexBound = off + len; int keep; for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == 0; ++keep) { } int intLength = indexBound - keep + 3 &gt;&gt;&gt; 2; int[] result = new int[intLength]; int b = indexBound - 1; for(int i = intLength - 1; i &gt;= 0; --i) { result[i] = a[b--] &amp; 255; int bytesRemaining = b - keep + 1; int bytesToTransfer = Math.min(3, bytesRemaining); for(int j = 8; j &lt;= bytesToTransfer &lt;&lt; 3; j += 8) { result[i] |= (a[b--] &amp; 255) &lt;&lt; j; } } return result; } private static int[] makePositive(byte[] a, int off, int len) { int indexBound = off + len; int keep; for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == -1; ++keep) { } int k; for(k = keep; k &lt; indexBound &amp;&amp; a[k] == 0; ++k) { } int extraByte = k == indexBound ? 1 : 0; int intLength = indexBound - keep + extraByte + 3 &gt;&gt;&gt; 2; int[] result = new int[intLength]; int b = indexBound - 1; int i; for(i = intLength - 1; i &gt;= 0; --i) { result[i] = a[b--] &amp; 255; int numBytesToTransfer = Math.min(3, b - keep + 1); if (numBytesToTransfer &lt; 0) { numBytesToTransfer = 0; } int mask; for(mask = 8; mask &lt;= 8 * numBytesToTransfer; mask += 8) { result[i] |= (a[b--] &amp; 255) &lt;&lt; mask; } mask = -1 &gt;&gt;&gt; 8 * (3 - numBytesToTransfer); result[i] = ~result[i] &amp; mask; } for(i = result.length - 1; i &gt;= 0; --i) { result[i] = (int)(((long)result[i] &amp; 4294967295L) + 1L); if (result[i] != 0) { break; } } return result; } private static int[] makePositive(int[] a) { int keep; for(keep = 0; keep &lt; a.length &amp;&amp; a[keep] == -1; ++keep) { } int j; for(j = keep; j &lt; a.length &amp;&amp; a[j] == 0; ++j) { } int extraInt = j == a.length ? 1 : 0; int[] result = new int[a.length - keep + extraInt]; int i; for(i = keep; i &lt; a.length; ++i) { result[i - keep + extraInt] = ~a[i]; } for(i = result.length - 1; ++result[i] == 0; --i) { } return result; } private int intLength() { return (this.bitLength() &gt;&gt;&gt; 5) + 1; } private int signBit() { return this.signum &lt; 0 ? 1 : 0; } private int signInt() { return this.signum &lt; 0 ? -1 : 0; } private int getInt(int n) { if (n &lt; 0) { return 0; } else if (n &gt;= this.mag.length) { return this.signInt(); } else { int magInt = this.mag[this.mag.length - n - 1]; return this.signum &gt;= 0 ? magInt : (n &lt;= this.firstNonzeroIntNum() ? -magInt : ~magInt); } } private int firstNonzeroIntNum() { int fn = this.firstNonzeroIntNumPlusTwo - 2; if (fn == -2) { int mlen = this.mag.length; int i; for(i = mlen - 1; i &gt;= 0 &amp;&amp; this.mag[i] == 0; --i) { } fn = mlen - i - 1; this.firstNonzeroIntNumPlusTwo = fn + 2; } return fn; } private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { GetField fields = s.readFields(); int sign = fields.get(\"signum\", -2); byte[] magnitude = (byte[])fields.get(\"magnitude\", (Object)null); if (sign &gt;= -1 &amp;&amp; sign &lt;= 1) { int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length); if (mag.length == 0 != (sign == 0)) { String message = \"BigInteger: signum-magnitude mismatch\"; if (fields.defaulted(\"magnitude\")) { message = \"BigInteger: Magnitude not present in stream\"; } throw new StreamCorruptedException(message); } else { BigInteger.UnsafeHolder.putSign(this, sign); BigInteger.UnsafeHolder.putMag(this, mag); if (mag.length &gt;= 67108864) { try { this.checkRange(); } catch (ArithmeticException var7) { throw new StreamCorruptedException(\"BigInteger: Out of the supported range\"); } } } } else { String message = \"BigInteger: Invalid signum value\"; if (fields.defaulted(\"signum\")) { message = \"BigInteger: Signum not present in stream\"; } throw new StreamCorruptedException(message); } } private void writeObject(ObjectOutputStream s) throws IOException { PutField fields = s.putFields(); fields.put(\"signum\", this.signum); fields.put(\"magnitude\", this.magSerializedForm()); fields.put(\"bitCount\", -1); fields.put(\"bitLength\", -1); fields.put(\"lowestSetBit\", -2); fields.put(\"firstNonzeroByteNum\", -2); s.writeFields(); } private byte[] magSerializedForm() { int len = this.mag.length; int bitLen = len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]); int byteLen = bitLen + 7 &gt;&gt;&gt; 3; byte[] result = new byte[byteLen]; int i = byteLen - 1; int bytesCopied = 4; int intIndex = len - 1; for(int nextInt = 0; i &gt;= 0; --i) { if (bytesCopied == 4) { nextInt = this.mag[intIndex--]; bytesCopied = 1; } else { nextInt &gt;&gt;&gt;= 8; ++bytesCopied; } result[i] = (byte)nextInt; } return result; } public long longValueExact() { if (this.mag.length &lt;= 2 &amp;&amp; this.bitLength() &lt;= 63) { return this.longValue(); } else { throw new ArithmeticException(\"BigInteger out of long range\"); } } public int intValueExact() { if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) { return this.intValue(); } else { throw new ArithmeticException(\"BigInteger out of int range\"); } } public short shortValueExact() { if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) { int value = this.intValue(); if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) { return this.shortValue(); } } throw new ArithmeticException(\"BigInteger out of short range\"); } public byte byteValueExact() { if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) { int value = this.intValue(); if (value &gt;= -128 &amp;&amp; value &lt;= 127) { return this.byteValue(); } } throw new ArithmeticException(\"BigInteger out of byte range\"); } static { int i; for(i = 1; i &lt;= 16; ++i) { int[] magnitude = new int[]{i}; posConst[i] = new BigInteger(magnitude, 1); negConst[i] = new BigInteger(magnitude, -1); } powerCache = new BigInteger[37][]; logCache = new double[37]; for(i = 2; i &lt;= 36; ++i) { powerCache[i] = new BigInteger[]{valueOf((long)i)}; logCache[i] = Math.log((double)i); } ZERO = new BigInteger(new int[0], 0); ONE = valueOf(1L); TWO = valueOf(2L); NEGATIVE_ONE = valueOf(-1L); TEN = valueOf(10L); bnExpModThreshTable = new int[]{7, 25, 81, 241, 673, 1793, 2147483647}; zeros = new String[64]; zeros[63] = \"000000000000000000000000000000000000000000000000000000000000000\"; for(i = 0; i &lt; 63; ++i) { zeros[i] = zeros[63].substring(0, i); } digitsPerLong = new int[]{0, 0, 62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12}; longRadix = new BigInteger[]{null, null, valueOf(4611686018427387904L), valueOf(4052555153018976267L), valueOf(4611686018427387904L), valueOf(7450580596923828125L), valueOf(4738381338321616896L), valueOf(3909821048582988049L), valueOf(1152921504606846976L), valueOf(1350851717672992089L), valueOf(1000000000000000000L), valueOf(5559917313492231481L), valueOf(2218611106740436992L), valueOf(8650415919381337933L), valueOf(2177953337809371136L), valueOf(6568408355712890625L), valueOf(1152921504606846976L), valueOf(2862423051509815793L), valueOf(6746640616477458432L), valueOf(799006685782884121L), valueOf(1638400000000000000L), valueOf(3243919932521508681L), valueOf(6221821273427820544L), valueOf(504036361936467383L), valueOf(876488338465357824L), valueOf(1490116119384765625L), valueOf(2481152873203736576L), valueOf(4052555153018976267L), valueOf(6502111422497947648L), valueOf(353814783205469041L), valueOf(531441000000000000L), valueOf(787662783788549761L), valueOf(1152921504606846976L), valueOf(1667889514952984961L), valueOf(2386420683693101056L), valueOf(3379220508056640625L), valueOf(4738381338321616896L)}; digitsPerInt = new int[]{0, 0, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5}; intRadix = new int[]{0, 0, 1073741824, 1162261467, 1073741824, 1220703125, 362797056, 1977326743, 1073741824, 387420489, 1000000000, 214358881, 429981696, 815730721, 1475789056, 170859375, 268435456, 410338673, 612220032, 893871739, 1280000000, 1801088541, 113379904, 148035889, 191102976, 244140625, 308915776, 387420489, 481890304, 594823321, 729000000, 887503681, 1073741824, 1291467969, 1544804416, 1838265625, 60466176}; serialPersistentFields = new ObjectStreamField[]{new ObjectStreamField(\"signum\", Integer.TYPE), new ObjectStreamField(\"magnitude\", byte[].class), new ObjectStreamField(\"bitCount\", Integer.TYPE), new ObjectStreamField(\"bitLength\", Integer.TYPE), new ObjectStreamField(\"firstNonzeroByteNum\", Integer.TYPE), new ObjectStreamField(\"lowestSetBit\", Integer.TYPE)}; } private static class UnsafeHolder { private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long signumOffset; private static final long magOffset; private UnsafeHolder() { } static void putSign(BigInteger bi, int sign) { unsafe.putInt(bi, signumOffset, sign); } static void putMag(BigInteger bi, int[] magnitude) { unsafe.putObject(bi, magOffset, magnitude); } static { signumOffset = unsafe.objectFieldOffset(BigInteger.class, \"signum\"); magOffset = unsafe.objectFieldOffset(BigInteger.class, \"mag\"); } }}","link":"/2019/09/21/BigInteger类/"},{"title":"HashMap类","text":"HashMap类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392/* * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * */package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;/** * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface. This * implementation provides all of the optional map operations, and permits * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key. (The &lt;tt&gt;HashMap&lt;/tt&gt; * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is * unsynchronized and permits nulls.) This class makes no guarantees as to * the order of the map; in particular, it does not guarantee that the order * will remain constant over time. * * &lt;p&gt;This implementation provides constant-time performance for the basic * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function * disperses the elements properly among the buckets. Iteration over * collection views requires time proportional to the \"capacity\" of the * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number * of key-value mappings). Thus, it's very important not to set the initial * capacity too high (or the load factor too low) if iteration performance is * important. * * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. The * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial * capacity is simply the capacity at the time the hash table is created. The * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to * get before its capacity is automatically increased. When the number of * entries in the hash table exceeds the product of the load factor and the * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data * structures are rebuilt) so that the hash table has approximately twice the * number of buckets. * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good * tradeoff between time and space costs. Higher values decrease the * space overhead but increase the lookup cost (reflected in most of * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;). The expected number of entries in * the map and its load factor should be taken into account when * setting its initial capacity, so as to minimize the number of * rehash operations. If the initial capacity is greater than the * maximum number of entries divided by the load factor, no rehash * operations will ever occur. * * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; * instance, creating it with a sufficiently large capacity will allow * the mappings to be stored more efficiently than letting it perform * automatic rehashing as needed to grow the table. Note that using * many keys with the same {@code hashCode()} is a sure way to slow * down performance of any hash table. To ameliorate impact, when keys * are {@link Comparable}, this class may use comparison order among * keys to help break ties. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a hash map concurrently, and at least one of * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more mappings; merely changing the value * associated with a key that an instance already contains is not a * structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the map. * * If no such object exists, the map should be \"wrapped\" using the * {@link Collections#synchronizedMap Collections.synchronizedMap} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; * Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt; * * &lt;p&gt;The iterators returned by all of this class's \"collection view methods\" * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after * the iterator is created, in any way except through the iterator's own * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a * {@link ConcurrentModificationException}. Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than risking * arbitrary, non-deterministic behavior at an undetermined time in the * future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=\"{@docRoot}/../technotes/guides/collections/index.html\"&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;K&gt; the type of keys maintained by this map * @param &lt;V&gt; the type of mapped values * * @author Doug Lea * @author Josh Bloch * @author Arthur van Hoff * @author Neal Gafter * @see Object#hashCode() * @see Collection * @see Map * @see TreeMap * @see Hashtable * @since 1.2 */public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; /* * Implementation notes. * * This map usually acts as a binned (bucketed) hash table, but * when bins get too large, they are transformed into bins of * TreeNodes, each structured similarly to those in * java.util.TreeMap. Most methods try to use normal bins, but * relay to TreeNode methods when applicable (simply by checking * instanceof a node). Bins of TreeNodes may be traversed and * used like any others, but additionally support faster lookup * when overpopulated. However, since the vast majority of bins in * normal use are not overpopulated, checking for existence of * tree bins may be delayed in the course of table methods. * * Tree bins (i.e., bins whose elements are all TreeNodes) are * ordered primarily by hashCode, but in the case of ties, if two * elements are of the same \"class C implements Comparable&lt;C&gt;\", * type then their compareTo method is used for ordering. (We * conservatively check generic types via reflection to validate * this -- see method comparableClassFor). The added complexity * of tree bins is worthwhile in providing worst-case O(log n) * operations when keys either have distinct hashes or are * orderable, Thus, performance degrades gracefully under * accidental or malicious usages in which hashCode() methods * return values that are poorly distributed, as well as those in * which many keys share a hashCode, so long as they are also * Comparable. (If neither of these apply, we may waste about a * factor of two in time and space compared to taking no * precautions. But the only known cases stem from poor user * programming practices that are already so slow that this makes * little difference.) * * Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million * * The root of a tree bin is normally its first node. However, * sometimes (currently only upon Iterator.remove), the root might * be elsewhere, but can be recovered following parent links * (method TreeNode.root()). * * All applicable internal methods accept a hash code as an * argument (as normally supplied from a public method), allowing * them to call each other without recomputing user hashCodes. * Most internal methods also accept a \"tab\" argument, that is * normally the current table, but may be a new or old one when * resizing or converting. * * When bin lists are treeified, split, or untreeified, we keep * them in the same relative access/traversal order (i.e., field * Node.next) to better preserve locality, and to slightly * simplify handling of splits and traversals that invoke * iterator.remove. When using comparators on insertion, to keep a * total ordering (or as close as is required here) across * rebalancings, we compare classes and identityHashCodes as * tie-breakers. * * The use and transitions among plain vs tree modes is * complicated by the existence of subclass LinkedHashMap. See * below for hook methods defined to be invoked upon insertion, * removal and access that allow LinkedHashMap internals to * otherwise remain independent of these mechanics. (This also * requires that a map instance be passed to some utility methods * that may create new nodes.) * * The concurrent-programming-like SSA-based coding style helps * avoid aliasing errors amid all of the twisty pointer operations. */ /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } /* ---------------- Static utilities -------------- */ /** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } /** * Returns x's Class if it is of the form \"class C implements * Comparable&lt;C&gt;\", else null. */ static Class&lt;?&gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (int i = 0; i &lt; ts.length; ++i) { if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; } } } return null; } /** * Returns k.compareTo(x) if x matches kc (k's screened comparable * class), else 0. */ @SuppressWarnings({\"rawtypes\",\"unchecked\"}) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) { return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); } /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } /* ---------------- Fields -------------- */ /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; /* ---------------- Public operations -------------- */ /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } /** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); } else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } /** * Returns the number of key-value mappings in this map. * * @return the number of key-value mappings in this map */ public int size() { return size; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */ public boolean isEmpty() { return size == 0; } /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the * specified key. * * @param key The key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. */ public boolean containsKey(Object key) { return getNode(hash(key), key) != null; } /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } /** * Copies all of the mappings from the specified map to this map. * These mappings will replace any mappings that this map had for * any of the keys currently in the specified map. * * @param m mappings to be stored in this map * @throws NullPointerException if the specified map is null */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) { putMapEntries(m, true); } /** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } /** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } /** * Removes all of the mappings from this map. * The map will be empty after this call returns. */ public void clear() { Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) { size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; } } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value */ public boolean containsValue(Object value) { Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; } } } return false; } /** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */ public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks = keySet; if (ks == null) { ks = new KeySet(); keySet = ks; } return ks; } final class KeySet extends AbstractSet&lt;K&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public final boolean contains(Object o) { return containsKey(o); } public final boolean remove(Object key) { return removeNode(hash(key), key, null, false, true) != null; } public final Spliterator&lt;K&gt; spliterator() { return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super K&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); } if (modCount != mc) throw new ConcurrentModificationException(); } } } /** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a view of the values contained in this map */ public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; if (vs == null) { vs = new Values(); values = vs; } return vs; } final class Values extends AbstractCollection&lt;V&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public final boolean contains(Object o) { return containsValue(o); } public final Spliterator&lt;V&gt; spliterator() { return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } } } /** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; } final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } public final boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); } public final boolean remove(Object o) { if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; } return false; } public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() { return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); } if (modCount != mc) throw new ConcurrentModificationException(); } } } // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; } @Override public V putIfAbsent(K key, V value) { return putVal(hash(key), key, value, true, true); } @Override public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } @Override public boolean replace(K key, V oldValue, V newValue) { Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) { e.value = newValue; afterNodeAccess(e); return true; } return false; } @Override public V replace(K key, V value) { Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) { V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; } return null; } @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) { if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) { afterNodeAccess(old); return oldValue; } } V v = mappingFunction.apply(key); if (v == null) { return null; } else if (old != null) { old.value = v; afterNodeAccess(old); return v; } else if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); return v; } public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) { V v = remappingFunction.apply(key, oldValue); if (v != null) { e.value = v; afterNodeAccess(e); return v; } else removeNode(hash, key, null, false, true); } return null; } @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) { if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); } else if (v != null) { if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return v; } @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) { if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } if (old != null) { V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); return v; } if (value != null) { if (t != null) t.putTreeVal(this, tab, hash, key, value); else { tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return value; } @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } } @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) { Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { e.value = function.apply(e.key, e.value); } } if (modCount != mc) throw new ConcurrentModificationException(); } } /* ------------------------------------------------------------ */ // Cloning and serialization /** * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and * values themselves are not cloned. * * @return a shallow copy of this map */ @SuppressWarnings(\"unchecked\") @Override public Object clone() { HashMap&lt;K,V&gt; result; try { result = (HashMap&lt;K,V&gt;)super.clone(); } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } result.reinitialize(); result.putMapEntries(this, false); return result; } // These methods are also used when serializing HashSets final float loadFactor() { return loadFactor; } final int capacity() { return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; } /** * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., * serialize it). * * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the * bucket array) is emitted (int), followed by the * &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value * mappings), followed by the key (Object) and value (Object) * for each key-value mapping. The key-value mappings are * emitted in no particular order. */ private void writeObject(java.io.ObjectOutputStream s) throws IOException { int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); } /** * Reconstitute the {@code HashMap} instance from a stream (i.e., * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\"Illegal load factor: \" + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); else if (mappings &gt; 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } /* ------------------------------------------------------------ */ // iterators abstract class HashIterator { Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() { expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) { // advance to first entry do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } } public final boolean hasNext() { return next != null; } final Node&lt;K,V&gt; nextNode() { Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) { do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } return e; } public final void remove() { Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; } } final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; { public final K next() { return nextNode().key; } } final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; { public final V next() { return nextNode().value; } } final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; { public final Map.Entry&lt;K,V&gt; next() { return nextNode(); } } /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; { final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; } final int getFence() { // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) { HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; } return hi; } public final long estimateSize() { getFence(); // force init return (long) est; } } static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; { KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public KeySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super K&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.key); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super K&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; } } static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; { ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public ValueSpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super V&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.value); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super V&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); } } static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public EntrySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; } } /* ------------------------------------------------------------ */ // LinkedHashMap support /* * The following package-protected methods are designed to be * overridden by LinkedHashMap, but not by any other subclass. * Nearly all other internal methods are also package-protected * but are declared final, so can be used by LinkedHashMap, view * classes, and HashSet. */ // Create a regular (non-tree) node Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next); } // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(p.hash, p.key, p.value, next); } // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(hash, key, value, next); } // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); } /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() { table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; } // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node&lt;K,V&gt; p) { } // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException { Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { s.writeObject(e.key); s.writeObject(e.value); } } } } /* ------------------------------------------------------------ */ // Tree bins /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } /** * Ensures that the given root is the first node of its bin. */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) { int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) { int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) { Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; } assert checkInvariants(root); } } /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) { TreeNode&lt;K,V&gt; p = this; do { int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; } /** * Calls find for root node. */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. */ static int tieBreakOrder(Object a, Object b) { int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; } /** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) { TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) { next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; } } } } moveRootToFront(tab, root); } /** * Returns a list of non-TreeNodes replacing those linked from * this node. */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) { Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) { Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; } return hd; } /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by \"next\" pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) { int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) { tab[index] = first.untreeify(map); // too small return; } TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) { TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) { // p was s's direct parent p.parent = s; s.right = p; } else { TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) { if (s == sp.left) sp.left = p; else sp.right = p; } if ((s.right = pr) != null) pr.parent = s; } p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; } else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) { TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; } TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) { // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) { if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; } } if (movable) moveRootToFront(tab, r); } /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) { TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) { next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) { if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; } else { if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; } } if (loHead != null) { if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else { tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); } } if (hiHead != null) { if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else { tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); } } } /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) { if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) { if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) { if ((xp = x.parent) == null) { x.red = false; return x; } else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) { if ((xppr = xpp.right) != null &amp;&amp; xppr.red) { xppr.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.right) { root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateRight(root, xpp); } } } } else { if (xppl != null &amp;&amp; xppl.red) { xppl.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.left) { root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateLeft(root, xpp); } } } } } } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) { if (x == null || x == root) return root; else if ((xp = x.parent) == null) { x.red = false; return x; } else if (x.red) { x.red = false; return root; } else if ((xpl = xp.left) == x) { if ((xpr = xp.right) != null &amp;&amp; xpr.red) { xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) { xpr.red = true; x = xp; } else { if (sr == null || !sr.red) { if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr != null) { xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; } if (xp != null) { xp.red = false; root = rotateLeft(root, xp); } x = root; } } } else { // symmetric if (xpl != null &amp;&amp; xpl.red) { xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) { xpl.red = true; x = xp; } else { if (sl == null || !sl.red) { if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl != null) { xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; } if (xp != null) { xp.red = false; root = rotateRight(root, xp); } x = root; } } } } } /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) { TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; } }}","link":"/2019/09/23/HashMap类/"},{"title":"Peak Labs","text":"Peak Labs从零开始为Magi项目创建了整个技术堆栈。从自然语言理解到Web规模的搜索引擎，这些经过考验的产品可随时帮助您增强业务并为您的客户带来Magi体验。 伊鲁尔神经信息提取系统 Ireul神经信息提取引擎具有详尽的开放信息提取（OIE）的独特功能。Ireul理解通过自然语言表达的知识，并将其转换为结构化数据，从而实现自动知识库构建和众多商业智能应用程序。 通过多个专门设计的神经网络和假设搜索算法，Ireul能够利用深入的语义特征并促进多语言迁移学习，并在零资源的情况下在多种语言上获得令人满意的结果。 与传统的信息提取系统不同，Ireul放弃了人工设置的规则，语义角色标签，依赖项解析以及其他限制系统泛化能力的技术，从而使Ireul在处理交叉信息，长期依赖项，Winograd Schema，和其他复杂情况。 拉米尔网络规模搜索引擎 Ramiel是一款性能驱动的全文本搜索引擎，具有经过TLA +验证的原始索引结构，可确保在任何规模下均具有出色的响应速度和可靠的结果质量。 简洁的数据结构充分利用了不同的存储介质，与定制的基于机器学习的排名算法配合使用，并实现了令牌级增量更新和基于概率的各种提前终止策略。 Ramiel还原生支持用于分片和复制的内置协议的分布式部署。 阿拉雷多语言分析管道 Arael为自然语言的分析提供了基本的支持，能够以流的形式处理170多种不同的语言。对于中文，日文，韩文，泰文等语言，Arael可以使用机器学习来处理重叠的歧义和词汇外的词/短语。 Arael不仅可以分割基本字素，单词/短语和句子，而且还可以配置分析器和过滤器以构成定制的工作流程。 此外，Arael还实施了Unicode®标准附件＃29和技术标准＃51，翻译：永不被Emojis搞砸！ 马塔雷尔分布式检索系统 Matarael是符合标准的分布式爬网系统，能够以Internet规模对数据进行爬网和分析。 我们没有使用肿的无头浏览器，而是遵循IETF RFC和W3C的众多标准从正方形设计了Matarael，从而实现了高效的基于流的爬网以及对JavaScript等高级功能的全面支持。我们非常重视合规性，因此Matarael会遵循robots.txt，X-Robots-Tag和所有“机器人排除协议”变体。 Matarael还支持在各种存储后端上进行分布式Web Graph构建和Map-Reduce分析。 传送门","link":"/2019/11/15/peak-labs/"},{"title":"PaddlePaddle Models","text":"PaddlePaddle Models PaddlePaddle 提供了丰富的计算单元，使得用户可以采用模块化的方法解决各种学习问题。在此Repo中，我们展示了如何用 PaddlePaddle来解决常见的机器学习任务，提供若干种不同的易学易用的神经网络模型。PaddlePaddle用户可领取免费Tesla V100在线算力资源，高效训练模型，每日登陆即送12小时，连续五天运行再加送48小时，前往使用免费算力。 目录 智能视觉(PaddleCV) 图像分类 目标检测 图像分割 关键点检测 图像生成 场景文字识别 度量学习 视频分类和动作定位 智能文本处理(PaddleNLP) NLP 基础技术 NLP 核心技术 NLP 系统应用 智能推荐(PaddleRec) 智能语音(PaddleSpeech) 模型压缩(PaddleSlim) 其他模型 快速下载模型库 PaddleCV图像分类图像分类 是根据图像的语义信息对不同类别图像进行区分，是计算机视觉中重要的基础问题，是物体检测、图像分割、物体跟踪、行为分析、人脸识别等其他高层视觉任务的基础，在许多领域都有着广泛的应用。如：安防领域的人脸识别和智能视频分析等，交通领域的交通场景识别，互联网领域基于内容的图像检索和相册自动归类，医学领域的图像识别等。 模型名称 模型简介 数据集 评估指标 top-1/top-5 accuracy AlexNet 首次在 CNN 中成功的应用了 ReLU, Dropout 和 LRN，并使用 GPU 进行运算加速 ImageNet-2012验证集 56.72%/79.17% VGG19 在 AlexNet 的基础上使用 3*3 小卷积核，增加网络深度，具有很好的泛化能力 ImageNet-2012验证集 72.56%/90.93% GoogLeNet 在不增加计算负载的前提下增加了网络的深度和宽度，性能更加优越 ImageNet-2012验证集 70.70%/89.66% ResNet50 Residual Network，引入了新的残差结构，解决了随着网络加深，准确率下降的问题 ImageNet-2012验证集 76.50%/93.00% ResNet200_vd 融合多种对 ResNet 改进策略，ResNet200_vd 的 top1 准确率达到 80.93% ImageNet-2012验证集 80.93%/95.33% Inceptionv4 将 Inception 模块与 Residual Connection 进行结合，通过ResNet的结构极大地加速训练并获得性能的提升 ImageNet-2012验证集 80.77%/95.26% MobileNetV1 将传统的卷积结构改造成两层卷积结构的网络，在基本不影响准确率的前提下大大减少计算时间，更适合移动端和嵌入式视觉应用 ImageNet-2012验证集 70.99%/89.68% MobileNetV2 MobileNet结构的微调，直接在 thinner 的 bottleneck层上进行 skip learning 连接以及对 bottleneck layer 不进行 ReLu 非线性处理可取得更好的结果 ImageNet-2012验证集 72.15%/90.65% SENet154_vd 在ResNeXt 基础、上加入了 SE(Sequeeze-and-Excitation) 模块，提高了识别准确率，在 ILSVRC 2017 的分类项目中取得了第一名 ImageNet-2012验证集 81.40%/95.48% ShuffleNetV2 ECCV2018，轻量级 CNN 网络，在速度和准确度之间做了很好地平衡。在同等复杂度下，比 ShuffleNet 和 MobileNetv2 更准确，更适合移动端以及无人车领域 ImageNet-2012验证集 70.03%/89.17% efficientNet 同时对模型的分辨率，通道数和深度。进行缩放，用极少的参数就可以达到SOTA的精度。 ImageNet-2012验证集 77.38%/93.31% xception71 对inception-v3的改进，用深度可分离卷积代替普通卷积，降低参数量的同时提高了精度。 ImageNet-2012验证集 81.11%/95.45% dpn107 融合了densenet和resnext的特点。 ImageNet-2012验证集 80.89%/95.32% mobilenetV3_small_x1_0 在v2的基础上增加了se模块，并且使用hard-swish激活函数。在分类、检测、分割等视觉任务上都有不错表现。 ImageNet-2012验证集 67.46%/87.12% DarkNet53 检测框架yolov3使用的backbone，在分类和检测任务上都有不错表现。 ImageNet-2012验证集 78.04%/94.05% DenseNet161 提出了密集连接的网络结构，更加有利于信息流的传递。 ImageNet-2012验证集 78.57%/94.14% ResNeXt152_vd_64x4d 提出了cardinatity的概念，用于作为模型复杂度的另外一个度量，并依据该概念有效地提升了模型精度。 ImageNet-2012验证集 81.08%/95.34% SqueezeNet1_1 提出了新的网络架构Fire Module，通过减少参数来进行模型压缩。 ImageNet-2012验证集 60.08%/81.85% 更多图像分类模型请参考 Image Classification。 目标检测目标检测任务的目标是给定一张图像或是一个视频帧，让计算机找出其中所有目标的位置，并给出每个目标的具体类别。对于计算机而言，能够“看到”的是图像被编码之后的数字，但很难解图像或是视频帧中出现了人或是物体这样的高层语义概念，也就更加难以定位目标出现在图像中哪个区域。目标检测模型请参考 PaddleDetection。 模型名称 模型简介 数据集 评估指标 mAP SSD 很好的继承了 MobileNet 预测速度快，易于部署的特点，能够很好的在多种设备上完成图像目标检测任务 VOC07 test mAP = 73.32% Faster-RCNN 创造性地采用卷积网络自行产生建议框，并且和目标检测网络共享卷积网络，建议框数目减少，质量提高 MS-COCO 基于ResNet 50 mAP(0.50: 0.95) = 36.7% Mask-RCNN 经典的两阶段框架，在 Faster R-CNN模型基础上添加分割分支，得到掩码结果，实现了掩码和类别预测关系的解藕，可得到像素级别的检测结果。 MS-COCO 基于ResNet 50 Mask mAP（0.50: 0.95） = 31.4% RetinaNet 经典的一阶段框架，由主干网络、FPN结构、和两个分别用于回归物体位置和预测物体类别的子网络组成。在训练过程中使用 Focal Loss，解决了传统一阶段检测器存在前景背景类别不平衡的问题，进一步提高了一阶段检测器的精度。 MS-COCO 基于ResNet 50 mAP (0.50: 0.95) = 36% YOLOv3 速度和精度均衡的目标检测网络，相比于原作者 darknet 中的 YOLO v3 实现，PaddlePaddle 实现参考了论文 Bag of Tricks for Image Classification with Convolutional Neural Networks 增加了 mixup，label_smooth 等处理，精度 (mAP(0.50: 0.95)) 相比于原作者提高了 4.7 个绝对百分点，在此基础上加入 synchronize batch normalization, 最终精度相比原作者提高 5.9 个绝对百分点。 MS-COCO 基于DarkNet mAP(0.50: 0.95)= 38.9% PyramidBox PyramidBox 模型是百度自主研发的人脸检测模型，利用上下文信息解决困难人脸的检测问题，网络表达能力高，鲁棒性强。于18年3月份在 WIDER Face 数据集上取得第一名 WIDER FACE mAP （Easy/Medium/Hard set）= 96.0%/ 94.8%/ 88.8% Cascade RCNN Cascade R-CNN 在 Faster R-CNN 框架下，通过级联多个检测器，在训练过程中选取不同的 IoU 阈值，逐步提高目标定位的精度，从而获取优异的检测性能。 MS-COCO 基于ResNet 50 mAP (0.50: 0.95) = 40.9% Faceboxes 经典的人脸检测网络，被称为“高精度 CPU 实时人脸检测器”。网络中使用率 CReLU、density_prior_bo x等组件，使得模型的精度和速度得到平衡与提升。相比于 PyramidBox，预测与计算更快，模型更小，精度也保持高水平。 WIDER FACE mAP (Easy/Medium/Hard Set) = 0.898/0.872/0.752 BlazeFace 高速的人脸检测网络，由5个单的和6个双 BlazeBlocks、和 SSD 的架构构成。它轻巧但性能良好，并且专为移动 GPU 推理量身定制。 WIDER FACE mAP Easy/Medium/Hard Set = 0.915/0.892/0.797 图像分割图像语义分割顾名思义是将图像像素按照表达的语义含义的不同进行分组/分割，图像语义是指对图像内容的理解，例如，能够描绘出什么物体在哪里做了什么事情等，分割是指对图片中的每个像素点进行标注，标注属于哪一类别。近年来用在无人车驾驶技术中分割街景来避让行人和车辆、医疗影像分析中辅助诊断等。 模型名称 模型简介 数据集 评估指标 ICNet 主要用于图像实时语义分割，能够兼顾速度和准确性，易于线上部署 Cityscape Mean IoU=67.0% DeepLab V3+ 通过 encoder-decoder 进行多尺度信息的融合，同时保留了原来的空洞卷积和 ASSP 层， 其骨干网络使用了 Xception 模型，提高了语义分割的健壮性和运行速率 Cityscape Mean IoU=78.81% 关键点检测人体骨骼关键点检测 (Pose Estimation) 主要检测人体的一些关键点，如关节，五官等，通过关键点描述人体骨骼信息。人体骨骼关键点检测对于描述人体姿态，预测人体行为至关重要。是诸多计算机视觉任务的基础，例如动作分类，异常行为检测，以及自动驾驶等等。 模型名称 模型简介 数据集 评估指标 Simple Baselines coco2018 关键点检测项目亚军方案，网络结构非常简单，效果达到 state of the art COCO val2017 AP = 72.7% 图像生成图像生成是指根据输入向量，生成目标图像。这里的输入向量可以是随机的噪声或用户指定的条件向量。具体的应用场景有：手写体生成、人脸合成、风格迁移、图像修复等。PaddleGAN 包含和图像生成相关的多个模型。 模型名称 模型简介 数据集 CGAN 条件生成对抗网络，一种带条件约束的 GAN，使用额外信息对模型增加条件，可以指导数据生成过程 Mnist DCGAN 深度卷积生成对抗网络，将 GAN 和卷积网络结合起来，以解决 GAN 训练不稳定的问题 Mnist Pix2Pix 图像翻译，通过成对图片将某一类图片转换成另外一类图片，可用于风格迁移 Cityscapes CycleGAN 图像翻译，可以通过非成对的图片将某一类图片转换成另外一类图片，可用于风格迁移 Cityscapes StarGAN 多领域属性迁移，引入辅助分类帮助单个判别器判断多个属性，可用于人脸属性转换 Celeba AttGAN 利用分类损失和重构损失来保证改变特定的属性，可用于人脸特定属性转换 Celeba STGAN 人脸特定属性转换，只输入有变化的标签，引入 GRU 结构，更好的选择变化的属性 Celeba SPADE 提出一种考虑空间语义信息的归一化方法，从而更好的保留语义信息，生成更为逼真的图像，可用于图像翻译。 Cityscapes 场景文字识别场景文字识别是在图像背景复杂、分辨率低下、字体多样、分布随意等情况下，将图像信息转化为文字序列的过程，可认为是一种特别的翻译过程：将图像输入翻译为自然语言输出。 模型名称 模型简介 数据集 评估指标 CRNN-CTC 使用 CTC model 识别图片中单行英文字符，用于端到端的文本行图片识别方法 单行不定长的英文字符串图片 错误率= 22.3% OCR Attention 使用 attention 识别图片中单行英文字符，用于端到端的自然场景文本识别 单行不定长的英文字符串图片 错误率 = 15.8% 度量学习度量学习也称作距离度量学习、相似度学习，通过学习对象之间的距离，度量学习能够用于分析对象时间的关联、比较关系，在实际问题中应用较为广泛，可应用于辅助分类、聚类问题，也广泛用于图像检索、人脸识别等领域。 模型名称 模型简介 数据集 评估指标 Recall@Rank-1（使用arcmargin训练） ResNet50未微调 使用 arcmargin loss 训练的特征模型 Stanford Online Product(SOP) 78.11% ResNet50使用triplet微调 在 arcmargin loss 基础上，使用 triplet loss 微调的特征模型 Stanford Online Product(SOP) 79.21% ResNet50使用quadruplet微调 在 arcmargin loss 基础上，使用 quadruplet loss 微调的特征模型 Stanford Online Product(SOP) 79.59% ResNet50使用eml微调 在 arcmargin loss 基础上，使用 eml loss 微调的特征模型 Stanford Online Product(SOP) 80.11% ResNet50使用npairs微调 在 arcmargin loss基础上，使用npairs loss 微调的特征模型 Stanford Online Product(SOP) 79.81% 视频分类和动作定位视频分类和动作定位是视频理解任务的基础。视频数据包含语音、图像等多种信息，因此理解视频任务不仅需要处理语音和图像，还需要提取视频帧时间序列中的上下文信息。视频分类模型提供了提取全局时序特征的方法，主要方式有卷积神经网络 (C3D, I3D, C2D等)，神经网络和传统图像算法结合 (VLAD 等)，循环神经网络等建模方法。视频动作定位模型需要同时识别视频动作的类别和起止时间点，通常采用类似于图像目标检测中的算法在时间维度上进行建模。 模型名称 模型简介 数据集 评估指标 TSN ECCV’16 提出的基于 2D-CNN 经典解决方案 Kinetics-400 Top-1 = 67% Non-Local 视频非局部关联建模模型 Kinetics-400 Top-1 = 74% StNet AAAI’19 提出的视频联合时空建模方法 Kinetics-400 Top-1 = 69% TSM 基于时序移位的简单高效视频时空建模方法 Kinetics-400 Top-1 = 70% Attention LSTM 常用模型，速度快精度高 Youtube-8M GAP = 86% Attention Cluster CVPR’18 提出的视频多模态特征注意力聚簇融合方法 Youtube-8M GAP = 84% NeXtVlad 2nd-Youtube-8M 比赛第 3 名的模型 Youtube-8M GAP = 87% C-TCN 2018 年 ActivityNet 夺冠方案 ActivityNet1.3 MAP=31% BSN 为视频动作定位问题提供高效的 proposal 生成方法 ActivityNet1.3 AUC=66.64% BMN 2019 年 ActivityNet 夺冠方案 ActivityNet1.3 AUC=67.19% ETS 视频摘要生成领域的基准模型 ActivityNet Captions METEOR：10.0 TALL 视频Grounding方向的BaseLine模型 TACoS R1@IOU5=0.13 PaddleNLPPaddleNLP 是基于 PaddlePaddle 深度学习框架开发的自然语言处理 (NLP) 工具，算法，模型和数据的开源项目。百度在 NLP 领域十几年的深厚积淀为 PaddleNLP 提供了强大的核心动力。使用 PaddleNLP，您可以得到： 丰富而全面的 NLP 任务支持： PaddleNLP 为您提供了多粒度，多场景的应用支持。涵盖了从分词，词性标注，命名实体识别等 NLP 基础技术，到文本分类，文本相似度计算，语义表示，文本生成等 NLP 核心技术。同时，PaddleNLP 还提供了针对常见 NLP 大型应用系统（如阅读理解，对话系统，机器翻译系统等）的特定核心技术和工具组件，模型和预训练参数等，让您在 NLP 领域畅通无阻。 稳定可靠的 NLP 模型和强大的预训练参数： PaddleNLP集成了百度内部广泛使用的 NLP 工具模型，为您提供了稳定可靠的 NLP 算法解决方案。基于百亿级数据的预训练参数和丰富的预训练模型，助您轻松提高模型效果，为您的 NLP 业务注入强大动力。 持续改进和技术支持，零基础搭建 NLP 应用： PaddleNLP 为您提供持续的技术支持和模型算法更新，为您的 NLP 业务保驾护航。 NLP 基础技术 任务类型 目录 简介 中文词法分析 LAC(Lexical Analysis of Chinese) 百度自主研发中文特色模型词法分析任务，集成了中文分词、词性标注和命名实体识别任务。输入是一个字符串，而输出是句子中的词边界和词性、实体类别。 词向量 Word2vec 提供单机多卡，多机等分布式训练中文词向量能力，支持主流词向量模型（skip-gram，cbow等），可以快速使用自定义数据训练词向量模型。 语言模型 Language_model 给定一个输入词序列（中文需要先分词、英文需要先 tokenize），计算其生成概率。 语言模型的评价指标 PPL(困惑度)，用于表示模型生成句子的流利程度。 NLP 核心技术语义表示PaddleLARK (Paddle LAngauge Representation ToolKit) 是传统语言模型的进一步发展，通过在大规模语料上训练得到的通用的语义表示模型，可以助益其他自然语言处理任务，是通用预训练 + 特定任务精调范式的体现。PaddleLARK 集成了 ELMO，BERT，ERNIE 1.0，ERNIE 2.0，XLNet 等热门中英文预训练模型。 模型 简介 ERNIE(Enhanced Representation from kNowledge IntEgration) 百度自研的语义表示模型，通过建模海量数据中的词、实体及实体关系，学习真实世界的语义知识。相较于 BERT 学习原始语言信号，ERNIE 直接对先验语义知识单元进行建模，增强了模型语义表示能力。 BERT(Bidirectional Encoder Representation from Transformers) 一个迁移能力很强的通用语义表示模型， 以 Transformer 为网络基本组件，以双向 Masked Language Model和 Next Sentence Prediction 为训练目标，通过预训练得到通用语义表示，再结合简单的输出层，应用到下游的 NLP 任务，在多个任务上取得了 SOTA 的结果。 XLNet(XLNet: Generalized Autoregressive Pretraining for Language Understanding) 重要的语义表示模型之一，引入 Transformer-XL 为骨架，以 Permutation Language Modeling 为优化目标，在若干下游任务上优于 BERT 的性能。 ELMo(Embeddings from Language Models) 重要的通用语义表示模型之一，以双向 LSTM 为网路基本组件，以 Language Model 为训练目标，通过预训练得到通用的语义表示，将通用的语义表示作为 Feature 迁移到下游 NLP 任务中，会显著提升下游任务的模型性能。 文本相似度计算SimNet (Similarity Net) 是一个计算短文本相似度的框架，主要包括 BOW、CNN、RNN、MMDNN 等核心网络结构形式。SimNet 框架在百度各产品上广泛应用，提供语义相似度计算训练和预测框架，适用于信息检索、新闻推荐、智能客服等多个应用场景，帮助企业解决语义匹配问题。 文本生成PaddleTextGEN (Paddle Text Generation) ,一个基于 PaddlePaddle 的文本生成框架，提供了一些列经典文本生成模型案例，如 vanilla seq2seq，seq2seq with attention，variational seq2seq 模型等。 NLP 系统应用情感分析 模型 简介 Senta (Sentiment Classification，简称Senta) 面向通用场景的情感分类模型，针对带有主观描述的中文文本，可自动判断该文本的情感极性类别。 EmotionDetection (Emotion Detection，简称EmoTect) 专注于识别人机对话场景中用户的情绪，针对智能对话场景中的用户文本，自动判断该文本的情绪类别。 阅读理解PaddleMRC (Paddle Machine Reading Comprehension)，集合了百度在阅读理解领域相关的模型，工具，开源数据集等一系列工作。 模型 简介 DuReader 包含百度开源的基于真实搜索用户行为的中文大规模阅读理解数据集以及基线模型。 KT-Net 结合知识的阅读理解模型，Squad 曾排名第一。 D-Net 阅读理解十项全能模型，在 EMNLP2019 国际阅读理解大赛夺得 10 项冠军。 机器翻译PaddleMT ，全称为Paddle Machine Translation，基于Transformer的经典机器翻译模型，基于论文 Attention Is All You Need。 对话系统PaddleDialogue 包含对话系统方向的模型、数据集和工具。 模型 简介 DGU (Dialogue General Understanding，通用对话理解模型) 覆盖了包括检索式聊天系统中 context-response matching 任务和任务完成型对话系统中意图识别，槽位解析，状态追踪等常见对话系统任务，在 6 项国际公开数据集中都获得了最佳效果。 ADEM (Auto Dialogue Evaluation Model) 评估开放领域对话系统的回复质量，能够帮助企业或个人快速评估对话系统的回复质量，减少人工评估成本。 Proactive Conversation 包含百度开源的知识驱动的开放领域对话数据集 DuConv，以及基线模型。对应论文 Proactive Human-Machine Conversation with Explicit Conversation Goals 发表于 ACL2019。 DAM（Deep Attention Matching Network，深度注意力机制模型） 开放领域多轮对话匹配模型，对应论文 Multi-Turn Response Selection for Chatbots with Deep Attention Matching Network 发表于 ACL2018。 百度最新前沿工作开源，请参考 Research。 PaddleRec个性化推荐，在当前的互联网服务中正在发挥越来越大的作用，目前大部分电子商务系统、社交网络，广告推荐，搜索引擎，都不同程度的使用了各种形式的个性化推荐技术，帮助用户快速找到他们想要的信息。PaddleRec 包含的模型如下。 模型 应用场景 简介 GRU4Rec Session-based 推荐, 图网络推荐 首次将 RNN（GRU）运用于 session-based 推荐，核心思想是在一个 session 中，用户点击一系列item的行为看做一个序列，用来训练 RNN 模型 TagSpace 标签推荐 Tagspace 模型学习文本及标签的 embedding 表示，应用于工业级的标签推荐，具体应用场景有 feed 新闻标签推荐。 SequenceSemanticRetrieval 召回 解决了 GRU4Rec 模型无法预测训练数据集中不存在的项目，比如新闻推荐的问题。它由两个部分组成：一个是匹配模型部分，另一个是检索部分 Word2Vec 词向量 训练得到词的向量表示、广泛应用于 NLP 、推荐等任务场景。 Multiview-Simnet 排序 多视角Simnet模型是可以融合用户以及推荐项目的多个视角的特征并进行个性化匹配学习的一体化模型。这类模型在很多工业化的场景中都会被使用到，比如百度的 Feed 产品中 GraphNeuralNetwork 召回 SR-GNN，全称为 Session-based Recommendations with Graph Neural Network（GNN）。使用 GNN 进行会话序列建模。 DeepInterestNetwork 排序 DIN，全称为 Deep Interest Network。特点为对历史序列建模的过程中结合了预估目标的信息。 DeepFM 推荐系统 DeepFM，全称 Factorization-Machine based Neural Network。经典的 CTR 推荐算法，网络由DNN和FM两部分组成。 DCN 推荐系统 全称 Deep &amp; Cross Network。提出一种新的交叉网络（cross network），在每个层上明确地应用特征交叉。 XDeepFM 推荐系统 xDeepFM，全称 extreme Factorization Machine。对 DeepFM 和 DCN 的改进，提出 CIN（Compressed Interaction Network），使用 vector-wise 等级的显示特征交叉。 PaddleSpeechPaddleSpeech 包含语音识别和语音合成相关的模型。 模型 简介 DeepASR 利用 PaddlePaddle 框架完成语音识别中声学模型的配置和训练，并集成 Kaldi 的解码器。 DeepSpeech2 一个采用 PaddlePaddle 平台的端到端自动语音识别（ASR）引擎的开源项目，具体原理请参考论文 Deep Speech 2: End-to-End Speech Recognition in English and Mandarin。 DeepVoice3 百度研发的基于卷积神经网络的端到端语音合成模型，对应论文 Deep Voice 3: Scaling Text-to-Speech with Convolutional Sequence Learning， 基于 PaddlePaddle 动态图实现。 PaddleSlimPaddleSlim 是 PaddlePaddle 框架的一个子模块，主要用于压缩图像领域模型。在 PaddleSlim 中，不仅实现了目前主流的网络剪枝、量化、蒸馏三种压缩策略，还实现了超参数搜索和小模型网络结构搜索功能。在后续版本中，会添加更多的压缩策略，以及完善对 NLP 领域模型的支持。 PaddleSlim 模型压缩工具库的实验结果和模型库见 详细实验结果与ModelZoo。 基于动态图实现的模型自 PaddlePaddle fluid 1.5 版本正式支持动态图模式以来，模型库新增若干基于动态图实现的模型，请参考 dygraph，这些模型可以作为了解和使用 PaddlePaddle 动态图模式的示例。目前 PaddlePaddle 的动态图功能正在活跃开发中，API 可能发生变动，欢迎用户试用并给我们反馈。 其他模型 模型名称 模型简介 DQN value-based 强化学习算法，第一个成功地将深度学习和强化学习结合起来的模型 DoubleDQN 将 Double Q 的想法应用在 DQN 上，解决过优化问题 DuelingDQN 改进了 DQN 模型，提高了模型的性能 CIKM2019-MONOPOLY Monopoly 是一个实用的 POI 商业智能算法，能够利用少量的房产价格，对大量其他的固定资产进行价值估计。 该算法全面适配 MapReduce 的分布式计算框架，能够快速用于工业部署。 快速下载模型库由于 github 在国内的下载速度不稳定，我们提供了 models 各版本压缩包的百度云下载地址，以便用户更快速地获取代码。 版本号 tar包 zip包 models 1.6 https://paddlepaddle-modles.bj.bcebos.com/models-1.6.tar.gz https://paddlepaddle-modles.bj.bcebos.com/models-1.6.zip models 1.5.1 https://paddlepaddle-modles.bj.bcebos.com/models-1.5.1.tar.gz https://paddlepaddle-modles.bj.bcebos.com/models-1.5.1.zip models 1.5 https://paddlepaddle-modles.bj.bcebos.com/models-1.5.tar.gz https://paddlepaddle-modles.bj.bcebos.com/models-1.5.zip models 1.4 https://paddlepaddle-modles.bj.bcebos.com/models-1.4.tar.gz https://paddlepaddle-modles.bj.bcebos.com/models-1.4.zip models 1.3 https://paddlepaddle-modles.bj.bcebos.com/models-1.3.tar.gz https://paddlepaddle-modles.bj.bcebos.com/models-1.3.zip LicenseThis tutorial is contributed by PaddlePaddle and licensed under the Apache-2.0 license. 许可证书此向导由PaddlePaddle贡献，受Apache-2.0 license许可认证。","link":"/2019/11/15/PaddlePaddle/"},{"title":"世界上没有技术驱动型公司","text":"一、世界上没有技术驱动型公司世界上没有技术驱动型公司，不论google、facebook，还是腾讯、阿里，都不是技术驱动型公司。因为技术不是源头，需求才是。 因此一切技术问题，都要服从产品交付和市场反馈。所以，任何公司，都不可能以技术去驱动自身。人可以以技术驱动自己进步，但公司不行。 一家公司可以以技术切入某个市场，但如果它想生存下去，就一定不能以技术为导向，坚持以技术为导向的公司的生命力为零，其下场有两个：破产或者在破产之前被收购。 如果你真的很痴迷钻研技术，请读研读博最后留校或者进研究院让国家用纳税人的钱养你。 二、人人都得加班资本富集的地方，人都得加班，加班的本质，是人跟着机器跑、人跟着钱跑；更为本质地说，资本富集的地方，人作为劳动力，也是资本的一种。即，人是资本而不是人本身。资本的运转是不能停的，因为停一下损失的钱太多了。中国、外国，都一样。知道发达国家为什么产业工人不加班吗？因为制造业已经不是这些国家主要创造财富的领域了。发达国家资本富集的地方是金融行业，所以西方国家的金融狗一样加班。劳动法？加班费？都不存在的。劳动法和加班费只有在资本离开这个市场后才能给你保证。 一般公司的策略是：付给你高于其他行业的薪水、换取你“自愿”加班。不想加班的同学们，你们可以去考公务员或者去欧洲做IT，我保证你不加班、不但不用加班，你甚至会闲出病。 三、先想后写IT是工科，不是理科，和IT行业相似度最高的行业是盖楼房。真的，相似度相当惊人。 IT领域最重要的是经验而不是你有多聪明，不聪明的人或者更准确地说不适合做这个行业的人，大学毕业后就改行了。记住：你做得好不好，不取决于你是否聪明，而取决于你是否愿意不断读书不断学习和不断积累。因此，如果你打算投身这个行业而你还在学校，请抓紧一切时间多读书。 公司是你创造财富的地方，公司不是学校。你可以在工作中学习，但你不能放下工作然后去学习除非你的工作已经做完了。 能大规模商用的技术，都不需要智商，否则这种技术就不可能规模化。某些程序员们，请停止你们的蜜汁自信。 技术栈，一旦确立了，就很难改了。一个技术人员是如此，一家公司也是如此。根本原因是：每一个栈的size都太深了…就像是ulimit -s unlimited过一样。 一个程序员，应该花80%的时间做代码设计、画UML图、画时序图，20%的时间写code和debug；菜鸟程序员的这个比例恰好是反的。一句话，不论这个需求有多紧急，你都一定要“想好再动手”；“想好”的标志就是设计文档写好了；文档一旦写好，写代码就是纯粹的无脑工作。 写文档的目的是让你在code的时候，不需要停下来思考更不需要推倒重来。如果没有文档也可以做到这一点，你当然可以不写文档同时思考下自己水平这么高是不是可以要求升职加薪了……或者，你是不是在做无聊的if else编码工作？ 四、关注软技能英语，很重要。能否使用英语查阅资料，是区分技术人员水平的重要指示之一。寄希望于“有人迟早会翻译成中文”的人是愚蠢的、是会被淘汰的。 要有分享精神，不要担心你知道的东西告诉了别人你就没价值了。（参考阅读：https://www.zhihu.com/question/67169545/answer/807120993） 你最大的价值在于你知道那些东西的过程，而不是那些东西本身。 你愿意和别人分享别人自然也会愿意和你分享，最终达到1+1大于2的效果。 不分享，就像一个失去了互联网的程序员，试问他还能创造多少价值？恐怕他连日常工作都无法展开了。 持有“我把别人知道的都学会、我把自己知道的都藏起来别让别人学去”想法的人，其实是默认全世界只有你聪明别人都是傻瓜，这样的人，在信息传输成本高的时代，可以活下去，但是在今天这个时代，他们的路会越走越窄最后会自己走入死胡同。当然，如果你真的知道了了不得的黑科技，那就请你保护好自己的知识产权然后自己开公司玩吧。 工作要有热情。 智商决定你的起点情商决定你能走多远爬多高；混职场，靠的是情商。情商高就是：别人愿意和你一起工作、你有问题的时候别人愿意帮你。智商有时候可以稍微弥补一下情商但不起决定性的作用。 现代管理学的精髓，就是让每个人（包括老板本人）都变得可替代。如果你觉得自己不可替代，要么是你的错觉，要么是你在一家管理非常原始的、摇摇欲坠马上要完蛋的公司。 五、写好文档怎样让程序员变得可替代？三个字：写文档。不愿意写文档的程序员，应该立刻马上毫不犹豫地开掉。程序员工作创造的价值，至少一半是通过文档体现出来才对。“一个项目换一个人就要让项目大地震一下、解决bug换一个人就不行因为只有老人知道要改哪一行的哪个关键字”，这不说明这个项目所涉及的技术有多复杂、不说明这个老人是什么技术大牛，而只说明这个项目的项目经理是蠢货因为这个项目已经失控了。 文档不是事无巨细的流水账，写文档以及组织文档是需要智商的、是需要架构师去设计的。美国的航天飞机那么复杂，但是在pilot手里的手册也就那么多，而这个手册可以在航天飞机出问题的时候协助pilot快速定位绝大多数问题。 不可替代的打工者只有一种：以中高层领导的身份跟完了一个项目而且这个项目正处于大红大紫的阶段，公司为了防止你跳槽到竞争对手那里，愿意付给你薪水养着你天天在办公室喝茶。只要项目一直红着，公司就愿意一直养着你。 读完这个答案后如果你觉得我是一个轻视技术的人，那么恭喜你，你和我一样，是一名钢精。钢精读别人的回答，永远不会去正面理解，而只会想尽一切办法找这个答案的漏洞。（觉得我轻视技术的人，麻烦看下这个：https://www.zhihu.com/question/36729502/answer/613762292） ======== 下面展开一点谈文档和技术驱动 ======== 六、开发人员的文档的作用“开发人员的文档的作用”： 给正在code的自己看、给几个月后已经忘记这个模块当初是怎么开发的自己看、给要接手自己工作的新人看、给周边有关联开发任务的同事看、给领导等有关人员看、产品出bug的时候用来和别人怼的武器。如果没有文档，这些工作量都会成倍增长。 代码再精简再直观，也不可能有人类语言直观，谁觉得自己厉害到读代码和读人类语言写的文档速度一样快读地步，我给你个我上大学时候写的小程序，麻烦你读一下代码，看看你多长时间可以看明白：https://github.com/YvesZHI/FallingCode 这段代码本身并不复杂，应该说非常简单，但是没有文档……读读看吧。 简而言之，文档，就像盖楼房的设计图，没有图纸，你是不能开始搬砖的。 领导有没有给你看需求分析文档？有没有拿着需求分析文档给你宣讲你要做什么？没有？不干活； 测试的同事有没有给你看测试用例文档？有没有给你宣讲？没有？不干活； 你自己明白领导的意图了吗？明白测试同事的意图了吗？想明白后，开始想自己要开发的模块里的各个功能模块之间的关系，可以画时序图；时序图画完了，看看是否有（可能）频繁变化的模块/需求，如果有，请务必使用一些设计模式，如果要用设计模式，请务必画UML类图，如果没有频繁变化的模块/需求，请一定不要用设计模式；最后，看看在一个功能模块中，有没有逻辑比较复杂的地方，如果有，请画流程图；模块和模块之间有没有需要明确的协议？如果有，请把协议写出来。 上面这一段话，就是你要写的文档，这个文档的读者主要是你，在你的模块出问题之前，别人通常不会读这个文档（不排除你的领导会要求看你这个文档）。如果你既不需要时序图又不需要类图又没什么协议需要明确，那么，你就可以不写这个文档。另外，如果这个文档写得好，你的代码是不需要任何注释的。 七、技术驱动“技术驱动1”： 一些朋友认为我对“技术驱动”有误解，对此我不想辩论了。题目是：作为IT行业的过来人，我有什么想对后辈说的。上面那段话就是我想对后辈说的。什么意思呢？就是告诉后辈，如果一家公司打着“我们是技术驱动型公司”的名号在招人，那么如果你决定要去这家公司，我劝你一定要想好考察好。 为什么呢？因为我知道他的那句“技术驱动”很吸引你你想学东西，但是对小公司来说，它最大的任务是活下去，然后才是其他，我不是说小公司学不到东西，我只是说小公司很难很难做到真正的技术驱动；评论区有人坚持认为微软这种公司是技术驱动，这个问题我后面会专门补充，目前我只能说：我是没见过微软大张旗鼓地说自己是什么“技术驱动”公司然后忽悠新人。 “技术驱动2”： 看来有不少朋友愿意和我纠结这个“技术驱动”的问题，那我就和你们杠一杠。 我以华为为例来说说。 华为成功的内在原因，早就敲锣打鼓地告诉全世界了： 以客户为中心，以奋斗者为本，长期艰苦奋斗，坚持自我批判。 这四句话，没一句是直接和技术相关的。这里我先特别声明一下，我不是说，技术人员在华为就不会搞技术、不会提升自己的技术水平、华为的技术水平差。我绝不是这个意思。 华为的技术，不需要我多说，全世界的人都是有目共睹的，华为公司的技术专利数就摆在那里，那是谁也抹杀不了的；华为公司里的技术大牛，多了去了；但在这里，我要说的还是第一段的意思：一个人可以以技术驱动，但一家公司不行。 华为公司的核心理念，本质就是“成就客户”，你把客户成就了，你就也把自己成就了，华为不是先成就自己再去成就客户的公司。你去华为工作，你可以以技术驱动自己，但华为不能这样做。 这一点和微软与IBM的合作极其相似：IBM说，你们微软现在搞的东西我愿意用，但是我需要你们给我搞个操作系统，这样我们才能继续合作。然后微软怎么做的呢？它马上购买了另外一家公司搞的DOS操作系统，然后直接授权给IBM使用。 这里面有四个问题需要各位精钢们思考： 1）为什么那家开发DOS的公司没能直接和IBM合作？ 2）微软购买DOS系统的钱哪里来的？ 3）微软为什么不自己开发操作系统？ 4）技术在前三个问题中的角色和作用是什么？ 至于评论区有朋友说Intel是技术驱动公司，我建议他去了解一下Intel为什么放弃了手机市场：重点关注Intel决定放弃手机市场的原因，然后你就会发现，这个原因的本质，就是一种技术情节的产物。Intel放弃手机市场与华为决定进军手机市场是截然不同的。华为本来是做基站、路由器和交换机的，这是它的主营业务。那么华为为什么决定进入手机市场？是什么原因驱使华为在没有任何技术积累的前提下进入手机市场、以至于最初华为的手机被华为员工戏称为“暖手宝”倒贴钱都没人愿意用但现在华为手机如此成功？ 所以，我还是那个观点：世界上没有技术驱动型公司。我本人就是程序员，我一直都以技术在驱动自己我一直都在努力提升自己的技术水平但是我还是要说：世界上没有技术驱动型公司。 “技术驱动3”：继续怼 一个新的team要开发一款软件。它首先要解决的问题，是在产品1.0开发出来并且赚到钱之前这个team的经费；其次，它要提前找好产品的客户群和可能存在的销售渠道并且做完相应的工作；再次，它要做产品规划，如什么时候出1.0版本的产品、哪个模块开发大概要多久、什么类型的问题可以暂时搁置什么类型的问题不能搁置要组织攻关组公关等（全是项目管理相关内容，和技术没有直接关系）。最后，进入产品开发阶段。 一旦进入产品开发，就像工厂的流水线一样，是不可能出现什么导致产品开发进行不下去的技术难点的（否则技术leader就是白痴这种产品应该在头脑风暴阶段就被拍死才对），所以，“期望出现什么决定产品生死的技术难点然后自己nb闪闪地搞定”这种事情，是不可能发生的；同时，在开发过程中，难免出现各种意料之外的bug，比如，你负责的模块出现了三个bug，其中一个是必现问题且直接影响功能实现，那这个一定要搞定的，如果你搞不定，team会找其他老手和你一起攻关，攻关结果有两种，一种是bug解决了但是不知道为什么，另一种是bug解决了也知道了是为什么。对于第一种情况，team是不会让你“潜心研究几个月最后找到了原因”的，为什么？因为你还有后续工作要完成而这个bug已经解决了不影响用户使用了，什么时候才有可能让你继续跟进这个问题呢？1.0版本的产品市场反馈符合预期且公司决定要继续投入搞2.0版本 ———只有这个条件满足，你才有可能继续跟进这个问题，为什么是有可能呢？因为这个bug已经不影响客户使用了，没必要投入人力去搞了，你如果花几个月的时间去找这个bug的原因，那么请问：2.0版本的工作谁做？在很多项目中，类似这种“问题解决了但是不知道原因的bug”现象，是比较常见的，很多时候，直到这个产品生命周期结束，这些bug的原因都没有找到。因此，“期望碰到神秘bug然后自己潜心研究几个月终于把原因找到”这种事情，很多时候是不存在的。 接着上面的“三个bug”继续：另外两个bug，是概率发生且发生概率很低。这个时候如果工期比较赶，公司会想办法绕过去这两个bug，比如定时重启服务器、定时清理缓存等（这些方法通常可以绕开低概率bug），不会给你“潜心研究三个月然后把bug解决”的机会的。什么时候才有可能让你继续研究这两个bug呢？和第一个bug一样，只有在后续继续开发，才有可能让你继续跟进。 现在，请各位再重新品味一下“技术驱动”这个词。到底什么是技术驱动？其实这个词真正的含义就是：我们公司效益很好能养活nb的技术团队所以产品能不断迭代演进开发，随着产品的不断迭代，技术人员有可能会遇到一些其他公司遇不到的问题。所以，如果一家新成立的小公司说自己是技术驱动的……连1.0版本的产品都没有就敢说自己是技术驱动？你信吗？不管你信不信，反正我不信。 简而言之，“技术驱动”的同义词就是“我们公司很有钱”+“我们公司不是炒股炒房而是做产品的公司”。至于为什么不直接这么说呢？这是因为这种说法不容易被十年寒窗苦读潜心研究技术的同学接受……被“技术驱动”迷惑的同学，其实就是读书读傻了，什么叫“读书读傻了”？就是把社会和学校等同成同样的东西…… “很有钱的做IT产品的公司”，这个世界上当然是有的，但是这样的公司，根本不会用“技术驱动”这种词来忽悠新人。 最后，隔行如隔山但隔行不隔理。如果你读完上面的东西，对自己所处的行业有了进一步的认识，我以为，是很正常的。 来源：zhihu.com/question/312019918/answer/608965942作者：二律背反","link":"/2019/11/16/There are no technology-driven companies in the world/"},{"title":"哈佛大学教授问与答：解析量子计算浪潮","text":"乘着量子计算的浪潮，哈佛大学量子计划负责人Lukin 谈量子优势和谷歌宣布的成就。 前不久，谷歌科学家宣布突破了量子霸权里程碑，首台实验性的量子计算机在几分钟内解决了一个传统计算机需要上万年(按谷歌的计算是10000年)才能解决的问题。这一声明后来受到了竞争对手 IBM 科学家的质疑，IBM质疑谷歌“量子优势”，但是最后谷歌Nature发文明确“优势“属实，证实了这一突破 。而在刚刚结束的微软Ignite会议上，微软也正式宣布推出量子计算云服务Azure Quantum。量子计算的关注持续走高。 量子计算机被广泛赞誉可实现“量子优势”，其能力甚至大大超越了当今世界上最强的超级计算机。当然，其奥妙是利用了物质在极小尺度上的神秘特性，使得其计算能力大为提高。 对于谷歌声称首次实现里程碑量子优势，哈佛大学物理学教授Lukin饶有兴趣地观看了这一幕消息，部分原因是他已经与哈佛大学和麻省理工学院(MIT)的合作者一起建造了一台与谷歌相似的量子设备，并已经用它来解决相关科学问题。Lukin是哈佛量子计划的共同负责人，他在接受Gazette采访时谈到了上个月谷歌量子优势（也有译作“量子霸权”）声称量子计算里程碑的新闻，对于量子计算的发展，以及很多疑惑作了解答。 上图是一位艺术家绘制的谷歌量子计算机芯片Sycamore及其周围的硬件构造图。 直入主题，如下是采访内容简录，讨论内容中肯，译者整理后以文字形式供读者参考，仅作学习交流： GAZETTE：什么是“量子优势” ？为什么谈论量子计算很重要？ LUKIN：首先描述一下量子计算机，它是一种利用量子力学规律来处理信息的物理设备，它在用新的方法去处理信息（这个新方法对信息科学发展极为重要）。而量子力学主要描述了微观层面上粒子、原子或原子核的行为。 GAZETTE：量子计算机用了哪些在经典世界中我们期望的特殊行为？ LUKIN： 量子计算利用了经典世界里不具备的特殊物理行为，特别是量子世界中一个非常奇怪的叠加（Superpostion）特征。也就是说，物体可以同时处于几种不同的状态。对于宏观世界而言，这听起来很奇怪，但是在量子世界里，一个物体可以同时在你的办公室和我的办公室里。尽管这听起来很诡异，但“量子叠加”已经得到了证实，而且在过去的一个世纪里，它已经在涉及单个原子等微观物体的实验中得到了常规进展研究。 GAZETTE： 照此说来，量子计算并不是一个新的想法，可以说不是革命性的，因为它已经存于日常生活中，对吗？ LUKIN：是的。某些现有的技术，如磁共振成像(MRI)也是基于这种叠加的特性。所以当你在医院做核磁共振的时候，就已经用到了叠加态。叠加态看起来很奇怪，因为这样的特性在宏观世界中并不存在。不过，微观世界里的量子叠加是极其脆弱的，容易受到外界任何形式的环境干扰。比如，一个光子的击中，就能导致态叠加特性坍缩（Collapse）。 这意味着当你看着它的时候，你总是会在一个地方或者另一个地方发现一个“物体”（已经从叠加态坍塌成常规态）。量子计算的想法就是利用这些叠加来大规模并行处理机来处理信息。如果你使用传统的计算机，你会用一串0和1来编码你的信息。在量子计算机中，你可以准备一个有各种0和1组合的状态，它可以处于一种状态0，也可以处于另一种状态1，还可以同时处于另一种状态（0&amp;1）。然后，只要它能保持这种叠加态，它就能同时处理所有这些输入。这种巨大的并行性产生了一台非常强大的计算机。 “即使是谷歌的团队也会认同，现在的真正目标是展示一些实例，说明量子计算机可以用于科学应用或通用应用。”— Mikhail Lukin GAZETTE：什么是“量子优势（Quantum supremacy）”的基准，谷歌宣称，它上周通过了？ LUKIN：这种巨大的并行性计算使得人们可以在经典计算机上以指数级速度进行量子计算模拟。模拟量子比特存储叠加态。即使一台量子计算机看起来只有50个量子比特，这看起来很小，但是对于一台经典机器来说，模拟它已经非常具有挑战性了。原因是在一个叠加态中，即使是50个量子比特也可以同时存储和处理更多的指数组合。 如果你有一个300量子位的系统，你可以存储和处理的信息比宇宙中粒子的数量还多。所谓的量子优势这种至高无上的理念就是你能建造一个足够大、足够量、足够可编程的量子系统，从而可以执行那些哪怕是最强的经典超级计算机也无法在任何合理的时间内模拟的操作而达到的优势。 GAZETTE：值此特殊时刻，我们讨论了一台53量子比特的量子计算机。 它的体积有多大？ 它与超级计算机相比如何？ LUKIN：就物理尺寸而言，这是一个装满了设备的房间， 类似于橡树岭国家实验室的Summit超级计算机。从体积大小的角度来说，它们有得一比。 GAZETTE：但是它的计算能力是指数级的，是吗？ LUKIN： 这就是众人所希望的。如果你有一个50量子比特位的系统，并且运行足够长的时间来执行一个足够通用的算法，那么对于最好的经典计算机来说，要赶上它将是非常非常具有挑战性的。如果他们能够赶上，那你只需要再加上几个量子比特位，在60、70或100以上，几乎就可以很清楚地看到，在特殊问题上其碾压经典计算机的能力，实际上，我们可以预见，后期经典计算机无法赶上。 GAZETTE：作为谷歌的竞争对手之一IBM对他们的成就表示怀疑， 您如何看待双方观点的对与错？ LUKIN： 谷歌的成就确实令人印象深刻。但它指向的是一个特殊具体的计算问题，谷歌称“我们跨过了量子优势门槛”。但在我看来，实际上并不是这样的。毫无疑问，一旦量子计算机的容量（指量子比特数）变得足够大，经典计算机就无法模拟它们。显而易见的是，50个量子比特确实是一个门槛，他们建立的系统与世界上最好的系统，包括哈佛大学的系统都非常有竞争力。他们的快速推进就是一个很好的例子，说明如何检验这种所谓量子霸权（量子优势，此处过分强调了“优势”的强度）的理念。 然而，在过去的两年左右的时间里，包括我们在内的其他实验室已经开始使用大约50个量子比特位的系统。对于这种规模的系统已经做了许多实验，且已明确发现，传统的计算机已很难赶上这些实验。从这个意义上说，我认为现在正在发生的事情，谷歌量子优势并不是一个单一的事件，而更像是一个即将到来的浪潮。也许 IBM 的人发现了一种算法，可以在经典计算机上有效地模拟谷歌量子计算机所做的事情。我对此并不感到惊讶。但关键的问题很明显，我们正在进入一个，前所未有的世界，一个前所未有的领域，这意味着我们可以比传统超超级计算机，更快地完成任务。 毫无疑问，这种情况正在悄然发生。 GAZETTE：谷歌试图解决的问题是什么？ LUKIN： 谷歌试图解决的具体问题类似于用量子的方式去产生随机数。 谷歌所使用的算法在设计上相对实际应用来说并不实用。因此，在这个实际意义上，量子优势的本身对我来说，并不意味着什么。真正令人兴奋的是，该领域的一个关键目标——能在有用的东西上实现量子优势。当然，谷歌执行了这个算法并且真正学到了一些东西。目前，有两种有用的量子优势，一种是用于科学应用，而另一种则是通用应用（商业用例），而谷歌的论文介于两者之间。 GAZETTE：谷歌此次的目的纯粹是为了演示吗？ LUKIN: 是的，这是一个演示实验。然而，在科学应用领域，很明显量子计算机对于模拟复杂的量子系统是非常有用的。这也是我们在哈佛大学所关注的。事实上，通过使用我们的系统，我相信我们已经进入了我们在科学应用中有用的量子优势领域。使用我们的51量子位系统，我们已经建立了最大的态叠加原理状态之一，并且我们已经发现了以前不知道的新现象，而且你不能通过使用暴力累加经典模拟来揭示这些新现象。事实上，在哈佛大学不同的实验室里，我们至少有两个系统已经或正在进入这个“量子优势”的科学应用领域。我认为这非常重要，因为这些实验已经为科学界创造了价值。 GAZETTE：那么，如您所说，如果量子优势的定义就是它比经典计算机解决问题快，或者解决经典计算机不能解决的问题，目前，您已经实现了？ LUKIN：没错。你可以争辩说，你所谈论的这些问题并不是大多数人们会关心的问题，但我对此却很敏感。另一个目标才是令人兴奋的，那就是寻找与实际相关的量子优势，我认为我们现在正处于这样一个特殊时期。这可能也是 IBM 的观点之一，我非常赞同这一点，即使是谷歌的团队也会同意，现在大家的真正目标是展示一些实用例子，能有依据的说明量子计算机可以用于科学应用或商业应用。 GAZETTE：你认为未来量子计算机会取代传统计算机吗？比如智能手机或笔记本电脑等。还是说，量子计算机在某些特定领域将非常有价值，而经典计算机将继续在他擅长的领域有价值？ LUKIN：这样的预测未来，非常困难。但就我而言，最好的猜测备选是后者。量子计算机将被用作加速器，来解决对于经典机器来说非常困难的问题。 GAZETTE：那么，当你思考这些非常困难的大问题时，你是在思考气候模型或融合研究之类的事情呢，还是您先前提到的，物理学家探索的事情: 去理解像量子力学本身这样非常复杂的东西？ LUKIN：虽然我试图回答“上述所有” 问题，但这包含了太多不同类型的问题。例如，理解复杂材料和模拟化学反应是最基本的量子力学问题，这也是为什么经典计算机很难攻克它们。理解复杂的量子系统如何远离平衡并寻找物质的新阶段，这些都是我们已经在使用量子优势解决的问题。这项工作已经激发了许多研究方向。还有其他一些问题推动了经典计算机的可行性，比如气候模型或复杂的优化，这为网络通信、金融、物流和人工智能寻找最佳方案。我们希望量子计算机最终能够加速与这些问题相关的计算。 另一个著名的问题是因数分解，它与当今的加密有关。当你对你的信用卡号码进行编码时，你目前使用的便是所谓的 RSA 加密，它是基于传统计算机很难找到大数字的因子问题而设计。对于这样的问题，量子算法可以比最著名的经典算法快几何级数。与此同时，量子计算机实际上可以用来提高通信信道的安全性，当然，这是另一个有用的量子优势的例子。 GAZETTE：您能谈谈您看到的未来挑战吗？ LUKIN：这里，需要强调很重要的两点: 第一，我们仍然不知道如何建造真正大规模的量子机器，使其可以包含成千上万的量子比特位。对于这个问题，有很多方法和途径需要认真研究，但我们目前还不知道真正大规模的量子计算机最终会是什么样子。我们已经讨论过的第二个问题是，我们仍然不知道量子计算机在哪些应用中最有用。这个领域正处于一个独特的时刻，许多基础研究仍有待完成，但一些系统已经准备好被设计和部署，尽管规模相对较小，关注的人还比较少。 GAZETTE：感谢，最后我想谈谈从事这个领域工作的社区情况和以及哈佛大学的量子计划，它开始多久了？ LUKIN：大约有一年的时间了。在哈佛大学和麻省理工学院之间，我们有一个非常特殊的研究团体，研究着这个前沿领域的各个方面。在一个极具合作性的研究社区里，大约有40个研究小组，他们横跨这两个机构和几个创业公司。这些团体中的许多人已经是各自领域的世界领导者，当他们一起工作时，可能会发生一些非常特别的事情。当然，这也是一个教育学生独特的机会，他们最终将成为这一令人兴奋的跨学科领域的前沿领导者。 实现跨学科合作，培养新一代的量子科学家和工程师，是哈佛量子计划的主要目标。我们在量子计算机方面的工作是理论家、实验研究者、工程师和计算机科学家之间真正的跨学科合作，当热这是我们的竞争优势，也是我们的“秘密武器”。 延伸阅读01 称，谷歌已量子霸权02 谷歌Nature发文明确“量子优势“属实03 著名物理学家教你如何硬核识破“量子骗局”04 三星领投，IonQ获5500万美元资金05 迎刃而上，华为发布量子计算云平台HiQ 2.006 量子计算机如何实现量子霸权07 免费量子编程：Atos启动myQLM08 谷歌量子霸权里程碑，媲美莱特兄弟首飞 量子客 • 2019年11月6日 • 量子计算 • 阅读 159作者：Alvin Powell / 哈佛大学特约撰稿人译文：Liuwu Wang传送门：https://www.qtumist.com/post/9743","link":"/2019/11/17/quantum-computing-wave/"},{"title":"目标检测YOLOv3","text":"简介YOLOv3 是由 Joseph Redmon 和 Ali Farhadi 提出的单阶段检测器, 该检测器与达到同样精度的传统目标检测方法相比，推断速度能达到接近两倍. 模型结构YOLOv3将输入图像分成SS个格子，每个格子预测B个bounding box，每个bounding box预测内容包括: Location(x, y, w, h)、Confidence Score和C个类别的概率，因此YOLOv3输出层的channel数为B(5 + C)。YOLOv3的loss函数也有三部分组成：Location误差，Confidence误差和分类误差。 YOLOv3的网络结构如下图所示: YOLOv3 的网络结构由基础特征提取网络、multi-scale特征融合层和输出层组成。 特征提取网络。YOLOv3使用 DarkNet53作为特征提取网络：DarkNet53 基本采用了全卷积网络，用步长为2的卷积操作替代了池化层，同时添加了 Residual 单元，避免在网络层数过深时发生梯度弥散。 特征融合层。为了解决之前YOLO版本对小目标不敏感的问题，YOLOv3采用了3个不同尺度的特征图来进行目标检测，分别为1313,2626,52*52,用来检测大、中、小三种目标。特征融合层选取 DarkNet 产出的三种尺度特征图作为输入，借鉴了FPN(feature pyramid networks)的思想，通过一系列的卷积层和上采样对各尺度的特征图进行融合。 输出层。同样使用了全卷积结构，其中最后一个卷积层的卷积核个数是255：3*(80+4+1)=255，3表示一个grid cell包含3个bounding box，4表示框的4个坐标信息，1表示Confidence Score，80表示COCO数据集中80个类别的概率。如果换用别的数据集，80可以更改为实际类别数量 论文链接：https://arxiv.org/pdf/1804.02767v1.pdf 解压螺丝螺母训练数据背景非常干净小巧的目标检测数据集。 里面仅仅包含螺丝和螺母两种类别的目标，背景为干净的培养皿。图片数量约420张，train.txt 文件描述每个图片中的目标，label_list 文件描述类别 另附一个验证集合，有10张图片，eval.txt 描述图片中目标，格式和 train.txt 相同 1234567# 解压螺丝螺母数据，并将数据处理成需要的格式!cd data/data6045/ &amp;&amp; unzip -qo lslm.zip &amp;&amp; unzip -qo lslm-test.zip!cd data/data6045/ &amp;&amp; mv lslm/*.txt .!cd data/data6045/ &amp;&amp; mv lslm-test/*.txt .!cd data/data6045/ &amp;&amp; sed -i 's/^/lslm\\//' train.txt!cd data/data6045/ &amp;&amp; sed -i 's/^/lslm-test\\//' eval.txt!cd data/data6045/ &amp;&amp; awk '{print $2}' label_list.txt &gt; label_list 训练配置训练YOLOv3模型的配置项，配置里控制以下行为： 可以控制是否启用tiny版本，tiny版本体积小，适合部署在移动设备。本次实验默认使用 tiny 训练轮数 每批次训练图片数量 是否使用GPU训练 学习率调整 训练图片尺寸 &amp; anchors 的尺寸如果不熟悉，请不要随便更改训练图片的尺寸和anchors的尺寸，两者相互关联 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding: UTF-8 -*-\"\"\"训练常基于dark-net的YOLOv3网络，目标检测\"\"\"from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport osos.environ[\"FLAGS_fraction_of_gpu_memory_to_use\"] = '0.82'import uuidimport numpy as npimport timeimport siximport mathimport randomimport paddleimport paddle.fluid as fluidimport loggingimport xml.etree.ElementTreeimport codecsimport jsonfrom paddle.fluid.initializer import MSRAfrom paddle.fluid.param_attr import ParamAttrfrom paddle.fluid.regularizer import L2Decayfrom PIL import Image, ImageEnhance, ImageDrawlogger = Nonetrain_parameters = { \"data_dir\": \"data/data6045\", \"train_list\": \"train.txt\", \"eval_list\": \"eval.txt\", \"class_dim\": -1, \"label_dict\": {}, \"num_dict\": {}, \"image_count\": -1, \"continue_train\": True, # 是否加载前一次的训练参数，接着训练 \"pretrained\": False, \"pretrained_model_dir\": \"./pretrained-model\", \"save_model_dir\": \"./yolo-model\", \"model_prefix\": \"yolo-v3\", \"freeze_dir\": \"freeze_model\", \"use_tiny\": True, # 是否使用 裁剪 tiny 模型 \"max_box_num\": 20, # 一幅图上最多有多少个目标 \"num_epochs\": 80, \"train_batch_size\": 32, # 对于完整 yolov3，每一批的训练样本不能太多，内存会炸掉；如果使用 tiny，可以适当大一些 \"use_gpu\": True, \"yolo_cfg\": { \"input_size\": [3, 448, 448], # 原版的边长大小为608，为了提高训练速度和预测速度，此处压缩为448 \"anchors\": [7, 10, 12, 22, 24, 17, 22, 45, 46, 33, 43, 88, 85, 66, 115, 146, 275, 240], \"anchor_mask\": [[6, 7, 8], [3, 4, 5], [0, 1, 2]] }, \"yolo_tiny_cfg\": { \"input_size\": [3, 256, 256], \"anchors\": [6, 8, 13, 15, 22, 34, 48, 50, 81, 100, 205, 191], \"anchor_mask\": [[3, 4, 5], [0, 1, 2]] }, \"ignore_thresh\": 0.7, \"mean_rgb\": [127.5, 127.5, 127.5], \"mode\": \"train\", \"multi_data_reader_count\": 4, \"apply_distort\": True, \"nms_top_k\": 300, \"nms_pos_k\": 300, \"valid_thresh\": 0.01, \"nms_thresh\": 0.45, \"image_distort_strategy\": { \"expand_prob\": 0.5, \"expand_max_ratio\": 4, \"hue_prob\": 0.5, \"hue_delta\": 18, \"contrast_prob\": 0.5, \"contrast_delta\": 0.5, \"saturation_prob\": 0.5, \"saturation_delta\": 0.5, \"brightness_prob\": 0.5, \"brightness_delta\": 0.125 }, \"sgd_strategy\": { \"learning_rate\": 0.002, \"lr_epochs\": [30, 50, 65], \"lr_decay\": [1, 0.5, 0.25, 0.1] }, \"early_stop\": { \"sample_frequency\": 50, \"successive_limit\": 3, \"min_loss\": 2.5, \"min_curr_map\": 0.84 }}def init_train_parameters(): \"\"\" 初始化训练参数，主要是初始化图片数量，类别数 :return: \"\"\" file_list = os.path.join(train_parameters['data_dir'], train_parameters['train_list']) label_list = os.path.join(train_parameters['data_dir'], \"label_list\") index = 0 with codecs.open(label_list, encoding='utf-8') as flist: lines = [line.strip() for line in flist] for line in lines: train_parameters['num_dict'][index] = line.strip() train_parameters['label_dict'][line.strip()] = index index += 1 train_parameters['class_dim'] = index with codecs.open(file_list, encoding='utf-8') as flist: lines = [line.strip() for line in flist] train_parameters['image_count'] = len(lines) 日志相关的配置123456789101112131415161718192021def init_log_config(): \"\"\" 初始化日志相关配置 :return: \"\"\" global logger logger = logging.getLogger() logger.setLevel(logging.INFO) log_path = os.path.join(os.getcwd(), 'logs') if not os.path.exists(log_path): os.makedirs(log_path) log_name = os.path.join(log_path, 'train.log') fh = logging.FileHandler(log_name, mode='w') fh.setLevel(logging.DEBUG) formatter = logging.Formatter(\"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s\") fh.setFormatter(formatter) logger.addHandler(fh) init_log_config() YOLOv3网络结构 YOLOv3网络结构 YOLOv3-tiny网络结构根据配置使用不同的模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313class YOLOv3(object): def __init__(self, class_num, anchors, anchor_mask): self.outputs = [] self.downsample_ratio = 1 self.anchor_mask = anchor_mask self.anchors = anchors self.class_num = class_num self.yolo_anchors = [] self.yolo_classes = [] for mask_pair in self.anchor_mask: mask_anchors = [] for mask in mask_pair: mask_anchors.append(self.anchors[2 * mask]) mask_anchors.append(self.anchors[2 * mask + 1]) self.yolo_anchors.append(mask_anchors) self.yolo_classes.append(class_num) def name(self): return 'YOLOv3' def get_anchors(self): return self.anchors def get_anchor_mask(self): return self.anchor_mask def get_class_num(self): return self.class_num def get_downsample_ratio(self): return self.downsample_ratio def get_yolo_anchors(self): return self.yolo_anchors def get_yolo_classes(self): return self.yolo_classes def conv_bn(self, input, num_filters, filter_size, stride, padding, use_cudnn=True): conv = fluid.layers.conv2d( input=input, num_filters=num_filters, filter_size=filter_size, stride=stride, padding=padding, act=None, use_cudnn=use_cudnn, param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02)), bias_attr=False) # batch_norm中的参数不需要参与正则化，所以主动使用正则系数为0的正则项屏蔽掉 # 在batch_norm中使用 leaky 的话，只能使用默认的 alpha=0.02；如果需要设值，必须提出去单独来 out = fluid.layers.batch_norm( input=conv, act=None, param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02), regularizer=L2Decay(0.)), bias_attr=ParamAttr(initializer=fluid.initializer.Constant(0.0), regularizer=L2Decay(0.))) out = fluid.layers.leaky_relu(out, 0.1) return out def downsample(self, input, num_filters, filter_size=3, stride=2, padding=1): self.downsample_ratio *= 2 return self.conv_bn(input, num_filters=num_filters, filter_size=filter_size, stride=stride, padding=padding) def basicblock(self, input, num_filters): conv1 = self.conv_bn(input, num_filters, filter_size=1, stride=1, padding=0) conv2 = self.conv_bn(conv1, num_filters * 2, filter_size=3, stride=1, padding=1) out = fluid.layers.elementwise_add(x=input, y=conv2, act=None) return out def layer_warp(self, input, num_filters, count): res_out = self.basicblock(input, num_filters) for j in range(1, count): res_out = self.basicblock(res_out, num_filters) return res_out def upsample(self, input, scale=2): # get dynamic upsample output shape shape_nchw = fluid.layers.shape(input) shape_hw = fluid.layers.slice(shape_nchw, axes=[0], starts=[2], ends=[4]) shape_hw.stop_gradient = True in_shape = fluid.layers.cast(shape_hw, dtype='int32') out_shape = in_shape * scale out_shape.stop_gradient = True # reisze by actual_shape out = fluid.layers.resize_nearest( input=input, scale=scale, actual_shape=out_shape) return out def yolo_detection_block(self, input, num_filters): assert num_filters % 2 == 0, \"num_filters {} cannot be divided by 2\".format(num_filters) conv = input for j in range(2): conv = self.conv_bn(conv, num_filters, filter_size=1, stride=1, padding=0) conv = self.conv_bn(conv, num_filters * 2, filter_size=3, stride=1, padding=1) route = self.conv_bn(conv, num_filters, filter_size=1, stride=1, padding=0) tip = self.conv_bn(route, num_filters * 2, filter_size=3, stride=1, padding=1) return route, tip def net(self, img): # darknet stages = [1,2,8,8,4] assert len(self.anchor_mask) &lt;= len(stages), \"anchor masks can't bigger than downsample times\" # 256x256 conv1 = self.conv_bn(img, num_filters=32, filter_size=3, stride=1, padding=1) downsample_ = self.downsample(conv1, conv1.shape[1] * 2) blocks = [] for i, stage_count in enumerate(stages): block = self.layer_warp(downsample_, 32 *(2**i), stage_count) blocks.append(block) if i &lt; len(stages) - 1: downsample_ = self.downsample(block, block.shape[1]*2) blocks = blocks[-1:-4:-1] # 取倒数三层，并且逆序，后面跨层级联需要 # yolo detector for i, block in enumerate(blocks): # yolo 中跨视域链接 if i &gt; 0: block = fluid.layers.concat(input=[route, block], axis=1) route, tip = self.yolo_detection_block(block, num_filters=512 // (2**i)) block_out = fluid.layers.conv2d( input=tip, num_filters=len(self.anchor_mask[i]) * (self.class_num + 5), # 5 elements represent x|y|h|w|score filter_size=1, stride=1, padding=0, act=None, param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02)), bias_attr=ParamAttr(initializer=fluid.initializer.Constant(0.0), regularizer=L2Decay(0.))) self.outputs.append(block_out) # 为了跨视域链接，差值方式提升特征图尺寸 if i &lt; len(blocks) - 1: route = self.conv_bn(route, 256//(2**i), filter_size=1, stride=1, padding=0) route = self.upsample(route) return self.outputsclass YOLOv3Tiny(object): def __init__(self, class_num, anchors, anchor_mask): self.outputs = [] self.downsample_ratio = 1 self.anchor_mask = anchor_mask self.anchors = anchors self.class_num = class_num self.yolo_anchors = [] self.yolo_classes = [] for mask_pair in self.anchor_mask: mask_anchors = [] for mask in mask_pair: mask_anchors.append(self.anchors[2 * mask]) mask_anchors.append(self.anchors[2 * mask + 1]) self.yolo_anchors.append(mask_anchors) self.yolo_classes.append(class_num) def name(self): return 'YOLOv3-tiny' def get_anchors(self): return self.anchors def get_anchor_mask(self): return self.anchor_mask def get_class_num(self): return self.class_num def get_downsample_ratio(self): return self.downsample_ratio def get_yolo_anchors(self): return self.yolo_anchors def get_yolo_classes(self): return self.yolo_classes def conv_bn(self, input, num_filters, filter_size, stride, padding, num_groups=1, use_cudnn=True): conv = fluid.layers.conv2d( input=input, num_filters=num_filters, filter_size=filter_size, stride=stride, padding=padding, act=None, groups=num_groups, use_cudnn=use_cudnn, param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02)), bias_attr=False) # batch_norm中的参数不需要参与正则化，所以主动使用正则系数为0的正则项屏蔽掉 out = fluid.layers.batch_norm( input=conv, act='relu', param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02), regularizer=L2Decay(0.)), bias_attr=ParamAttr(initializer=fluid.initializer.Constant(0.0), regularizer=L2Decay(0.))) return out def depthwise_conv_bn(self, input, filter_size=3, stride=1, padding=1): num_filters = input.shape[1] return self.conv_bn(input, num_filters=num_filters, filter_size=filter_size, stride=stride, padding=padding, num_groups=num_filters) def downsample(self, input, pool_size=2, pool_stride=2): self.downsample_ratio *= 2 return fluid.layers.pool2d(input=input, pool_type='max', pool_size=pool_size, pool_stride=pool_stride) def basicblock(self, input, num_filters): conv1 = self.conv_bn(input, num_filters, filter_size=3, stride=1, padding=1) out = self.downsample(conv1) return out def upsample(self, input, scale=2): # get dynamic upsample output shape shape_nchw = fluid.layers.shape(input) shape_hw = fluid.layers.slice(shape_nchw, axes=[0], starts=[2], ends=[4]) shape_hw.stop_gradient = True in_shape = fluid.layers.cast(shape_hw, dtype='int32') out_shape = in_shape * scale out_shape.stop_gradient = True # reisze by actual_shape out = fluid.layers.resize_nearest( input=input, scale=scale, actual_shape=out_shape) return out def yolo_detection_block(self, input, num_filters): route = self.conv_bn(input, num_filters, filter_size=1, stride=1, padding=0) tip = self.conv_bn(route, num_filters * 2, filter_size=3, stride=1, padding=1) return route, tip def net(self, img): # darknet-tiny stages = [16, 32, 64, 128, 256, 512] assert len(self.anchor_mask) &lt;= len(stages), \"anchor masks can't bigger than downsample times\" # 256x256 tmp = img blocks = [] for i, stage_count in enumerate(stages): if i == len(stages) - 1: block = self.conv_bn(tmp, stage_count, filter_size=3, stride=1, padding=1) blocks.append(block) block = self.depthwise_conv_bn(blocks[-1]) block = self.depthwise_conv_bn(blocks[-1]) block = self.conv_bn(blocks[-1], stage_count * 2, filter_size=1, stride=1, padding=0) blocks.append(block) else: tmp = self.basicblock(tmp, stage_count) blocks.append(tmp) blocks = [blocks[-1], blocks[3]] # yolo detector for i, block in enumerate(blocks): # yolo 中跨视域链接 if i &gt; 0: block = fluid.layers.concat(input=[route, block], axis=1) if i &lt; 1: route, tip = self.yolo_detection_block(block, num_filters=256 // (2**i)) else: tip = self.conv_bn(block, num_filters=256, filter_size=3, stride=1, padding=1) block_out = fluid.layers.conv2d( input=tip, num_filters=len(self.anchor_mask[i]) * (self.class_num + 5), # 5 elements represent x|y|h|w|score filter_size=1, stride=1, padding=0, act=None, param_attr=ParamAttr(initializer=fluid.initializer.Normal(0., 0.02)), bias_attr=ParamAttr(initializer=fluid.initializer.Constant(0.0), regularizer=L2Decay(0.))) self.outputs.append(block_out) # 为了跨视域链接，差值方式提升特征图尺寸 if i &lt; len(blocks) - 1: route = self.conv_bn(route, 128 // (2**i), filter_size=1, stride=1, padding=0) route = self.upsample(route) return self.outputs def get_yolo(is_tiny, class_num, anchors, anchor_mask): if is_tiny: return YOLOv3Tiny(class_num, anchors, anchor_mask) else: return YOLOv3(class_num, anchors, anchor_mask) 定义训练时候，数据增强需要的辅助类，例如外接矩形框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Sampler(object): \"\"\" 采样器，用于扣取采样 \"\"\" def __init__(self, max_sample, max_trial, min_scale, max_scale, min_aspect_ratio, max_aspect_ratio, min_jaccard_overlap, max_jaccard_overlap): \"\"\" 构造函数 :param max_sample: :param max_trial: :param min_scale: :param max_scale: :param min_aspect_ratio: :param max_aspect_ratio: :param min_jaccard_overlap: :param max_jaccard_overlap: \"\"\" self.max_sample = max_sample self.max_trial = max_trial self.min_scale = min_scale self.max_scale = max_scale self.min_aspect_ratio = min_aspect_ratio self.max_aspect_ratio = max_aspect_ratio self.min_jaccard_overlap = min_jaccard_overlap self.max_jaccard_overlap = max_jaccard_overlapclass bbox(object): \"\"\" 外界矩形框 \"\"\" def __init__(self, xmin, ymin, xmax, ymax): \"\"\" 构造函数 :param xmin: :param ymin: :param xmax: :param ymax: \"\"\" self.xmin = xmin self.ymin = ymin self.xmax = xmax self.ymax = ymax 训练数据增强，主要是采样。利用随机截取训练图上的框来生成新的训练样本。同时要保证采样的样本能包含真实的目标。采样之后，为了保持训练数据格式的一致性，还需要对标注的坐标信息做变换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677def box_to_center_relative(box, img_height, img_width): \"\"\" Convert COCO annotations box with format [x1, y1, w, h] to center mode [center_x, center_y, w, h] and divide image width and height to get relative value in range[0, 1] \"\"\" assert len(box) == 4, \"box should be a len(4) list or tuple\" x, y, w, h = box x1 = max(x, 0) x2 = min(x + w - 1, img_width - 1) y1 = max(y, 0) y2 = min(y + h - 1, img_height - 1) x = (x1 + x2) / 2 / img_width y = (y1 + y2) / 2 / img_height w = (x2 - x1) / img_width h = (y2 - y1) / img_height return np.array([x, y, w, h])def resize_img(img, sampled_labels, input_size): target_size = input_size img = img.resize((target_size[1], target_size[2]), Image.BILINEAR) return imgdef box_iou_xywh(box1, box2): assert box1.shape[-1] == 4, \"Box1 shape[-1] should be 4.\" assert box2.shape[-1] == 4, \"Box2 shape[-1] should be 4.\" b1_x1, b1_x2 = box1[:, 0] - box1[:, 2] / 2, box1[:, 0] + box1[:, 2] / 2 b1_y1, b1_y2 = box1[:, 1] - box1[:, 3] / 2, box1[:, 1] + box1[:, 3] / 2 b2_x1, b2_x2 = box2[:, 0] - box2[:, 2] / 2, box2[:, 0] + box2[:, 2] / 2 b2_y1, b2_y2 = box2[:, 1] - box2[:, 3] / 2, box2[:, 1] + box2[:, 3] / 2 inter_x1 = np.maximum(b1_x1, b2_x1) inter_x2 = np.minimum(b1_x2, b2_x2) inter_y1 = np.maximum(b1_y1, b2_y1) inter_y2 = np.minimum(b1_y2, b2_y2) inter_w = inter_x2 - inter_x1 + 1 inter_h = inter_y2 - inter_y1 + 1 inter_w[inter_w &lt; 0] = 0 inter_h[inter_h &lt; 0] = 0 inter_area = inter_w * inter_h b1_area = (b1_x2 - b1_x1 + 1) * (b1_y2 - b1_y1 + 1) b2_area = (b2_x2 - b2_x1 + 1) * (b2_y2 - b2_y1 + 1) return inter_area / (b1_area + b2_area - inter_area)def box_crop(boxes, labels, crop, img_shape): x, y, w, h = map(float, crop) im_w, im_h = map(float, img_shape) boxes = boxes.copy() boxes[:, 0], boxes[:, 2] = (boxes[:, 0] - boxes[:, 2] / 2) * im_w, (boxes[:, 0] + boxes[:, 2] / 2) * im_w boxes[:, 1], boxes[:, 3] = (boxes[:, 1] - boxes[:, 3] / 2) * im_h, (boxes[:, 1] + boxes[:, 3] / 2) * im_h crop_box = np.array([x, y, x + w, y + h]) centers = (boxes[:, :2] + boxes[:, 2:]) / 2.0 mask = np.logical_and(crop_box[:2] &lt;= centers, centers &lt;= crop_box[2:]).all(axis=1) boxes[:, :2] = np.maximum(boxes[:, :2], crop_box[:2]) boxes[:, 2:] = np.minimum(boxes[:, 2:], crop_box[2:]) boxes[:, :2] -= crop_box[:2] boxes[:, 2:] -= crop_box[:2] mask = np.logical_and(mask, (boxes[:, :2] &lt; boxes[:, 2:]).all(axis=1)) boxes = boxes * np.expand_dims(mask.astype('float32'), axis=1) labels = labels * mask.astype('float32') boxes[:, 0], boxes[:, 2] = (boxes[:, 0] + boxes[:, 2]) / 2 / w, (boxes[:, 2] - boxes[:, 0]) / w boxes[:, 1], boxes[:, 3] = (boxes[:, 1] + boxes[:, 3]) / 2 / h, (boxes[:, 3] - boxes[:, 1]) / h return boxes, labels, mask.sum() 图像增强相关的函数： 对比度 饱和度 明暗 颜色 扩张 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149def random_brightness(img): prob = np.random.uniform(0, 1) if prob &lt; train_parameters['image_distort_strategy']['brightness_prob']: brightness_delta = train_parameters['image_distort_strategy']['brightness_delta'] delta = np.random.uniform(-brightness_delta, brightness_delta) + 1 img = ImageEnhance.Brightness(img).enhance(delta) return imgdef random_contrast(img): prob = np.random.uniform(0, 1) if prob &lt; train_parameters['image_distort_strategy']['contrast_prob']: contrast_delta = train_parameters['image_distort_strategy']['contrast_delta'] delta = np.random.uniform(-contrast_delta, contrast_delta) + 1 img = ImageEnhance.Contrast(img).enhance(delta) return imgdef random_saturation(img): prob = np.random.uniform(0, 1) if prob &lt; train_parameters['image_distort_strategy']['saturation_prob']: saturation_delta = train_parameters['image_distort_strategy']['saturation_delta'] delta = np.random.uniform(-saturation_delta, saturation_delta) + 1 img = ImageEnhance.Color(img).enhance(delta) return imgdef random_hue(img): prob = np.random.uniform(0, 1) if prob &lt; train_parameters['image_distort_strategy']['hue_prob']: hue_delta = train_parameters['image_distort_strategy']['hue_delta'] delta = np.random.uniform(-hue_delta, hue_delta) img_hsv = np.array(img.convert('HSV')) img_hsv[:, :, 0] = img_hsv[:, :, 0] + delta img = Image.fromarray(img_hsv, mode='HSV').convert('RGB') return imgdef distort_image(img): prob = np.random.uniform(0, 1) # Apply different distort order if prob &gt; 0.5: img = random_brightness(img) img = random_contrast(img) img = random_saturation(img) img = random_hue(img) else: img = random_brightness(img) img = random_saturation(img) img = random_hue(img) img = random_contrast(img) return imgdef random_crop(img, boxes, labels, scales=[0.3, 1.0], max_ratio=2.0, constraints=None, max_trial=50): if random.random() &gt; 0.6: return img, boxes, labels if len(boxes) == 0: return img, boxes, labels if not constraints: constraints = [ (0.1, 1.0), (0.3, 1.0), (0.5, 1.0), (0.7, 1.0), (0.9, 1.0), (0.0, 1.0)] w, h = img.size crops = [(0, 0, w, h)] for min_iou, max_iou in constraints: for _ in range(max_trial): scale = random.uniform(scales[0], scales[1]) aspect_ratio = random.uniform(max(1 / max_ratio, scale * scale), \\ min(max_ratio, 1 / scale / scale)) crop_h = int(h * scale / np.sqrt(aspect_ratio)) crop_w = int(w * scale * np.sqrt(aspect_ratio)) crop_x = random.randrange(w - crop_w) crop_y = random.randrange(h - crop_h) crop_box = np.array([[ (crop_x + crop_w / 2.0) / w, (crop_y + crop_h / 2.0) / h, crop_w / float(w), crop_h /float(h) ]]) iou = box_iou_xywh(crop_box, boxes) if min_iou &lt;= iou.min() and max_iou &gt;= iou.max(): crops.append((crop_x, crop_y, crop_w, crop_h)) break while crops: crop = crops.pop(np.random.randint(0, len(crops))) crop_boxes, crop_labels, box_num = box_crop(boxes, labels, crop, (w, h)) if box_num &lt; 1: continue img = img.crop((crop[0], crop[1], crop[0] + crop[2], crop[1] + crop[3])).resize(img.size, Image.LANCZOS) return img, crop_boxes, crop_labels return img, boxes, labelsdef random_expand(img, gtboxes, keep_ratio=True): if np.random.uniform(0, 1) &lt; train_parameters['image_distort_strategy']['expand_prob']: return img, gtboxes max_ratio = train_parameters['image_distort_strategy']['expand_max_ratio'] w, h = img.size c = 3 ratio_x = random.uniform(1, max_ratio) if keep_ratio: ratio_y = ratio_x else: ratio_y = random.uniform(1, max_ratio) oh = int(h * ratio_y) ow = int(w * ratio_x) off_x = random.randint(0, ow -w) off_y = random.randint(0, oh -h) out_img = np.zeros((oh, ow, c), np.uint8) for i in range(c): out_img[:, :, i] = train_parameters['mean_rgb'][i] out_img[off_y: off_y + h, off_x: off_x + w, :] = img gtboxes[:, 0] = ((gtboxes[:, 0] * w) + off_x) / float(ow) gtboxes[:, 1] = ((gtboxes[:, 1] * h) + off_y) / float(oh) gtboxes[:, 2] = gtboxes[:, 2] / ratio_x gtboxes[:, 3] = gtboxes[:, 3] / ratio_y return Image.fromarray(out_img), gtboxesdef preprocess(img, bbox_labels, input_size, mode): img_width, img_height = img.size sample_labels = np.array(bbox_labels) if mode == 'train': if train_parameters['apply_distort']: img = distort_image(img) img, gtboxes = random_expand(img, sample_labels[:, 1:5]) img, gtboxes, gtlabels = random_crop(img, gtboxes, sample_labels[:, 0]) sample_labels[:, 0] = gtlabels sample_labels[:, 1:5] = gtboxes img = resize_img(img, sample_labels, input_size) img = np.array(img).astype('float32') img -= train_parameters['mean_rgb'] img = img.transpose((2, 0, 1)) # HWC to CHW img *= 0.007843 return img, sample_labels 数据读取器自定义数据读取器，如果需要自定义数据，需要修改下面这段函数，以适配自定义数据的格式 此外还定义了训练时候的读取方式，有同步的读取器，也有异步的读取器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def custom_reader(file_list, data_dir, input_size, mode): def reader(): np.random.shuffle(file_list) for line in file_list: if mode == 'train' or mode == 'eval': ###################### 以下可能是需要自定义修改的部分 ############################ parts = line.split('\\t') image_path = parts[0] img = Image.open(os.path.join(data_dir, image_path)) if img.mode != 'RGB': img = img.convert('RGB') im_width, im_height = img.size # bbox 的列表，每一个元素为这样 # layout: label | x-center | y-cneter | width | height | difficult bbox_labels = [] for object_str in parts[1:]: if len(object_str) &lt;= 1: continue bbox_sample = [] object = json.loads(object_str) bbox_sample.append(float(train_parameters['label_dict'][object['value']])) bbox = object['coordinate'] box = [bbox[0][0], bbox[0][1], bbox[1][0] - bbox[0][0], bbox[1][1] - bbox[0][1]] bbox = box_to_center_relative(box, im_height, im_width) bbox_sample.append(float(bbox[0])) bbox_sample.append(float(bbox[1])) bbox_sample.append(float(bbox[2])) bbox_sample.append(float(bbox[3])) difficult = float(0) bbox_sample.append(difficult) bbox_labels.append(bbox_sample) ###################### 可能需要自定义修改部分结束 ############################ if len(bbox_labels) == 0: continue img, sample_labels = preprocess(img, bbox_labels, input_size, mode) # sample_labels = np.array(sample_labels) if len(sample_labels) == 0: continue boxes = sample_labels[:, 1:5] lbls = sample_labels[:, 0].astype('int32') difficults = sample_labels[:, -1].astype('int32') max_box_num = train_parameters['max_box_num'] cope_size = max_box_num if len(boxes) &gt;= max_box_num else len(boxes) ret_boxes = np.zeros((max_box_num, 4), dtype=np.float32) ret_lbls = np.zeros((max_box_num), dtype=np.int32) ret_difficults = np.zeros((max_box_num), dtype=np.int32) ret_boxes[0: cope_size] = boxes[0: cope_size] ret_lbls[0: cope_size] = lbls[0: cope_size] ret_difficults[0: cope_size] = difficults[0: cope_size] yield img, ret_boxes, ret_lbls elif mode == 'test': img_path = os.path.join(line) yield Image.open(img_path) return reader 定义优化器 定义同步数据读取 定义优化器 构建 program 和损失函数 注意yolo_loss里面，smooth_label 选项默认为 True，如果类别较少的情况下，建议置为 False 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def single_custom_reader(file_path, data_dir, input_size, mode): file_path = os.path.join(data_dir, file_path) images = [line.strip() for line in open(file_path)] reader = custom_reader(images, data_dir, input_size, mode) reader = paddle.reader.shuffle(reader, train_parameters['train_batch_size']) reader = paddle.batch(reader, train_parameters['train_batch_size']) return readerdef optimizer_sgd_setting(): batch_size = train_parameters[\"train_batch_size\"] iters = train_parameters[\"image_count\"] // batch_size iters = 1 if iters &lt; 1 else iters learning_strategy = train_parameters['sgd_strategy'] lr = learning_strategy['learning_rate'] boundaries = [i * iters for i in learning_strategy[\"lr_epochs\"]] values = [i * lr for i in learning_strategy[\"lr_decay\"]] logger.info(\"origin learning rate: {0} boundaries: {1} values: {2}\".format(lr, boundaries, values)) optimizer = fluid.optimizer.SGDOptimizer( learning_rate=fluid.layers.piecewise_decay(boundaries, values), # learning_rate=lr, regularization=fluid.regularizer.L2Decay(0.00005)) return optimizerdef build_program_with_feeder(main_prog, startup_prog, place): max_box_num = train_parameters['max_box_num'] ues_tiny = train_parameters['use_tiny'] yolo_config = train_parameters['yolo_tiny_cfg'] if ues_tiny else train_parameters['yolo_cfg'] with fluid.program_guard(main_prog, startup_prog): img = fluid.layers.data(name='img', shape=yolo_config['input_size'], dtype='float32') gt_box = fluid.layers.data(name='gt_box', shape=[max_box_num, 4], dtype='float32') gt_label = fluid.layers.data(name='gt_label', shape=[max_box_num], dtype='int32') feeder = fluid.DataFeeder(feed_list=[img, gt_box, gt_label], place=place, program=main_prog) reader = single_custom_reader(train_parameters['train_list'], train_parameters['data_dir'], yolo_config['input_size'], 'train') ues_tiny = train_parameters['use_tiny'] yolo_config = train_parameters['yolo_tiny_cfg'] if ues_tiny else train_parameters['yolo_cfg'] with fluid.unique_name.guard(): model = get_yolo(ues_tiny, train_parameters['class_dim'], yolo_config['anchors'], yolo_config['anchor_mask']) outputs = model.net(img) return feeder, reader, get_loss(model, outputs, gt_box, gt_label) def get_loss(model, outputs, gt_box, gt_label): losses = [] downsample_ratio = model.get_downsample_ratio() with fluid.unique_name.guard('train'): for i, out in enumerate(outputs): loss = fluid.layers.yolov3_loss( x=out, gt_box=gt_box, gt_label=gt_label, anchors=model.get_anchors(), anchor_mask=model.get_anchor_mask()[i], class_num=model.get_class_num(), ignore_thresh=train_parameters['ignore_thresh'], use_label_smooth=False, # 对于类别不多的情况，设置为 False 会更合适一些，不然 score 会很小 downsample_ratio=downsample_ratio) losses.append(fluid.layers.reduce_mean(loss)) downsample_ratio //= 2 loss = sum(losses) optimizer = optimizer_sgd_setting() optimizer.minimize(loss) return loss 加载已经有的参数12345678910111213def load_pretrained_params(exe, program): if train_parameters['continue_train'] and os.path.exists(train_parameters['save_model_dir']): logger.info('load param from retrain model') fluid.io.load_persistables(executor=exe, dirname=train_parameters['save_model_dir'], main_program=program) elif train_parameters['pretrained'] and os.path.exists(train_parameters['pretrained_model_dir']): logger.info('load param from pretrained model') def if_exist(var): return os.path.exists(os.path.join(train_parameters['pretrained_model_dir'], var.name)) fluid.io.load_vars(exe, train_parameters['pretrained_model_dir'], main_program=program, predicate=if_exist) 训练主体，开始愉快的炼丹吧~当前日志默认输出到日志文件中，刷新左侧文件显示，能看到在 logs 目录下。可以在编辑区上方【终端】里输入如下命令看到滚动的日志 1tailf logs/train.log 为了演示，此处并没有训练很多轮，如果需要得到较好的效果，可以增加训练轮数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def train(): init_log_config() init_train_parameters() logger.info(\"start train YOLOv3, train params:%s\", str(train_parameters)) logger.info(\"create place, use gpu:\" + str(train_parameters['use_gpu'])) place = fluid.CUDAPlace(0) if train_parameters['use_gpu'] else fluid.CPUPlace() logger.info(\"build network and program\") train_program = fluid.Program() start_program = fluid.Program() feeder, reader, loss = build_program_with_feeder(train_program, start_program, place) logger.info(\"build executor and init params\") exe = fluid.Executor(place) exe.run(start_program) train_fetch_list = [loss.name] load_pretrained_params(exe, train_program) stop_strategy = train_parameters['early_stop'] successive_limit = stop_strategy['successive_limit'] sample_freq = stop_strategy['sample_frequency'] min_curr_map = stop_strategy['min_curr_map'] min_loss = stop_strategy['min_loss'] stop_train = False successive_count = 0 total_batch_count = 0 valid_thresh = train_parameters['valid_thresh'] nms_thresh = train_parameters['nms_thresh'] current_best_loss = 10000000000.0 for pass_id in range(train_parameters[\"num_epochs\"]): logger.info(\"current pass: {}, start read image\".format(pass_id)) batch_id = 0 total_loss = 0.0 for batch_id, data in enumerate(reader()): t1 = time.time() loss = exe.run(train_program, feed=feeder.feed(data), fetch_list=train_fetch_list) period = time.time() - t1 loss = np.mean(np.array(loss)) total_loss += loss batch_id += 1 total_batch_count += 1 if batch_id % 10 == 0: # 调整日志输出的频率 logger.info(\"pass {}, trainbatch {}, loss {} time {}\".format(pass_id, batch_id, loss, \"%2.2f sec\" % period)) pass_mean_loss = total_loss / batch_id logger.info(\"pass {0} train result, current pass mean loss: {1}\".format(pass_id, pass_mean_loss)) # 采用每训练完一轮停止办法，可以调整为更精细的保存策略 if pass_mean_loss &lt; current_best_loss: logger.info(\"temp save {} epcho train result, current best pass loss {}\".format(pass_id, pass_mean_loss)) fluid.io.save_persistables(dirname=train_parameters['save_model_dir'], main_program=train_program, executor=exe) current_best_loss = pass_mean_loss logger.info(\"training till last epcho, end training\") fluid.io.save_persistables(dirname=train_parameters['save_model_dir'], main_program=train_program, executor=exe)if __name__ == '__main__': train() 固化保存模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import paddleimport paddle.fluid as fluidimport codecsinit_train_parameters()def freeze_model(): exe = fluid.Executor(fluid.CPUPlace()) ues_tiny = train_parameters['use_tiny'] yolo_config = train_parameters['yolo_tiny_cfg'] if ues_tiny else train_parameters['yolo_cfg'] path = train_parameters['save_model_dir'] model = get_yolo(ues_tiny, train_parameters['class_dim'], yolo_config['anchors'], yolo_config['anchor_mask']) image = fluid.layers.data(name='image', shape=yolo_config['input_size'], dtype='float32') image_shape = fluid.layers.data(name=\"image_shape\", shape=[2], dtype='int32') boxes = [] scores = [] outputs = model.net(image) downsample_ratio = model.get_downsample_ratio() for i, out in enumerate(outputs): box, score = fluid.layers.yolo_box( x=out, img_size=image_shape, anchors=model.get_yolo_anchors()[i], class_num=model.get_class_num(), conf_thresh=train_parameters['valid_thresh'], downsample_ratio=downsample_ratio, name=\"yolo_box_\" + str(i)) boxes.append(box) scores.append(fluid.layers.transpose(score, perm=[0, 2, 1])) downsample_ratio //= 2 pred = fluid.layers.multiclass_nms( bboxes=fluid.layers.concat(boxes, axis=1), scores=fluid.layers.concat(scores, axis=2), score_threshold=train_parameters['valid_thresh'], nms_top_k=train_parameters['nms_top_k'], keep_top_k=train_parameters['nms_pos_k'], nms_threshold=train_parameters['nms_thresh'], background_label=-1, name=\"multiclass_nms\") freeze_program = fluid.default_main_program() fluid.io.load_persistables(exe, path, freeze_program) freeze_program = freeze_program.clone(for_test=True) print(\"freeze out: {0}, pred layout: {1}\".format(train_parameters['freeze_dir'], pred)) fluid.io.save_inference_model(train_parameters['freeze_dir'], ['image', 'image_shape'], pred, exe, freeze_program) print(\"freeze end\")if __name__ == '__main__': freeze_model() 加载固化的模型进行预测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import codecsimport sysimport numpy as npimport timeimport paddleimport paddle.fluid as fluidimport mathimport functoolsfrom IPython.display import displayfrom PIL import Imagefrom PIL import ImageFontfrom PIL import ImageDrawfrom collections import namedtupleinit_train_parameters()ues_tiny = train_parameters['use_tiny']yolo_config = train_parameters['yolo_tiny_cfg'] if ues_tiny else train_parameters['yolo_cfg']target_size = yolo_config['input_size']anchors = yolo_config['anchors']anchor_mask = yolo_config['anchor_mask']label_dict = train_parameters['num_dict']class_dim = train_parameters['class_dim']print(\"label_dict:{} class dim:{}\".format(label_dict, class_dim))place = fluid.CUDAPlace(0) if train_parameters['use_gpu'] else fluid.CPUPlace()exe = fluid.Executor(place)path = train_parameters['freeze_dir'][inference_program, feed_target_names, fetch_targets] = fluid.io.load_inference_model(dirname=path, executor=exe)def draw_bbox_image(img, boxes, labels, save_name): \"\"\" 给图片画上外接矩形框 :param img: :param boxes: :param save_name: :param labels :return: \"\"\" img_width, img_height = img.size draw = ImageDraw.Draw(img) for box, label in zip(boxes, labels): xmin, ymin, xmax, ymax = box[0], box[1], box[2], box[3] draw.rectangle((xmin, ymin, xmax, ymax), None, 'red') draw.text((xmin, ymin), label_dict[int(label)], (255, 255, 0)) img.save(save_name) display(img)def resize_img(img, target_size): \"\"\" 保持比例的缩放图片 :param img: :param target_size: :return: \"\"\" img = img.resize(target_size[1:], Image.BILINEAR) return imgdef read_image(img_path): \"\"\" 读取图片 :param img_path: :return: \"\"\" origin = Image.open(img_path) img = resize_img(origin, target_size) resized_img = img.copy() if img.mode != 'RGB': img = img.convert('RGB') img = np.array(img).astype('float32').transpose((2, 0, 1)) # HWC to CHW img -= 127.5 img *= 0.007843 img = img[np.newaxis, :] return origin, img, resized_imgdef infer(image_path): \"\"\" 预测，将结果保存到一副新的图片中 :param image_path: :return: \"\"\" origin, tensor_img, resized_img = read_image(image_path) input_w, input_h = origin.size[0], origin.size[1] image_shape = np.array([input_h, input_w], dtype='int32') # print(\"image shape high:{0}, width:{1}\".format(input_h, input_w)) t1 = time.time() batch_outputs = exe.run(inference_program, feed={feed_target_names[0]: tensor_img, feed_target_names[1]: image_shape[np.newaxis, :]}, fetch_list=fetch_targets, return_numpy=False) period = time.time() - t1 print(\"predict cost time:{0}\".format(\"%2.2f sec\" % period)) bboxes = np.array(batch_outputs[0]) # print(bboxes) if bboxes.shape[1] != 6: print(\"No object found in {}\".format(image_path)) return labels = bboxes[:, 0].astype('int32') scores = bboxes[:, 1].astype('float32') boxes = bboxes[:, 2:].astype('float32') last_dot_index = image_path.rfind('.') out_path = image_path[:last_dot_index] out_path += '-result.jpg' draw_bbox_image(origin, boxes, labels, out_path)if __name__ == '__main__': image_name = sys.argv[1] image_path = image_name for i in range(10): image_path = \"data/data6045/lslm-test/\"+str(i+1)+\".jpg\" infer(image_path) 1tar -cf yolo-model.tar freeze-model/* 传送门","link":"/2019/11/18/target-detection-yolo/"},{"title":"赋予 SQL AI 能力 SQLFlow","text":"SQLFlow What is SQLFlowSQLFlow is a bridge that connects a SQL engine, e.g. MySQL, Hive or MaxCompute, with TensorFlow, XGBoost and other machine learning toolkits. SQLFlow extends the SQL syntax to enable model training, prediction and model explanation. MotivationThe current experience of development ML based applications requires a team of data engineers, data scientists, business analysts as well as a proliferation of advanced languages and programming tools like Python, SQL, SAS, SASS, Julia, R. The fragmentation of tooling and development environment brings additional difficulties in engineering to model trainning/tunning. What if we marry the most widely used data management/processing language SQL with ML/system capabilities and let engineers with SQL skills develop advanced ML based applications? There are already some work in progress in the industry. We can write simple machine learning prediction (or scoring) algorithms in SQL using operators like DOT_PRODUCT. However, this requires copy-n-pasting model parameters from the training program to SQL statements. In the commercial world, we see some proprietary SQL engines providing extensions to support machine learning capabilities. Microsoft SQL Server: Microsoft SQL Server has the machine learning service that runs machine learning programs in R or Python as an external script. Teradata SQL for DL: Teradata also provides a RESTful service, which is callable from the extended SQL SELECT syntax. Google BigQuery: Google BigQuery enables machine learning in SQL by introducing the CREATE MODEL statement. None of the existing solution solves our pain point, instead we want it to be fully extensible. This solution should be compatible to many SQL engines, instead of a specific version or type. It should support sophisticated machine learning models, including TensorFlow for deep learning and XGBoost for trees. We also want the flexibility to configure and run cutting-edge ML algorithms including specifying feature crosses, at least, no Python or R code embedded in the SQL statements, and fully integrated with hyperparameter estimation. Quick OverviewHere are examples for training a Tensorflow DNNClassifer model using sample data Iris.train, and running prediction using the trained model. You can see how cool it is to write some elegant ML code using SQL: 1234567891011sqlflow&gt; SELECT *FROM iris.trainTO TRAIN DNNClassifierWITH model.n_classes = 3, model.hidden_units = [10, 20]COLUMN sepal_length, sepal_width, petal_length, petal_widthLABEL classINTO sqlflow_models.my_dnn_model;...Training set accuracy: 0.96721Done training 1234567sqlflow&gt; SELECT *FROM iris.testTO PREDICT iris.predict.classUSING sqlflow_models.my_dnn_model;...Done predicting. Predict table : iris.predict How to use SQLFlow Quick Start Language Guide Docker Installation Contributions Build from source The walkthrough of the source code The choice of parser generator RoadmapSQLFlow will love to support as many mainstream ML frameworks and data sources as possible, but we feel like the expansion would be hard to be done merely on our own, so we would love to hear your options on what ML frameworks and data sources you are currently using and build upon. Please refer to our roadmap for specific timelines, also let us know your current scenarios and interests around SQLFlow project so we can prioritize based on the feedback from the community. FeedbackYour feedback is our motivation to move on. Please let us know your questions, concerns, and issues by filing Github Issues. LicenseApache License 2.0","link":"/2019/11/19/sqlflow/"},{"title":"PythonRobotics","text":"PythonRobotics Python codes for robotics algorithm. Table of Contents What is this? Requirements Documentation How to use Localization Extended Kalman Filter localization Particle filter localization Histogram filter localization Mapping Gaussian grid map Ray casting grid map Lidar to grid map k-means object clustering Rectangle fitting SLAM Iterative Closest Point (ICP) Matching FastSLAM 1.0 Path Planning Dynamic Window Approach Grid based search Dijkstra algorithm A* algorithm Potential Field algorithm Grid based coverage path planning State Lattice Planning Biased polar sampling Lane sampling Probabilistic Road-Map (PRM) planning Rapidly-Exploring Random Trees (RRT) RRT* RRT* with reeds-shepp path LQR-RRT* Quintic polynomials planning Reeds Shepp planning LQR based path planning Optimal Trajectory in a Frenet Frame Path Tracking move to a pose control Stanley control Rear wheel feedback control Linear–quadratic regulator (LQR) speed and steering control Model predictive speed and steering control Nonlinear Model predictive control with C-GMRES Arm Navigation N joint arm to point control Arm navigation with obstacle avoidance Aerial Navigation drone 3d trajectory following rocket powered landing Bipedal bipedal planner with inverted pendulum License Use-case Contribution Citing Support Authors What is this?This is a Python code collection of robotics algorithms, especially for autonomous navigation. Features: Easy to read for understanding each algorithm’s basic idea. Widely used and practical algorithms are selected. Minimum dependency. See this paper for more details: [1808.10703] PythonRobotics: a Python code collection of robotics algorithms (BibTeX) Requirements Python 3.7.x (2.7 is not supported) numpy scipy matplotlib pandas cvxpy DocumentationThis README only shows some examples of this project. If you are interested in other examples or mathematical backgrounds of each algorithm, You can check the full documentation online: https://pythonrobotics.readthedocs.io/ All animation gifs are stored here: AtsushiSakai/PythonRoboticsGifs: Animation gifs of PythonRobotics How to use Clone this repo. git clone https://github.com/AtsushiSakai/PythonRobotics.git cd PythonRobotics/ Install the required libraries. You can use environment.yml with conda command. conda env create -f environment.yml Execute python script in each directory. Add star to this repo if you like it :smiley:. LocalizationExtended Kalman Filter localization Documentation: Notebook Particle filter localization This is a sensor fusion localization with Particle Filter(PF). The blue line is true trajectory, the black line is dead reckoning trajectory, and the red line is estimated trajectory with PF. It is assumed that the robot can measure a distance from landmarks (RFID). This measurements are used for PF localization. Ref: PROBABILISTIC ROBOTICS Histogram filter localization This is a 2D localization example with Histogram filter. The red cross is true position, black points are RFID positions. The blue grid shows a position probability of histogram filter. In this simulation, x,y are unknown, yaw is known. The filter integrates speed input and range observations from RFID for localization. Initial position is not needed. Ref: PROBABILISTIC ROBOTICS MappingGaussian grid mapThis is a 2D Gaussian grid mapping example. Ray casting grid mapThis is a 2D ray casting grid mapping example. Lidar to grid mapThis example shows how to convert a 2D range measurement to a grid map. k-means object clusteringThis is a 2D object clustering with k-means algorithm. Rectangle fittingThis is a 2D rectangle fitting for vehicle detection. SLAMSimultaneous Localization and Mapping(SLAM) examples Iterative Closest Point (ICP) MatchingThis is a 2D ICP matching example with singular value decomposition. It can calculate a rotation matrix and a translation vector between points to points. Ref: Introduction to Mobile Robotics: Iterative Closest Point Algorithm FastSLAM 1.0This is a feature based SLAM example using FastSLAM 1.0. The blue line is ground truth, the black line is dead reckoning, the red line is the estimated trajectory with FastSLAM. The red points are particles of FastSLAM. Black points are landmarks, blue crosses are estimated landmark positions by FastSLAM. Ref: PROBABILISTIC ROBOTICS SLAM simulations by Tim Bailey Path PlanningDynamic Window ApproachThis is a 2D navigation sample code with Dynamic Window Approach. The Dynamic Window Approach to Collision Avoidance Grid based searchDijkstra algorithmThis is a 2D grid based shortest path planning with Dijkstra’s algorithm. In the animation, cyan points are searched nodes. A* algorithmThis is a 2D grid based shortest path planning with A star algorithm. In the animation, cyan points are searched nodes. Its heuristic is 2D Euclid distance. Potential Field algorithmThis is a 2D grid based path planning with Potential Field algorithm. In the animation, the blue heat map shows potential value on each grid. Ref: Robotic Motion Planning:Potential Functions Grid based coverage path planningThis is a 2D grid based coverage path planning simulation. State Lattice PlanningThis script is a path planning code with state lattice planning. This code uses the model predictive trajectory generator to solve boundary problem. Ref: Optimal rough terrain trajectory generation for wheeled mobile robots State Space Sampling of Feasible Motions for High-Performance Mobile Robot Navigation in Complex Environments Biased polar sampling Lane sampling Probabilistic Road-Map (PRM) planning This PRM planner uses Dijkstra method for graph search. In the animation, blue points are sampled points, Cyan crosses means searched points with Dijkstra method, The red line is the final path of PRM. Ref: Probabilistic roadmap - Wikipedia Rapidly-Exploring Random Trees (RRT)RRT* This is a path planning code with RRT* Black circles are obstacles, green line is a searched tree, red crosses are start and goal positions. Ref: Incremental Sampling-based Algorithms for Optimal Motion Planning Sampling-based Algorithms for Optimal Motion Planning RRT* with reeds-shepp path) Path planning for a car robot with RRT* and reeds shepp path planner. LQR-RRT*This is a path planning simulation with LQR-RRT*. A double integrator motion model is used for LQR local planner. Ref: LQR-RRT*: Optimal Sampling-Based Motion Planning with Automatically Derived Extension Heuristics MahanFathi/LQR-RRTstar: LQR-RRT* method is used for random motion planning of a simple pendulum in its phase plot Quintic polynomials planningMotion planning with quintic polynomials. It can calculate 2D path, velocity, and acceleration profile based on quintic polynomials. Ref: Local Path Planning And Motion Control For Agv In Positioning Reeds Shepp planningA sample code with Reeds Shepp path planning. Ref: 15.3.2 Reeds-Shepp Curves optimal paths for a car that goes both forwards and backwards ghliu/pyReedsShepp: Implementation of Reeds Shepp curve. LQR based path planningA sample code using LQR based path planning for double integrator model. Optimal Trajectory in a Frenet Frame This is optimal trajectory generation in a Frenet Frame. The cyan line is the target course and black crosses are obstacles. The red line is predicted path. Ref: Optimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame Optimal trajectory generation for dynamic street scenarios in a Frenet Frame Path Trackingmove to a pose controlThis is a simulation of moving to a pose control Ref: P. I. Corke, “Robotics, Vision and Control” | SpringerLink p102 Stanley controlPath tracking simulation with Stanley steering control and PID speed control. Ref: Stanley: The robot that won the DARPA grand challenge Automatic Steering Methods for Autonomous Automobile Path Tracking Rear wheel feedback controlPath tracking simulation with rear wheel feedback steering control and PID speed control. Ref: A Survey of Motion Planning and Control Techniques for Self-driving Urban Vehicles Linear–quadratic regulator (LQR) speed and steering controlPath tracking simulation with LQR speed and steering control. Ref: Towards fully autonomous driving: Systems and algorithms - IEEE Conference Publication Model predictive speed and steering controlPath tracking simulation with iterative linear model predictive speed and steering control. Ref: notebook Real-time Model Predictive Control (MPC), ACADO, Python | Work-is-Playing Nonlinear Model predictive control with C-GMRESA motion planning and path tracking simulation with NMPC of C-GMRES Ref: notebook Arm NavigationN joint arm to point controlN joint arm to a point control simulation. This is a interactive simulation. You can set the goal position of the end effector with left-click on the ploting area. In this simulation N = 10, however, you can change it. Arm navigation with obstacle avoidanceArm navigation with obstacle avoidance simulation. Aerial Navigationdrone 3d trajectory followingThis is a 3d trajectory following simulation for a quadrotor. rocket powered landingThis is a 3d trajectory generation simulation for a rocket powered landing. Ref: notebook Bipedalbipedal planner with inverted pendulumThis is a bipedal planner for modifying footsteps with inverted pendulum. You can set the footsteps and the planner will modify those automatically. LicenseMIT Use-caseIf this project helps your robotics project, please let me know with . Your robot’s video, which is using PythonRobotics, is very welcome!! This is a list of other user’s comment and references:users_comments ContributionA small PR like bug fix is welcome. If your PR is merged multiple times, I will add your account to the author list. CitingIf you use this project’s code for your academic work, we encourage you to cite our papers If you use this project’s code in industry, we’d love to hear from you as well; feel free to reach out to the developers directly. SupportIf you or your company would like to support this project, please consider: Become a backer or sponsor on Patreon One-time donation via PayPal You can add your name or your company logo in README if you are a patron. E-mail consultant is also available. Your comment using is also welcome. This is a list: Users comments Authors Atsushi Sakai (@Atsushi_twi) Daniel Ingram Joe Dinius Karan Chawla Antonin RAFFIN Alexis Paques Ryohei Sasaki","link":"/2019/11/20/PythonRobotics/"},{"title":"Gitpod","text":"Gitpod - One-Click Online IDE for GitHubGitpod provides instant dev environments for any GitHub project in your browser. Simply prefix any GitHub URL with gitpod.io/#. How to use Gitpod?You can use Gitpod to simplify contributions for your repository, so people can code on your project with a single click.Just add the following markdown code to your Readme: 1[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/&lt;org&gt;/&lt;repo&gt;) Here’s an example opening the project for the Theia IDE: ContributePlease file any issues and feature requests here. :heart:","link":"/2019/11/21/gitpod/"}],"tags":[{"name":"文章","slug":"文章","link":"/tags/文章/"},{"name":"机器学习","slug":"机器学习","link":"/tags/机器学习/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"Xbox","slug":"Xbox","link":"/tags/Xbox/"},{"name":"游戏","slug":"游戏","link":"/tags/游戏/"},{"name":"B+树","slug":"B-树","link":"/tags/B-树/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"双指针","slug":"双指针","link":"/tags/双指针/"},{"name":"编程","slug":"编程","link":"/tags/编程/"},{"name":"矩阵","slug":"矩阵","link":"/tags/矩阵/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"书籍","slug":"书籍","link":"/tags/书籍/"},{"name":"网络安全","slug":"网络安全","link":"/tags/网络安全/"},{"name":"逆向工程","slug":"逆向工程","link":"/tags/逆向工程/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"ASM","slug":"ASM","link":"/tags/ASM/"},{"name":"加密算法","slug":"加密算法","link":"/tags/加密算法/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"飞行","slug":"飞行","link":"/tags/飞行/"},{"name":"军事","slug":"军事","link":"/tags/军事/"},{"name":"拟真","slug":"拟真","link":"/tags/拟真/"},{"name":"VR","slug":"VR","link":"/tags/VR/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"webhooks","slug":"webhooks","link":"/tags/webhooks/"},{"name":"自动化部署","slug":"自动化部署","link":"/tags/自动化部署/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Http","slug":"Http","link":"/tags/Http/"},{"name":"dio","slug":"dio","link":"/tags/dio/"},{"name":"反编译","slug":"反编译","link":"/tags/反编译/"},{"name":"jad","slug":"jad","link":"/tags/jad/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"边缘检测","slug":"边缘检测","link":"/tags/边缘检测/"},{"name":"诺贝尔奖","slug":"诺贝尔奖","link":"/tags/诺贝尔奖/"},{"name":"后缀表达式","slug":"后缀表达式","link":"/tags/后缀表达式/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"推荐系统","slug":"推荐系统","link":"/tags/推荐系统/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"OCR","slug":"OCR","link":"/tags/OCR/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"安全","slug":"安全","link":"/tags/安全/"},{"name":"指纹","slug":"指纹","link":"/tags/指纹/"},{"name":"汇编","slug":"汇编","link":"/tags/汇编/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"B-树","slug":"B-树","link":"/tags/B-树/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"Stack Overflow","slug":"Stack-Overflow","link":"/tags/Stack-Overflow/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/汇编语言/"},{"name":"反汇编","slug":"反汇编","link":"/tags/反汇编/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"国家","slug":"国家","link":"/tags/国家/"},{"name":"计算机视觉","slug":"计算机视觉","link":"/tags/计算机视觉/"},{"name":"陨石","slug":"陨石","link":"/tags/陨石/"},{"name":"卷积神经网络","slug":"卷积神经网络","link":"/tags/卷积神经网络/"},{"name":"人工智能","slug":"人工智能","link":"/tags/人工智能/"},{"name":"Global ","slug":"Global","link":"/tags/Global/"},{"name":"Key ","slug":"Key","link":"/tags/Key/"},{"name":"JNA","slug":"JNA","link":"/tags/JNA/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"ICRUS","slug":"ICRUS","link":"/tags/ICRUS/"},{"name":"黄山","slug":"黄山","link":"/tags/黄山/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"lazydocker","slug":"lazydocker","link":"/tags/lazydocker/"},{"name":"MD5","slug":"MD5","link":"/tags/MD5/"},{"name":"minio","slug":"minio","link":"/tags/minio/"},{"name":"nohup","slug":"nohup","link":"/tags/nohup/"},{"name":"2019","slug":"2019","link":"/tags/2019/"},{"name":"信息安全","slug":"信息安全","link":"/tags/信息安全/"},{"name":"行业分析","slug":"行业分析","link":"/tags/行业分析/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"openssl","slug":"openssl","link":"/tags/openssl/"},{"name":"sha256","slug":"sha256","link":"/tags/sha256/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"论文","slug":"论文","link":"/tags/论文/"},{"name":"搜索引擎","slug":"搜索引擎","link":"/tags/搜索引擎/"},{"name":"TabNine","slug":"TabNine","link":"/tags/TabNine/"},{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"战斗机","slug":"战斗机","link":"/tags/战斗机/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"edb","slug":"edb","link":"/tags/edb/"},{"name":"编程思想","slug":"编程思想","link":"/tags/编程思想/"},{"name":"x64dbg","slug":"x64dbg","link":"/tags/x64dbg/"},{"name":"魔方","slug":"魔方","link":"/tags/魔方/"},{"name":"相对论","slug":"相对论","link":"/tags/相对论/"},{"name":"爱因斯坦","slug":"爱因斯坦","link":"/tags/爱因斯坦/"},{"name":"天平","slug":"天平","link":"/tags/天平/"},{"name":"暴力破解","slug":"暴力破解","link":"/tags/暴力破解/"},{"name":"素数","slug":"素数","link":"/tags/素数/"},{"name":"备份","slug":"备份","link":"/tags/备份/"},{"name":"晨间日记","slug":"晨间日记","link":"/tags/晨间日记/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"树","slug":"树","link":"/tags/树/"},{"name":"二叉树","slug":"二叉树","link":"/tags/二叉树/"},{"name":"狂野飙车","slug":"狂野飙车","link":"/tags/狂野飙车/"},{"name":"跑车","slug":"跑车","link":"/tags/跑车/"},{"name":"脚本","slug":"脚本","link":"/tags/脚本/"},{"name":"百科","slug":"百科","link":"/tags/百科/"},{"name":"红黑树","slug":"红黑树","link":"/tags/红黑树/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"思考","slug":"思考","link":"/tags/思考/"},{"name":"量子","slug":"量子","link":"/tags/量子/"},{"name":"量子位","slug":"量子位","link":"/tags/量子位/"},{"name":"NoteBook","slug":"NoteBook","link":"/tags/NoteBook/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"}],"categories":[{"name":"文章","slug":"文章","link":"/categories/文章/"},{"name":"人工智能","slug":"人工智能","link":"/categories/人工智能/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"笔试","slug":"笔试","link":"/categories/笔试/"}]}