<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.9.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Time</title>
  

  
  
  <meta name="description" content>
  <meta name="author" content="times">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-134224598-1', 'auto');
	ga('send', 'pageview');
</script>


  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/theme-icon.svg' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">Time</a>
			</h1>
			<subtitle>
				time
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
			<li><a href="/categories/文章/"><img src="/images/文章.svg" alt="文章" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='文章'></a></li>
		
			<li><a href="/categories/算法/"><img src="/images/算法.svg" alt="算法" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='算法'></a></li>
		
			<li><a href="/categories/人工智能/"><img src="/images/人工智能.svg" alt="人工智能" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='人工智能'></a></li>
		
			<li><a href="/categories/生活/"><img src="/images/生活.svg" alt="生活" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='生活'></a></li>
		
			<li><a href="/categories/笔试/"><img src="/images/笔试.svg" alt="笔试" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='笔试'></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"334. 反转字符串","date":"2019-08-31T14:49:17.000Z","content":"\n334. 反转字符串题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1：\n输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：\n输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]    题解\n递归解法\n\n123456789101112131415class Solution &#123;    public void reverseString(char[] s) &#123;        swap(0, s.length-1, s);    &#125;        public void swap(int start, int end, char[] s) &#123;        if(start &gt;= end)&#123;            return;        &#125;        char temp = s[start];        s[start] = s[end];        s[end] = temp;        swap(start+1, end-1, s);    &#125;&#125;\n\n\n循环解法\n\n1234567891011class Solution &#123;    public void reverseString(char[] s) &#123;        int j=s.length-1;        for(int i=0;i&lt;s.length2;i++)&#123;            char tmp = s[i];            s[i] = s[j];            s[j] = tmp;            j--;        &#125;    &#125;&#125;\n\n\nPython解法\n\n12def reverseString(self, s: List[str]) -&gt; None:    s[0::]=s[::-1]\n\n\nc++解法\n\n双指针，交换头尾两个指针所指的两个位置的值，指针向中间移动一个位置，重复以上操作，直到两个指针交错；\n12345678910111213class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int i = 0;        int j = s.size() - 1;        while(i&lt;j)        &#123;            swap(s[i],s[j]);            ++ i;            -- j;        &#125;    &#125;&#125;;","tags":["算法","leetcode","递归"],"path":"2019/08/31/334-反转字符串/","external_link":""},{"title":"118. 杨辉三角","date":"2019-08-31T15:25:17.000Z","content":"杨辉三角题目给定一个非负整数 numRows，生成杨辉三角的前 numRows行。\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n123456789输入: 5输出:[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]\n\n题解\n动态规划\n\n思路\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n算法\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 0 的特殊情况，否则我们会返回 [1]。如果 numRows &gt; 0，那么我们用 [1] 作为第一行来初始化 triangle with [1]，并按如下方式继续填充：\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;List&lt;Integer&gt;&gt;();         First base case; if user requests zero rows, they get zero rows.        if (numRows == 0) &#123;            return triangle;        &#125;         Second base case; first row is always [1].        triangle.add(new ArrayList&lt;&gt;());        triangle.get(0).add(1);        for (int rowNum = 1; rowNum &lt; numRows; rowNum++) &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            List&lt;Integer&gt; prevRow = triangle.get(rowNum-1);             The first row element is always 1.            row.add(1);             Each triangle element (other than the first and last of each row)             is equal to the sum of the elements above-and-to-the-left and             above-and-to-the-right.            for (int j = 1; j &lt; rowNum; j++) &#123;                row.add(prevRow.get(j-1) + prevRow.get(j));            &#125;             The last row element is always 1.            row.add(1);            triangle.add(row);        &#125;        return triangle;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(numRows²)\n\n虽然更新 triangle 中的每个值都是在常量时间内发生的，但它会被执行 O(numRows²) 次。想要了解原因，就需要考虑总共有多少次循环迭代。很明显外层循环需要运行 numRows 次，但在外层循环的每次迭代中，内层循环要运行 rowNumrowNum 次。因此，triangle 发生的更新总数为1 + 2 + 3 + ... + *numRows*，根据高斯公式有\n\n\n空间复杂度：O(numRows²)\n\n因为我们需要存储我们在 triangle 中更新的每个数字，所以空间需求与时间复杂度相同。\n\nPython解法\n\n1234567891011121314151617class Solution:    def generate(self, num_rows):        triangle = []        for row_num in range(num_rows):            # The first and last row elements are always 1.            row = [None for _ in range(row_num+1)]            row[0], row[-1] = 1, 1            # Each triangle element is equal to the sum of the elements            # above-and-to-the-left and above-and-to-the-right.            for j in range(1, len(row)-1):                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]            triangle.append(row)        return triangle\n\n\n递归解法\n\n通过numRows-1，求numRows行，递归求解\n1234567891011121314151617181920212223242526class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; listw = new ArrayList&lt;List&lt;Integer&gt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;Integer&gt; listn = new ArrayList&lt;Integer&gt;();        if (numRows == 0)            return listw;        generate(numRows - 1);        for (int i = 0; i &lt; numRows; i++) &#123;            if (i == 0) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 1) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 2) &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + 1);                continue;            &#125; else &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + listw.get(numRows - 2).get(i));            &#125;        &#125;        listw.add(listn);        return listw;    &#125;&#125;\n\n","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/118-杨辉三角/","external_link":""},{"title":"54. 螺旋矩阵","date":"2019-09-07T03:08:58.000Z","content":"\n54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n示例 1:\n1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]\n\n示例 2:\n1234567输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n方法 1：模拟直觉\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n算法\n假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。\n当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n1234567891011121314151617181920212223242526class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0) return ans;        int R = matrix.length, C = matrix[0].length;        boolean[][] seen = new boolean[R][C];        int[] dr = &#123;0, 1, 0, -1&#125;;        int[] dc = &#123;1, 0, -1, 0&#125;;        int r = 0, c = 0, di = 0;        for (int i = 0; i &lt; R * C; i++) &#123;            ans.add(matrix[r][c]);            seen[r][c] = true;            int cr = r + dr[di];            int cc = c + dc[di];            if (0 &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;                r = cr;                c = cc;            &#125; else &#123;                di = (di + 1) % 4;                r += dr[di];                c += dc[di];            &#125;        &#125;        return ans;    &#125;&#125;\n\n12345678910111213141516171819class Solution(object):    def spiralOrder(self, matrix):        if not matrix: return []        R, C = len(matrix), len(matrix[0])        seen = [[False] * C for _ in matrix]        ans = []        dr = [0, 1, 0, -1]        dc = [1, 0, -1, 0]        r = c = di = 0        for _ in range(R * C):            ans.append(matrix[r][c])            seen[r][c] = True            cr, cc = r + dr[di], c + dc[di]            if 0 &lt;= cr &lt; R and 0 &lt;= cc &lt; C and not seen[cr][cc]:                r, c = cr, cc            else:                di = (di + 1) % 4                r, c = r + dr[di], c + dc[di]        return ans\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要两个矩阵 seen 和 ans 存储所需信息。\n\n方法 2：按层模拟\n直觉\n答案是最外层所有元素按照顺时针顺序输出，其次是次外层，以此类推。\n算法\n我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，然后是第 3 层的。\n12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]]\n\n\n12345678910111213141516171819202122class Solution &#123;    public List &lt; Integer &gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0)            return ans;        int r1 = 0, r2 = matrix.length - 1;        int c1 = 0, c2 = matrix[0].length - 1;        while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;            for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);            for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]);            if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;                for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]);                for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);            &#125;            r1++;            r2--;            c1++;            c2--;        &#125;        return ans;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要矩阵 ans 存储信息。\n\n方法 3：顺时针旋转\n这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小\n\n首先设定上下左右边界\n其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界\n判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案\n若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理\n不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        int[][] matrix = new int[][] &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;        List&lt;Integer&gt; list = spiralOrder(matrix);        System.out.println(list);    &#125;    static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        if (matrix.length == 0)            return list;        int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1;        while (true) &#123;             向右            for (int i = l; i &lt;= r; i++)                list.add(matrix[u][i]);            if (++u &gt; d)                break;             向下            for (int i = u; i &lt;= d; i++)                list.add(matrix[i][r]);            if (--r &lt; l)                break;             向左            for (int i = r; i &gt;= l; i--)                list.add(matrix[d][i]);            if (--d &lt; u)                break;             向上            for (int i = d; i &gt;= u; i--)                list.add(matrix[i][l]);            if (++l &gt; r)                break;        &#125;        return list;    &#125;&#125;\n\n1234567891011121314151617181920212223class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        vector &lt;int&gt; ans;        if(matrix.empty()) return ans; 若数组为空，直接返回答案        int u = 0; 赋值上下左右边界        int d = matrix.size() - 1;        int l = 0;        int r = matrix[0].size() - 1;        while(true)        &#123;            for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); 向右移动直到最右            if(++ u &gt; d) break; 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同            for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); 向下            if(-- r &lt; l) break; 重新设定有边界            for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); 向左            if(-- d &lt; u) break; 重新设定下边界            for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); 向上            if(++ l &gt; r) break; 重新设定左边界        &#125;        return ans;    &#125;&#125;;","author":null,"tags":["leetcode","编程","矩阵"],"path":"2019/09/07/54-螺旋矩阵/","external_link":""},{"title":"24. 两两交换链表中的节点","date":"2019-08-31T14:57:20.000Z","content":"\n24. 两两交换链表中的节点题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.题解\n非递归\n\n123456789101112131415161718192021222324** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; *class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0);        pre.next = head;        ListNode temp = pre;        while(temp.next != null &amp;&amp; temp.next.next != null) &#123;            ListNode start = temp.next;            ListNode end = temp.next.next;            temp.next = end;            start.next = end.next;            end.next = start;            temp = start;        &#125;        return pre.next;    &#125;&#125;\n\n\n递归解法\n\n详细介绍一下递归的思路;\n递归和栈处理问题类似,先把问题从前往后收集起来,然后再从后往前处理每一个问题;\n两两交换链表结点,先处理最后两个或一个节点,然后再从后往前处理每一对节点;\n先创建一个next临时结点保存head的下一个结点,然后让head指向下下一个节点,最后让 next节点指向head结点;\n此题只有处理完后面的结点才可处理前面的结点,画图更容易理解;\n\n\n\n\n123456789101112class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null)            return head;         三个节点顺序:head, next, swapPairs(next.next)        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;        return next;    &#125;&#125;","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/24-两两交换链表中的节点/","external_link":""},{"title":"Electron-vue","date":"2019-09-08T03:09:19.000Z","content":"\nElectron-vue\n基于 vue (基本上是它听起来的样子) 来构造 electron 应用程序的样板代码。\n\n什么是electron?\n\nelectron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。\n它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：\n\nMain进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。\nRenderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在3. Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。Main进程和Renderer进程通过ipcMain和ipcRenderer来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。\n\n起步该样板代码被构建为 vue-cli 的一个模板，并且包含多个选项，可以自定义你最终的脚手架程序。本项目需要使用 node@^7 或更高版本。electron-vue 官方推荐 yarn 作为软件包管理器，因为它可以更好地处理依赖关系，并可以使用 yarn clean 帮助减少最后构建文件的大小。\n12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgregelectron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev\n\n项目结构12345678910111213141516171819202122232425262728293031323334353637my-project├─ .electron-vue│  └─ &lt;builddevelopment&gt;.js files├─ build│  └─ icons├─ dist│  ├─ electron│  └─ web├─ node_modules├─ src│  ├─ main│  │  ├─ index.dev.js│  │  └─ index.js│  ├─ renderer│  │  ├─ components│  │  ├─ router│  │  ├─ store│  │  ├─ App.vue│  │  └─ main.js│  └─ index.ejs├─ static├─ test│  ├─ e2e│  │  ├─ specs│  │  ├─ index.js│  │  └─ utils.js│  ├─ unit│  │  ├─ specs│  │  ├─ index.js│  │  └─ karma.config.js│  └─ .eslintrc├─ .babelrc├─ .eslintignore├─ .eslintrc.js├─ .gitignore├─ package.json└─ README.md\n\n产品构建123456789app.asar├─ dist│  └─ electron│     ├─ static│     ├─ index.html│     ├─ main.js│     └─ renderer.js├─ node_modules└─ package.json\n\n运行效果\n","tags":["electron","vue"],"path":"2019/09/08/Electron-vue/","external_link":""},{"title":"Java面试题（框架+JVM+多线程+算法+数据库）","date":"2019-08-24T08:20:38.000Z","content":"\n基础与框架\nString类能被继承吗，为什么\nString，Stringbuffer，StringBuilder的区别？\nArrayList和LinkedList有什么区别\n类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序\n用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等\nHashMap为什么get和set那么快，concurrentHashMap为什么能提高并发\n抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\n什么情况下会发生栈内存溢出\n什么是nio，原理\n反射中，Class.forName和ClassLoader区别\ntomcat结构，类加载器流程\n讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式\nSpring的beanFactory和factoryBean的区别\nSpring加载流程\nSpring如何管理事务的\n\n多线程\n线城池的最大线程数目根据什么确定\n多线程的几种实现方式，什么是线程安全，什么是重排序3.volatile的原理，作用，能代替锁么\nsleep和wait的区别，以及wait的实现原理\nLock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁\n用过哪些原子类，他们的参数以及原理是什么\n用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等\n有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。\nspring的controller是单例还是多例，怎么保证并发的安全\n用三个线程按顺序循环打印abc三个字母，比如abcabcabc\nThreadLocal用过么，原理是什么，用的时候要注意什么\n如果让你实现一个并发安全的链表，你会怎么做\n\nJVM相关\njvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等\n你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms\n当出现了内存溢出，你怎么排错\nJVM内存模型的相关知识了解多少\n简单说说你了解的类加载器\nJAVA的反射机制\n\n网络\nhttp1.0和http1.1有什么区别\nTCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么\nTIME_WAIT和CLOSE_WAIT的区别\n说说你知道的几种HTTP响应码\n当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤\nLinux下IO模型有几种，各自的含义是什么\nTCPIP如何保证可靠性，数据包有哪些数据组成\n架构设计与分布式：\ntomcat如何调优，各种参数的意义\n常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等\n如何防止缓存雪崩12.用java自己实现一个LRU\n分布式集群下如何做到唯一序列号\n设计一个秒杀系统，30分钟没付款就自动关闭交易\n如何做一个分布式锁\n用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗\nMQ系统的数据如何保证不丢失\n分布式事务的原理，如何使用分布式事务\n什么是一致性hash\n什么是restful，讲讲你理解的restful\n如何设计建立和保持100w的长连接？\n解释什么是MESI协议(缓存一致性)\n说说你知道的几种HASH算法，简单的也可以\n什么是paxos算法\nredis和memcached 的内存管理的区别\n一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新\n\n算法\n10亿个数字里里面找最小的10个2、有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优3、2亿个随机生成的无序整数,找出中间大小的值4、遍历二叉树六、数据库1.数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点\n高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义\nSQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？\n数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁\nMYsql的索引实现方式\n聚集索引和非聚集索引的区别\n数据库中 BTREE和B+tree区别\n\n作者：程序汪追风链接：https:juejin.impost5d5fd40bf265da03df5f1b3a来源：掘金\n","tags":["算法","面试","数据库","JVM","框架"],"path":"2019/08/24/Java面试题（框架-JVM-多线程-算法-数据库）/","external_link":""},{"title":"Java反编译工具jad","date":"2019-09-06T05:21:38.000Z","content":"\nJad(JAva Decompiler)Jad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。下载点击\n使用方法：\n[1] 反编译一个class文件：jad example.class，会生成example.jad，用文本编辑器打开就是java源代码\n[2] 指定生成源代码的后缀名：jad -sjava example.class，生成example.java\n[3] 改变生成的源代码的名称，可以先使用-p将反编译后的源代码输出到控制台窗口，然后使用重定向，输出到文件：jad -p example.class &gt; myexample.java\n[4] 把源代码文件输出到指定的目录：jad -dnewdir -sjava example.class，在newdir目录下生成example.java\n[5] 把packages目录下的class文件全部反编译：jad -sjava packages*.class\n[6] 把packages目录以及子目录下的文件全部反编译：jad -sjava packages*.class，不过你仍然会发现所有的源代码文件被放到了同一个文件中，没有按照class文件的包路径建立起路径\n[7] 把packages目录以及子目录下的文件全部反编译并建立和java包一致的文件夹路径，可以使用-r命令：jad -r -sjava packages*.class\n[8] 当重复使用命令反编译时，Jad会提示“whether you want to overwrite it or not”，使用-o可以强制覆盖旧文件\n[9] 还有其他的参数可以设置生成的源代码的格式，可以输入jad命令查看帮助，这里有个人做了简单的翻译：jad命令总结\n[10] 当然，你会发现有些源文件头部有些注释信息，不用找了，jad没有参数可以去掉它，用别的办法吧。\n测试Main.java\n123456789101112131415161718192021222324252627282930public class Main &#123;    static volatile int t = 0;    public static void main(String[] args) &#123;        int n = 100;        Thread[] threads = new Thread[n];        for (int i = 0; i &lt; n; i++) &#123;            threads[i] = new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i = 0; i &lt; 10000; i++) &#123;                        add();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        while (Thread.activeCount() &gt; 1)            Thread.yield();        System.out.println(t);    &#125;    static void add() &#123;        t++;    &#125;&#125;\n\nMain.class\n1234567891011121314151617cafe babe 0000 0034 0037 0a00 0d00 1d07001e 0700 1f0a 0003 001d 0a00 0200 200a0002 0021 0a00 0200 220a 0002 0023 09002400 2509 000c 0026 0a00 2700 2807 00290700 2a01 000c 496e 6e65 7243 6c61 73736573 0100 0174 0100 0149 0100 063c 696e6974 3e01 0003 2829 5601 0004 436f 64650100 0f4c 696e 654e 756d 6265 7254 61626c65 0100 046d 6169 6e01 0016 285b 4c6a6176 612f 6c61 6e67 2f53 7472 696e 673b2956 0100 0d53 7461 636b 4d61 7054 61626c65 0700 2b01 0003 6164 6401 0008 3c636c69 6e69 743e 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0011 0012 0100 106a 6176 612f 6c61 6e672f54 6872 6561 6401 0006 4d61 696e 2431...\n\n\n反编译后的结果\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. Jad home page: http:www.kpdus.comjad.html Decompiler options: packimports(3)  Source File Name:   Main.javaimport java.io.PrintStream;public class Main&#123;    public Main()    &#123;    &#125;    public static void main(String args[])    &#123;        byte byte0 = 100;        Thread athread[] = new Thread[byte0];        for(int i = 0; i &lt; byte0; i++)        &#123;            athread[i] = new Thread(new Runnable() &#123;                public void run()                &#123;                    for(int j = 0; j &lt; 10000; j++)                        Main.add();                &#125;            &#125;);            athread[i].start();        &#125;        for(; Thread.activeCount() &gt; 1; Thread.yield());        System.out.println(t);    &#125;    static void add()    &#123;        t++;    &#125;    static volatile int t = 0;&#125;\n\n","tags":["Java","反编译","jad"],"path":"2019/09/06/Java反编译工具jad/","external_link":""},{"title":"git教程","date":"2019-08-16T07:47:37.000Z","content":"名称git - 愚蠢的内容跟踪器\n概要git [--version] [ -  help] [-C &lt;path&gt;] [-c &lt;name&gt; = &lt;value&gt;]\n    [--exec-path [= &lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n    [-p | --paginate | -P | --no-pager] [ -  no-replace-objects] [--bare]\n    [--git-dir = &lt;path&gt;] [ -  work-tree = &lt;path&gt;] [--namespace = &lt;name&gt;]\n    [--super前缀= &lt;路径&gt;]\n    &lt;command&gt; [&lt;args&gt;]描述Git是一个快速，可扩展的分布式版本控制系统，具有异常丰富的命令集，可提供高级操作和对内部的完全访问。\n请参阅gittutorial [7]以开始使用，然后查看 giteveryday [7]以获取有用的最小命令集。在Git的用户手册有一个更深入的介绍。\n掌握了基本概念后，您可以回到此页面了解Git提供的命令。您可以使用“git help command”了解有关各个Git命令的更多信息。 gitcli [7] 手册页概述了命令行命令语法。\n可以在以下位置查看最新Git文档的格式化和超链接副本https:git.github.iohtmldocsgit.html。\nOPTIONS\n版打印git程序来自的Git套件版本。\n\n救命打印概要和最常用命令的列表。如果选择–all或-a已给出，则打印所有可用命令。如果命名了Git命令，则此选项将显示该命令的手册页。\n\n\n其他选项可用于控制手册页的显示方式。有关更多信息，请参阅git-help [1]，因为git –help …内部转换为git help …。\n-C &lt;路径&gt;运行就好像git是在而不是当前工作目录中启动的。当-C给出多个选项时，-C 相对于前面的每个后续非绝对值被解释-C 。如果存在但是为空，例如-C “”，则保持当前工作目录不变。\n此选项会影响预期的路径名的选项一样–git-dir，并 –work-tree在他们的路径名的解释，将相对于所造成的工作目录进行-C选择。例如，以下调用是等效的：\ngit --git-dir = a.git --work-tree = b -C c status\ngit --git-dir = c  a.git --work-tree = c  b status-c  = 将配置参数传递给命令。给定的值将覆盖配置文件中的值。的格式与git config列出的格式相同 （以点分隔的子键）。\n请注意，允许省略=in git -c foo.bar …并设置 foo.bar为布尔值true（就像[foo]bar在配置文件中一样）。包括equals但空值（如git -c foo.bar= …）设置foo.bar为git config –type=bool将转换为的空字符串false。\n–exec路径[= &lt;路径&gt;]安装核心Git程序的路径。这也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径，git将打印当前设置然后退出。\n–html路径打印路径，不带斜杠，安装Git的HTML文档并退出。\n–man路径打印manpath（请参阅参考资料man(1)）获取此版本Git的手册页并退出。\n–info路径打印安装记录此版本Git的Info文件的路径并退出。\n-p–paginate如果标准输出是终端，则将所有输出传输到较少（或如果设置为$ PAGER）。这将覆盖pager. 配置选项（请参阅下面的“配置机制”部分）。\n-P–no寻呼机不要将Git输出传输到寻呼机。\n–git-DIR = &lt;路径&gt;设置存储库的路径。这也可以通过设置GIT_DIR环境变量来控制。它可以是当前工作目录的绝对路径或相对路径。\n\n共同努力树= &lt;路径&gt;设置工作树的路径。它可以是绝对路径或相对于当前工作目录的路径。这也可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制（有关更详细的讨论，请参阅git-config [1]中的core.worktree ）。\n\n–namespace = &lt;路径&gt;设置Git名称空间。有关更多详细信息，请参阅gitnamespaces [7]。相当于设置GIT_NAMESPACE环境变量。\n–super前缀= &lt;路径&gt;目前仅供内部使用。设置一个前缀，该前缀提供从存储库上方到其根目录的路径。一个用途是给出调用它的超级项目的子模块上下文。\n\n裸将存储库视为裸存储库。如果未设置GIT_DIR环境，则将其设置为当前工作目录。\n\n–no替换对象不要使用替换引用来替换Git对象。有关更多信息，请参阅 git-replace [1]。\n–literal按本义，pathspecs按字面意思处理pathspecs（即没有globbing，没有pathspec魔法）。这相当于将GIT_LITERAL_PATHSPECS环境变量设置为1。\n–glob-pathspecs为所有pathspec添加“glob”魔法。这相当于将GIT_GLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( literal）”在各个pathspec上禁用通配符\n–noglob-pathspecs为所有pathspec添加“literal”魔法。这相当于将GIT_NOGLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( glob）”在各个pathspec上启用globbing\n–icase-pathspecs为所有pathspec添加“icase”魔法。这相当于将GIT_ICASE_PATHSPECS环境变量设置为1。\n–no-可选锁不要执行需要锁定的可选操作。这相当于设置GIT_OPTIONAL_LOCKS为0。\n–list-CMDS =基团[，组…]按组列出命令。这是一个内部实验选项，可能会在将来更改或删除。支持的组包括：builtins，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（所有其他命令$PATH都有git-前缀），list- （请参阅命令中的类别 - list.txt），nohelpers（排除帮助程序命令），别名和配置（从配置变量completion.commands检索命令列表）\n","tags":["文章","git"],"path":"2019/08/16/git教程/","external_link":""},{"title":"TensorFlow 2.0 中文手写字识别（汉字OCR）","date":"2019-09-06T07:08:56.000Z","content":"\nTensorFlow 2.0 中文手写字识别（汉字OCR）\n搜索空间空前巨大，我们使用的数据集1.0版本汉字就多大3755个，如果加上1.1版本一起，总共汉字可以分为多达7599+个类别！这比10个阿拉伯字母识别难度大很多！\n数据集处理挑战更大，相比于mnist和fasionmnist来说，汉字手写字体识别数据集非常少，而且仅有的数据集数据预处理难度非常大，非常不直观，但是，千万别吓到，相信你看完本教程一定会收货满满!\n汉字识别更考验选手的建模能力，还在分类花？分类猫和狗？随便搭建的几层在搜索空间巨大的汉字手写识别里根本不work！你现在是不是想用很深的网络跃跃欲试？更深的网络在这个任务上可能根本不可行！！看完本教程我们就可以一探究竟！总之一句话，模型太简单和太复杂都不好，甚至会发散！（想亲身体验模型训练发散抓狂的可以来尝试一下！）。\n\n数据准备在开始之前，先介绍一下本项目所采用的数据信息。我们的数据全部来自于CASIA的开源中文手写字数据集，该数据集分为两部分：\n\nCASIA-HWDB：离线的HWDB，我们仅仅使用1.0-1.2，这是单字的数据集，2.0-2.2是整张文本的数据集，我们暂时不用，单字里面包含了约7185个汉字以及171个英文字母、数字、标点符号等；\nCASIA-OLHWDB：在线的HWDB，格式一样，包含了约7185个汉字以及171个英文字母、数字、标点符号等，我们不用。\n\n其实你下载1.0的train和test差不多已经够了，可以直接运行 datasetget_hwdb_1.0_1.1.sh 下载。原始数据下载链接点击这里. 由于原始数据过于复杂，我们使用一个类来封装数据读取过程，这是我们展示的效果：\n看到这么密密麻麻的文字相信连人类都…. 开始头疼了，这些复杂的文字能够通过一个神经网络来识别出来？？答案是肯定的…. 不有得感叹一下神经网络的强大。。上面的部分文字识别出来的结果是这样的：\n\n关于数据的处理部分，从服务器下载到的原始数据是 trn_gnt.zip 解压之后是 gnt.alz， 需要再次解压得到一个包含 gnt文件的文件夹。里面每一个gnt文件都包含了若干个汉字及其标注。直接处理比较麻烦，也不方便抽取出图片再进行操作，虽然转为图片存入文件夹比较直观，但是不适合批量读取和训练, 后面我们统一转为tfrecord进行训练。\n更新: 实际上，由于单个汉字图片其实很小，差不多也就最大80x80的大小，这个大小不适合转成图片保存到本地，因此我们将hwdb原始的二进制保存为tfrecord。同时也方便后面训练，可以直接从tfrecord读取图片进行训练。\n\n训练过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def train():    all_characters = load_characters()    num_classes = len(all_characters)    logging.info(all characters: &#123;&#125;.format(num_classes))    train_dataset = load_ds()    train_dataset = train_dataset.shuffle(100).map(preprocess).batch(32).repeat()    val_ds = load_val_ds()    val_ds = val_ds.shuffle(100).map(preprocess).batch(32).repeat()    for data in train_dataset.take(2):        print(data)    # init model    model = build_net_003((64, 64, 1), num_classes)    model.summary()    logging.info(model loaded.)    start_epoch = 0    latest_ckpt = tf.train.latest_checkpoint(os.path.dirname(ckpt_path))    if latest_ckpt:        start_epoch = int(latest_ckpt.split(-)[1].split(.)[0])        model.load_weights(latest_ckpt)        logging.info(model resumed from: &#123;&#125;, start at epoch: &#123;&#125;.format(latest_ckpt, start_epoch))    else:        logging.info(passing resume since weights not there. training from scratch)    if use_keras_fit:        model.compile(            optimizer=tf.keras.optimizers.Adam(),            loss=tf.keras.losses.SparseCategoricalCrossentropy(),            metrics=[accuracy])        callbacks = [            tf.keras.callbacks.ModelCheckpoint(ckpt_path,                                               save_weights_only=True,                                               verbose=1,                                               period=500)        ]        try:            model.fit(                train_dataset,                validation_data=val_ds,                validation_steps=1000,                epochs=15000,                steps_per_epoch=1024,                callbacks=callbacks)        except KeyboardInterrupt:            model.save_weights(ckpt_path.format(epoch=0))            logging.info(keras model saved.)        model.save_weights(ckpt_path.format(epoch=0))        model.save(os.path.join(os.path.dirname(ckpt_path), cn_ocr.h5))\n\n大家在以后编写训练代码的时候其实可以保持这个好的习惯。\nOK，整个模型训练起来之后，可以在短时间内达到95%的准确率：\n\n\n总结通过本教程，我们完成了使用tensorflow 2.0全新的API搭建一个中文汉字手写识别系统。模型基本能够实现我们想要的功能。要知道，这个模型可是在搜索空间多大3755的类别当中准确的找到最相似的类别！！通过本实验，我们有几点心得：\n\n神经网络不仅仅是在学习，它具有一定的想象力！！比如它的一些看着很像的字：拜-佯， 扮-捞，笨-苯…. 这些字如果手写出来，连人都比较难以辨认！！但是大家要知道这些字在类别上并不是相领的！也就是说，模型具有一定的联想能力！\n不管问题多复杂，要敢于动手、善于动手。\n\n","tags":["AI","TensorFlow","OCR"],"path":"2019/09/06/TensorFlow-2-0-中文手写字识别（汉字OCR）/","external_link":""},{"title":"Spring框架面试总结","date":"2019-09-03T16:32:24.000Z","content":"介绍spring框架它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。\nSpring的优点？\n降低了组件之间的耦合性 ，实现了软件各层之间的解耦 \n可以使用容易提供的众多服务，如事务管理，消息服务等 \n容器提供单例模式支持 \n容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 \n容器提供了众多的辅助类，能加快应用的开发 \nspring对于主流的应用框架提供了集成支持，如hibernate，   JPA，Struts等 \nspring属于低侵入式设计，代码的污染极低 \n独立于各种应用服务器 \nspring的DI机制降低了业务对象替换的复杂性 \nSpring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring 的部分或全部 \n\nspring有两种代理方式：答: 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。\n  优点：因为有接口，所以使系统更加松耦合\n  缺点：为每一个目标类创建接口\n若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。\n  优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。\n  缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好\n如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。\nXML配置文件。\n基于注解的配置。\n基于java的配置。\n构造方法注入和设值注入有什么区别？请注意以下明显的区别：\n在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。\n对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。\n在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。\n设值注入不会重写构造方法的值。\n在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。\n请介绍一下Spring框架中Bean的生命周期一、Bean的定义 \nSpring通常通过配置文件定义Bean。如：  \n这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 \n二、Bean的初始化\n有两种方式初始化Bean。 \n1、在配置文档中通过指定init-method 属性来完成 \n2、实现 org.springframwork.beans.factory.InitializingBean接口  \n那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 \n三、Bean的调用 \n有三种方式可以得到Bean并进行调用： \n1、使用BeanWrapper\n2、使用BeanFactory\n3、使用ApplicationConttext\n四、Bean的销毁 \n1、使用配置文件中的 destory-method 属性\n2、实现 org.springframwork.bean.factory.DisposebleBean接口 \nSpring中AOP的应用场景、Aop原理、好处？答：AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:\nAuthentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务\n原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。\n优点：1.各个步骤之间的良好隔离性耦合性大大降低 \n2.源代码无关性，再扩展功能的同时不对源码进行修改操作 有几种不同类型的自动代理？BeanNameAutoProxyCreator\nDefaultAdvisorAutoProxyCreator\nMetadata autoproxying\nApplicationContext通常的实现是什么?FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\nClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\nWebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。\n有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\nSetter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。\n什么是IOC，什么又是DI，他们有什么区别？一、IOC介绍\nIOC是控制反转。\n创建对象实例的控制权从代码控制剥离到IOC容器控制(之前的写法，由程序代码直接操控使用new关键字)，实际就是你在xml文件控制，控制权的转移是所谓反转，侧重于原理。 \n二、DI介绍\nDI是依赖注入\n创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。\nspring事务定义事务的定义：事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么都成功。其必须遵循四个原则（ACID）。\n原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做；\n一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。\n隔离性（Isolation）：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；\n持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。\nSpring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。\n","tags":["面试","Spring"],"path":"2019/09/04/Spring框架面试总结/","external_link":""},{"title":"System类","date":"2019-09-06T06:20:34.000Z","content":"\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256* * Copyright (c) 1994, 2013, Oracle andor its affiliates. All rights reserved. * ORACLE PROPRIETARYCONFIDENTIAL. Use is subject to license terms. * * *package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;** * The &lt;code&gt;System&lt;code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author  unascribed * @since   JDK1.0 *public final class System &#123;    * register the natives via the static initializer.     *     * VM will invoke the initializeSystemClass method to complete     * the initialization for this class separated from clinit.     * Note that to use properties set by the VM, see the constraints     * described in the initializeSystemClass method.     *    private static native void registerNatives();    static &#123;        registerNatives();    &#125;    ** Dont let anyone instantiate this class *    private System() &#123;    &#125;    **     * The standard input stream. This stream is already     * open and ready to supply input data. Typically this stream     * corresponds to keyboard input or another input source specified by     * the host environment or user.     *    public final static InputStream in = null;    **     * The standard output stream. This stream is already     * open and ready to accept output data. Typically this stream     * corresponds to display output or another output destination     * specified by the host environment or user.     * &lt;p&gt;     * For simple stand-alone Java applications, a typical way to write     * a line of output data is:     * &lt;blockquote&gt;&lt;pre&gt;     *     System.out.println(data)     * &lt;pre&gt;&lt;blockquote&gt;     * &lt;p&gt;     * See the &lt;code&gt;println&lt;code&gt; methods in class &lt;code&gt;PrintStream&lt;code&gt;.     *     * @see     java.io.PrintStream#println()     * @see     java.io.PrintStream#println(boolean)     * @see     java.io.PrintStream#println(char)     * @see     java.io.PrintStream#println(char[])     * @see     java.io.PrintStream#println(double)     * @see     java.io.PrintStream#println(float)     * @see     java.io.PrintStream#println(int)     * @see     java.io.PrintStream#println(long)     * @see     java.io.PrintStream#println(java.lang.Object)     * @see     java.io.PrintStream#println(java.lang.String)     *    public final static PrintStream out = null;    **     * The standard error output stream. This stream is already     * open and ready to accept output data.     * &lt;p&gt;     * Typically this stream corresponds to display output or another     * output destination specified by the host environment or user. By     * convention, this output stream is used to display error messages     * or other information that should come to the immediate attention     * of a user even if the principal output stream, the value of the     * variable &lt;code&gt;out&lt;code&gt;, has been redirected to a file or other     * destination that is typically not continuously monitored.     *    public final static PrintStream err = null;    * The security manager for the system.     *    private static volatile SecurityManager security = null;    **     * Reassigns the standard input stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard input stream.     * &lt;p&gt;     *     * @param in the new standard input stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard input stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setIn(InputStream in) &#123;        checkIO();        setIn0(in);    &#125;    **     * Reassigns the standard output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard output stream.     *     * @param out the new standard output stream     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setOut(PrintStream out) &#123;        checkIO();        setOut0(out);    &#125;    **     * Reassigns the standard error output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard error output stream.     *     * @param err the new standard error output stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard error output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setErr(PrintStream err) &#123;        checkIO();        setErr0(err);    &#125;    private static volatile Console cons = null;    **     * Returns the unique &#123;@link java.io.Console Console&#125; object associated     * with the current Java virtual machine, if any.     *     * @return  The system console, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @since   1.6     *     public static Console console() &#123;         if (cons == null) &#123;             synchronized (System.class) &#123;                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();             &#125;         &#125;         return cons;     &#125;    **     * Returns the channel inherited from the entity that created this     * Java virtual machine.     *     * &lt;p&gt; This method returns the channel obtained by invoking the     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125; method of the system-wide default     * &#123;@link java.nio.channels.spi.SelectorProvider&#125; object. &lt;p&gt;     *     * &lt;p&gt; In addition to the network-oriented channels described in     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125;, this method may return other kinds of     * channels in the future.     *     * @return  The inherited channel, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @throws  IOException     *          If an IO error occurs     *     * @throws  SecurityException     *          If a security manager is present and it does not     *          permit access to the channel.     *     * @since 1.5     *    public static Channel inheritedChannel() throws IOException &#123;        return SelectorProvider.provider().inheritedChannel();    &#125;    private static void checkIO() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(setIO));        &#125;    &#125;    private static native void setIn0(InputStream in);    private static native void setOut0(PrintStream out);    private static native void setErr0(PrintStream err);    **     * Sets the System security.     *     * &lt;p&gt; If there is a security manager already installed, this method first     * calls the security managers &lt;code&gt;checkPermission&lt;code&gt; method     * with a &lt;code&gt;RuntimePermission(setSecurityManager)&lt;code&gt;     * permission to ensure its ok to replace the existing     * security manager.     * This may result in throwing a &lt;code&gt;SecurityException&lt;code&gt;.     *     * &lt;p&gt; Otherwise, the argument is established as the current     * security manager. If the argument is &lt;code&gt;null&lt;code&gt; and no     * security manager has been established, then no action is taken and     * the method simply returns.     *     * @param      s   the security manager.     * @exception  SecurityException  if the security manager has already     *             been set and its &lt;code&gt;checkPermission&lt;code&gt; method     *             doesnt allow it to be replaced.     * @see #getSecurityManager     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *    public static    void setSecurityManager(final SecurityManager s) &#123;        try &#123;            s.checkPackageAccess(java.lang);        &#125; catch (Exception e) &#123;             no-op        &#125;        setSecurityManager0(s);    &#125;    private static synchronized    void setSecurityManager0(final SecurityManager s) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;             ask the currently installed security manager if we             can replace it.            sm.checkPermission(new RuntimePermission                                     (setSecurityManager));        &#125;        if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) &#123;             New security manager class is not on bootstrap classpath.             Cause policy to get initialized before we install the new             security manager, in order to prevent infinite loops when             trying to initialize the policy (which usually involves             accessing some security andor system properties, which in turn             calls the installed security managers checkPermission method             which will loop infinitely if there is a non-system class             (in this case: the new security manager class) on the stack).            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;                public Object run() &#123;                    s.getClass().getProtectionDomain().implies                        (SecurityConstants.ALL_PERMISSION);                    return null;                &#125;            &#125;);        &#125;        security = s;    &#125;    **     * Gets the system security interface.     *     * @return  if a security manager has already been established for the     *          current application, then that security manager is returned;     *          otherwise, &lt;code&gt;null&lt;code&gt; is returned.     * @see     #setSecurityManager     *    public static SecurityManager getSecurityManager() &#123;        return security;    &#125;    **     * Returns the current time in milliseconds.  Note that     * while the unit of time of the return value is a millisecond,     * the granularity of the value depends on the underlying     * operating system and may be larger.  For example, many     * operating systems measure time in units of tens of     * milliseconds.     *     * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;code&gt; for     * a discussion of slight discrepancies that may arise between     * computer time and coordinated universal time (UTC).     *     * @return  the difference, measured in milliseconds, between     *          the current time and midnight, January 1, 1970 UTC.     * @see     java.util.Date     *    public static native long currentTimeMillis();    **     * Returns the current value of the running Java Virtual Machines     * high-resolution time source, in nanoseconds.     *     * &lt;p&gt;This method can only be used to measure elapsed time and is     * not related to any other notion of system or wall-clock time.     * The value returned represents nanoseconds since some fixed but     * arbitrary &lt;i&gt;origin&lt;i&gt; time (perhaps in the future, so values     * may be negative).  The same origin is used by all invocations of     * this method in an instance of a Java virtual machine; other     * virtual machine instances are likely to use a different origin.     *     * &lt;p&gt;This method provides nanosecond precision, but not necessarily     * nanosecond resolution (that is, how frequently the value changes)     * - no guarantees are made except that the resolution is at least as     * good as that of &#123;@link #currentTimeMillis()&#125;.     *     * &lt;p&gt;Differences in successive calls that span greater than     * approximately 292 years (2&lt;sup&gt;63&lt;sup&gt; nanoseconds) will not     * correctly compute elapsed time due to numerical overflow.     *     * &lt;p&gt;The values returned by this method become meaningful only when     * the difference between two such values, obtained within the same     * instance of a Java virtual machine, is computed.     *     * &lt;p&gt; For example, to measure how long some code takes to execute:     *  &lt;pre&gt; &#123;@code     * long startTime = System.nanoTime();     *  ... the code being measured ...     * long estimatedTime = System.nanoTime() - startTime;&#125;&lt;pre&gt;     *     * &lt;p&gt;To compare two nanoTime values     *  &lt;pre&gt; &#123;@code     * long t0 = System.nanoTime();     * ...     * long t1 = System.nanoTime();&#125;&lt;pre&gt;     *     * one should use &#123;@code t1 - t0 &lt; 0&#125;, not &#123;@code t1 &lt; t0&#125;,     * because of the possibility of numerical overflow.     *     * @return the current value of the running Java Virtual Machines     *         high-resolution time source, in nanoseconds     * @since 1.5     *    public static native long nanoTime();    **     * Copies an array from the specified source array, beginning at the     * specified position, to the specified position of the destination array.     * A subsequence of array components are copied from the source     * array referenced by &lt;code&gt;src&lt;code&gt; to the destination array     * referenced by &lt;code&gt;dest&lt;code&gt;. The number of components copied is     * equal to the &lt;code&gt;length&lt;code&gt; argument. The components at     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; in the source array are copied into     * positions &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+length-1&lt;code&gt;, respectively, of the destination     * array.     * &lt;p&gt;     * If the &lt;code&gt;src&lt;code&gt; and &lt;code&gt;dest&lt;code&gt; arguments refer to the     * same array object, then the copying is performed as if the     * components at positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; were first copied to a temporary     * array with &lt;code&gt;length&lt;code&gt; components and then the contents of     * the temporary array were copied into positions     * &lt;code&gt;destPos&lt;code&gt; through &lt;code&gt;destPos+length-1&lt;code&gt; of the     * destination array.     * &lt;p&gt;     * If &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown.     * &lt;p&gt;     * If &lt;code&gt;src&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown and the destination     * array is not modified.     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown and the destination is     * not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;dest&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument and &lt;code&gt;dest&lt;code&gt; argument refer     *     to arrays whose component types are different primitive types.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a primitive     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a reference component type.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a reference     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a primitive component type.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;IndexOutOfBoundsException&lt;code&gt; is     * thrown and the destination is not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;srcPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;destPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;length&lt;code&gt; argument is negative.     * &lt;li&gt;&lt;code&gt;srcPos+length&lt;code&gt; is greater than     *     &lt;code&gt;src.length&lt;code&gt;, the length of the source array.     * &lt;li&gt;&lt;code&gt;destPos+length&lt;code&gt; is greater than     *     &lt;code&gt;dest.length&lt;code&gt;, the length of the destination array.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any actual component of the source array from     * position &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; cannot be converted to the component     * type of the destination array by assignment conversion, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown. In this case, let     * &lt;b&gt;&lt;i&gt;k&lt;i&gt;&lt;b&gt; be the smallest nonnegative integer less than     * length such that &lt;code&gt;src[srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;]&lt;code&gt;     * cannot be converted to the component type of the destination     * array; when the exception is thrown, source array components from     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;-1&lt;code&gt;     * will already have been copied to destination array positions     * &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+&lt;code&gt;&lt;i&gt;k&lt;I&gt;&lt;code&gt;-1&lt;code&gt; and no other     * positions of the destination array will have been modified.     * (Because of the restrictions already itemized, this     * paragraph effectively applies only to the situation where both     * arrays have component types that are reference types.)     *     * @param      src      the source array.     * @param      srcPos   starting position in the source array.     * @param      dest     the destination array.     * @param      destPos  starting position in the destination data.     * @param      length   the number of array elements to be copied.     * @exception  IndexOutOfBoundsException  if copying would cause     *               access of data outside array bounds.     * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;code&gt;     *               array could not be stored into the &lt;code&gt;dest&lt;code&gt; array     *               because of a type mismatch.     * @exception  NullPointerException if either &lt;code&gt;src&lt;code&gt; or     *               &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     *    public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);    **     * Returns the same hash code for the given object as     * would be returned by the default method hashCode(),     * whether or not the given objects class overrides     * hashCode().     * The hash code for the null reference is zero.     *     * @param x object for which the hashCode is to be calculated     * @return  the hashCode     * @since   JDK1.1     *    public static native int identityHashCode(Object x);    **     * System properties. The following properties are guaranteed to be defined:     * &lt;dl&gt;     * &lt;dt&gt;java.version         &lt;dd&gt;Java version number     * &lt;dt&gt;java.vendor          &lt;dd&gt;Java vendor specific string     * &lt;dt&gt;java.vendor.url      &lt;dd&gt;Java vendor URL     * &lt;dt&gt;java.home            &lt;dd&gt;Java installation directory     * &lt;dt&gt;java.class.version   &lt;dd&gt;Java class version number     * &lt;dt&gt;java.class.path      &lt;dd&gt;Java classpath     * &lt;dt&gt;os.name              &lt;dd&gt;Operating System Name     * &lt;dt&gt;os.arch              &lt;dd&gt;Operating System Architecture     * &lt;dt&gt;os.version           &lt;dd&gt;Operating System Version     * &lt;dt&gt;file.separator       &lt;dd&gt;File separator ( on Unix)     * &lt;dt&gt;path.separator       &lt;dd&gt;Path separator (: on Unix)     * &lt;dt&gt;line.separator       &lt;dd&gt;Line separator (n on Unix)     * &lt;dt&gt;user.name            &lt;dd&gt;User account name     * &lt;dt&gt;user.home            &lt;dd&gt;User home directory     * &lt;dt&gt;user.dir             &lt;dd&gt;Users current working directory     * &lt;dl&gt;     *    private static Properties props;    private static native Properties initProperties(Properties props);    **     * Determines the current system properties.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The current set of system properties for use by the     * &#123;@link #getProperty(String)&#125; method is returned as a     * &lt;code&gt;Properties&lt;code&gt; object. If there is no current set of     * system properties, a set of system properties is first created and     * initialized. This set of system properties always includes values     * for the following keys:     * &lt;table summary=Shows property keys and associated values&gt;     * &lt;tr&gt;&lt;th&gt;Key&lt;th&gt;     *     &lt;th&gt;Description of Associated Value&lt;th&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor.url&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java vendor URL&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java installation directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class format version number&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.library.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;List of paths to search when loading libraries&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.io.tmpdir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Default temp file path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.compiler&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Name of JIT compiler to use&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.ext.dirs&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path of extension directory or directories     *         &lt;b&gt;Deprecated.&lt;b&gt; &lt;i&gt;This property, and the mechanism     *            which implements it, may be removed in a future     *            release.&lt;i&gt; &lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.arch&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system architecture&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;file.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;File separator ( on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;path.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path separator (: on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;line.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Line separator (n on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users account name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users home directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.dir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users current working directory&lt;td&gt;&lt;tr&gt;     * &lt;table&gt;     * &lt;p&gt;     * Multiple paths in a system property value are separated by the path     * separator character of the platform.     * &lt;p&gt;     * Note that even if the security manager does not permit the     * &lt;code&gt;getProperties&lt;code&gt; operation, it may choose to permit the     * &#123;@link #getProperty(String)&#125; operation.     *     * @return     the system properties     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #setProperties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @see        java.util.Properties     *    public static Properties getProperties() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        return props;    &#125;    **     * Returns the system-dependent line separator string.  It always     * returns the same value - the initial value of the &#123;@linkplain     * #getProperty(String) system property&#125; &#123;@code line.separator&#125;.     *     * &lt;p&gt;On UNIX systems, it returns &#123;@code n&#125;; on Microsoft     * Windows systems it returns &#123;@code rn&#125;.     *     * @return the system-dependent line separator string     * @since 1.7     *    public static String lineSeparator() &#123;        return lineSeparator;    &#125;    private static String lineSeparator;    **     * Sets the system properties to the &lt;code&gt;Properties&lt;code&gt;     * argument.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The argument becomes the current set of system properties for use     * by the &#123;@link #getProperty(String)&#125; method. If the argument is     * &lt;code&gt;null&lt;code&gt;, then the current set of system properties is     * forgotten.     *     * @param      props   the new system properties.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #getProperties     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     *    public static void setProperties(Properties props) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        if (props == null) &#123;            props = new Properties();            initProperties(props);        &#125;        System.props = props;    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the key as     * its argument. This may result in a SecurityException.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @return     the string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key);    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the     * &lt;code&gt;key&lt;code&gt; as its argument.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @param      def   a default value.     * @return     the string value of the system property,     *             or the default value if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *             access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key, String def) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key, def);    &#125;    **     * Sets the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is set to the given     * value.     * &lt;p&gt;     *     * @param      key   the name of the system property.     * @param      value the value of the system property.     * @return     the previous value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if it did not have one.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *             setting of the specified property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; or     *             &lt;code&gt;value&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        java.lang.System#getProperty(java.lang.String)     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)     * @see        java.util.PropertyPermission     * @see        SecurityManager#checkPermission     * @since      1.2     *    public static String setProperty(String key, String value) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key,                SecurityConstants.PROPERTY_WRITE_ACTION));        &#125;        return (String) props.setProperty(key, value);    &#125;    **     * Removes the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is removed.     * &lt;p&gt;     *     * @param      key   the name of the system property to be removed.     * @return     the previous string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there was no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        #setProperty     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @since 1.5     *    public static String clearProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key, write));        &#125;        return (String) props.remove(key);    &#125;    private static void checkKey(String key) &#123;        if (key == null) &#123;            throw new NullPointerException(key cant be null);        &#125;        if (key.equals()) &#123;            throw new IllegalArgumentException(key cant be empty);        &#125;    &#125;    **     * Gets the value of the specified environment variable. An     * environment variable is a system-dependent external named     * value.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.+name)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125;     * being thrown.  If no exception is thrown the value of the     * variable &lt;code&gt;name&lt;code&gt; is returned.     *     * &lt;p&gt;&lt;a name=EnvironmentVSSystemProperties&gt;&lt;i&gt;System     * properties&lt;i&gt; and &lt;i&gt;environment variables&lt;i&gt;&lt;a&gt; are both     * conceptually mappings between names and values.  Both     * mechanisms can be used to pass user-defined information to a     * Java process.  Environment variables have a more global effect,     * because they are visible to all descendants of the process     * which defines them, not just the immediate Java subprocess.     * They can have subtly different semantics, such as case     * insensitivity, on different operating systems.  For these     * reasons, environment variables are more likely to have     * unintended side effects.  It is best to use system properties     * where possible.  Environment variables should be used when a     * global effect is desired, or when an external system interface     * requires an environment variable (such as &lt;code&gt;PATH&lt;code&gt;).     *     * &lt;p&gt;On UNIX systems the alphabetic case of &lt;code&gt;name&lt;code&gt; is     * typically significant, while on Microsoft Windows systems it is     * typically not.  For example, the expression     * &lt;code&gt;System.getenv(FOO).equals(System.getenv(foo))&lt;code&gt;     * is likely to be true on Microsoft Windows.     *     * @param  name the name of the environment variable     * @return the string value of the variable, or &lt;code&gt;null&lt;code&gt;     *         if the variable is not defined in the system environment     * @throws NullPointerException if &lt;code&gt;name&lt;code&gt; is &lt;code&gt;null&lt;code&gt;     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the environment variable     *         &lt;code&gt;name&lt;code&gt;     * @see    #getenv()     * @see    ProcessBuilder#environment()     *    public static String getenv(String name) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.+name));        &#125;        return ProcessEnvironment.getenv(name);    &#125;    **     * Returns an unmodifiable string map view of the current system environment.     * The environment is a system-dependent mapping from names to     * values which is passed from parent to child processes.     *     * &lt;p&gt;If the system does not support environment variables, an     * empty map is returned.     *     * &lt;p&gt;The returned map will never contain null keys or values.     * Attempting to query the presence of a null key or value will     * throw a &#123;@link NullPointerException&#125;.  Attempting to query     * the presence of a key or value which is not of type     * &#123;@link String&#125; will throw a &#123;@link ClassCastException&#125;.     *     * &lt;p&gt;The returned map and its collection views may not obey the     * general contract of the &#123;@link Object#equals&#125; and     * &#123;@link Object#hashCode&#125; methods.     *     * &lt;p&gt;The returned map is typically case-sensitive on all platforms.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.*)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125; being     * thrown.     *     * &lt;p&gt;When passing information to a Java subprocess,     * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;a&gt;     * are generally preferred over environment variables.     *     * @return the environment as a map of variable names to values     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the process environment     * @see    #getenv(String)     * @see    ProcessBuilder#environment()     * @since  1.5     *    public static java.util.Map&lt;String,String&gt; getenv() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.*));        &#125;        return ProcessEnvironment.getenv();    &#125;    **     * Terminates the currently running Java Virtual Machine. The     * argument serves as a status code; by convention, a nonzero status     * code indicates abnormal termination.     * &lt;p&gt;     * This method calls the &lt;code&gt;exit&lt;code&gt; method in class     * &lt;code&gt;Runtime&lt;code&gt;. This method never returns normally.     * &lt;p&gt;     * The call &lt;code&gt;System.exit(n)&lt;code&gt; is effectively equivalent to     * the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().exit(n)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      status   exit status.     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow exit with the specified status.     * @see        java.lang.Runtime#exit(int)     *    public static void exit(int status) &#123;        Runtime.getRuntime().exit(status);    &#125;    **     * Runs the garbage collector.     * &lt;p&gt;     * Calling the &lt;code&gt;gc&lt;code&gt; method suggests that the Java Virtual     * Machine expend effort toward recycling unused objects in order to     * make the memory they currently occupy available for quick reuse.     * When control returns from the method call, the Java Virtual     * Machine has made a best effort to reclaim space from all discarded     * objects.     * &lt;p&gt;     * The call &lt;code&gt;System.gc()&lt;code&gt; is effectively equivalent to the     * call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().gc()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#gc()     *    public static void gc() &#123;        Runtime.getRuntime().gc();    &#125;    **     * Runs the finalization methods of any objects pending finalization.     * &lt;p&gt;     * Calling this method suggests that the Java Virtual Machine expend     * effort toward running the &lt;code&gt;finalize&lt;code&gt; methods of objects     * that have been found to be discarded but whose &lt;code&gt;finalize&lt;code&gt;     * methods have not yet been run. When control returns from the     * method call, the Java Virtual Machine has made a best effort to     * complete all outstanding finalizations.     * &lt;p&gt;     * The call &lt;code&gt;System.runFinalization()&lt;code&gt; is effectively     * equivalent to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().runFinalization()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#runFinalization()     *    public static void runFinalization() &#123;        Runtime.getRuntime().runFinalization();    &#125;    **     * Enable or disable finalization on exit; doing so specifies that the     * finalizers of all objects that have finalizers that have not yet been     * automatically invoked are to be run before the Java runtime exits.     * By default, finalization on exit is disabled.     *     * &lt;p&gt;If there is a security manager,     * its &lt;code&gt;checkExit&lt;code&gt; method is first called     * with 0 as its argument to ensure the exit is allowed.     * This could result in a SecurityException.     *     * @deprecated  This method is inherently unsafe.  It may result in     *      finalizers being called on live objects while other threads are     *      concurrently manipulating those objects, resulting in erratic     *      behavior or deadlock.     * @param value indicating enabling or disabling of finalization     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow the exit.     *     * @see     java.lang.Runtime#exit(int)     * @see     java.lang.Runtime#gc()     * @see     java.lang.SecurityManager#checkExit(int)     * @since   JDK1.1     *    @Deprecated    public static void runFinalizersOnExit(boolean value) &#123;        Runtime.runFinalizersOnExit(value);    &#125;    **     * Loads the native library specified by the filename argument.  The filename     * argument must be an absolute path name.     *     * If the filename argument, when stripped of any platform-specific library     * prefix, path, and file extension, indicates a library whose name is,     * for example, L, and a native library called L is statically linked     * with the VM, then the JNI_OnLoad_L function exported by the library     * is invoked rather than attempting to load a dynamic library.     * A filename matching the argument does not have to exist in the     * file system.     * See the JNI Specification for more details.     *     * Otherwise, the filename argument is mapped to a native library image in     * an implementation-dependent manner.     *     * &lt;p&gt;     * The call &lt;code&gt;System.load(name)&lt;code&gt; is effectively equivalent     * to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().load(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      filename   the file to load.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError  if either the filename is not an     *             absolute path name, the native library is not statically     *             linked with the VM, or the library cannot be mapped to     *             a native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;filename&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#load(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void load(String filename) &#123;        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);    &#125;    **     * Loads the native library specified by the &lt;code&gt;libname&lt;code&gt;     * argument.  The &lt;code&gt;libname&lt;code&gt; argument must not contain any platform     * specific prefix, file extension or path. If a native library     * called &lt;code&gt;libname&lt;code&gt; is statically linked with the VM, then the     * JNI_OnLoad_&lt;code&gt;libname&lt;code&gt; function exported by the library is invoked.     * See the JNI Specification for more details.     *     * Otherwise, the libname argument is loaded from a system library     * location and mapped to a native library image in an implementation-     * dependent manner.     * &lt;p&gt;     * The call &lt;code&gt;System.loadLibrary(name)&lt;code&gt; is effectively     * equivalent to the call     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().loadLibrary(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      libname   the name of the library.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError if either the libname argument     *             contains a file path, the native library is not statically     *             linked with the VM,  or the library cannot be mapped to a     *             native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#loadLibrary(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void loadLibrary(String libname) &#123;        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);    &#125;    **     * Maps a library name into a platform-specific string representing     * a native library.     *     * @param      libname the name of the library.     * @return     a platform-dependent native library name.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.System#loadLibrary(java.lang.String)     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)     * @since      1.2     *    public static native String mapLibraryName(String libname);    **     * Create PrintStream for stdouterr based on encoding.     *    private static PrintStream newPrintStream(FileOutputStream fos, String enc) &#123;       if (enc != null) &#123;            try &#123;                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);            &#125; catch (UnsupportedEncodingException uee) &#123;&#125;        &#125;        return new PrintStream(new BufferedOutputStream(fos, 128), true);    &#125;    **     * Initialize the system class.  Called after thread initialization.     *    private static void initializeSystemClass() &#123;         VM might invoke JNU_NewStringPlatform() to set those encoding         sensitive properties (user.home, user.name, boot.class.path, etc.)         during props initialization, in which it may need access, via         System.getProperty(), to the related system encoding property that         have been initialized (put into props) at early stage of the         initialization. So make sure the props is available at the         very beginning of the initialization and all system properties to         be put into it directly.        props = new Properties();        initProperties(props);   initialized by the VM         There are certain system configurations that may be controlled by         VM options such as the maximum amount of direct memory and         Integer cache size used to support the object identity semantics         of autoboxing.  Typically, the library will obtain these values         from the properties set by the VM.  If the properties are for         internal implementation use only, these properties should be         removed from the system properties.                 See java.lang.Integer.IntegerCache and the         sun.misc.VM.saveAndRemoveProperties method for example.                 Save a private copy of the system properties object that         can only be accessed by the internal implementation.  Remove         certain system properties that are not intended for public access.        sun.misc.VM.saveAndRemoveProperties(props);        lineSeparator = props.getProperty(line.separator);        sun.misc.Version.init();        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);        setIn0(new BufferedInputStream(fdIn));        setOut0(newPrintStream(fdOut, props.getProperty(sun.stdout.encoding)));        setErr0(newPrintStream(fdErr, props.getProperty(sun.stderr.encoding)));         Load the zip library now in order to keep java.util.zip.ZipFile         from trying to use itself to load this library later.        loadLibrary(zip);         Setup Java signal handlers for HUP, TERM, and INT (where available).        Terminator.setup();         Initialize any miscellenous operating system settings that need to be         set for the class libraries. Currently this is no-op everywhere except         for Windows where the process-wide error mode is set before the java.io         classes are used.        sun.misc.VM.initializeOSEnvironment();         The main thread is not added to its thread group in the same         way as other threads; we must do it ourselves here.        Thread current = Thread.currentThread();        current.getThreadGroup().add(current);         register shared secrets        setJavaLangAccess();         Subsystems that are invoked during initialization can invoke         sun.misc.VM.isBooted() in order to avoid doing things that should         wait until the application class loader has been set up.         IMPORTANT: Ensure that this remains the last initialization action!        sun.misc.VM.booted();    &#125;    private static void setJavaLangAccess() &#123;         Allow privileged classes outside of java.lang        sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess()&#123;            public sun.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) &#123;                return klass.getConstantPool();            &#125;            public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) &#123;                return klass.casAnnotationType(oldType, newType);            &#125;            public AnnotationType getAnnotationType(Class&lt;?&gt; klass) &#123;                return klass.getAnnotationType();            &#125;            public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) &#123;                return klass.getDeclaredAnnotationMap();            &#125;            public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawAnnotations();            &#125;            public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawTypeAnnotations();            &#125;            public byte[] getRawExecutableTypeAnnotations(Executable executable) &#123;                return Class.getExecutableTypeAnnotationBytes(executable);            &#125;            public &lt;E extends Enum&lt;E&gt;&gt;                    E[] getEnumConstantsShared(Class&lt;E&gt; klass) &#123;                return klass.getEnumConstantsShared();            &#125;            public void blockedOn(Thread t, Interruptible b) &#123;                t.blockedOn(b);            &#125;            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) &#123;                Shutdown.add(slot, registerShutdownInProgress, hook);            &#125;            public int getStackTraceDepth(Throwable t) &#123;                return t.getStackTraceDepth();            &#125;            public StackTraceElement getStackTraceElement(Throwable t, int i) &#123;                return t.getStackTraceElement(i);            &#125;            public String newStringUnsafe(char[] chars) &#123;                return new String(chars, true);            &#125;            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) &#123;                return new Thread(target, acc);            &#125;            public void invokeFinalize(Object o) throws Throwable &#123;                o.finalize();            &#125;        &#125;);    &#125;&#125;\n\n","tags":["编程","Java"],"path":"2019/09/06/System类/","external_link":""},{"title":"你也能懂相对论","date":"2019-09-08T11:25:53.000Z","content":"\n相对论\n光线在通过强引力场附近时会发生弯曲，这是广义相对论的重要预言之一\n\n\n如果我说，相对论与日常生用息息相关，你会信吗？或许就算我是一位知名的物理学教授，说服力相信也不会大得多少。以下我将要用比较浅白简单的文字和少许初等代数，说明并说服大家，相对论并不难懂，而且它在日常经验中是如此的明显、如此的必要！\n1905 年被称为爱因斯坦的「奇迹年」，爱因斯坦向世界提出了一套非常明显、非常合理，但却一直不为人所理解的理论狭义相对论(special relativity)。被称为「狭义」是因为这个理论只在惯性座标系中适用；换句话说，即是在所有没有加速度的系统中都适用。狭义相对论建基于两大假设：\n\n在所有的惯性系统中，所有有物理定律保持不变。\n对于所有系统中的所有观测者，光速永远不变，而且不是无限快的。\n\n假设(一)「所有自然定律不变」一般被称为相对性原理(principle of relativity)，明显比较合理，也比较容易理解。而乍看之下，光速相对于所有人都不变，而不论那人正在高速奔跑或者静止不动都没有关系，就显得较为奇怪了。要理解这一点，我们需要由速度的意义说起。速度，就是在说「每单位时间内走了多远」。说得再浅白一点，可以想像为「每秒走了多少米(ms)」。但这只是惯用单位的问题，你当然可以想成「每小时走了多少公里(kmh)」，这正是司机们惯用的单位。在科学中，单位是至关重要的，因为不同单位的东西就是不同性质的东西，不可以混为一谈的比较，好像一个苹果永远不会等于一个橙。\n假设(二)「光速相对所有人都不变」，就是说相对于所有人，光在每单位时间内走的距离都一样。就是说，当你向着一道光奔跑，「直觉上」你会认为你所看到的光速比起你在静止不动时快，因为在你向光跑去的「同时」，光亦向着你冲去。换成数学上的表达，就是说如果你用速度  v 向着光冲去，而我们用  c 代表你在静止时看到的光速，那你看到的光速就会变成了c + v。这就是所谓的伽俐略变换，亦被一般人叫做「常识」。当然了啊，两个物件互相冲去，当然会比其中一个不动、或两者互相远离快啊。但是，爱因斯坦却说不论你用什么速度，向着光或离开光移动，你到的光速都仍然为  c，不多也不少！\n你会说：「这怎可能！这是违反常识的！」我的回答是，一般人的常识存在非常明显的漏洞，可是在爱因斯坦之前却一直没有人留意到这个严重的错误！这个错误就是「同时」这一概念的演绎。什么是「同时」？就是说大家的时钟显示的时间都一样啊！对，这也是爱因斯坦对「同时」的理解。但现在要再问一道问题，如何知道两个时钟的时间一样？\n问题到肉了，可是你会觉得很无聊：「说什么废话！只要我看到两个钟的指针拍着的时间就是了！」好，停一停，想一想：我们能「看」到东西，是因为光进入到我们的眼球穿过水晶体折射后投影在视网膜上。总言之，我们能看到东西，是因为有光。光以一定的速度前进，而且因为光速有限，因此在不同距离发出的光相对于同一个观测者而言，会在不同时间到达。试想像，两个人相距非常远，而两个人都带着一个时钟，那么当然，任何一方都会觉得对方那个时钟所发出的光，会比自己手上的时钟所发出的光要用更多时间才能进入你的眼睛吧！好了，我希望大家想想，究竟事先要如何调整两个时钟，才能使你和对方都看到两个时钟是同步的呢？当然，这是办不到的！因为两个时钟相距两个人的距离都不同。若然你看到它们是同步的，对方就会看到他手上的走得较快，反之亦然。\n如果你不太理解的话，请从头思考一次，先不要跳过读下去，因为刚才所说的就是相对论的精髓所在。重点是，要知道世界上并没有「对所有人都同时」这个概念存在，因此也可以说，「同时」这个概念对每个人都不同；说「对大家来说都是同时」就是错误的，没有可能发生。这是非常明显的，但却一直被我们所忽略。这完全是因为对于人类的感觉来说，光速(每秒三十万公里，能够环绕地球七个半圈) 实在是太快、太快了。\n好了，接下来我要介绍相对论导致的两个非常重要的结果，这些结果令人类对时间及空间的概念有了根本上的改变：时间及空间其实是互相纠缠、难分难离的。在这部分我会以数学论证，狭义相对论所涉及的数学都只是基本数学运算以及向量微积分，相信对有会考物理根基的朋友来说不会太难。\n\n在我们生活的三维空间中，每一件事件都可以用座标系的四个变量决定，就是(长，阔，高，时间)，数学表达为( x , y , z , t )。假设在座标系  S 中有一原点  O，在  S 内观测的人都会对每一件事件测得一组座标( x , y , z , t )；而现在有另一座标系S’正在相对S以速度  v 向右移动，它的原点  O’ 在时间  t = 0的时候刚好与  O重叠，而在S’内观测的人都会对每一件事件测得一组座标( x’ , y’ , z’ ,       t’ )。那么，在我们的「常识」中， ( x , y , z , t )与 ( x’ , y’ , z’ , t’ )的关系就是由伽俐略变换来决定：\n\n这就是我们认为的「常识」的数学表达方法。留意当中t’ = t，因为在传统的观念里，「同时」这概念仍然存在。明显地，在伽俐略变换当中，时间是独立地流逝的，与空间( x , y , z )无关。可是，在上文中我们知道「同时」是不存在的。\n\n想像小明站在一节正在行进的列车车厢正中间，在车头及车尾都摆放了感应器。他向左右同时照射出两道光束。对小明来说，车厢并没有移动，所以他会看到两道光束同时到达感应器。可是，对于一位站在月台上的人来说，因为列车正在向右移动，右边的感应器不断远离光束，而左边的就不断靠边光束。所以他会看到左边那道光束首先到达感应器。因此，时间会因为观测者的运动状态不同而有所分别，而且这是非常明显的！请注意，上述两种情况都是正确的，没有谁对谁错，完全因为观点与角度而已。回到  S 和  S’ 座标系的讨论，因为两个座标系的运动状态不同，所以伽俐略变换就不是正确的描述了，我们必须改用另外一种座标变换方法，名为洛伦兹变换( Lorentz Transformation)：\n\n有关这组公式的推导过程，有兴趣的朋友可以参考任何相对论课本。在这里我们有兴趣的是：如果时间及空间确实根据以上方程组变换的话，会有什么有趣的事情发生？\n\n首先，考虑一个「光钟」，这是一个纯粹由两块互相平行的平面镜组成的计时器，有一束光在两块镜之间来回反弹。然后我们定义这束光来回反弹一次的时间Δ t = 2 h  c 为一个时间单位，故此我们就有了这样一种有趣的计时器。\n\n现在，我们让这个光钟在S座标系中以水平方向向右以均速  v 移动。所以我们就知道，如果我们称光钟为S’ 座标系，就有Δ t’ = 2 h  c。在S 座标系当中，光就是以斜线行进的，根据毕氐定理，我们得到  \n  \n使用简单代数运算求得Δ t：\n\n因为v &lt; c，所以分母必定小于1 ，故此Δ t’ &lt; Δ t。换句话说，移动中的座标系的时间流逝得比较慢。这就是著名的时间迟滞(Time Dilation) 。 \n除了移动中的人的时间在其他人眼中会变慢之外，移动中的物体看起来也会变短。这叫做长度收缩(Length Contraction)。如果L 0 是物体静止时的长度，L是物体相对于观测者以速度  v移动时的长度，那么我们就会得到   \n\n公式(3) 的推导过程与公式(2) 差不多，只要把光钟转个直角再考虑水平移动就可以了，有兴趣的朋友可以自己当做练习试试推导。\n以上两个「违反直觉」的现象都已经被实验观测所证实了。其中一个重要的证明是关于宇宙射线的问题。每分每秒都有大量的宇宙射线攻击着地球，这些射线多是带电粒子诸如质子及电子等等，能量很高。幸好地球有磁场以及大气层的保护，不然地球上就不可能有生命存在了。\n一些粒子与大气粒子碰撞后，会产生许多不同种类的粒子，向各个方向散射。这些粒子的寿命一般都非常短暂，就算在产生的一刻开始已经用接近光速前进，在它再衰变成其他粒子之前，前进的距离最多也只得几百米。但是，虽然地球的大气层厚度约为100公里，设置在地面上的仪器却可以探测到它们！这完全是因为这些粒子以接近光速行进，相对论的效应就会变得很大。如果在静止时这些粒子的寿命是  T，那么根据时间迟滞现象，地面上的人就会测得它们的寿命为\n\n其中  v 是粒子的速度。明显地，当  v 非常接近  c 的时候，T’ 就会变得非常大，所以它们有足够的时间可以穿过厚厚的大气层落到地面。\n我最后想介绍的是著名的爱因斯坦速度相加法则。在早前的讨论中，我们已经明白到，在光速不是无限快的条件下，时间必须是「相对」的。亦即是说，对于不同运动状态的观测者，时间的流逝速率各有不同。同样地对于空间来说也是如此。因此，我们就不能说两个互相靠近的人的相对速度  v’，会简单地为  v’ = v 1 + v 2，其中  v 1 和  v 2 分别为两个人的速度。那么  v’ 应该如何表达才对呢？其实简单得很，只要把洛伦兹公式对时间微分就可以了。详细的做法可以参考教科书，其结果为\n\n因此可以看到在相对论下，相对速度  v’ 比较小。如果代入文章开头的例子，你和光束互相冲向对方，就有\n\n所以你会惊讶地发现，c + v 仍然是  c！这是当然的，因为相对论本身必须符合它的假设：光速不变。\n其实狭义相对论还有许多有趣的题目可以讨论的，例如著名的质能公式E = mc^2、双生子悖论、能量-动量四维向量、以及相对论性电磁场理论等等，或许在以后我会和大家深入讨论。而爱因斯坦在1916 年提出的广义相对论(general relativity)，则是一套把重力与加速度都包含在内的时空理论，能够非常准确地描述我们身处的宇宙。广义相对论所涉及的数学非常深奥，需要使用到十分抽象的黎曼几何以及张量的概念，确实并非每个学生也能明白。在以后我会试试为大家说明广义相对论的重要性。总而言之，在这篇文章中，我希望大家明白的事，是相对论其实并非一般人想像的那么深奥难懂。至少，就狭义相对论而言，只需要中学程度的物理及数学知识就可以了。\n原文链接\n","tags":["相对论","爱因斯坦"],"path":"2019/09/08/你也能懂相对论/","external_link":""},{"title":"判断素数","date":"2019-09-05T18:53:05.000Z","content":"\n素数\n质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。\n0和1既不是质数也不是合数，最小的质数是2\n\n\n最直观，但效率最低的写法\n\n这里特殊处理了一下小于等于3的数，因为小于等于3的自然数只有2和3是质数。\n然后，我们只需要从2开始，一直到小于其自身，依次判断能否被n整除即可，能够整除则不是质数，否则是质数。\n1234567891011public static boolean isPrime(int n)&#123;    if (n &lt;= 3) &#123;        return n &gt; 1;    &#125;    for(int i = 2; i &lt; n; i++)&#123;        if (n % i == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n优化\n\n我们继续分析，其实质数还有一个特点，就是它总是等于 6x-1 或者 6x+1，其中 x 是大于等于1的自然数。\n如何论证这个结论呢，其实不难。首先 6x 肯定不是质数，因为它能被 6 整除；其次 6x+2 肯定也不是质数，因为它还能被2整除；依次类推，6x+3 肯定能被 3 整除；6x+4 肯定能被 2 整除。那么，就只有 6x+1 和 6x+5 (即等同于6x-1) 可能是质数了。所以循环的步长可以设为 6，然后每次只判断 6 两侧的数即可。\n12345678910111213141516public static boolean isPrime(int num) &#123;    if (num &lt;= 3) &#123;        return num &gt; 1;    &#125;     不在6的倍数两侧的一定不是质数    if (num % 6 != 1 &amp;&amp; num % 6 != 5) &#123;        return false;    &#125;    int sqrt = (int) Math.sqrt(num);    for (int i = 5; i &lt;= sqrt; i += 6) &#123;        if (num % i == 0 || num % (i + 2) == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n性能对比\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        Stack&lt;Integer&gt; a = new Stack&lt;&gt;(), b = new Stack&lt;&gt;();        int n = 100000;        long s = System.currentTimeMillis(), e;        for (int i = 1; i &lt; n; i++) &#123;            if (f(i))                a.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        s = System.currentTimeMillis();        for (int i = 1; i &lt; n; i++) &#123;            if (func(i))                b.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        System.gc();    &#125;    static boolean f(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        for (int i = 2; i &lt; n; i++) &#123;            if (n % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;    static boolean func(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        if (n % 6 != 1 &amp;&amp; n % 6 != 5) &#123;            return false;        &#125;        int tem = (int) Math.sqrt(n);        for (int i = 5; i &lt;= tem; i += 6) &#123;            if (n % i == 0 || n % (i + 2) == 0)                return false;        &#125;        return true;    &#125;&#125;\n\n121392 ms5 ms","author":"times","tags":["编程","Java","素数"],"path":"2019/09/06/判断素数/","external_link":""},{"title":"天平砝码摆放问题","date":"2019-09-02T04:41:41.000Z","content":"题目一个天平上有6个位置，左右各三个位置，有6个砝码，分别是1、2、3、4、5、6克重。要使天平平衡，有多少种方法？（对称摆放算作一种方法） \n\n题解暴力求解\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    int t = 6;    int count = 0;    vector&lt;string&gt; v;    for (int i = 1; i &lt;= t; ++i) &#123;        for (int j = 1; j &lt;= t; ++j) &#123;            for (int k = 1; k &lt;= t; ++k) &#123;                for (int l = 1; l &lt;= t; ++l) &#123;                    for (int m = 1; m &lt;= t; ++m) &#123;                        for (int n = 1; n &lt;= t; ++n) &#123;                            if (i == j ||                                i == k || j == k ||                                i == l || j == l || k == l ||                                i == m || j == m || k == m || l == m ||                                i == n || j == n || k == n || l == n || m == n)                                continue;                            if ((3 * i + 2 * j + k) == (l + 2 * m + 3 * n)) &#123;                                string s = to_string(i) + to_string(j) + to_string(k) + to_string(l) + to_string(m) +                                           to_string(n);                                int te = 0;                                if (v.size() &gt; 0) &#123;                                    string tem = s;                                    reverse(tem.begin(), tem.end());                                    vector&lt;string&gt;::iterator it;                                    for (it = v.begin(); it != v.end(); it++) &#123;                                        if (*it == tem) &#123;                                            cout&lt;&lt;tem&lt;&lt;endl;                                            te = 1;                                            break;                                        &#125;                                    &#125;                                &#125;                                if (te == 0) &#123;                                    v.push_back(s);                                    count++;                                    printf( %d %d %d | %d %d %dn, i, j, k, l, m, n);                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;    return 0;&#125;\n\n1234567891011121314151617181 4 6 | 5 3 21 5 6 | 2 4 31 5 6 | 3 2 41 6 4 | 3 5 21 6 5 | 2 3 42 4 6 | 1 5 32 4 6 | 3 1 52 6 3 | 4 1 52 6 4 | 1 3 53 2 6 | 5 1 43 4 5 | 2 1 63 5 4 | 1 2 63 6 2 | 1 5 44 2 6 | 1 3 54 3 5 | 1 2 65 2 4 | 3 1 65 4 2 | 1 3 617","tags":["算法","天平","暴力破解"],"path":"2019/09/02/天平砝码摆放问题/","external_link":""},{"title":"技术栈","date":"2019-08-18T15:30:34.000Z","content":"\nHTML  CSS\n【HTML】HTML，即超文本标记语言（Hyper Text Markup Language）\n【HTML5】HTML5 是下一代 HTML 标准\n【CSS】层叠样式表（Cascading StyleSheet）\n【CSS3】CSS3是CSS技术的升级版本\n【Bootstrap3】Bootstrap，来自 Twitter，是目前最受欢迎的前端框架\n【Bootstrap4】Bootstrap4 目前是 Bootstrap 的最新版本\n【Font Awesome】Font Awesome 是一套绝佳的图标字体库和CSS框架。\n【Foundation】Foundation 用于开发响应式的 HTML, CSS and JavaScript 框架JavaScript\n【JavaScript】JavaScript 是 Web 的编程语言\n【HTML DOM】HTML DOM 定义了访问和操作 HTML 文档的标准方法\n【jQuery】jQuery 是一个 JavaScript 库\n【AngularJS】AngularJS 通过新的属性和表达式扩展了 HTML\n【AngularJS2】AngularJS2 是一款开源JavaScript库，由Google维护。\n【Vue.js】Vue.js 是一套构建用户界面的渐进式框架。\n【React】React 是一个用于构建用户界面的 JAVASCRIPT 库\n【TypeScript】TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准\n【jQuery UI】jQuery UI 是建立在 jQuery上的一组用户界面交互、特效、小部件及主题\n【jQuery EasyUI 】jQuery EasyUI 是一个基于 jQuery 的框架，集成了各种用户界面插件\n【Node.js】Node.js 是运行在服务端的 JavaScript\n【AJAX】AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n【JSON】JSON 是存储和交换文本信息的语法\n【Highcharts】Highcharts 是一个用纯JavaScript编写的一个图表库\n【Google 地图】Google 地图接口使用说明\n\n服务端\n【PHP】PHP 是一种通用开源脚本语言\n【Python】Python 是一种面向对象、解释型计算机程序设计语言\n【Python3】Python 升级版，变化较大\n【Django】Django是一个开放源代码的Web应用框架，由Python写成\n【Linux】Linux是一套免费使用和自由传播的类Unix操作系统\n【Docker】Docker 是一个开源的应用容器引擎，基于 Go 语言\n【Ruby】一种为简单快捷的面向对象编程（面向对象程序设计）而创的脚本语言\n【Java】一种可以撰写跨平台应用软件的面向对象的程序设计语言\n【C】一门通用计算机编程语言\n【C++】C++是在C语言的基础上开发的一种通用编程语言\n【Perl】Perl 是高级、通用、直译式、动态的程序语言\n【Servlet 】运行在 Web 服务器或应用服务器上的程序\n【JSP】JSP与PHP、ASP、ASP.NET等语言类似，运行在服务端的语言\n【Lua】Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放\n【Scala】Scala 是一门多范式（multi-paradigm）的编程语言。\n【Go】Go语言是谷歌推出的一种全新的编程语言\n【设计模式】设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用\n【正则表达式】正则表达式是对字符串操作的一种逻辑公式\n【Maven】Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n【NumPy】NumPy 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算。\n【ASP】ASP（Active Server Pages 动态服务器页面）是一种生成动态交互性网页的强有力工具\n【AppML】AppML 是一个为web应用程序设计的HTML扩展框\n【VBScript】一种微软环境下的轻量级的解释型语言\n\n数据库\n【SQL】结构化查询语言(Structured Query Language)\n【Mysql】MySQL是一个关系型数据库管理系统\n【PostgreSQL】PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)\n【SQLite】一款轻型的数据库\n【MongoDB】Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql)\n【Redis】一个高性能的key-value数据库\n【Memcached】Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。\n\n移动端\n【Android】Android 是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备\n【Swift】Swift 是一种支持多编程范式和编译式的编程语言,用于开发 iOS，OS X 和 watchOS应用程序。\n【jQuery Mobile】jQuery Mobile是jQuery 在手机上和平板设备上的版本\n【ionic】ionic 是一个强大的 HTML5 应用程序开发框架(HTML5 Hybrid Mobile App Framework )\n【Kotlin】在 Java 虚拟机上运行的静态类型编程语言，Android 官方开发语言\n\nXML 教程\n【XML】XML 被设计用来传输和存储数据\n【DTD】DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块\n【XML DOM】XML DOM 定义访问和操作XML文档的标准方法\n【XSLT】XSL 是一个 XML 文档的样式表语言，XSLT 指 XSL 转换\n【XPath】XPath 是一门在 XML 文档中查找信息的语言\n【XQuery】XQuery 被设计用来查询 XML 数据\n【XLink】XLink 定义在 XML 文档中创建超级链接的标准方法\n【XPointer】XPointer是在可扩展标志语言（XML）文件中定位数据的一种语言\n【XML Schema】XML Schema 描述了 XML文档的结构\n【XSL-FO】XSL-FO 指可扩展样式表语言格式化对象\n【SVG】SVG 使用 XML 格式定义图像\n\nASP.NET\n【ASP.NET】ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架\n【C#】C# 是一个简单的、现代的、通用的、面向对象的编程语言\n【Web Pages】Web Pages 是三种网页编程模型中的一种，用于创建网站和web 应用程序\n【Razor】Razor 是一种标记语法，可以让您将基于服务器的代码（Visual Basic 和 C#）嵌入到网页中\n【MVC】MVC（Model View Controller 模型-视图-控制器）\n【Web Forms】Web Forms 是三种创建 ASP.NET 网站和 Web 应用程序的编程模式中的一种\n\nWeb Service\n【Web Service】Web Service 脚本平台需支持 XML + HTTP\n【WSDL】WSDL是一门基于 XML 的语言，用于描述 Web Service 以及如何对它们进行访问\n【SOAP】SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息\n【RSS】RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议\n【RDF】DF(资源描述框架)是描述网络资源的 W3C 标准\n\n开发工具\n【Eclipse】Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台\n【Git】Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目\n【Svn】SVN 是一个开放源代码的版本控制系统\n【Markdown】Markdown 是一种轻量级标记语\n\n网站建设\n【HTTP】HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议\n【网站建设指南】网站建设指导课程\n【浏览器信息】对于网站开发人员来说，浏览器信息和统计数据都是非常重要的\n【网站主机教程】如果您希望向全世界发布自己的网站，那么您的网站就需要被放置于一个 WEB 服务器\n【TCPIP】TCPIP 是因特网的通信协议\n【W3C】W3C 让每个人都能在互联网上分享资源\n【网站品质】何创建高质量的web网站\n\n菜鸟教程\n","tags":["文章","编程"],"path":"2019/08/18/技术栈/","external_link":""},{"title":"树的高度（小米2017秋招真题）","date":"2019-09-05T08:08:46.000Z","content":"\n树的高度（小米2017秋招真题）题目题目描述\n现在有一棵合法的二叉树，树的节点都是用数字表示，现在给定这棵树上所有的父子关系，求这棵树的高度\n时间限制CC++语言：1000MS 其它语言：3000MS\n内存限制CC++语言：65536KB 其它语言：589824KB\n输入\n输入的第一行表示节点的个数n（1&lt;=n&lt;=1000，节点的编号为0到n-1）组成，下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号\n输出\n输出树的高度，为一个整数\n样例输入\n1234550 10 21 31 4\n\n样例输出\n13\n\n题解java\n1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] parent = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            parent[i] = -1;        &#125;        for (int i = 0; i &lt; n - 1; i++) &#123;            int a = sc.nextInt();            int b = sc.nextInt();            parent[b] = a;        &#125;        int h = 0;        for (int i = 0; i &lt; n; i++) &#123;            int max = 1;            int j = i;            while (parent[j] != -1) &#123;                j = parent[j];                max++;            &#125;            h = max &gt; h ? max : h;        &#125;        System.out.println(h);    &#125;&#125;\n\npython\n1234567891011121314import sysdef get(x):    try:        return 1 + get(dic_s[x])    except KeyError:        return 1n = int(sys.stdin.readline().strip())dic_s = &#123;&#125;for i in range(int(n)-1):    j_1,j_2 = sys.stdin.readline().strip().split()    dic_s[j_2] = j_1print max([get(i) for i in set(dic_s.keys()) - set(dic_s.values())]) if n&gt;1 else 1\n\njavascript\n12345678910111213141516var n=readInt(),rec=&#123;&#125;,dps=&#123;&#125;,rs=1while(n--&gt;1) &#123;  var a=readInt(),b=readInt()  rec[a]=rec[a]||[]  rec[a].push(b)&#125;for(var k in rec) rs=Math.max(rs,maxDps(k))print(rs)function maxDps(n)&#123;  if(!rec[n]) return 1  if(dps[n]) return dps[n]  var r=1  for(var x of rec[n]) r=Math.max(r,maxDps(x)+1)  dps[n]=r  return dps[n]&#125;\n\n","tags":["算法","树","二叉树"],"path":"2019/09/05/树的高度（小米2017秋招真题）/","external_link":""},{"title":"深入理解Node.js 中的进程与线程","date":"2019-09-05T13:26:58.000Z","content":"\n前言进程与线程是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解进程与线程，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用。\n面试会问\nNode.js是单线程吗？\n\n\nNode.js 做耗时的计算时候，如何避免阻塞？\n\n\nNode.js如何实现多进程的开启和关闭？\n\n\nNode.js可以创建线程吗？\n\n\n你们开发过程中如何实现进程守护的？\n\n\n除了使用第三方模块，你们自己是否封装过一个多进程架构?\n\n进程进程Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。\n1234567const http = require(http);const server = http.createServer();server.listen(3000,()=&gt;&#123;    process.title=程序员成长指北测试进程;    console.log(进程id,process.pid)&#125;)\n\n运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663\n线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。\n单线程单线程就是一个进程只开一个线程\nJavascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。\n123456789101112131415161718192021222324const http = require(http);const longComputation = () =&gt; &#123;  let sum = 0;  for (let i = 0; i &lt; 1e10; i++) &#123;    sum += i;  &#125;;  return sum;&#125;;const server = http.createServer();server.on(request, (req, res) =&gt; &#123;  if (req.url === compute) &#123;    console.info(计算开始,new Date());    const sum = longComputation();    console.info(计算结束,new Date());    return res.end(`Sum is $&#123;sum&#125;`);  &#125; else &#123;    res.end(Ok)  &#125;&#125;);server.listen(3000);打印结果计算开始 2019-07-28T07:08:49.849Z计算结束 2019-07-28T07:09:04.522Z\n\n查看打印结果，当我们调用127.0.0.1:3000compute的时候，如果想要调用其他的路由地址比如127.0.0.1大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。\n单线程的一些说明\n\nNode.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。\n当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。\nNode.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。\n单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。\n\n","tags":["Nodejs"],"path":"2019/09/05/深入理解Node-js-中的进程与线程/","external_link":""},{"title":"面试红黑树","date":"2019-09-08T02:43:14.000Z","content":"什么是红黑树红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。\n它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。\n由于 TreeMap 就是由红黑树实现的，因此本文将使用 TreeMap 的相关操作的代码进行分析、论证。\n黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。\n红黑树的 5 个特性\n红黑树在原有的二叉查找树基础上增加了如下几个要求：\n\nEvery node is either red or black.\nThe root is black.\nEvery leaf (NIL) is black.\nIf a node is red, then both its children are black.\nFor each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\n中文意思是：\n\n每个节点要么是红色，要么是黑色；\n根节点永远是黑色的；\n所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；\n每个红色节点的两个子节点一定都是黑色；\n从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；\n\n注意：性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。\n性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。\n性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。\n红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。\n红黑树的左旋右旋\n红黑树的左右旋是比较重要的操作，左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。\n比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。\n我们以 Java 集合框架中的 TreeMap 中的代码来看下左右旋的具体操作方法：\n指定节点 x 的左旋 (右图转成左图)：\n123456789101112131415161718 这里 p 代表 xprivate void rotateLeft(Entry p) &#123;    if (p != null) &#123;        Entry r = p.right;  p 是上图中的 x，r 就是 y        p.right = r.left;        左旋后，x 的右子树变成了 y 的左子树 β         if (r.left != null)                     r.left.parent = p;  β 确认父亲为 x        r.parent = p.parent;        y 取代 x 的第一步：认 x 的父亲为爹        if (p.parent == null)       要是 x 没有父亲，那 y 就是最老的根节点            root = r;        else if (p.parent.left == p) 如果 x 有父亲并且是它父亲的左孩子，x 的父亲现在认 y 为左孩子，不要 x 了            p.parent.left = r;        else                            如果 x 是父亲的右孩子，父亲就认 y 为右孩子，抛弃 x            p.parent.right = r;        r.left = p;     y 逆袭成功，以前的爸爸 x 现在成了它的左孩子        p.parent = r;    &#125;&#125;\n\n可以看到，x 节点的左旋就是把 x 变成 右孩子 y 的左孩子，同时把 y 的左孩子送给 x 当右子树。\n简单点记就是：左旋把右子树里的一个节点（上图 β）移动到了左子树。\n指定节点 y 的右旋（左图转成右图）：\n123456789101112131415private void rotateRight(Entry p) &#123;    if (p != null) &#123;        Entry l = p.left;        p.left = l.right;        if (l.right != null) l.right.parent = p;        l.parent = p.parent;        if (p.parent == null)            root = l;        else if (p.parent.right == p)            p.parent.right = l;        else p.parent.left = l;        l.right = p;        p.parent = l;    &#125;&#125;\n\n同理，y 节点的右旋就是把 y 变成 左孩子 x 的右孩子，同时把 x 的右孩子送给 x 当左子树。\n简单点记就是：右旋把左子树里的一个节点（上图 β）移动到了右子树。\n了解左旋、右旋的方法及意义后，就可以了解红黑树的主要操作：插入、删除。\n总结红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。\n红黑树的插入、删除调整逻辑比较复杂，但最终目的是满足红黑树的 5 个特性，尤其是 4 和 5。\n在插入调整时为了简化操作我们直接把插入的节点涂成红色，这样只要保证插入节点的父节点不是红色就可以了。\n而在删除后的调整中，针对删除黑色节点，所在子树缺少一个节点，需要进行弥补或者对别人造成一个黑色节点的伤害。具体调整方法取决于兄弟节点所在子树的情况。\n红黑树的插入、删除在树形数据结构中算比较复杂的，理解起来比较难，但只要记住，红黑树有其特殊的平衡规则，而我们为了维持平衡，根据邻树的状况进行旋转或者涂色。\n红黑树这么难理解，必定有其过人之处。它的有序、快速特性在很多场景下都有用到，比如 Java 集合框架的 TreeMap, TreeSet 等。\n","tags":["算法","面试","红黑树"],"path":"2019/09/08/面试红黑树/","external_link":""},{"title":"狂野飙车9","date":"2019-09-04T18:19:56.000Z","content":"兰博基尼\n法拉利\n布加迪\n迈凯伦\n兰博基尼\n风神\n","tags":["狂野飙车","跑车"],"path":"2019/09/05/狂野飙车9/","external_link":""},{"title":"Airbnb JavaScript 代码规范() {","date":"2019-09-08T02:51:27.000Z","content":"Airbnb JavaScript 代码规范() {一种写JavaScript更合理的代码风格。\n\nNote: 本指南假设你使用了 Babel, 并且要求你使用 babel-preset-airbnb 或者其他同等资源。 并且假设你在你的应用中安装了 shimspolyfills ，使用airbnb-browser-shims 或者相同功能。\n\n\n\n\n其他代码风格指南\n\nES5 (Deprecated)\nReact\nCSS-in-JavaScript\nCSS &amp; Sass\nRuby\n\n目录\n类型\n引用\n对象\n数组\n解构\n字符\n方法\n箭头函数\n类和构造器\n模块\n迭代器和发生器\n属性\n变量\n提升\n比较运算符和等号\n块\n控制语句\n注释\n空白\n逗号\n分号\n类型转换和强制类型转换\n命名规范\n存取器\n事件\njQuery\nECMAScript 5 兼容性\nECMAScript 6+ (ES 2015+) 风格\n标准库\n测试\n性能\n资源\nJavaScript风格指南的指南\n许可证\n修正案\n\n类型  \n\n1.1 原始值: 当你访问一个原始类型的时候，你可以直接使用它的值。\n\nstring\nnumber\nboolean\nnull\nundefined\nsymbol\n\n123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar);  =&gt; 1, 9\n\n\nSymbols cannot be faithfully polyfilled, so they should not be used when targeting browsersenvironments that don’t support them natively.\n\n\n\n1.2  复杂类型: 当你访问一个复杂类型的时候，你需要一个值得引用。\n\nobject\narray\nfunction\n\n123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]);  =&gt; 9, 9\n\n\n\n⬆ 返回目录\n引用  \n\n2.1 使用 const 定义你的所有引用；避免使用 var。 eslint: prefer-const, no-const-assign\n\n为什么? 这样能够确保你不能从新分配你的引用，否则可能导致错误或者产生难以理解的代码。.\n\n1234567 badvar a = 1;var b = 2; goodconst a = 1;const b = 2;\n\n\n\n2.2 如果你必须重新分配你的引用， 使用 let 代替 var。 eslint: no-var\n\n为什么? let 是块级作用域，而不像 var 是函数作用域.\n\n1234567891011 badvar count = 1;if (true) &#123;  count += 1;&#125; good, use the let.let count = 1;if (true) &#123;  count += 1;&#125;\n\n\n\n2.3 注意，let 和 const 都是块级范围的。\n1234567 const 和 let 只存在于他们定义的块中。&#123;  let a = 1;  const b = 1;&#125;console.log(a);  ReferenceErrorconsole.log(b);  ReferenceError\n\n\n\n⬆ 返回目录\n对象  \n\n3.1 使用字面语法来创建对象。 eslint: no-new-object\n12345 badconst item = new Object(); goodconst item = &#123;&#125;;\n\n\n\n3.2 在创建具有动态属性名称的对象时使用计算属性名。\n\n为什么? 它允许你在一个地方定义对象的所有属性。\n\n123456789101112131415161718function getKey(k) &#123;  return `a key named $&#123;k&#125;`;&#125; badconst obj = &#123;  id: 5,  name: San Francisco,&#125;;obj[getKey(enabled)] = true; goodconst obj = &#123;  id: 5,  name: San Francisco,  [getKey(enabled)]: true,&#125;;\n\n\n\n3.3 使用对象方法的缩写。 eslint: object-shorthand\n1234567891011121314151617 badconst atom = &#123;  value: 1,  addValue: function (value) &#123;    return atom.value + value;  &#125;,&#125;; goodconst atom = &#123;  value: 1,  addValue(value) &#123;    return atom.value + value;  &#125;,&#125;;\n\n\n\n3.4 使用属性值的缩写。 eslint: object-shorthand\n\n为什么? 它的写法和描述较短。\n\n1234567891011const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  lukeSkywalker: lukeSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,&#125;;\n\n\n\n3.5 在对象声明的时候将简写的属性进行分组。\n\n为什么? 这样更容易的判断哪些属性使用的简写。\n\n12345678910111213141516171819202122const anakinSkywalker = Anakin Skywalker;const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  episodeOne: 1,  twoJediWalkIntoACantina: 2,  lukeSkywalker,  episodeThree: 3,  mayTheFourth: 4,  anakinSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,  anakinSkywalker,  episodeOne: 1,  twoJediWalkIntoACantina: 2,  episodeThree: 3,  mayTheFourth: 4,&#125;;\n\n\n\n3.6 只使用引号标注无效标识符的属性。 eslint: quote-props\n\n为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。\n\n12345678910111213 badconst bad = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;; goodconst good = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;;\n\n\n\n3.7 不能直接调用 Object.prototype 的方法，如： hasOwnProperty 、 propertyIsEnumerable 和 isPrototypeOf。\n\n为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 { hasOwnProperty: false } - 或者，对象是一个空对象 (Object.create(null))。\n\n123456789101112 badconsole.log(object.hasOwnProperty(key)); goodconsole.log(Object.prototype.hasOwnProperty.call(object, key)); bestconst has = Object.prototype.hasOwnProperty;  在模块范围内的缓存中查找一次* or *import has from has;  https:www.npmjs.compackagehas ...console.log(has.call(object, key));\n\n\n\n3.8 更喜欢对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n1234567891011121314 very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;);  变异的 `original` ಠ_ಠdelete copy.a;  这.... badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;);  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125; goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;;  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy;  noA =&gt; &#123; b: 2, c: 3 &#125;\n\n\n\n⬆ 返回目录\n数组  \n\n4.1 使用字面语法创建数组。 eslint: no-array-constructor\n12345 badconst items = new Array(); goodconst items = [];\n\n\n\n4.2 使用 Array#push 取代直接赋值来给数组添加项。\n1234567const someStack = []; badsomeStack[someStack.length] = abracadabra; goodsomeStack.push(abracadabra);\n\n\n\n4.3 使用数组展开方法 ... 来拷贝数组。\n1234567891011 badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) &#123;  itemsCopy[i] = items[i];&#125; goodconst itemsCopy = [...items];\n\n\n\n4.4 将一个类数组对象转换成一个数组， 使用展开方法 ... 代替 Array.from。\n1234567const foo = document.querySelectorAll(.foo); goodconst nodes = Array.from(foo); bestconst nodes = [...foo];\n\n\n\n4.5 对于对迭代器的映射，使用 Array.from 替代展开方法 ... ， 因为它避免了创建中间数组。\n12345 badconst baz = [...foo].map(bar); goodconst baz = Array.from(foo, bar);\n\n\n\n4.6 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 8.2。 eslint: array-callback-return\n1234567891011121314151617181920212223242526272829303132333435363738394041 good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map(x =&gt; x + 1); bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;&#125;); good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;  return flatten;&#125;); badinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125; else &#123;    return false;  &#125;&#125;); goodinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125;  return false;&#125;);\n\n\n\n4.7 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n12345678910111213141516171819202122232425262728293031 badconst arr = [  [0, 1], [2, 3], [4, 5],];const objectInArray = [&#123;  id: 1,&#125;, &#123;  id: 2,&#125;];const numberInArray = [  1, 2,]; goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [  &#123;    id: 1,  &#125;,  &#123;    id: 2,  &#125;,];const numberInArray = [  1,  2,];\n\n\n\n⬆ 返回目录\n解构  \n\n5.1 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: prefer-destructuring\n\n为什么? 解构可以避免为这些属性创建临时引用。\n\n123456789101112131415161718 badfunction getFullName(user) &#123;  const firstName = user.firstName;  const lastName = user.lastName;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; goodfunction getFullName(user) &#123;  const &#123; firstName, lastName &#125; = user;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;\n\n\n\n5.2 使用数组解构。 eslint: prefer-destructuring\n12345678const arr = [1, 2, 3, 4]; badconst first = arr[0];const second = arr[1]; goodconst [first, second] = arr;\n\n\n\n5.3 对于多个返回值使用对象解构，而不是数组解构。\n\n为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。\n\n1234567891011121314151617 badfunction processInput(input) &#123;   处理代码...  return [left, right, top, bottom];&#125; 调用者需要考虑返回数据的顺序。const [left, __, top] = processInput(input); goodfunction processInput(input) &#123;   处理代码...  return &#123; left, right, top, bottom &#125;;&#125; 调用者只选择他们需要的数据。const &#123; left, top &#125; = processInput(input);\n\n\n\n⬆ 返回目录\n字符  \n\n6.1 使用单引号 &#39;&#39; 定义字符串。 eslint: quotes\n12345678 badconst name = Capt. Janeway; bad - 模板文字应该包含插值或换行。const name = `Capt. Janeway`; goodconst name = Capt. Janeway;\n\n\n\n6.2 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n\n为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。\n\n12345678910111213 badconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.; badconst errorMessage = This is a super long error that was thrown because  +  of Batman. When you stop to think about how Batman had anything to do  +  with this, you would get nowhere fast.; goodconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.;\n\n\n\n6.3 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: prefer-template template-curly-spacing\n\n为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。\n\n12345678910111213141516171819 badfunction sayHi(name) &#123;  return How are you,  + name + ?;&#125; badfunction sayHi(name) &#123;  return [How are you, , name, ?].join();&#125; badfunction sayHi(name) &#123;  return `How are you, $&#123; name &#125;?`;&#125; goodfunction sayHi(name) &#123;  return `How are you, $&#123;name&#125;?`;&#125;\n\n\n\n6.4 不要在字符串上使用 eval() ，它打开了太多漏洞。 eslint: no-eval\n\n\n6.5 不要转义字符串中不必要的字符。 eslint: no-useless-escape\n\n为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。\n\n123456 badconst foo = this is quoted; goodconst foo = this is quoted;const foo = `my name is $&#123;name&#125;`;\n\n\n\n⬆ 返回目录\n方法  \n\n7.1 使用命名的函数表达式代替函数声明。 eslint: func-style\n\n为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (Discussion)\n\n123456789101112131415 badfunction foo() &#123;   ...&#125; badconst foo = function () &#123;   ...&#125;; good 从变量引用调用中区分的词汇名称const short = function longUniqueMoreDescriptiveLexicalFoo() &#123;   ...&#125;;\n\n\n\n7.2 Wrap立即调用函数表达式。 eslint: wrap-iife\n\n为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。\n\n1234 immediately-invoked function expression (IIFE) 立即调用的函数表达式(function () &#123;  console.log(Welcome to the Internet. Please follow me.);&#125;());\n\n\n\n7.3 切记不要在非功能块中声明函数 (if, while, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: no-loop-func\n\n\n7.4 注意: ECMA-262 将 block 定义为语句列表。 函数声明不是语句。\n1234567891011121314 badif (currentUser) &#123;  function test() &#123;    console.log(Nope.);  &#125;&#125; goodlet test;if (currentUser) &#123;  test = () =&gt; &#123;    console.log(Yup.);  &#125;;&#125;\n\n\n\n7.5 永远不要定义一个参数为 arguments。 这将会优先于每个函数给定范围的 arguments 对象。\n123456789 badfunction foo(name, options, arguments) &#123;   ...&#125; goodfunction foo(name, options, args) &#123;   ...&#125;\n\n\n\n7.6 不要使用 arguments, 选择使用 rest 语法 ... 代替。 eslint: prefer-rest-params\n\n为什么? ... 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 arguments 。\n\n12345678910 badfunction concatenateAll() &#123;  const args = Array.prototype.slice.call(arguments);  return args.join();&#125; goodfunction concatenateAll(...args) &#123;  return args.join();&#125;\n\n\n\n7.7 使用默认的参数语法，而不是改变函数参数。\n123456789101112131415161718192021 really badfunction handleThings(opts) &#123;   No! We shouldn’t mutate function arguments.   Double bad: if opts is falsy itll be set to an object which may   be what you want but it can introduce subtle bugs.  opts = opts || &#123;&#125;;   ...&#125; still badfunction handleThings(opts) &#123;  if (opts === void 0) &#123;    opts = &#123;&#125;;  &#125;   ...&#125; goodfunction handleThings(opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.8 避免使用默认参数的副作用。\n\n为什么? 他们很容易混淆。\n\n123456789var b = 1; badfunction count(a = b++) &#123;  console.log(a);&#125;count();   1count();   2count(3);  3count();   3\n\n\n\n7.9 总是把默认参数放在最后。\n123456789 badfunction handleThings(opts = &#123;&#125;, name) &#123;   ...&#125; goodfunction handleThings(name, opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.10 永远不要使用函数构造器来创建一个新函数。 eslint: no-new-func\n\n为什么? 以这种方式创建一个函数将对一个类似于 eval() 的字符串进行计算，这将打开漏洞。\n\n12345 badvar add = new Function(a, b, return a + b); still badvar subtract = Function(a, b, return a - b);\n\n\n\n7.11 函数签名中的间距。 eslint: space-before-function-paren space-before-blocks\n\n为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。\n\n12345678 badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;; goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;;\n\n\n\n7.12 没用变异参数。 eslint: no-param-reassign\n\n为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。\n\n123456789 badfunction f1(obj) &#123;  obj.key = 1;&#125; goodfunction f2(obj) &#123;  const key = Object.prototype.hasOwnProperty.call(obj, key) ? obj.key : 1;&#125;\n\n\n\n7.13 不要再分配参数。 eslint: no-param-reassign\n\n为什么? 重新分配参数会导致意外的行为，尤其是在访问 arguments 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。\n\n1234567891011121314151617181920 badfunction f1(a) &#123;  a = 1;   ...&#125;function f2(a) &#123;  if (!a) &#123; a = 1; &#125;   ...&#125; goodfunction f3(a) &#123;  const b = a || 1;   ...&#125;function f4(a = 1) &#123;   ...&#125;\n\n\n\n7.14 优先使用扩展运算符 ... 来调用可变参数函数。 eslint: prefer-spread\n\n为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 apply 来 new 。\n\n12345678910111213 badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x); goodconst x = [1, 2, 3, 4, 5];console.log(...x); badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5])); goodnew Date(...[2016, 8, 5]);\n\n\n\n7.15 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: function-paren-newline\n123456789101112131415161718192021222324252627 badfunction foo(bar,             baz,             quux) &#123;   ...&#125; goodfunction foo(  bar,  baz,  quux,) &#123;   ...&#125; badconsole.log(foo,  bar,  baz); goodconsole.log(  foo,  bar,  baz,);\n\n\n\n⬆ 返回目录\n箭头函数  \n\n8.1 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: prefer-arrow-callback, arrow-spacing\n\n为什么? 它创建了一个在 this 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。\n\n\n为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。\n\n1234567891011 bad[1, 2, 3].map(function (x) &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.2 如果函数体包含一个单独的语句，返回一个没有副作用的 expression ， 省略括号并使用隐式返回。否则，保留括号并使用 return 语句。 eslint: arrow-parens, arrow-body-style\n\n为什么? 语法糖。 多个函数被链接在一起时，提高可读性。\n\n12345678910111213141516171819202122232425262728293031323334353637 bad[1, 2, 3].map(number =&gt; &#123;  const nextNumber = number + 1;  `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`); good[1, 2, 3].map((number) =&gt; &#123;  const nextNumber = number + 1;  return `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map((number, index) =&gt; (&#123;  [index]: number,&#125;)); 没有副作用的隐式返回function foo(callback) &#123;  const val = callback();  if (val === true) &#123;     如果回调返回 true 执行  &#125;&#125;let bool = false; badfoo(() =&gt; bool = true); goodfoo(() =&gt; &#123;  bool = true;&#125;);\n\n\n\n8.3 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n\n为什么? 它清楚地显示了函数的起点和终点。\n\n1234567891011121314 bad[get, post, put].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )); good[get, post, put].map(httpMethod =&gt; (  Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )));\n\n\n\n8.4 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 “always” option 来配置 eslint. eslint: arrow-parens\n\n为什么? 减少视觉上的混乱。\n\n12345678910111213141516171819202122 bad[1, 2, 3].map((x) =&gt; x * x); good[1, 2, 3].map(x =&gt; x * x); good[1, 2, 3].map(number =&gt; (  `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`)); bad[1, 2, 3].map(x =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.5 避免箭头函数符号 (=&gt;) 和比较运算符 (&lt;=, &gt;=) 的混淆。 eslint: no-confusing-arrow\n1234567891011121314 badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize); goodconst itemHeight = (item) =&gt; &#123;  const &#123; height, largeSize, smallSize &#125; = item;  return height &gt; 256 ? largeSize : smallSize;&#125;;\n\n\n\n8.6 注意带有隐式返回的箭头函数函数体的位置。 eslint: implicit-arrow-linebreak\n12345678910111213 bad(foo) =&gt;  bar;(foo) =&gt;  (bar); good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; (   bar)\n\n\n\n⬆ 返回目录\n类和构造器  \n\n9.1 尽量使用 class. 避免直接操作 prototype .\n\n为什么? class 语法更简洁，更容易推理。\n\n123456789101112131415161718192021 badfunction Queue(contents = []) &#123;  this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123;  const value = this.queue[0];  this.queue.splice(0, 1);  return value;&#125;; goodclass Queue &#123;  constructor(contents = []) &#123;    this.queue = [...contents];  &#125;  pop() &#123;    const value = this.queue[0];    this.queue.splice(0, 1);    return value;  &#125;&#125;\n\n\n\n9.2 使用 extends 来扩展继承。\n\n为什么? 它是一个内置的方法，可以在不破坏 instanceof 的情况下继承原型功能。\n\n12345678910111213141516 badconst inherits = require(inherits);function PeekableQueue(contents) &#123;  Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123;  return this.queue[0];&#125;; goodclass PeekableQueue extends Queue &#123;  peek() &#123;    return this.queue[0];  &#125;&#125;\n\n\n\n9.3 方法返回了 this 来供其内部方法调用。\n12345678910111213141516171819202122232425262728293031 badJedi.prototype.jump = function () &#123;  this.jumping = true;  return true;&#125;;Jedi.prototype.setHeight = function (height) &#123;  this.height = height;&#125;;const luke = new Jedi();luke.jump();  =&gt; trueluke.setHeight(20);  =&gt; undefined goodclass Jedi &#123;  jump() &#123;    this.jumping = true;    return this;  &#125;  setHeight(height) &#123;    this.height = height;    return this;  &#125;&#125;const luke = new Jedi();luke.jump()  .setHeight(20);\n\n\n\n9.4 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 toString() 方法也是可以的。\n12345678910111213class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    this.name = options.name || no name;  &#125;  getName() &#123;    return this.name;  &#125;  toString() &#123;    return `Jedi - $&#123;this.getName()&#125;`;  &#125;&#125;\n\n\n\n9.5 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: no-useless-constructor\n1234567891011121314151617181920212223 badclass Jedi &#123;  constructor() &#123;&#125;  getName() &#123;    return this.name;  &#125;&#125; badclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125; goodclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);    this.name = Rey;  &#125;&#125;\n\n\n\n9.6 避免定义重复的类成员。 eslint: no-dupe-class-members\n\n为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。\n\n123456789101112131415 badclass Foo &#123;  bar() &#123; return 1; &#125;  bar() &#123; return 2; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 1; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 2; &#125;&#125;\n\n\n\n⬆ 返回目录\n模块  \n\n10.1 你可能经常使用模块 (importexport) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n\n为什么? 模块是未来的趋势，让我们拥抱未来。\n\n1234567891011 badconst AirbnbStyleGuide = require(.AirbnbStyleGuide);module.exports = AirbnbStyleGuide.es6; okimport AirbnbStyleGuide from .AirbnbStyleGuide;export default AirbnbStyleGuide.es6; bestimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.2 不要使用通配符导入。\n\n为什么? 这确定你有一个单独的默认导出。\n\n12345 badimport * as AirbnbStyleGuide from .AirbnbStyleGuide; goodimport AirbnbStyleGuide from .AirbnbStyleGuide;\n\n\n\n10.3 不要直接从导入导出。\n\n为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。\n\n12345678 bad filename es6.jsexport &#123; es6 as default &#125; from .AirbnbStyleGuide; good filename es6.jsimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.4 只从一个路径导入所有需要的东西。eslint: no-duplicate-imports\n\n为什么? 从同一个路径导入多个行，使代码更难以维护。\n\n12345678910111213 badimport foo from foo; … 其他导入 … import &#123; named1, named2 &#125; from foo; goodimport foo, &#123; named1, named2 &#125; from foo; goodimport foo, &#123;  named1,  named2,&#125; from foo;\n\n\n\n10.5 不要导出可变的引用。eslint: importno-mutable-exports\n\n为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。\n\n1234567 badlet foo = 3;export &#123; foo &#125;; goodconst foo = 3;export &#123; foo &#125;;\n\n\n\n10.6 在单个导出的模块中，选择默认模块而不是指定的导出。eslint: importprefer-default-export\n\n为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。\n\n12345 badexport function foo() &#123;&#125; goodexport default function foo() &#123;&#125;\n\n\n\n10.7 将所有的 imports 语句放在所有非导入语句的上边。eslint: importfirst\n\n为什么? 由于所有的 imports 都被提前，保持他们在顶部是为了防止意外发生。\n\n1234567891011 badimport foo from foo;foo.init();import bar from bar; goodimport foo from foo;import bar from bar;foo.init();\n\n\n\n10.8 多行导入应该像多行数组和对象一样缩进。\n\n为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。\n\n1234567891011 badimport &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from path; goodimport &#123;  longNameA,  longNameB,  longNameC,  longNameD,  longNameE,&#125; from path;\n\n\n\n10.9 在模块导入语句中禁止使用 Webpack 加载器语法。eslint: importno-webpack-loader-syntax\n\n为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 webpack.config.js 中使用加载器语法。\n\n1234567 badimport fooSass from css!sass!foo.scss;import barCss from style!css!bar.css; goodimport fooSass from foo.scss;import barCss from bar.css;\n\n\n\n⬆ 返回目录\n迭代器和发生器  \n\n11.1 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of。 eslint: no-iterator no-restricted-syntax\n\n为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。\n\n\n使用 map()  every()  filter()  find()  findIndex()  reduce()  some()  … 遍历数组， 和使用 Object.keys()  Object.values()  Object.entries() 迭代你的对象生成数组。\n\n12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5]; badlet sum = 0;for (let num of numbers) &#123;  sum += num;&#125;sum === 15; goodlet sum = 0;numbers.forEach((num) =&gt; &#123;  sum += num;&#125;);sum === 15; best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) &#123;  increasedByOne.push(numbers[i] + 1);&#125; goodconst increasedByOne = [];numbers.forEach((num) =&gt; &#123;  increasedByOne.push(num + 1);&#125;); best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1);\n\n\n\n11.2 不要使用发生器。\n\n为什么? They don’t transpile well to ES5.\n\n\n\n11.3 如果你必须使用发生器或者无视 我们的建议，请确保他们的函数签名是正常的间隔。 eslint: generator-star-spacing\n\n为什么? function 和 * 是同一个概念关键字的一部分 - * 不是 function 的修饰符， function* 是一个不同于 function 的构造器。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 badfunction * foo() &#123;   ...&#125; badconst bar = function * () &#123;   ...&#125;; badconst baz = function *() &#123;   ...&#125;; badconst quux = function*() &#123;   ...&#125;; badfunction*foo() &#123;   ...&#125; badfunction *foo() &#123;   ...&#125; very badfunction*foo() &#123;   ...&#125; very badconst wat = function*() &#123;   ...&#125;; goodfunction* foo() &#123;   ...&#125; goodconst foo = function* () &#123;   ...&#125;;\n\n\n\n⬆ 返回目录\n属性  \n\n12.1 访问属性时使用点符号。 eslint: dot-notation\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;; badconst isJedi = luke[jedi]; goodconst isJedi = luke.jedi;\n\n\n\n12.2 使用变量访问属性时，使用 []表示法。\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;;function getProp(prop) &#123;  return luke[prop];&#125;const isJedi = getProp(jedi);\n\n\n\n12.3 计算指数时，可以使用 ** 运算符。 eslint: no-restricted-properties.\n12345 badconst binary = Math.pow(2, 10); goodconst binary = 2 ** 10;\n\n\n\n⬆ 返回目录\n变量  \n\n13.1 使用 const 或者 let 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: no-undef prefer-const\n12345 badsuperPower = new SuperPower(); goodconst superPower = new SuperPower();\n\n\n\n13.2 使用 const 或者 let 声明每一个变量。 eslint: one-var\n\n为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 ; 还是使用 , 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。\n\n123456789101112131415 badconst items = getItems(),    goSportsTeam = true,    dragonball = z; bad (compare to above, and try to spot the mistake)const items = getItems(),    goSportsTeam = true;    dragonball = z; goodconst items = getItems();const goSportsTeam = true;const dragonball = z;\n\n\n\n13.3 把 const 声明的放在一起，把 let 声明的放在一起。.\n\n为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。\n\n123456789101112131415161718 badlet i, len, dragonball,    items = getItems(),    goSportsTeam = true; badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len; goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length;\n\n\n\n13.4 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n\n为什么? let 和 const 是块级作用域而不是函数作用域。\n\n12345678910111213141516171819202122232425262728293031 bad - 不必要的函数调用function checkName(hasName) &#123;  const name = getName();  if (hasName === test) &#123;    return false;  &#125;  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125; goodfunction checkName(hasName) &#123;  if (hasName === test) &#123;    return false;  &#125;  const name = getName();  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125;\n\n\n\n13.5 不要链式变量赋值。 eslint: no-multi-assign\n\n为什么? 链式变量赋值会创建隐式全局变量。\n\n123456789101112131415161718192021222324 bad(function example() &#123;   JavaScript 把它解释为   let a = ( b = ( c = 1 ) );   let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。  let a = b = c = 1;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  1console.log(c);  1 good(function example() &#123;  let a = 1;  let b = a;  let c = a;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  throws ReferenceErrorconsole.log(c);  throws ReferenceError 对于 `const` 也一样\n\n\n\n13.6 避免使用不必要的递增和递减 (++, --)。 eslint no-plusplus\n\n为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 num += 1 这样的语句来改变您的值，而不是使用 num++ 或 num ++ 。不允许不必要的增量和减量语句也会使您无法预先递增预递减值，这也会导致程序中的意外行为。\n\n1234567891011121314151617181920212223242526 badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) &#123;  let value = array[i];  sum += value;  if (value) &#123;    truthyCount++;  &#125;&#125; goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length;\n\n\n\n\n\n13.7 避免在赋值语句 = 前后换行。如果你的代码违反了 max-len， 使用括号包裹。 eslint operator-linebreak.\n\n为什么? 在 = 前后换行，可能混淆分配的值。\n\n123456789101112131415 badconst foo =  superLongLongLongLongLongLongLongLongFunctionName(); badconst foo  = superLongLongLongLongLongLongLongLongString; goodconst foo = (  superLongLongLongLongLongLongLongLongFunctionName()); goodconst foo = superLongLongLongLongLongLongLongLongString;\n\n\n\n⬆ 返回目录\n提升  \n\n14.1 var 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。const 和 let 声明的变量受到一个称之为 Temporal Dead Zones (TDZ) 的新概念保护。 知道为什么 typeof 不在安全 是很重要的。\n1234567891011121314151617181920212223242526 我们知道这个行不通 (假设没有未定义的全局变量)function example() &#123;  console.log(notDefined);  =&gt; throws a ReferenceError&#125; 在引用变量后创建变量声明将会因变量提升而起作用。 注意: 真正的值 `true` 不会被提升。function example() &#123;  console.log(declaredButNotAssigned);  =&gt; undefined  var declaredButNotAssigned = true;&#125; 解释器将变量提升到函数的顶部 这意味着我们可以将上边的例子重写为：function example() &#123;  let declaredButNotAssigned;  console.log(declaredButNotAssigned);  =&gt; undefined  declaredButNotAssigned = true;&#125; 使用 const 和 letfunction example() &#123;  console.log(declaredButNotAssigned);  =&gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned);  =&gt; throws a ReferenceError  const declaredButNotAssigned = true;&#125;\n\n\n\n14.2 匿名函数表达式提升变量名，而不是函数赋值。\n123456789function example() &#123;  console.log(anonymous);  =&gt; undefined  anonymous();  =&gt; TypeError anonymous is not a function  var anonymous = function () &#123;    console.log(anonymous function expression);  &#125;;&#125;\n\n\n\n14.3 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n12345678910111213141516171819202122function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  superPower();  =&gt; ReferenceError superPower is not defined  var named = function superPower() &#123;    console.log(Flying);  &#125;;&#125; 当函数名和变量名相同时也是如此。function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  var named = function named() &#123;    console.log(named);  &#125;;&#125;\n\n\n\n14.4 函数声明提升其名称和函数体。\n1234567function example() &#123;  superPower();  =&gt; Flying  function superPower() &#123;    console.log(Flying);  &#125;&#125;\n\n更多信息请参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。\n\n\n⬆ 返回目录\n比较运算符和等号  \n\n15.1 使用 === 和 !== 而不是 == 和 !=。 eslint: eqeqeq\n\n\n15.2 条件语句，例如 if 语句使用 ToBoolean 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：\n\nObjects 的取值为： true\nUndefined 的取值为： false\nNull 的取值为： false\nBooleans 的取值为： 布尔值的取值\nNumbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true\nStrings 的取值为: 如果是一个空字符串 &#39;&#39; 值为 false 否则为 true\n\n1234if ([0] &amp;&amp; []) &#123;   true   一个数组（既是是空的）是一个对象，对象的取值为 true&#125;\n\n\n\n15.3 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n1234567891011121314151617181920212223242526272829 badif (isValid === true) &#123;   ...&#125; goodif (isValid) &#123;   ...&#125; badif (name) &#123;   ...&#125; goodif (name !== ) &#123;   ...&#125; badif (collection.length) &#123;   ...&#125; goodif (collection.length &gt; 0) &#123;   ...&#125;\n\n\n\n15.4 获取更多信息请查看 Angus Croll 的 Truth Equality and JavaScript 。\n\n\n15.5 在 case 和 default 的子句中，如果存在声明 (例如. let, const, function, 和 class)，使用大括号来创建块 。 eslint: no-case-declarations\n\n为什么? 语法声明在整个 switch 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 case 条件达到才会发生。 当多个 case 语句定义相同的东西是，这会导致问题问题。\n\n12345678910111213141516171819202122232425262728293031323334353637383940 badswitch (foo) &#123;  case 1:    let x = 1;    break;  case 2:    const y = 2;    break;  case 3:    function f() &#123;       ...    &#125;    break;  default:    class C &#123;&#125;&#125; goodswitch (foo) &#123;  case 1: &#123;    let x = 1;    break;  &#125;  case 2: &#123;    const y = 2;    break;  &#125;  case 3: &#123;    function f() &#123;       ...    &#125;    break;  &#125;  case 4:    bar();    break;  default: &#123;    class C &#123;&#125;  &#125;&#125;\n\n\n\n15.6 三目表达式不应该嵌套，通常是单行表达式。 eslint: no-nested-ternary\n123456789101112131415 badconst foo = maybe1 &gt; maybe2  ? bar  : value1 &gt; value2 ? baz : null; 分离为两个三目表达式const maybeNull = value1 &gt; value2 ? baz : null; betterconst foo = maybe1 &gt; maybe2  ? bar  : maybeNull; bestconst foo = maybe1 &gt; maybe2 ? bar : maybeNull;\n\n\n\n15.7 避免不必要的三目表达式。 eslint: no-unneeded-ternary\n123456789 badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true; goodconst foo = a || b;const bar = !!c;const baz = !c;\n\n\n\n15.8 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (+, -, *, &amp; ) 因为他们的优先级被广泛理解。 eslint: no-mixed-operators\n\n为什么? 这能提高可读性并且表明开发人员的意图。\n\n12345678910111213141516171819202122232425 badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0; badconst bar = a ** b - 5 % d; bad 可能陷入一种 (a || b) &amp;&amp; c 的思考if (a || b &amp;&amp; c) &#123;  return d;&#125; goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0); goodconst bar = (a ** b) - (5 % d); goodif (a || (b &amp;&amp; c)) &#123;  return d;&#125; goodconst bar = a + b  c * d;\n\n\n\n⬆ 返回目录\n块  \n\n16.1 当有多行代码块的时候，使用大括号包裹。 eslint: nonblock-statement-body-position\n12345678910111213141516171819 badif (test)  return false; goodif (test) return false; goodif (test) &#123;  return false;&#125; badfunction foo() &#123; return false; &#125; goodfunction bar() &#123;  return false;&#125;\n\n\n\n16.2 如果你使用的是 if 和 else 的多行代码块，则将 else 语句放在 if 块闭括号同一行的位置。 eslint: brace-style\n12345678910111213141516 badif (test) &#123;  thing1();  thing2();&#125;else &#123;  thing3();&#125; goodif (test) &#123;  thing1();  thing2();&#125; else &#123;  thing3();&#125;\n\n\n\n16.3 如果一个 if 块总是执行一个 return 语句，那么接下来的 else 块就没有必要了。 如果一个包含 return 语句的 else if 块，在一个包含了 return 语句的 if 块之后，那么可以拆成多个 if 块。 eslint: no-else-return\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 badfunction foo() &#123;  if (x) &#123;    return x;  &#125; else &#123;    return y;  &#125;&#125; badfunction cats() &#123;  if (x) &#123;    return x;  &#125; else if (y) &#123;    return y;  &#125;&#125; badfunction dogs() &#123;  if (x) &#123;    return x;  &#125; else &#123;    if (y) &#123;      return y;    &#125;  &#125;&#125; goodfunction foo() &#123;  if (x) &#123;    return x;  &#125;  return y;&#125; goodfunction cats() &#123;  if (x) &#123;    return x;  &#125;  if (y) &#123;    return y;  &#125;&#125; goodfunction dogs(x) &#123;  if (x) &#123;    if (z) &#123;      return y;    &#125;  &#125; else &#123;    return z;  &#125;&#125;\n\n\n\n⬆ 返回目录\n控制语句  \n\n17.1 如果你的控制语句 (if, while 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n\n为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 badif ((foo === 123 || bar === abc) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; badif (foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; badif (foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; badif (  foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; goodif (  foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; goodif (  (foo === 123 || bar === abc)  &amp;&amp; doesItLookGoodWhenItBecomesThatLong()  &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; goodif (foo === 123 &amp;&amp; bar === abc) &#123;  thing1();&#125;\n\n\n\n17.2 不要使用选择操作符代替控制语句。\n1234567 bad!isRunning &amp;&amp; startRunning(); goodif (!isRunning) &#123;  startRunning();&#125;\n\n\n\n⬆ 返回目录\n注释  \n\n18.1 使用 ** ... * 来进行多行注释。\n123456789101112131415161718192021222324 bad make() returns a new element based on the passed in tag name @param &#123;String&#125; tag @return &#123;Element&#125; elementfunction make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.2 使用  进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n123456789101112131415161718192021222324252627282930313233 badconst active = true;   is current tab good is current tabconst active = true; badfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; goodfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; also goodfunction getType() &#123;   set the default type to no type  const type = this.type || no type;  return type;&#125;\n\n\n\n18.3 用一个空格开始所有的注释，使它更容易阅读。 eslint: spaced-comment\n12345678910111213141516171819202122232425262728293031 badis current tabconst active = true; good is current tabconst active = true; bad** *make() returns a new element *based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.4 使用 FIXME 或者 TODO 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 FIXME: -- 需要解决这个问题 或者 TODO: -- 需要被实现。\n\n\n18.5 使用  FIXME: 注释一个问题。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     FIXME: 这里不应该使用全局变量    total = 0;  &#125;&#125;\n\n\n\n18.6 使用  TODO: 注释解决问题的方法。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     TODO: total 应该由一个 param 的选项配置    this.total = 0;  &#125;&#125;\n\n\n\n⬆ 返回目录\n空白  \n\n19.1 使用 tabs (空格字符) 设置为 2 个空格。 eslint: indent\n1234567891011121314 badfunction foo() &#123;∙∙∙∙let name;&#125; badfunction bar() &#123;∙let name;&#125; goodfunction baz() &#123;∙∙let name;&#125;\n\n\n\n19.2 在主体前放置一个空格。 eslint: space-before-blocks\n123456789101112131415161718192021 badfunction test()&#123;  console.log(test);&#125; goodfunction test() &#123;  console.log(test);&#125; baddog.set(attr,&#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;); gooddog.set(attr, &#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;);\n\n\n\n19.3 在控制语句（if, while 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: keyword-spacing\n12345678910111213141516171819 badif(isJedi) &#123;  fight ();&#125; goodif (isJedi) &#123;  fight();&#125; badfunction fight () &#123;  console.log (Swooosh!);&#125; goodfunction fight() &#123;  console.log(Swooosh!);&#125;\n\n\n\n19.4 用空格分离操作符。 eslint: space-infix-ops\n12345 badconst x=y+5; goodconst x = y + 5;\n\n\n\n19.5 使用单个换行符结束文件。 eslint: eol-last\n1234 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;\n\n12345 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵↵\n\n1234 goodimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵\n\n\n\n19.6 在使用长方法连滴啊用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: newline-per-chained-call no-whitespace-before-property\n12345678910111213141516171819202122232425262728293031323334353637 bad$(#items).find(.selected).highlight().end().find(.open).updateCount(); bad$(#items).  find(.selected).    highlight().    end().  find(.open).    updateCount(); good$(#items)  .find(.selected)    .highlight()    .end()  .find(.open)    .updateCount(); badconst leds = stage.selectAll(.led).data(data).enter().append(svg:svg).classed(led, true)    .attr(width, (radius + margin) * 2).append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led)    .data(data)  .enter().append(svg:svg)    .classed(led, true)    .attr(width, (radius + margin) * 2)  .append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led).data(data);\n\n\n\n19.7 在块和下一个语句之前留下一空白行。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 badif (foo) &#123;  return bar;&#125;return baz; goodif (foo) &#123;  return bar;&#125;return baz; badconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; goodconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; badconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr; goodconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr;\n\n\n\n19.8 不要在块的开头使用空白行。 eslint: padded-blocks\n1234567891011121314151617181920212223242526272829303132333435 badfunction bar() &#123;  console.log(foo);&#125; badif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125; badclass Foo &#123;  constructor(bar) &#123;    this.bar = bar;  &#125;&#125; goodfunction bar() &#123;  console.log(foo);&#125; goodif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125;\n\n\n\n19.9 不要在括号内添加空格。 eslint: space-in-parens\n12345678910111213141516171819 badfunction bar( foo ) &#123;  return foo;&#125; goodfunction bar(foo) &#123;  return foo;&#125; badif ( foo ) &#123;  console.log(foo);&#125; goodif (foo) &#123;  console.log(foo);&#125;\n\n\n\n19.10 不要在中括号中添加空格。 eslint: array-bracket-spacing\n1234567 badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]); goodconst foo = [1, 2, 3];console.log(foo[0]);\n\n\n\n19.11 在花括号内添加空格。 eslint: object-curly-spacing\n12345 badconst foo = &#123;clark: kent&#125;; goodconst foo = &#123; clark: kent &#125;;\n\n\n\n19.12 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 约束，长字符串可免除此规定，不应分解。 eslint: max-len\n\n为什么? 这样能够确保可读性和可维护性。\n\n12345678910111213141516171819202122 badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; bad$.ajax(&#123; method: POST, url: https:airbnb.com, data: &#123; name: John &#125; &#125;).done(() =&gt; console.log(Congratulations!)).fail(() =&gt; console.log(You have failed this city.)); goodconst foo = jsonData  &amp;&amp; jsonData.foo  &amp;&amp; jsonData.foo.bar  &amp;&amp; jsonData.foo.bar.baz  &amp;&amp; jsonData.foo.bar.baz.quux  &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; good$.ajax(&#123;  method: POST,  url: https:airbnb.com,  data: &#123; name: John &#125;,&#125;)  .done(() =&gt; console.log(Congratulations!))  .fail(() =&gt; console.log(You have failed this city.));\n\n\n\n19.13 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: block-spacing\n1234567 badfunction foo() &#123;return true;&#125;if (foo) &#123; bar = 0;&#125; goodfunction foo() &#123; return true; &#125;if (foo) &#123; bar = 0; &#125;\n\n\n\n19.14 逗号之前避免使用空格，逗号之后需要使用空格。eslint: comma-spacing\n1234567 badvar foo = 1,bar = 2;var arr = [1 , 2]; goodvar foo = 1, bar = 2;var arr = [1, 2];\n\n\n\n19.15 在计算属性之间强化间距。eslint: computed-property-spacing\n1234567891011 badobj[foo ]obj[ foo]var x = &#123;[ b ]: a&#125;obj[foo[ bar ]] goodobj[foo]obj[foo]var x = &#123; [b]: a &#125;obj[foo[bar]]\n\n\n\n19.16 在函数和它的调用之间强化间距。 eslint: func-call-spacing\n12345678 badfunc ();func(); goodfunc();\n\n\n\n19.17 在对象的属性和值之间强化间距。 eslint: key-spacing\n123456 badvar obj = &#123; foo : 42 &#125;;var obj2 = &#123; foo:42 &#125;; goodvar obj = &#123; foo: 42 &#125;;\n\n\n\n19.18 在行的末尾避免使用空格。 eslint: no-trailing-spaces\n\n\n19.19 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: no-multiple-empty-lines\n\n1234567891011 badvar x = 1;var y = 2; goodvar x = 1;var y = 2;\n\n\n\n\n\n⬆ 返回目录\n逗号  \n\n20.1 逗号前置： 不行 eslint: comma-style\n1234567891011121314151617181920212223242526272829 badconst story = [    once  , upon  , aTime]; goodconst story = [  once,  upon,  aTime,]; badconst hero = &#123;    firstName: Ada  , lastName: Lovelace  , birthYear: 1815  , superPower: computers&#125;; goodconst hero = &#123;  firstName: Ada,  lastName: Lovelace,  birthYear: 1815,  superPower: computers,&#125;;\n\n\n\n20.2 添加尾随逗号： 可以 eslint: comma-dangle\n\n为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 尾随逗号问题 。\n\n1234567891011121314 bad - 没有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,-    lastName: Nightingale+    lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing]&#125;; good - 有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,     lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing],&#125;;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 badconst hero = &#123;  firstName: Dana,  lastName: Scully&#125;;const heroes = [  Batman,  Superman]; goodconst hero = &#123;  firstName: Dana,  lastName: Scully,&#125;;const heroes = [  Batman,  Superman,]; badfunction createHero(  firstName,  lastName,  inventorOf) &#123;   does nothing&#125; goodfunction createHero(  firstName,  lastName,  inventorOf,) &#123;   does nothing&#125; good (注意逗号不能出现在 rest 元素后边)function createHero(  firstName,  lastName,  inventorOf,  ...heroArgs) &#123;   does nothing&#125; badcreateHero(  firstName,  lastName,  inventorOf); goodcreateHero(  firstName,  lastName,  inventorOf,); good (注意逗号不能出现在 rest 元素后边)createHero(  firstName,  lastName,  inventorOf,  ...heroArgs);\n\n\n\n⬆ 返回目录\n分号  \n\n21.1 对 eslint: semi\n\n为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 Automatic Semicolon Insertion 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。\n\n123456789101112131415161718192021222324252627282930313233343536 bad - 可能异常const luke = &#123;&#125;const leia = &#123;&#125;[luke, leia].forEach(jedi =&gt; jedi.father = vader) bad - 可能异常const reaction = No! Thats impossible!(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()) bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生function foo() &#123;  return    search your feelings, you know it to be foo&#125; goodconst luke = &#123;&#125;;const leia = &#123;&#125;;[luke, leia].forEach((jedi) =&gt; &#123;  jedi.father = vader;&#125;); goodconst reaction = No! Thats impossible!;(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()); goodfunction foo() &#123;  return search your feelings, you know it to be foo;&#125;\n\n更多信息.\n\n\n⬆ 返回目录\n类型转换和强制类型转换  \n\n22.1 在语句开始前进行类型转换。\n\n\n22.2  字符类型： eslint: no-new-wrappers\n12345678910111213 =&gt; this.reviewScore = 9; badconst totalScore = new String(this.reviewScore);  typeof totalScore is object not string badconst totalScore = this.reviewScore + ;  invokes this.reviewScore.valueOf() badconst totalScore = this.reviewScore.toString();  isn’t guaranteed to return a string goodconst totalScore = String(this.reviewScore);\n\n\n\n22.3 数字类型：使用 Number 进行类型铸造和 parseInt 总是通过一个基数来解析一个字符串。 eslint: radix no-new-wrappers\n12345678910111213141516171819const inputValue = 4; badconst val = new Number(inputValue); badconst val = +inputValue; badconst val = inputValue &gt;&gt; 0; badconst val = parseInt(inputValue); goodconst val = Number(inputValue); goodconst val = parseInt(inputValue, 10);\n\n\n\n22.4 如果出于某种原因，你正在做一些疯狂的事情，而 parseInt 是你的瓶颈，并且出于 性能问题 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n123456 good** * parseInt 使我的代码变慢。 * 位运算将一个字符串转换成数字更快。 *const val = inputValue &gt;&gt; 0;\n\n\n\n22.5 注意： 当你使用位运算的时候要小心。 数字总是被以 64-bit 值 的形式表示，但是位运算总是返回一个 32-bit 的整数 (来源)。 对于大于 32 位的整数值，位运算可能会导致意外行为。讨论。 最大的 32 位整数是： 2,147,483,647。\n1232147483647 &gt;&gt; 0;  =&gt; 21474836472147483648 &gt;&gt; 0;  =&gt; -21474836482147483649 &gt;&gt; 0;  =&gt; -2147483647\n\n\n\n22.6 布尔类型： eslint: no-new-wrappers\n12345678910const age = 0; badconst hasAge = new Boolean(age); goodconst hasAge = Boolean(age); bestconst hasAge = !!age;\n\n\n\n⬆ 返回目录\n命名规范  \n\n23.1 避免单字母的名字。用你的命名来描述功能。 eslint: id-length\n123456789 badfunction q() &#123;   ...&#125; goodfunction query() &#123;   ...&#125;\n\n\n\n23.2 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: camelcase\n12345678 badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125; goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;\n\n\n\n23.3 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: new-cap\n12345678910111213141516171819 badfunction user(options) &#123;  this.name = options.name;&#125;const bad = new user(&#123;  name: nope,&#125;); goodclass User &#123;  constructor(options) &#123;    this.name = options.name;  &#125;&#125;const good = new User(&#123;  name: yup,&#125;);\n\n\n\n23.4 不要使用前置或者后置下划线。 eslint: no-underscore-dangle\n\n为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。\n\n123456789101112 badthis.__firstName__ = Panda;this.firstName_ = Panda;this._firstName = Panda; goodthis.firstName = Panda; 好，在 WeakMapx 可用的环境中 see https:kangax.github.iocompat-tablees6#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, Panda);\n\n\n\n23.5 不要保存 this 的引用。 使用箭头函数或者 函数#bind。\n12345678910111213141516171819202122 badfunction foo() &#123;  const self = this;  return function () &#123;    console.log(self);  &#125;;&#125; badfunction foo() &#123;  const that = this;  return function () &#123;    console.log(that);  &#125;;&#125; goodfunction foo() &#123;  return () =&gt; &#123;    console.log(this);  &#125;;&#125;\n\n\n\n23.6 文件名应该和默认导出的名称完全匹配。\n123456789101112131415161718192021222324252627282930 file 1 contentsclass CheckBox &#123;   ...&#125;export default CheckBox; file 2 contentsexport default function fortyTwo() &#123; return 42; &#125; file 3 contentsexport default function insideDirectory() &#123;&#125; in some other file badimport CheckBox from .checkBox;  PascalCase importexport, camelCase filenameimport FortyTwo from .FortyTwo;  PascalCase importfilename, camelCase exportimport InsideDirectory from .InsideDirectory;  PascalCase importfilename, camelCase export badimport CheckBox from .check_box;  PascalCase importexport, snake_case filenameimport forty_two from .forty_two;  snake_case importfilename, camelCase exportimport inside_directory from .inside_directory;  snake_case import, camelCase exportimport index from .inside_directoryindex;  requiring the index file explicitlyimport insideDirectory from .insideDirectoryindex;  requiring the index file explicitly goodimport CheckBox from .CheckBox;  PascalCase exportimportfilenameimport fortyTwo from .fortyTwo;  camelCase exportimportfilenameimport insideDirectory from .insideDirectory;  camelCase exportimportdirectory nameimplicit index ^ supports both insideDirectory.js and insideDirectoryindex.js\n\n\n\n23.7 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n12345function makeStyleGuide() &#123;   ...&#125;export default makeStyleGuide;\n\n\n\n23.8 当你导出一个构造器  类  单例  函数库  暴露的对象时应该使用帕斯卡命名法。\n123456const AirbnbStyleGuide = &#123;  es6: &#123;  &#125;,&#125;;export default AirbnbStyleGuide;\n\n\n\n23.9 缩略词和缩写都必须是全部大写或者全部小写。\n\n为什么? 名字是为了可读性，不是为了满足计算机算法。\n\n12345678910111213141516171819202122232425262728 badimport SmsContainer from .containersSmsContainer; badconst HttpRequests = [   ...]; goodimport SMSContainer from .containersSMSContainer; goodconst HTTPRequests = [   ...]; also goodconst httpRequests = [   ...]; bestimport TextMessageContainer from .containersTextMessageContainer; bestconst requests = [   ...];\n\n\n\n23.10 你可以大写一个常亮，如果它：（1）被导出，（2）使用 const 定义（不能被重新分配），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n\n为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。\n\n是否是对所有的 const 定义的变量？ - 这个是没哟必要的，不应该在文件中使用大学。但是，它应该用于导出常量。\n导出对象呢？ - 在顶级导出属性 (e.g. EXPORTED_OBJECT.key) 并且保持所有嵌套属性不变。\n\n\n12345678910111213141516171819202122232425262728 badconst PRIVATE_VARIABLE = should not be unnecessarily uppercased within a file; badexport const THING_TO_BE_CHANGED = should obviously not be uppercased; badexport let REASSIGNABLE_VARIABLE = do not use let with uppercase variables; --- 允许，但是不提供语义值export const apiKey = SOMEKEY; 多数情况下，很好export const API_KEY = SOMEKEY; --- bad - 不必要大写 key 没有增加语义值export const MAPPING = &#123;  KEY: value&#125;; goodexport const MAPPING = &#123;  key: value&#125;;\n\n\n\n⬆ 返回目录\n存取器  \n\n24.1 对于属性的的存取函数不是必须的。\n\n\n24.2 不要使用 JavaScript 的 getterssetters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 getVal() 和 setVal(&#39;hello&#39;)。\n123456789101112131415161718192021 badclass Dragon &#123;  get age() &#123;     ...  &#125;  set age(value) &#123;     ...  &#125;&#125; goodclass Dragon &#123;  getAge() &#123;     ...  &#125;  setAge(value) &#123;     ...  &#125;&#125;\n\n\n\n24.3 如果属性方法是一个 boolean 值，使用 isVal() 或者 hasVal()。\n123456789 badif (!dragon.age()) &#123;  return false;&#125; goodif (!dragon.hasAge()) &#123;  return false;&#125;\n\n\n\n24.4 可以创建 get() 和 set() 方法，但是要保证一致性。\n1234567891011121314class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    const lightsaber = options.lightsaber || blue;    this.set(lightsaber, lightsaber);  &#125;  set(key, val) &#123;    this[key] = val;  &#125;  get(key) &#123;    return this[key];  &#125;&#125;\n\n\n\n⬆ 返回目录\n事件  \n\n25.1 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n12345678 bad$(this).trigger(listingUpdated, listing.id); ...$(this).on(listingUpdated, (e, listingID) =&gt; &#123;   do something with listingID&#125;);\n\n更好的写法：\n12345678 good$(this).trigger(listingUpdated, &#123; listingID: listing.id &#125;); ...$(this).on(listingUpdated, (e, data) =&gt; &#123;   do something with data.listingID&#125;);\n\n\n  ⬆ 返回目录\njQuery  \n\n26.1 对于 jQuery 对象的变量使用 $ 作为前缀。\n12345678 badconst sidebar = $(.sidebar); goodconst $sidebar = $(.sidebar); goodconst $sidebarBtn = $(.sidebar-btn);\n\n\n\n26.2 缓存 jQuery 查询。\n12345678910111213141516171819202122 badfunction setSidebar() &#123;  $(.sidebar).hide();   ...  $(.sidebar).css(&#123;    background-color: pink,  &#125;);&#125; goodfunction setSidebar() &#123;  const $sidebar = $(.sidebar);  $sidebar.hide();   ...  $sidebar.css(&#123;    background-color: pink,  &#125;);&#125;\n\n\n\n26.3 对于 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;) 的格式。 jsPerf\n\n\n26.4 对于有作用域的 jQuery 对象查询使用 find 。\n1234567891011121314 bad$(ul, .sidebar).hide(); bad$(.sidebar).find(ul).hide(); good$(.sidebar ul).hide(); good$(.sidebar &gt; ul).hide(); good$sidebar.find(ul).hide();\n\n\n\n⬆ 返回目录\nECMAScript 5 兼容性  \n\n27.1 参考 Kangax的 ES5 兼容性表格。\n\n⬆ 返回目录\n\nECMAScript 6+ (ES 2015+) Styles  \n\n28.1 这是一个链接到各种 ES6+ 特性的集合。\n\n\n箭头函数\n\n类\n\n对象简写\n\n对象简洁\n\n对象计算属性\n\n字符串模板\n\n解构\n\n默认参数\n\nRest\n\n数组展开\n\nLet 和 Const\n\n求幂运算符\n\n迭代器和发生器\n\n模块\n\n\n28.2 不要使用尚未达到第3阶段的 TC39 建议。\n\n为什么? 它们没有最终确定， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。\n\n\n\n\n\n⬆ 返回目录\n标准库  标准库  包含功能已损坏的实用工具，但因为遗留原因而保留。\n  \n\n29.1 使用 Number.isNaN 代替全局的 isNaN.eslint: no-restricted-globals\n\n为什么? 全局的 isNaN 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n1234567 badisNaN(1.2);  falseisNaN(1.2.3);  true goodNumber.isNaN(1.2.3);  falseNumber.isNaN(Number(1.2.3));  true\n\n\n\n29.2 使用 Number.isFinite 代替全局的 isFinite.eslint: no-restricted-globals\n\n为什么? 全局的 isFinite 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n123456 badisFinite(2e3);  true goodNumber.isFinite(2e3);  falseNumber.isFinite(parseInt(2e3, 10));  true\n\n\n\n⬆ 返回目录\nTesting  \n\n30.1 是的.\n123function foo() &#123;  return true;&#125;\n\n\n\n30.2 没有，但是认真:\n\n无论你使用那种测试框架，都应该编写测试！\n努力写出许多小的纯函数，并尽量减少发生错误的地方。\n对于静态方法和 mock 要小心—-它们会使你的测试更加脆弱。\n我们主要在 Airbnb 上使用 mocha 和 jest 。 tape 也会用在一些小的独立模块上。\n100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。\n无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。\n\n\n\n⬆ 返回目录\n性能\nOn Layout &amp; Web Performance\nString vs Array Concat\nTryCatch Cost In a Loop\nBang Function\njQuery Find vs Context, Selector\ninnerHTML vs textContent for script text\nLong String Concatenation\nAre Javascript functions like map(), reduce(), and filter() optimized for traversing arrays?\nLoading…\n\n⬆ 返回目录\n资源学习 ES6+\n\nLatest ECMA spec\nExploringJS\nES6 Compatibility Table\nComprehensive Overview of ES6 Features\n\n读这个\n\nStandard ECMA-262\n\n工具\n\nCode Style Linters\nESlint - Airbnb Style .eslintrc\nJSHint - Airbnb Style .jshintrc\n\n\nNeutrino preset - neutrino-preset-airbnb-base\n\n其他编码规范\n\nGoogle JavaScript Style Guide\njQuery Core Style Guidelines\nPrinciples of Writing Consistent, Idiomatic JavaScript\nStandardJS\n\n其他风格\n\nNaming this in nested functions - Christian Johansen\nConditional Callbacks - Ross Allen\nPopular JavaScript Coding Conventions on GitHub - JeongHoon Byun\nMultiple var statements in JavaScript, not superfluous - Ben Alman\n\n进一步阅读\n\nUnderstanding JavaScript Closures - Angus Croll\nBasic JavaScript for the impatient programmer - Dr. Axel Rauschmayer\nYou Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz\nES6 Features - Luke Hoban\nFrontend Guidelines - Benjamin De Cock\n\n书籍\n\nJavaScript: The Good Parts - Douglas Crockford\nJavaScript Patterns - Stoyan Stefanov\nPro JavaScript Design Patterns  - Ross Harmes and Dustin Diaz\nHigh Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders\nMaintainable JavaScript - Nicholas C. Zakas\nJavaScript Web Applications - Alex MacCaw\nPro JavaScript Techniques - John Resig\nSmashing Node.js: JavaScript Everywhere - Guillermo Rauch\nSecrets of the JavaScript Ninja - John Resig and Bear Bibeault\nHuman JavaScript - Henrik Joreteg\nSuperhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy\nJSBooks - Julien Bouquillon\nThird Party JavaScript - Ben Vinegar and Anton Kovalyov\nEffective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman\nEloquent JavaScript - Marijn Haverbeke\nYou Don’t Know JS: ES6 &amp; Beyond - Kyle Simpson\n\n博客\n\nJavaScript Weekly\nJavaScript, JavaScript…\nBocoup Weblog\nAdequately Good\nNCZOnline\nPerfection Kills\nBen Alman\nDmitry Baranovskiy\nnettuts\n\n播客\n\nJavaScript Air\nJavaScript Jabber\n\n⬆ 返回目录\nJavaScript风格指南的指南\nReference\n\n许可证(The MIT License)\nCopyright (c) 2012 康兵奎\nPermission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, andor sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:\nThe above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n⬆ 返回目录\n修正案我们鼓励您使用此指南并更改规则以适应您的团队的风格指南。下面，你可以列出一些对风格指南的修正。这允许您定期更新您的样式指南，而不必处理合并冲突。\n};","tags":["javascript"],"path":"2019/09/08/Airbnb-JavaScript-代码规范/","external_link":""},{"title":"数据库备份恢复容器化项目实践经验总结","date":"2019-09-08T13:35:18.000Z","content":"数据库备份恢复容器化项目实践经验总结\n本文分享了唯品会数据库Docker的异地容灾项目实践经验，项目中针对用户数据库的异地恢复场景的需求进行开发和测试，整合了网络，存储、调度、监控，镜像等多个模块。在实施完成后，从技术上总结关于选型、开发、踩坑、测试等方面的经验。\n\n项目背景数据库Docker的异地备份恢复容灾项目，针对用户数据库的异地备份恢复场景的需求进行开发和测试，整合了容器网络、存储、调度、监控、镜像等多个模块。同时针对数据库的日常运维工作开发了监控、资源调度、日志、Puppet自动推送等工具。\n通过Docker天生隔离性和快速部署等特点，实现在单台物理机上运行多个数据库备份恢复实例，大大提高服务器使用率，节省大量成本。通过对Docker本身和相关组件的研究和改造，从普通开源产品落地到公司内部生产环境，积累宝贵的开发经验。通过对Docker已经在其上层运行的数据库日常运维和监控，也积累宝贵的Docker运维经验，为更大规模推广容器提供基础。\n\n关于容器技术通过实践，证明容器技术在易用性，可管理性，快速部署具备天然的优势。在资源利用率方面，容器部署在上百个物理节点上，提供约500多个数据库灾备实例，提升了硬件资源的利用率，节约了约400台物理机的采购成本。这些是容器技术带来的实实在在收益。在资源分配与隔离方面，又不输于虚拟机。CPU、内存、磁盘IO、网络IO限流等技术的应用，保证了资源的合理使用，从机制上阻止了单一实例的资源过分消耗的问题。\n稳定性是使用容器技术非常关注的一个点，也是基石。MySQL备份恢复属于CPU密集 + 磁盘IO密集 + 网络IO密集型业务，对于Docker daemon是个较大的考验。就目前来看，限制每台宿主机的容器数量（5个左右）的情况下，集群跑了三个多月没有出现因为容器负载过大导致的crash现象，还是值得信赖的。遇到的唯一相关问题是Docker daemon挂死，具体现象是docker info、docker ps没有响应，docker volume、docker images 正常，下面的容器运行正常。这是偶发事件，无法重现，以后需要继续观察。\n由于容器以进程方式存在，体现出几乎与物理机上相当的性能，Overheads极低（低于10%）。从数据抽取任务的结果来看，与物理机相比，使用容器对成功率没有影响，效率也差不多。这也很符合最初预想，不管跑容器还是外部服务从物理机角度来说它们之间是没有什么区别的，都是一个进程，唯一不同是父进程不一样而已。\n以上是容器“RUN”带来的好处，通过统一开发流程，应用微服务化，CICD等方面的改进，能够进一步利用容器“BUILD”、“SHIP” 优势，容器技术还来的潜力是巨大的。要说容器技术的缺点，还真的不明显。硬要提的话一个是需要一定的学习成本，改变开发流程与方式，一个是开发人员对容器技术的接受程度。这个项目仅用了不到二百人天，对于一个采用新技术的项目来说，真的是很低的了。一开始我们也担心因为采用新技术导致开发推广有困难，后来实际能通过技术上解决问题，打消了大部分用户对使用Docker的疑虑，反而有助于该技术的普遍应用。\n关于Docker daemon版本的选择，我们之前是有过一些讨论的。现在Docker社区非常活跃，当时我们用1.10.3， 到现在已经出了两个新版本了。在功能满足的前提下，稳定性是第一考量。Docker自1.9.0引入CNM网络模型，1.10算是比较成熟。CNM是我们希望在这个项目尝试的一部分。网络与Volume插件功能与稳定性的提升，开始支持磁盘IO读写限速，Device Mapper的支持，等等，都是选择了这个版本的原因。另外，Docker插件的引入，很好地解耦了Docker与底层模块的关系，使我们可以专注于底层（网络、存储）实现而不需要修改Docker daemon本身，同时避免产生升级依赖。\n关于容器存储容器外部卷使用Convoy，以插件的形式支持容器持久化数据。容器本身与外部卷均使用Device Mapper作为底层。没有选择分布式存储原因，主要是为了简化实现，更稳定。通过限制每个容器的BlkioDeviceReadBps、BlkioDeviceWriteBps、BlkioDeviceReadIOps、BlkioDeviceWriteIOps，使磁盘IO稳定地达到相当于95%物理机性能。\n\n对于Device Mapper，因为是红帽推荐的，而OS又是用的CentOS7.2, 所以就用了它。测试过程中发现Device Mapper健壮性不是很好，仅仅在低并发下，也会出现容器删除失败的情况，容器并发启停偶尔出现找不到设备的情况。这种使用映射关系的设备，功能是丰富，实现上过于复杂，每次对设备的修改都需要额外去更新Metadata，并发场景出错的机会就大了。让我再选的话我会考虑Overlay这种更简单的driver。\n对于Convoy，是来自Rancher的产品，Go语言，仍然处于未成熟阶段，版本号0.5, 并没有完全实现Volume Plugin接口。相比其它模块它的问题也是最多的，例如Volume创建失败，无法删除，UNIX Socket泄漏，重名冲突，异常自动退出等。属于能用，但未完善的状态，你自己得有一定开发调试能力去解决发现的问题。其它几个存储插件情况也差不多，Flocker、Blockbridge、Horcrux等等，有的连第一个正式发布版都还没有，Convoy反而相对好点，有点烂柿子堆里挑的感觉。\n关于容器监控容器监控在这个项目里还可以有很大的空间可以改进。项目里用的是cAdvisor，容器内top、free、iostat命令劫持，基于已有的Zabbix体系作数据收集与展示。结论是Zabbix完全不合适做容器监控，数据收集密度，展示质量，灵活度都没能满足需求。\n后来在测试中尝试使用Telegraf + InfluxDB + Grafana。 只需要Grafana简单的配置，能够帮忙我们清晰地展示容器及服务进程CPU、内存、网络、磁盘等情况。Grafana上SQL查询语句的调试与开发，确实需要不少的时间，但这个工作量是一次性的。因为是Go写的，Telegraf CPU占用属于比较低的水平（0.4 – 5%）。功能上比较丰富，同时支持外部进程与容器的数据收集，多达55种数据源插件，有它就不需要布cAdvisor了，个人比较推荐。需要告警的同学，可以考虑把influxDB改成Prometheus。它包含Alertmanager实现Email、PagerDuty等消息通知。数据Backend可以选择自带的DB，也可以外接influxDB、Graphite、OpenTSDB等流行方案。\n\n监控领域业界已经有很多开源方案可以参考，以下是要衡量的标准：易扩展、开销低、入侵小、大集中、易部署、实时性、展现清晰灵活。这方面希望与各位有更多的交流。\n","tags":["数据库","备份","Docker"],"path":"2019/09/08/数据库备份恢复容器化项目实践经验总结/","external_link":""},{"title":"灭霸脚本","date":"2019-09-08T23:20:36.000Z","content":"Thanos.shThis command could delete list half your files randomly.\ndon’t use it at home and other places. this is a real gun, use it wisely… \nfeel free to post your story on waiting.12345678910111213141516# 灭霸脚本这个命令会随机“删掉”您一半的文件。。请不要在家里或其他地方使用。这是真家伙，要小心…你可以在```Story.md```文件里发布你的故事，期待中…  ## 特别说明 &gt; 1. 支持mac系统，但是需要使用到```gshuf```命令，需要通过```brew```安装,安装命令如下：```shell    #安装brew    usrbinruby -e &quot;$(curl -fsSL https:raw.githubusercontent.comHomebrewinstallmasterinstall)&quot;    #安装gshuf    brew install coreutils`\n\n\n此脚本只会列出当前目录一半的文件。并且。。。总之小心点。。。  \n\n\nInvoke-Thanos.ps1Invokes Thanos to remove each object with probability 12. It works with files, registry, environment variables, functions, variables, aliases and certificates.\nFor help, use Get-Help .Invoke-Thanos.ps1. Be sure to not actually invoke it!\n123456789101112131415#!binshlet i=`find . -type f | wc -l`2;if [[ uname==Darwin ]]; then    find . -not -name Thanos.sh -type f -print0 | gshuf -z -n $i | xargs -0  -- cat;else    find . -not -name Thanos.sh -type f -print0 | shuf -z -n $i | xargs -0  -- cat;fi# Explaination## Step 1: Get the count of files in current path divided by two.## Step 2: Get all the files in current path and print in one line.## Step 3: Turn half of the second step output into standard input randomly.## Step 4: Show half of the files in terminal.# Key Point## If you want to make delete, what you need to do is turn cat into rm.\n\n本人在线上服务器上运行了一次，…\n\n\n","tags":["脚本"],"path":"2019/09/09/灭霸脚本/","external_link":""},{"title":"Github的webhooks网站自动化部署","date":"2019-09-08T23:56:41.000Z","content":"Github的webhooks进行网站自动化部署\n相信很多码农都玩过了Git，如果对Git只是一知半解，可以移步LV写的 GIT常用操作总结，下面介绍到的一些关于 Git 的概念就不再赘述。\n为啥想写这篇文章？主要是因为部门服务器因为安全性原因不允许SCP上传文件进行应用部署，然后有一些应用是放在Github上的，然后部署应用的步骤就变成：\n1.git clone github项目 本地目录2.配置一下应用的pm2.json并reload3.Nginx配置一下反向代理并restart\n当然如果只是一次性部署上去就不再修改的话并没啥问题，但是要是项目持续性修改迭代的话，就比较麻烦了，我们就在不断的重复着上面的步骤。作为一个码农，怎么允许不断的重复同样的工作，于是Github webhooks闪亮登场。\n关于Github webhooks\n必须是Github上面的项目\n订阅了确定的事件（包括pushpull等命令）\n自动触发\n\n刚好符合了这几个条件，那接下来就看看如何进行网站自动化部署，主要会从下面几点来讲解：\n\n自动化shell脚本\n服务端实现\n配置github webhooks\n\n自动化脚本auto_build.sh\n1234567#! binbashSITE_PATH=rootnginxwwwcd $SITE_PATHgit reset --hard originmastergit clean -fgit pullgit checkout master\n\nNote: 在执行上面shell脚本之前我们必须第一次手动git clone项目进去\n服务端实现Github webhooks需要跟我们的服务器进行通信，确保是可以推送到我们的服务器，所以会发送一个带有X-Hub-Signature的POST请求，为了方便我们直接用第三方的库github-webhook-handler来接收参数并且做监听事件的处理等工作。\n1npm i github-webhook-handler -S\n\nindex.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(http);var spawn = require(child_process).spawn;var createHandler = require(github-webhook-handler); 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径var handler = createHandler(&#123; path: auto_build, secret:  &#125;);http.createServer(function (req, res) &#123;  handler(req, res, function (err) &#123;    res.statusCode = 404;    res.end(no such location);  &#125;)&#125;).listen(6666);handler.on(error, function (err) &#123;  console.error(Error:, err.message)&#125;); 监听到push事件的时候执行我们的自动化脚本handler.on(push, function (event) &#123;  console.log(Received a push event for %s to %s,    event.payload.repository.name,    event.payload.ref);  runCommand(sh, [auto_build.sh], function( txt )&#123;    console.log(txt);  &#125;);&#125;);function runCommand( cmd, args, callback )&#123;    var child = spawn( cmd, args );    var response = ;    child.stdout.on(data, function( buffer )&#123; resp += buffer.toString(); &#125;);    child.stdout.on(end, function()&#123; callback( resp ) &#125;);&#125; 由于我们不需要监听issues，所以下面代码注释掉  handler.on(issues, function (event) &#123;    console.log(Received an issue event for %s action=%s: #%d %s,      event.payload.repository.name,      event.payload.action,      event.payload.issue.number,      event.payload.issue.title)&#125;);\n\n配置github webhooks\n小结上面就是利用Github webhooks进行网站自动化部署的全部内容了，不难发现其实这项技术还是有局限性的，那就是依赖于github，一般我们选择的都是免费github账号，所有项目都对外，一些敏感项目是不适合放置上去的。\n","tags":["git","github","webhooks","自动化部署"],"path":"2019/09/09/Github的webhooks网站自动化部署/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/AI/" style="font-size: 0.8em; color: #488baf">AI</a> <a href="/tags/Docker/" style="font-size: 0.8em; color: #488baf">Docker</a> <a href="/tags/JVM/" style="font-size: 0.8em; color: #488baf">JVM</a> <a href="/tags/Java/" style="font-size: 1.4em; color: #8f655d">Java</a> <a href="/tags/Nodejs/" style="font-size: 0.8em; color: #488baf">Nodejs</a> <a href="/tags/OCR/" style="font-size: 0.8em; color: #488baf">OCR</a> <a href="/tags/Spring/" style="font-size: 0.8em; color: #488baf">Spring</a> <a href="/tags/TensorFlow/" style="font-size: 0.8em; color: #488baf">TensorFlow</a> <a href="/tags/electron/" style="font-size: 0.8em; color: #488baf">electron</a> <a href="/tags/git/" style="font-size: 1.1em; color: #6c7886">git</a> <a href="/tags/github/" style="font-size: 0.8em; color: #488baf">github</a> <a href="/tags/jad/" style="font-size: 0.8em; color: #488baf">jad</a> <a href="/tags/javascript/" style="font-size: 0.8em; color: #488baf">javascript</a> <a href="/tags/leetcode/" style="font-size: 1.7em; color: #b35133">leetcode</a> <a href="/tags/vue/" style="font-size: 0.8em; color: #488baf">vue</a> <a href="/tags/webhooks/" style="font-size: 0.8em; color: #488baf">webhooks</a> <a href="/tags/二叉树/" style="font-size: 0.8em; color: #488baf">二叉树</a> <a href="/tags/反编译/" style="font-size: 0.8em; color: #488baf">反编译</a> <a href="/tags/备份/" style="font-size: 0.8em; color: #488baf">备份</a> <a href="/tags/天平/" style="font-size: 0.8em; color: #488baf">天平</a> <a href="/tags/数据库/" style="font-size: 1.1em; color: #6c7886">数据库</a> <a href="/tags/文章/" style="font-size: 1.1em; color: #6c7886">文章</a> <a href="/tags/暴力破解/" style="font-size: 0.8em; color: #488baf">暴力破解</a> <a href="/tags/树/" style="font-size: 0.8em; color: #488baf">树</a> <a href="/tags/框架/" style="font-size: 0.8em; color: #488baf">框架</a> <a href="/tags/爱因斯坦/" style="font-size: 0.8em; color: #488baf">爱因斯坦</a> <a href="/tags/狂野飙车/" style="font-size: 0.8em; color: #488baf">狂野飙车</a> <a href="/tags/相对论/" style="font-size: 0.8em; color: #488baf">相对论</a> <a href="/tags/矩阵/" style="font-size: 0.8em; color: #488baf">矩阵</a> <a href="/tags/算法/" style="font-size: 2em; color: #d63e0a">算法</a> <a href="/tags/素数/" style="font-size: 0.8em; color: #488baf">素数</a> <a href="/tags/红黑树/" style="font-size: 0.8em; color: #488baf">红黑树</a> <a href="/tags/编程/" style="font-size: 1.7em; color: #b35133">编程</a> <a href="/tags/脚本/" style="font-size: 0.8em; color: #488baf">脚本</a> <a href="/tags/自动化部署/" style="font-size: 0.8em; color: #488baf">自动化部署</a> <a href="/tags/跑车/" style="font-size: 0.8em; color: #488baf">跑车</a> <a href="/tags/递归/" style="font-size: 1.4em; color: #8f655d">递归</a> <a href="/tags/链表/" style="font-size: 1.1em; color: #6c7886">链表</a> <a href="/tags/面试/" style="font-size: 1.4em; color: #8f655d">面试</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> 版权所有 <a href="">times </a> @ 2019</p>
            <p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        pageSize: 10,
        comment_count: true,
        appId: 'x8sFMx0q5JkG3Y3x6Q3wiVoe-gzGzoHsz',
        appKey: 'Dt5xQxK8HtOYoNAmGQoWVMa6',
        placeholder: 'just go go',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'z'
    });
</script>








    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    
<script type='text/javascript'>
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
