<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.9.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Time</title>
  

  
  
  <meta name="description" content>
  <meta name="author" content="times">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-134224598-1', 'auto');
	ga('send', 'pageview');
</script>


  <!-- include comment system code -->
  
    <link rel="stylesheet" href="/css/gitment/default.css">
<script src="/js/gitment.browser.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/theme-icon.svg' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">Time</a>
			</h1>
			<subtitle>
				time
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
			<li><a href="/categories/文章/"><img src="/images/文章.svg" alt="文章" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='文章'></a></li>
		
			<li><a href="/categories/算法/"><img src="/images/算法.svg" alt="算法" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='算法'></a></li>
		
			<li><a href="/categories/人工智能/"><img src="/images/人工智能.svg" alt="人工智能" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='人工智能'></a></li>
		
			<li><a href="/categories/生活/"><img src="/images/生活.svg" alt="生活" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='生活'></a></li>
		
			<li><a href="/categories/笔试/"><img src="/images/笔试.svg" alt="笔试" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='笔试'></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"118. 杨辉三角","date":"2019-08-31T15:25:17.000Z","content":"杨辉三角题目给定一个非负整数 numRows，生成杨辉三角的前 numRows行。\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n123456789输入: 5输出:[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]\n\n题解\n动态规划\n\n思路\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n算法\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 0 的特殊情况，否则我们会返回 [1]。如果 numRows &gt; 0，那么我们用 [1] 作为第一行来初始化 triangle with [1]，并按如下方式继续填充：\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;List&lt;Integer&gt;&gt;();         First base case; if user requests zero rows, they get zero rows.        if (numRows == 0) &#123;            return triangle;        &#125;         Second base case; first row is always [1].        triangle.add(new ArrayList&lt;&gt;());        triangle.get(0).add(1);        for (int rowNum = 1; rowNum &lt; numRows; rowNum++) &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            List&lt;Integer&gt; prevRow = triangle.get(rowNum-1);             The first row element is always 1.            row.add(1);             Each triangle element (other than the first and last of each row)             is equal to the sum of the elements above-and-to-the-left and             above-and-to-the-right.            for (int j = 1; j &lt; rowNum; j++) &#123;                row.add(prevRow.get(j-1) + prevRow.get(j));            &#125;             The last row element is always 1.            row.add(1);            triangle.add(row);        &#125;        return triangle;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(numRows²)\n\n虽然更新 triangle 中的每个值都是在常量时间内发生的，但它会被执行 O(numRows²) 次。想要了解原因，就需要考虑总共有多少次循环迭代。很明显外层循环需要运行 numRows 次，但在外层循环的每次迭代中，内层循环要运行 rowNumrowNum 次。因此，triangle 发生的更新总数为1 + 2 + 3 + ... + *numRows*，根据高斯公式有\n\n\n空间复杂度：O(numRows²)\n\n因为我们需要存储我们在 triangle 中更新的每个数字，所以空间需求与时间复杂度相同。\n\nPython解法\n\n1234567891011121314151617class Solution:    def generate(self, num_rows):        triangle = []        for row_num in range(num_rows):            # The first and last row elements are always 1.            row = [None for _ in range(row_num+1)]            row[0], row[-1] = 1, 1            # Each triangle element is equal to the sum of the elements            # above-and-to-the-left and above-and-to-the-right.            for j in range(1, len(row)-1):                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]            triangle.append(row)        return triangle\n\n\n递归解法\n\n通过numRows-1，求numRows行，递归求解\n1234567891011121314151617181920212223242526class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; listw = new ArrayList&lt;List&lt;Integer&gt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;Integer&gt; listn = new ArrayList&lt;Integer&gt;();        if (numRows == 0)            return listw;        generate(numRows - 1);        for (int i = 0; i &lt; numRows; i++) &#123;            if (i == 0) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 1) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 2) &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + 1);                continue;            &#125; else &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + listw.get(numRows - 2).get(i));            &#125;        &#125;        listw.add(listn);        return listw;    &#125;&#125;\n\n","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/118-杨辉三角/","external_link":""},{"title":"24. 两两交换链表中的节点","date":"2019-08-31T14:57:20.000Z","content":"\n24. 两两交换链表中的节点题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.题解\n非递归\n\n123456789101112131415161718192021222324** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; *class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0);        pre.next = head;        ListNode temp = pre;        while(temp.next != null &amp;&amp; temp.next.next != null) &#123;            ListNode start = temp.next;            ListNode end = temp.next.next;            temp.next = end;            start.next = end.next;            end.next = start;            temp = start;        &#125;        return pre.next;    &#125;&#125;\n\n\n递归解法\n\n详细介绍一下递归的思路;\n递归和栈处理问题类似,先把问题从前往后收集起来,然后再从后往前处理每一个问题;\n两两交换链表结点,先处理最后两个或一个节点,然后再从后往前处理每一对节点;\n先创建一个next临时结点保存head的下一个结点,然后让head指向下下一个节点,最后让 next节点指向head结点;\n此题只有处理完后面的结点才可处理前面的结点,画图更容易理解;\n\n\n\n\n123456789101112class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null)            return head;         三个节点顺序:head, next, swapPairs(next.next)        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;        return next;    &#125;&#125;","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/24-两两交换链表中的节点/","external_link":""},{"title":"334. 反转字符串","date":"2019-08-31T14:49:17.000Z","content":"\n334. 反转字符串题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1：\n输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：\n输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]    题解\n递归解法\n\n123456789101112131415class Solution &#123;    public void reverseString(char[] s) &#123;        swap(0, s.length-1, s);    &#125;        public void swap(int start, int end, char[] s) &#123;        if(start &gt;= end)&#123;            return;        &#125;        char temp = s[start];        s[start] = s[end];        s[end] = temp;        swap(start+1, end-1, s);    &#125;&#125;\n\n\n循环解法\n\n1234567891011class Solution &#123;    public void reverseString(char[] s) &#123;        int j=s.length-1;        for(int i=0;i&lt;s.length2;i++)&#123;            char tmp = s[i];            s[i] = s[j];            s[j] = tmp;            j--;        &#125;    &#125;&#125;\n\n\nPython解法\n\n12def reverseString(self, s: List[str]) -&gt; None:    s[0::]=s[::-1]\n\n\nc++解法\n\n双指针，交换头尾两个指针所指的两个位置的值，指针向中间移动一个位置，重复以上操作，直到两个指针交错；\n12345678910111213class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int i = 0;        int j = s.size() - 1;        while(i&lt;j)        &#123;            swap(s[i],s[j]);            ++ i;            -- j;        &#125;    &#125;&#125;;","tags":["算法","leetcode","递归"],"path":"2019/08/31/334-反转字符串/","external_link":""},{"title":"54. 螺旋矩阵","date":"2019-09-07T03:08:58.000Z","content":"\n54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n示例 1:\n1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]\n\n示例 2:\n1234567输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n方法 1：模拟直觉\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n算法\n假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。\n当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n1234567891011121314151617181920212223242526class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0) return ans;        int R = matrix.length, C = matrix[0].length;        boolean[][] seen = new boolean[R][C];        int[] dr = &#123;0, 1, 0, -1&#125;;        int[] dc = &#123;1, 0, -1, 0&#125;;        int r = 0, c = 0, di = 0;        for (int i = 0; i &lt; R * C; i++) &#123;            ans.add(matrix[r][c]);            seen[r][c] = true;            int cr = r + dr[di];            int cc = c + dc[di];            if (0 &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;                r = cr;                c = cc;            &#125; else &#123;                di = (di + 1) % 4;                r += dr[di];                c += dc[di];            &#125;        &#125;        return ans;    &#125;&#125;\n\n12345678910111213141516171819class Solution(object):    def spiralOrder(self, matrix):        if not matrix: return []        R, C = len(matrix), len(matrix[0])        seen = [[False] * C for _ in matrix]        ans = []        dr = [0, 1, 0, -1]        dc = [1, 0, -1, 0]        r = c = di = 0        for _ in range(R * C):            ans.append(matrix[r][c])            seen[r][c] = True            cr, cc = r + dr[di], c + dc[di]            if 0 &lt;= cr &lt; R and 0 &lt;= cc &lt; C and not seen[cr][cc]:                r, c = cr, cc            else:                di = (di + 1) % 4                r, c = r + dr[di], c + dc[di]        return ans\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要两个矩阵 seen 和 ans 存储所需信息。\n\n方法 2：按层模拟\n直觉\n答案是最外层所有元素按照顺时针顺序输出，其次是次外层，以此类推。\n算法\n我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，然后是第 3 层的。\n12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]]\n\n\n12345678910111213141516171819202122class Solution &#123;    public List &lt; Integer &gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0)            return ans;        int r1 = 0, r2 = matrix.length - 1;        int c1 = 0, c2 = matrix[0].length - 1;        while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;            for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);            for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]);            if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;                for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]);                for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);            &#125;            r1++;            r2--;            c1++;            c2--;        &#125;        return ans;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要矩阵 ans 存储信息。\n\n方法 3：顺时针旋转\n这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小\n\n首先设定上下左右边界\n其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界\n判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案\n若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理\n不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        int[][] matrix = new int[][] &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;        List&lt;Integer&gt; list = spiralOrder(matrix);        System.out.println(list);    &#125;    static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        if (matrix.length == 0)            return list;        int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1;        while (true) &#123;             向右            for (int i = l; i &lt;= r; i++)                list.add(matrix[u][i]);            if (++u &gt; d)                break;             向下            for (int i = u; i &lt;= d; i++)                list.add(matrix[i][r]);            if (--r &lt; l)                break;             向左            for (int i = r; i &gt;= l; i--)                list.add(matrix[d][i]);            if (--d &lt; u)                break;             向上            for (int i = d; i &gt;= u; i--)                list.add(matrix[i][l]);            if (++l &gt; r)                break;        &#125;        return list;    &#125;&#125;\n\n1234567891011121314151617181920212223class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        vector &lt;int&gt; ans;        if(matrix.empty()) return ans; 若数组为空，直接返回答案        int u = 0; 赋值上下左右边界        int d = matrix.size() - 1;        int l = 0;        int r = matrix[0].size() - 1;        while(true)        &#123;            for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); 向右移动直到最右            if(++ u &gt; d) break; 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同            for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); 向下            if(-- r &lt; l) break; 重新设定有边界            for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); 向左            if(-- d &lt; u) break; 重新设定下边界            for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); 向上            if(++ l &gt; r) break; 重新设定左边界        &#125;        return ans;    &#125;&#125;;","author":null,"tags":["leetcode","编程","矩阵"],"path":"2019/09/07/54-螺旋矩阵/","external_link":""},{"title":"Flutter Http请求开源库-dio","date":"2019-09-09T00:39:17.000Z","content":"文档语言: English | 中文简体\ndio\ndio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传下载、超时等…\n添加依赖12dependencies:  dio: ^x.x.x   请使用pub上的最新版本\n\n一个极简的示例12345678910import package:diodio.dart;void getHttp() async &#123;  try &#123;    Response response;    response = await Dio().get(http:www.baidu.com);    return print(response);  &#125; catch (e) &#123;    return print(e);  &#125;&#125;\n\n内容列表\n示例\nDio APIs\n请求配置\n响应数据\n拦截器\n错误处理\n使用applicationx-www-form-urlencoded编码\nFormData\n转换器\n设置Http代理\nHttps证书校验\n请求取消\nCookie管理\nFeatures and bugs\n\n示例发起一个 GET 请求 :\n1234567  Response response;  Dio dio = new Dio();  response = await dio.get(test?id=12&amp;name=wendu)  print(response.data.toString()); 请求参数也可以通过对象传递，上面的代码等同于：  response = await dio.get(test, data: &#123;id: 12, name: wendu&#125;);  print(response.data.toString());\n\n发起一个 POST 请求:\n1response = await dio.post(test, data: &#123;id: 12, name: wendu&#125;);\n\n发起多个并发请求:\n1response = await Future.wait([dio.post(info), dio.get(token)]);\n\n下载文件:\n1response = await dio.download(https:www.google.com, .xx.html);\n\n发送 FormData:\n12345FormData formData = new FormData.from(&#123;    name: wendux,    age: 25,  &#125;);  response = await dio.post(info, data: formData);\n\n通过FormData上传多个文件:\n1234567891011121314FormData formData = new FormData.from(&#123;  name: wendux,  age: 25,  file1: new UploadFileInfo(new File(.upload.txt), upload1.txt),  支持直接上传字节数组 (List&lt;int&gt;) ，方便直接上传内存中的内容  file2: new UploadFileInfo.fromBytes(      utf8.encode(hello world), word.txt),   支持文件数组上传  files: [    new UploadFileInfo(new File(.exampleupload.txt), upload.txt),    new UploadFileInfo(new File(.exampleupload.txt), upload.txt)  ]&#125;);response = await dio.post(info, data: formData);\n\n监听发送(上传)数据进度:\n1234567response = await dio.post(  http:www.dtworkroom.comdoris12.0.0test,  data: &#123;aa: bb * 22&#125;,  onUploadProgress: (int sent, int total) &#123;    print($sent $total);  &#125;,);\n\n…你可以在这里获取所有示例代码.\nDio APIs创建一个Dio实例，并配置它你可以使用默认配置或传递一个可选 Options参数来创建一个Dio实例 :\n12345678910111213Dio dio = new Dio;  使用默认配置 配置dio实例  dio.options.baseUrl = https:www.xx.comapi;  dio.options.connectTimeout = 5000; 5s  dio.options.receiveTimeout = 3000; 或者通过传递一个 `options`来创建dio实例  Options options = new Options(      baseUrl: https:www.xx.comapi,      connectTimeout: 5000,      receiveTimeout: 3000);  Dio dio = new Dio(options);\n\nDio实例的核心API是 :\nFuture request(String path, {data, Options options,CancelToken cancelToken})\n12response = await request(    test, data: &#123;id: 12, name: xx&#125;, new Options(method: GET));\n\n请求方法别名为了方便使用，Dio提供了一些其它的Restful API, 这些API都是request的别名。\nFuture get(path, {data, Options options,CancelToken cancelToken})\nFuture post(path, {data, Options options,CancelToken cancelToken})\nFuture put(path, {data, Options options,CancelToken cancelToken})\nFuture delete(path, {data, Options options,CancelToken cancelToken})\nFuture head(path, {data, Options options,CancelToken cancelToken})\nFuture put(path, {data, Options options,CancelToken cancelToken})\nFuture path(path, {data, Options options,CancelToken cancelToken})\nFuture download(String urlPath, savePath,​    {OnDownloadProgress onProgress, data, bool flush: false, Options options,CancelToken cancelToken})\n请求配置下面是所有的请求配置选项。 如果请求method没有指定，则默认为GET :\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123;   Http method.  String method;   请求基地址,可以包含子路径，如: https:www.google.comapi.  String baseUrl;   Http请求头.  Map&lt;String, dynamic&gt; headers;   连接服务器超时时间，单位是毫秒.  int connectTimeout;    响应流上前后两次接受到数据的间隔，单位为毫秒。如果两次间隔超过[receiveTimeout]，    [Dio] 将会抛出一个[DioErrorType.RECEIVE_TIMEOUT]的异常.    注意: 这并不是接收数据的总时限.  int receiveTimeout;   请求数据,可以是任意类型.  var data;   请求路径，如果 `path` 以 http(s)开始, 则 `baseURL` 会被忽略； 否则,   将会和baseUrl拼接出完整的的url.  String path = ;   请求的Content-Type，默认值是[ContentType.JSON].   如果您想以applicationx-www-form-urlencoded格式编码请求数据,   可以设置此选项为 `ContentType.parse(applicationx-www-form-urlencoded)`,  这样[Dio]   就会自动编码请求体.  ContentType contentType;   [responseType] 表示期望以那种格式(方式)接受响应数据。   目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`.     默认值是 `JSON`, 当响应头中content-type为applicationjson时，dio 会自动将响应内容转化为json对象。   如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`.     如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`.  ResponseType responseType;   `validateStatus` 决定http响应状态码是否被dio视为请求成功， 返回`validateStatus`    返回`true` , 请求结果就会按成功处理，否则会按失败处理.  ValidateStatus validateStatus;   用户自定义字段，可以在 [Interceptor]、[Transformer] 和 [Response] 中取到.  Map&lt;String, dynamic&gt; extra;&#125;\n\n这里有一个完成的示例.\n响应数据当请求成功时会返回一个Response对象，它包含如下字段：\n123456789101112&#123;   响应数据，可能已经被转换了类型, 详情请参考Options中的[ResponseType].  var data;   响应头  HttpHeaders headers;   本次请求信息  Options request;   Http status code.  int statusCode;   响应对象的自定义字段（可以在拦截器中设置它），调用方可以在`then`中获取.  Map&lt;String, dynamic&gt; extra;&#125;\n\n示例如下:\n12345Response response = await dio.get(https:www.google.com);print(response.data);print(response.headers);print(response.request);print(response.statusCode);\n\n拦截器每一个 Dio 实例都有一个请求拦截器  RequestInterceptor 和一个响应拦截器 ResponseInterceptor, 通过拦截器你可以在请求之前或响应之后(但还没有被 then 或 catchError处理)做一些统一的预处理操作。\n1234567891011121314151617dio.interceptor.request.onSend = (Options options)&#123;     在请求被发送之前做一些事情    return options; continue     如果你想完成请求并返回一些自定义数据，可以返回一个`Response`对象或返回`dio.resolve(data)`。     这样请求将会被终止，上层then会被调用，then中返回的数据将是你的自定义数据data.         如果你想终止请求并触发一个错误,你可以返回一个`DioError`对象，或返回`dio.reject(errMsg)`，     这样请求将被中止并触发异常，上层catchError会被调用。&#125;dio.interceptor.response.onSuccess = (Response response) &#123;     在返回响应数据之前做一些预处理    return response;  continue&#125;;dio.interceptor.response.onError = (DioError e)&#123;     当请求失败时做一些预处理    return e;continue&#125;\n\n如果你想移除拦截器，你可以将它们置为null:\n123dio.interceptor.request.onSend = null;dio.interceptor.response.onSuccess = null;dio.interceptor.response.onError = null;\n\n完成和终止请求响应在所有拦截器中，你都可以改变请求执行流， 如果你想完成请求响应并返回自定义数据，你可以返回一个 Response 对象或返回 dio.resolve(data)的结果。 如果你想终止(触发一个错误，上层catchError会被调用)一个请求响应，那么可以返回一个DioError 对象或返回 dio.reject(errMsg) 的结果.\n12345dio.interceptor.request.onSend = (Options options) &#123;  return dio.resolve(fake data)&#125;Response response = await dio.get(test);print(response.data); fake data\n\n拦截器中支持异步任务拦截器中不仅支持同步任务，而且也支持异步任务, 下面是在请求拦截器中发起异步任务的一个实例:\n1234567 dio.interceptor.request.onSend = (Options options) async &#123;    ...If no token, request token firstly.    Response response = await dio.get(token);    Set the token to headers    options.headers[token] = response.data[data][token];    return options; continue&#125;\n\nLockunlock 拦截器你可以通过调用拦截器的 lock()unlock 方法来锁定解锁拦截器。一旦请求响应拦截器被锁定，接下来的请求响应将会在进入请求响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行(进入拦截器)。这在一些需要串行化请求响应的场景中非常实用，后面我们将给出一个示例。\n12345678910111213tokenDio = new Dio(); Create a new instance to request the token.tokenDio.options = dio;dio.interceptor.request.onSend = (Options options) async &#123;   If no token, request token firstly and lock this interceptor   to prevent other request enter this interceptor.  dio.interceptor.request.lock();   We use a new Dio(to avoid dead lock) instance to request token.  Response response = await tokenDio.get(token);  Set the token to headers  options.headers[token] = response.data[data][token];  dio.interceptor.request.unlock();  return options; continue&#125;\n\nClear()\n你也可以调用拦截器的clear()方法来清空等待队列。\n别名当请求拦截器被锁定时，接下来的请求将会暂停，这等价于锁住了dio实例，因此，Dio示例上提供了请求拦截器lockunlock的别名方法：\ndio.lock() ==  dio.interceptor.request.lock()\ndio.unlock() ==  dio.interceptor.request.unlock()\ndio.clear() ==  dio.interceptor.request.clear()\n示例假设这么一个场景：出于安全原因，我们需要给所有的请求头中添加一个csrfToken，如果csrfToken不存在，我们先去请求csrfToken，获取到csrfToken后，再发起后续请求。 由于请求csrfToken的过程是异步的，我们需要在请求过程中锁定后续请求（因为它们需要csrfToken), 直到csrfToken请求成功后，再解锁，代码如下：\n1234567891011121314151617dio.interceptor.request.onSend = (Options options) &#123;    print(send request：path:$&#123;options.path&#125;，baseURL:$&#123;options.baseUrl&#125;);    if (csrfToken == null) &#123;      print(no token，request token firstly...);      lock the dio.      dio.lock();      return tokenDio.get(token).then((d) &#123;        options.headers[csrfToken] = csrfToken = d.data[data][token];        print(request token succeed, value:  + d.data[data][token]);        print(continue to perform request：path:$&#123;options.path&#125;，baseURL:$&#123;options.path&#125;);        return options;      &#125;).whenComplete(() =&gt; dio.unlock());  unlock the dio    &#125; else &#123;      options.headers[csrfToken] = csrfToken;      return options;    &#125;  &#125;;\n\n完整的示例代码请点击 这里.\n错误处理当请求过程中发生错误时, Dio 会包装 ErrorException 为一个 DioError:\n12345678910111213141516try &#123;  404  await dio.get(https:wendux.github.ioxsddddd);&#125; on DioError catch (e) &#123;   The request was made and the server responded with a status code   that falls out of the range of 2xx and is also not 304.  if (e.response) &#123;    print(e.response.data);    print(e.response.headers);    print(e.response.request);  &#125; else &#123;     Something happened in setting up or sending the request that triggered an Error    print(e.request);    print(e.message);  &#125;&#125;\n\nDioError 字段12345678910111213 &#123;   响应信息, 如果错误发生在在服务器返回数据之前，它为 `null`  Response response;   错误描述.  String message;   错误类型，见下文  DioErrorType type;   错误栈信息，可能为null  StackTrace stackTrace;&#125;\n\nDioErrorType12345678910111213141516171819enum DioErrorType &#123;   Default error type, usually occurs before connecting the server.  DEFAULT,   When opening  url timeout, it occurs.  CONNECT_TIMEOUT,    Whenever more than [receiveTimeout] (in milliseconds) passes between two events from response stream,    [Dio] will throw the [DioError] with [DioErrorType.RECEIVE_TIMEOUT].      Note: This is not the receiving time limitation.  RECEIVE_TIMEOUT,   When the server response, but with a incorrect status, such as 404, 503...  RESPONSE,   When the request is cancelled, dio will throw a error with this type.  CANCEL&#125;\n\n使用applicationx-www-form-urlencoded编码默认情况下, Dio 会将请求数据(除过String类型)序列化为 JSON. 如果想要以 applicationx-www-form-urlencoded格式编码, 你可以显式设置contentType :\n1234Instance leveldio.options.contentType=ContentType.parse(applicationx-www-form-urlencoded);or works oncedio.post(info,data:&#123;id:5&#125;, options: new Options(contentType:ContentType.parse(applicationx-www-form-urlencoded)));\n\n这里有一个示例.\nFormDataDio支持发送 FormData, 请求数据将会以 multipartform-data方式编码, FormData中可以一个或多个包含文件 .\n123456FormData formData = new FormData.from(&#123;    name: wendux,    age: 25,    file: new UploadFileInfo(new File(.exampleupload.txt), upload.txt)&#125;);response = await dio.post(info, data: formData);\n\n\n注意: 只有 post 方法支持发送 FormData.\n\n这里有一个完整的示例.\n转换器转换器Transformer 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器DefaultTransformer作为默认的 Transformer. 如果你想对请求响应数据进行自定义编解码处理，可以提供自定义转换器，通过 dio.transformer设置。\n\n请求转换器  Transformer.transformRequest(...)   只会被用于 ‘PUT’、 ‘POST’、 ‘PATCH’方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 Transformer.transformResponse() 会被用于所有请求方法的返回数据。\n\n执行流虽然在拦截器中也可以对数据进行预处理，但是转换器主要职责是对请求响应数据进行编解码，之所以将转化器单独分离，一是为了和拦截器解耦，二是为了不修改原始请求数据(如果你在拦截器中修改请求数据(options.data)，会覆盖原始请求数据，而在某些时候您可能需要原始请求数据). Dio的请求流是：\n请求拦截器 &gt;&gt; 请求转换器 &gt;&gt; 发起请求  &gt;&gt; 响应转换器  &gt;&gt; 响应拦截器  &gt;&gt; 最终结果。\n这是一个自定义转换器的示例.\n设置Http代理Dio 是使用 HttpClient发起的http请求，所以你可以通过配置 httpClient来支持代理，示例如下：\n12345678dio.onHttpClientCreate = (HttpClient client) &#123;  client.findProxy = (uri) &#123;    proxy all request to localhost:8888    return PROXY localhost:8888;  &#125;;   你也可以自己创建一个新的HttpClient实例返回。   return new HttpClient(SecurityContext);&#125;;\n\n完整的示例请查看这里.\nHttps证书校验有两种方法可以校验https证书，假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下：\n123456789String PEM=XXXXX; 证书内容dio.onHttpClientCreate = (HttpClient client) &#123;  client.badCertificateCallback=(X509Certificate cert, String host, int port)&#123;    if(cert.pem==PEM)&#123;  证书一致，则放行      return true;     &#125;    return false;  &#125;;&#125;;\n\nX509Certificate是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。\n对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到badCertificateCallback回调中：\n1234567dio.onHttpClientCreate = (HttpClient client) &#123;  SecurityContext sc = new SecurityContext();  file为证书路径  sc.setTrustedCertificates(file);  HttpClient httpClient = new HttpClient(context: sc);  return httpClient;&#125;;\n\n注意，通过setTrustedCertificates()设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。\n请求取消你可以通过 cancel token 来取消发起的请求：\n1234567891011CancelToken token = new CancelToken();dio.get(url, cancelToken: token)    .catchError((DioError err)&#123;        if (CancelToken.isCancel(err)) &#123;            print(Request canceled! + err.message)        &#125;else&#123;             handle error.        &#125;    &#125;); cancel the requests with cancelled message.token.cancel(cancelled);\n\n\n注意: 同一个cancel token 可以用于多个请求，当一个cancel token取消时，所有使用该cancel token的请求都会被取消。\n\n完整的示例请参考取消示例.\nCookie管理你可以通过 cookieJar 来自动管理请求响应cookie.\n\n dio cookie 管理 API 是基于开源库 cookie_jar.\n\n你可以创建一个CookieJar 或 PersistCookieJar 来帮您自动管理cookie,  dio 默认使用  CookieJar , 它会将cookie保存在内存中。 如果您想对cookie进行持久化,  请使用 PersistCookieJar ,  示例代码如下:\n12var dio = new Dio();dio.cookieJar = new PersistCookieJar(.cookies);\n\nPersistCookieJar 实现了RFC中标准的cookie策略.  PersistCookieJar 会将cookie保存在文件中，所以 cookies 会一直存在除非显式调用 delete 删除.\n更多关于 cookie_jar  请参考 : https:github.comflutterchinacookie_jar .\nCopyright &amp; License此开源项目为Flutter中文网(https:flutterchina.club) 授权 ，license 是 MIT.   如果您喜欢，欢迎star.\nFlutter中文网开源项目计划\n开发一系列Flutter SDK之外常用(实用)的Package、插件，丰富Flutter第三方库，为Flutter生态贡献来自中国开发者的力量。所有项目将发布在 Github Flutter中文网 Organization ，所有源码贡献者将加入到我们的Organization，成为成员. 目前社区已有几个开源项目开始公测，欢迎您加入开发或测试，详情请查看: Flutter中文网开源项目。 如果您想加入到“开源项目计划”， 请发邮件到824783146@qq.com， 并附上自我介绍(个人基本信息+擅长关注技术)。\nFeatures and bugsPlease file feature requests and bugs at the issue tracker.\n","tags":["Flutter","Http","dio"],"path":"2019/09/09/Flutter-Http请求开源库-dio/","external_link":""},{"title":"Git Rebase 黄金法则问题","date":"2019-09-10T13:45:18.000Z","content":"Git Rebase 黄金法则问题git 整合来自不同分支的修改主要有两种方法：merge 操作和rebase操作，merge初学者可能很熟悉。我们今天来主要说一下 rebase 操作，文章结尾会简单说一下 merge 操作的 –no-ff 参数问题。\nrebase的简单定义：你可以把某一分支的所有修改都移至另外一个分支就像重新播放一样。有点儿像金庸武侠小说里面的乾坤大挪移。举个🌰假设我们本地库的代码，如下所示\n123      A---B---C  remotesoriginmaster     D---E---F---G  master\n\n如果此时我们执行 git pull 操作，就会变成下面的样子，因为 pull 默认执行的是 merge 操作，多出来H这次没必要的提交。如下所示\n123     A---B---C  remotesoriginmaster              D---E---F---G---H master\n\n如果我们执行 git pull –rebase 操作，将会变成下面的样子，这里我们用rebase代替了默认的merge操作\n12345            remotesorigin                |D---E---A---B---C---F---G                        |                        master\n\nrebase 作用就是变成线性了，这在多人协作的情况变得非常关键。因为多人合作是不允许随意制造分叉的。大家可以参考我这篇文章。\n这就引出了这篇博文要主要阐述的问题，rebase golden rule 问题。\n\nRebase golden rule“No one shall rebase a shared branch” — Everyone about rebase\n\n简单来说就是不要在你的公共分支上做任何rebase操作。再举一个🌰。\n图一是我们做rebase操作前的样子\n\n图二是我们正确rebase的结果，即在feature分支执行rebase develop命令\n\n图三是我们错误rebase的结果，即违反黄金法则的结果，我们在develop分支上执行了rebase feature操作\n\n当我们在图三这种情况下对develop分支进行提交的话，会发现和远程分支冲突，然后我们手动或自动解决冲突，继续提交上去之后发现，我们修改的功能代码已经提交上去了，但是当我们看我们提交历史的记录的时候会发现有一部分重复的提交log。这就是问题所在，你的项目组长是绝对不允许在他的项目里出现这种情况，因为会影响后续的代码追查，code review等问题。说完了这个问题，这篇博文的主要任务基本完成了，最后在简单说一下 merge 的 –no-ff 参数，这也是我们在分支合并的时候经常遇到的问题。–no-ff 的意思就是关闭 merge 的 fast-forwarded，merge 操作默认执行的是 fast-forwarded。fast-forwarded 的意思就是在合并分支的时候，如果不涉及三方合并，git 只会简单的移动指针。再再举一个🌰\n1234567        dev        |A---B---C                   D---E              |              feature\n\n此时我们执行 merge –no-ff 操作，将会得到如下图\n12345                dev                |A---B---C--------F                         D---E\n\n执行 merge 之后得到的结果如下\n123               dev                |A---B---C---D---E\n\n如上git 将指针从C移到了E。\n简单来说就是 –no-ff 的作用就是保持分支的非线性。方便我们看到分支的变化。\n\n本文作者： Frank本文链接： http:hellofrank.github.io20180427Git-Rebase-黄金法则问题版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！\n\n","tags":["git"],"path":"2019/09/10/Git-Rebase-黄金法则问题/","external_link":""},{"title":"Github的webhooks网站自动化部署","date":"2019-09-08T23:56:41.000Z","content":"Github的webhooks进行网站自动化部署\n相信很多码农都玩过了Git，如果对Git只是一知半解，可以移步LV写的 GIT常用操作总结，下面介绍到的一些关于 Git 的概念就不再赘述。\n为啥想写这篇文章？主要是因为部门服务器因为安全性原因不允许SCP上传文件进行应用部署，然后有一些应用是放在Github上的，然后部署应用的步骤就变成：\n1.git clone github项目 本地目录2.配置一下应用的pm2.json并reload3.Nginx配置一下反向代理并restart\n当然如果只是一次性部署上去就不再修改的话并没啥问题，但是要是项目持续性修改迭代的话，就比较麻烦了，我们就在不断的重复着上面的步骤。作为一个码农，怎么允许不断的重复同样的工作，于是Github webhooks闪亮登场。\n关于Github webhooks\n必须是Github上面的项目\n订阅了确定的事件（包括pushpull等命令）\n自动触发\n\n刚好符合了这几个条件，那接下来就看看如何进行网站自动化部署，主要会从下面几点来讲解：\n\n自动化shell脚本\n服务端实现\n配置github webhooks\n\n自动化脚本auto_build.sh\n1234567#! binbashSITE_PATH=rootnginxwwwcd $SITE_PATHgit reset --hard originmastergit clean -fgit pullgit checkout master\n\nNote: 在执行上面shell脚本之前我们必须第一次手动git clone项目进去\n服务端实现Github webhooks需要跟我们的服务器进行通信，确保是可以推送到我们的服务器，所以会发送一个带有X-Hub-Signature的POST请求，为了方便我们直接用第三方的库github-webhook-handler来接收参数并且做监听事件的处理等工作。\n1npm i github-webhook-handler -S\n\nindex.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(http);var spawn = require(child_process).spawn;var createHandler = require(github-webhook-handler); 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径var handler = createHandler(&#123; path: auto_build, secret:  &#125;);http.createServer(function (req, res) &#123;  handler(req, res, function (err) &#123;    res.statusCode = 404;    res.end(no such location);  &#125;)&#125;).listen(6666);handler.on(error, function (err) &#123;  console.error(Error:, err.message)&#125;); 监听到push事件的时候执行我们的自动化脚本handler.on(push, function (event) &#123;  console.log(Received a push event for %s to %s,    event.payload.repository.name,    event.payload.ref);  runCommand(sh, [auto_build.sh], function( txt )&#123;    console.log(txt);  &#125;);&#125;);function runCommand( cmd, args, callback )&#123;    var child = spawn( cmd, args );    var response = ;    child.stdout.on(data, function( buffer )&#123; resp += buffer.toString(); &#125;);    child.stdout.on(end, function()&#123; callback( resp ) &#125;);&#125; 由于我们不需要监听issues，所以下面代码注释掉  handler.on(issues, function (event) &#123;    console.log(Received an issue event for %s action=%s: #%d %s,      event.payload.repository.name,      event.payload.action,      event.payload.issue.number,      event.payload.issue.title)&#125;);\n\n配置github webhooks\n小结上面就是利用Github webhooks进行网站自动化部署的全部内容了，不难发现其实这项技术还是有局限性的，那就是依赖于github，一般我们选择的都是免费github账号，所有项目都对外，一些敏感项目是不适合放置上去的。\n","tags":["git","github","webhooks","自动化部署"],"path":"2019/09/09/Github的webhooks网站自动化部署/","external_link":""},{"title":"Electron-vue","date":"2019-09-08T03:09:19.000Z","content":"\nElectron-vue\n基于 vue (基本上是它听起来的样子) 来构造 electron 应用程序的样板代码。\n\n什么是electron?\n\nelectron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。\n它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：\n\nMain进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。\nRenderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在3. Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。Main进程和Renderer进程通过ipcMain和ipcRenderer来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。\n\n起步该样板代码被构建为 vue-cli 的一个模板，并且包含多个选项，可以自定义你最终的脚手架程序。本项目需要使用 node@^7 或更高版本。electron-vue 官方推荐 yarn 作为软件包管理器，因为它可以更好地处理依赖关系，并可以使用 yarn clean 帮助减少最后构建文件的大小。\n12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgregelectron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev\n\n项目结构12345678910111213141516171819202122232425262728293031323334353637my-project├─ .electron-vue│  └─ &lt;builddevelopment&gt;.js files├─ build│  └─ icons├─ dist│  ├─ electron│  └─ web├─ node_modules├─ src│  ├─ main│  │  ├─ index.dev.js│  │  └─ index.js│  ├─ renderer│  │  ├─ components│  │  ├─ router│  │  ├─ store│  │  ├─ App.vue│  │  └─ main.js│  └─ index.ejs├─ static├─ test│  ├─ e2e│  │  ├─ specs│  │  ├─ index.js│  │  └─ utils.js│  ├─ unit│  │  ├─ specs│  │  ├─ index.js│  │  └─ karma.config.js│  └─ .eslintrc├─ .babelrc├─ .eslintignore├─ .eslintrc.js├─ .gitignore├─ package.json└─ README.md\n\n产品构建123456789app.asar├─ dist│  └─ electron│     ├─ static│     ├─ index.html│     ├─ main.js│     └─ renderer.js├─ node_modules└─ package.json\n\n运行效果\n","tags":["electron","vue"],"path":"2019/09/08/Electron-vue/","external_link":""},{"title":"Java面试题（框架+JVM+多线程+算法+数据库）","date":"2019-08-24T08:20:38.000Z","content":"\n基础与框架\nString类能被继承吗，为什么\nString，Stringbuffer，StringBuilder的区别？\nArrayList和LinkedList有什么区别\n类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序\n用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等\nHashMap为什么get和set那么快，concurrentHashMap为什么能提高并发\n抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\n什么情况下会发生栈内存溢出\n什么是nio，原理\n反射中，Class.forName和ClassLoader区别\ntomcat结构，类加载器流程\n讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式\nSpring的beanFactory和factoryBean的区别\nSpring加载流程\nSpring如何管理事务的\n\n多线程\n线城池的最大线程数目根据什么确定\n多线程的几种实现方式，什么是线程安全，什么是重排序3.volatile的原理，作用，能代替锁么\nsleep和wait的区别，以及wait的实现原理\nLock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁\n用过哪些原子类，他们的参数以及原理是什么\n用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等\n有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。\nspring的controller是单例还是多例，怎么保证并发的安全\n用三个线程按顺序循环打印abc三个字母，比如abcabcabc\nThreadLocal用过么，原理是什么，用的时候要注意什么\n如果让你实现一个并发安全的链表，你会怎么做\n\nJVM相关\njvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等\n你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms\n当出现了内存溢出，你怎么排错\nJVM内存模型的相关知识了解多少\n简单说说你了解的类加载器\nJAVA的反射机制\n\n网络\nhttp1.0和http1.1有什么区别\nTCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么\nTIME_WAIT和CLOSE_WAIT的区别\n说说你知道的几种HTTP响应码\n当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤\nLinux下IO模型有几种，各自的含义是什么\nTCPIP如何保证可靠性，数据包有哪些数据组成\n架构设计与分布式：\ntomcat如何调优，各种参数的意义\n常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等\n如何防止缓存雪崩12.用java自己实现一个LRU\n分布式集群下如何做到唯一序列号\n设计一个秒杀系统，30分钟没付款就自动关闭交易\n如何做一个分布式锁\n用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗\nMQ系统的数据如何保证不丢失\n分布式事务的原理，如何使用分布式事务\n什么是一致性hash\n什么是restful，讲讲你理解的restful\n如何设计建立和保持100w的长连接？\n解释什么是MESI协议(缓存一致性)\n说说你知道的几种HASH算法，简单的也可以\n什么是paxos算法\nredis和memcached 的内存管理的区别\n一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新\n\n算法\n10亿个数字里里面找最小的10个2、有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优3、2亿个随机生成的无序整数,找出中间大小的值4、遍历二叉树六、数据库1.数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点\n高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义\nSQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？\n数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁\nMYsql的索引实现方式\n聚集索引和非聚集索引的区别\n数据库中 BTREE和B+tree区别\n\n作者：程序汪追风链接：https:juejin.impost5d5fd40bf265da03df5f1b3a来源：掘金\n","tags":["算法","面试","数据库","JVM","框架"],"path":"2019/08/24/Java面试题（框架-JVM-多线程-算法-数据库）/","external_link":""},{"title":"Spring框架面试总结","date":"2019-09-03T16:32:24.000Z","content":"\n介绍spring框架它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。\nSpring的优点？\n降低了组件之间的耦合性 ，实现了软件各层之间的解耦 \n可以使用容易提供的众多服务，如事务管理，消息服务等 \n容器提供单例模式支持 \n容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 \n容器提供了众多的辅助类，能加快应用的开发 \nspring对于主流的应用框架提供了集成支持，如hibernate，   JPA，Struts等 \nspring属于低侵入式设计，代码的污染极低 \n独立于各种应用服务器 \nspring的DI机制降低了业务对象替换的复杂性 \nSpring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring 的部分或全部 \n\nspring有两种代理方式：答: 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。\n  优点：因为有接口，所以使系统更加松耦合\n  缺点：为每一个目标类创建接口\n若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。\n  优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。\n  缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好\n如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。\nXML配置文件。\n基于注解的配置。\n基于java的配置。\n构造方法注入和设值注入有什么区别？请注意以下明显的区别：\n在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。\n对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。\n在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。\n设值注入不会重写构造方法的值。\n在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。\n请介绍一下Spring框架中Bean的生命周期一、Bean的定义 \nSpring通常通过配置文件定义Bean。如：  \n这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 \n二、Bean的初始化\n有两种方式初始化Bean。 \n1、在配置文档中通过指定init-method 属性来完成 \n2、实现 org.springframwork.beans.factory.InitializingBean接口  \n那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 \n三、Bean的调用 \n有三种方式可以得到Bean并进行调用： \n1、使用BeanWrapper\n2、使用BeanFactory\n3、使用ApplicationConttext\n四、Bean的销毁 \n1、使用配置文件中的 destory-method 属性\n2、实现 org.springframwork.bean.factory.DisposebleBean接口 \nSpring中AOP的应用场景、Aop原理、好处？答：AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:\nAuthentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务\n原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。\n优点：1.各个步骤之间的良好隔离性耦合性大大降低 \n2.源代码无关性，再扩展功能的同时不对源码进行修改操作 有几种不同类型的自动代理？BeanNameAutoProxyCreator\nDefaultAdvisorAutoProxyCreator\nMetadata autoproxying\nApplicationContext通常的实现是什么?FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\nClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\nWebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。\n有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\nSetter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。\n什么是IOC，什么又是DI，他们有什么区别？一、IOC介绍\nIOC是控制反转。\n创建对象实例的控制权从代码控制剥离到IOC容器控制(之前的写法，由程序代码直接操控使用new关键字)，实际就是你在xml文件控制，控制权的转移是所谓反转，侧重于原理。 \n二、DI介绍\nDI是依赖注入\n创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。\nspring事务定义事务的定义：事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么都成功。其必须遵循四个原则（ACID）。\n原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做；\n一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。\n隔离性（Isolation）：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；\n持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。\nSpring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。\n","tags":["面试","Spring"],"path":"2019/09/04/Spring框架面试总结/","external_link":""},{"title":"Java反编译工具jad","date":"2019-09-06T05:21:38.000Z","content":"\nJad(JAva Decompiler)Jad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。下载点击\n使用方法：\n[1] 反编译一个class文件：jad example.class，会生成example.jad，用文本编辑器打开就是java源代码\n[2] 指定生成源代码的后缀名：jad -sjava example.class，生成example.java\n[3] 改变生成的源代码的名称，可以先使用-p将反编译后的源代码输出到控制台窗口，然后使用重定向，输出到文件：jad -p example.class &gt; myexample.java\n[4] 把源代码文件输出到指定的目录：jad -dnewdir -sjava example.class，在newdir目录下生成example.java\n[5] 把packages目录下的class文件全部反编译：jad -sjava packages*.class\n[6] 把packages目录以及子目录下的文件全部反编译：jad -sjava packages*.class，不过你仍然会发现所有的源代码文件被放到了同一个文件中，没有按照class文件的包路径建立起路径\n[7] 把packages目录以及子目录下的文件全部反编译并建立和java包一致的文件夹路径，可以使用-r命令：jad -r -sjava packages*.class\n[8] 当重复使用命令反编译时，Jad会提示“whether you want to overwrite it or not”，使用-o可以强制覆盖旧文件\n[9] 还有其他的参数可以设置生成的源代码的格式，可以输入jad命令查看帮助，这里有个人做了简单的翻译：jad命令总结\n[10] 当然，你会发现有些源文件头部有些注释信息，不用找了，jad没有参数可以去掉它，用别的办法吧。\n测试Main.java\n123456789101112131415161718192021222324252627282930public class Main &#123;    static volatile int t = 0;    public static void main(String[] args) &#123;        int n = 100;        Thread[] threads = new Thread[n];        for (int i = 0; i &lt; n; i++) &#123;            threads[i] = new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i = 0; i &lt; 10000; i++) &#123;                        add();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        while (Thread.activeCount() &gt; 1)            Thread.yield();        System.out.println(t);    &#125;    static void add() &#123;        t++;    &#125;&#125;\n\nMain.class\n1234567891011121314151617cafe babe 0000 0034 0037 0a00 0d00 1d07001e 0700 1f0a 0003 001d 0a00 0200 200a0002 0021 0a00 0200 220a 0002 0023 09002400 2509 000c 0026 0a00 2700 2807 00290700 2a01 000c 496e 6e65 7243 6c61 73736573 0100 0174 0100 0149 0100 063c 696e6974 3e01 0003 2829 5601 0004 436f 64650100 0f4c 696e 654e 756d 6265 7254 61626c65 0100 046d 6169 6e01 0016 285b 4c6a6176 612f 6c61 6e67 2f53 7472 696e 673b2956 0100 0d53 7461 636b 4d61 7054 61626c65 0700 2b01 0003 6164 6401 0008 3c636c69 6e69 743e 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0011 0012 0100 106a 6176 612f 6c61 6e672f54 6872 6561 6401 0006 4d61 696e 2431...\n\n\n反编译后的结果\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. Jad home page: http:www.kpdus.comjad.html Decompiler options: packimports(3)  Source File Name:   Main.javaimport java.io.PrintStream;public class Main&#123;    public Main()    &#123;    &#125;    public static void main(String args[])    &#123;        byte byte0 = 100;        Thread athread[] = new Thread[byte0];        for(int i = 0; i &lt; byte0; i++)        &#123;            athread[i] = new Thread(new Runnable() &#123;                public void run()                &#123;                    for(int j = 0; j &lt; 10000; j++)                        Main.add();                &#125;            &#125;);            athread[i].start();        &#125;        for(; Thread.activeCount() &gt; 1; Thread.yield());        System.out.println(t);    &#125;    static void add()    &#123;        t++;    &#125;    static volatile int t = 0;&#125;\n\n","tags":["Java","反编译","jad"],"path":"2019/09/06/Java反编译工具jad/","external_link":""},{"title":"TensorFlow 2.0 中文手写字识别（汉字OCR）","date":"2019-09-06T07:08:56.000Z","content":"\nTensorFlow 2.0 中文手写字识别（汉字OCR）\n搜索空间空前巨大，我们使用的数据集1.0版本汉字就多大3755个，如果加上1.1版本一起，总共汉字可以分为多达7599+个类别！这比10个阿拉伯字母识别难度大很多！\n数据集处理挑战更大，相比于mnist和fasionmnist来说，汉字手写字体识别数据集非常少，而且仅有的数据集数据预处理难度非常大，非常不直观，但是，千万别吓到，相信你看完本教程一定会收货满满!\n汉字识别更考验选手的建模能力，还在分类花？分类猫和狗？随便搭建的几层在搜索空间巨大的汉字手写识别里根本不work！你现在是不是想用很深的网络跃跃欲试？更深的网络在这个任务上可能根本不可行！！看完本教程我们就可以一探究竟！总之一句话，模型太简单和太复杂都不好，甚至会发散！（想亲身体验模型训练发散抓狂的可以来尝试一下！）。\n\n数据准备在开始之前，先介绍一下本项目所采用的数据信息。我们的数据全部来自于CASIA的开源中文手写字数据集，该数据集分为两部分：\n\nCASIA-HWDB：离线的HWDB，我们仅仅使用1.0-1.2，这是单字的数据集，2.0-2.2是整张文本的数据集，我们暂时不用，单字里面包含了约7185个汉字以及171个英文字母、数字、标点符号等；\nCASIA-OLHWDB：在线的HWDB，格式一样，包含了约7185个汉字以及171个英文字母、数字、标点符号等，我们不用。\n\n其实你下载1.0的train和test差不多已经够了，可以直接运行 datasetget_hwdb_1.0_1.1.sh 下载。原始数据下载链接点击这里. 由于原始数据过于复杂，我们使用一个类来封装数据读取过程，这是我们展示的效果：\n看到这么密密麻麻的文字相信连人类都…. 开始头疼了，这些复杂的文字能够通过一个神经网络来识别出来？？答案是肯定的…. 不有得感叹一下神经网络的强大。。上面的部分文字识别出来的结果是这样的：\n\n关于数据的处理部分，从服务器下载到的原始数据是 trn_gnt.zip 解压之后是 gnt.alz， 需要再次解压得到一个包含 gnt文件的文件夹。里面每一个gnt文件都包含了若干个汉字及其标注。直接处理比较麻烦，也不方便抽取出图片再进行操作，虽然转为图片存入文件夹比较直观，但是不适合批量读取和训练, 后面我们统一转为tfrecord进行训练。\n更新: 实际上，由于单个汉字图片其实很小，差不多也就最大80x80的大小，这个大小不适合转成图片保存到本地，因此我们将hwdb原始的二进制保存为tfrecord。同时也方便后面训练，可以直接从tfrecord读取图片进行训练。\n\n训练过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def train():    all_characters = load_characters()    num_classes = len(all_characters)    logging.info(all characters: &#123;&#125;.format(num_classes))    train_dataset = load_ds()    train_dataset = train_dataset.shuffle(100).map(preprocess).batch(32).repeat()    val_ds = load_val_ds()    val_ds = val_ds.shuffle(100).map(preprocess).batch(32).repeat()    for data in train_dataset.take(2):        print(data)    # init model    model = build_net_003((64, 64, 1), num_classes)    model.summary()    logging.info(model loaded.)    start_epoch = 0    latest_ckpt = tf.train.latest_checkpoint(os.path.dirname(ckpt_path))    if latest_ckpt:        start_epoch = int(latest_ckpt.split(-)[1].split(.)[0])        model.load_weights(latest_ckpt)        logging.info(model resumed from: &#123;&#125;, start at epoch: &#123;&#125;.format(latest_ckpt, start_epoch))    else:        logging.info(passing resume since weights not there. training from scratch)    if use_keras_fit:        model.compile(            optimizer=tf.keras.optimizers.Adam(),            loss=tf.keras.losses.SparseCategoricalCrossentropy(),            metrics=[accuracy])        callbacks = [            tf.keras.callbacks.ModelCheckpoint(ckpt_path,                                               save_weights_only=True,                                               verbose=1,                                               period=500)        ]        try:            model.fit(                train_dataset,                validation_data=val_ds,                validation_steps=1000,                epochs=15000,                steps_per_epoch=1024,                callbacks=callbacks)        except KeyboardInterrupt:            model.save_weights(ckpt_path.format(epoch=0))            logging.info(keras model saved.)        model.save_weights(ckpt_path.format(epoch=0))        model.save(os.path.join(os.path.dirname(ckpt_path), cn_ocr.h5))\n\n大家在以后编写训练代码的时候其实可以保持这个好的习惯。\nOK，整个模型训练起来之后，可以在短时间内达到95%的准确率：\n\n\n总结通过本教程，我们完成了使用tensorflow 2.0全新的API搭建一个中文汉字手写识别系统。模型基本能够实现我们想要的功能。要知道，这个模型可是在搜索空间多大3755的类别当中准确的找到最相似的类别！！通过本实验，我们有几点心得：\n\n神经网络不仅仅是在学习，它具有一定的想象力！！比如它的一些看着很像的字：拜-佯， 扮-捞，笨-苯…. 这些字如果手写出来，连人都比较难以辨认！！但是大家要知道这些字在类别上并不是相领的！也就是说，模型具有一定的联想能力！\n不管问题多复杂，要敢于动手、善于动手。\n\n","tags":["AI","TensorFlow","OCR"],"path":"2019/09/06/TensorFlow-2-0-中文手写字识别（汉字OCR）/","external_link":""},{"title":"System类","date":"2019-09-06T06:20:34.000Z","content":"\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256* * Copyright (c) 1994, 2013, Oracle andor its affiliates. All rights reserved. * ORACLE PROPRIETARYCONFIDENTIAL. Use is subject to license terms. * * *package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;** * The &lt;code&gt;System&lt;code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author  unascribed * @since   JDK1.0 *public final class System &#123;    * register the natives via the static initializer.     *     * VM will invoke the initializeSystemClass method to complete     * the initialization for this class separated from clinit.     * Note that to use properties set by the VM, see the constraints     * described in the initializeSystemClass method.     *    private static native void registerNatives();    static &#123;        registerNatives();    &#125;    ** Dont let anyone instantiate this class *    private System() &#123;    &#125;    **     * The standard input stream. This stream is already     * open and ready to supply input data. Typically this stream     * corresponds to keyboard input or another input source specified by     * the host environment or user.     *    public final static InputStream in = null;    **     * The standard output stream. This stream is already     * open and ready to accept output data. Typically this stream     * corresponds to display output or another output destination     * specified by the host environment or user.     * &lt;p&gt;     * For simple stand-alone Java applications, a typical way to write     * a line of output data is:     * &lt;blockquote&gt;&lt;pre&gt;     *     System.out.println(data)     * &lt;pre&gt;&lt;blockquote&gt;     * &lt;p&gt;     * See the &lt;code&gt;println&lt;code&gt; methods in class &lt;code&gt;PrintStream&lt;code&gt;.     *     * @see     java.io.PrintStream#println()     * @see     java.io.PrintStream#println(boolean)     * @see     java.io.PrintStream#println(char)     * @see     java.io.PrintStream#println(char[])     * @see     java.io.PrintStream#println(double)     * @see     java.io.PrintStream#println(float)     * @see     java.io.PrintStream#println(int)     * @see     java.io.PrintStream#println(long)     * @see     java.io.PrintStream#println(java.lang.Object)     * @see     java.io.PrintStream#println(java.lang.String)     *    public final static PrintStream out = null;    **     * The standard error output stream. This stream is already     * open and ready to accept output data.     * &lt;p&gt;     * Typically this stream corresponds to display output or another     * output destination specified by the host environment or user. By     * convention, this output stream is used to display error messages     * or other information that should come to the immediate attention     * of a user even if the principal output stream, the value of the     * variable &lt;code&gt;out&lt;code&gt;, has been redirected to a file or other     * destination that is typically not continuously monitored.     *    public final static PrintStream err = null;    * The security manager for the system.     *    private static volatile SecurityManager security = null;    **     * Reassigns the standard input stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard input stream.     * &lt;p&gt;     *     * @param in the new standard input stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard input stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setIn(InputStream in) &#123;        checkIO();        setIn0(in);    &#125;    **     * Reassigns the standard output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard output stream.     *     * @param out the new standard output stream     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setOut(PrintStream out) &#123;        checkIO();        setOut0(out);    &#125;    **     * Reassigns the standard error output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard error output stream.     *     * @param err the new standard error output stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard error output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setErr(PrintStream err) &#123;        checkIO();        setErr0(err);    &#125;    private static volatile Console cons = null;    **     * Returns the unique &#123;@link java.io.Console Console&#125; object associated     * with the current Java virtual machine, if any.     *     * @return  The system console, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @since   1.6     *     public static Console console() &#123;         if (cons == null) &#123;             synchronized (System.class) &#123;                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();             &#125;         &#125;         return cons;     &#125;    **     * Returns the channel inherited from the entity that created this     * Java virtual machine.     *     * &lt;p&gt; This method returns the channel obtained by invoking the     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125; method of the system-wide default     * &#123;@link java.nio.channels.spi.SelectorProvider&#125; object. &lt;p&gt;     *     * &lt;p&gt; In addition to the network-oriented channels described in     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125;, this method may return other kinds of     * channels in the future.     *     * @return  The inherited channel, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @throws  IOException     *          If an IO error occurs     *     * @throws  SecurityException     *          If a security manager is present and it does not     *          permit access to the channel.     *     * @since 1.5     *    public static Channel inheritedChannel() throws IOException &#123;        return SelectorProvider.provider().inheritedChannel();    &#125;    private static void checkIO() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(setIO));        &#125;    &#125;    private static native void setIn0(InputStream in);    private static native void setOut0(PrintStream out);    private static native void setErr0(PrintStream err);    **     * Sets the System security.     *     * &lt;p&gt; If there is a security manager already installed, this method first     * calls the security managers &lt;code&gt;checkPermission&lt;code&gt; method     * with a &lt;code&gt;RuntimePermission(setSecurityManager)&lt;code&gt;     * permission to ensure its ok to replace the existing     * security manager.     * This may result in throwing a &lt;code&gt;SecurityException&lt;code&gt;.     *     * &lt;p&gt; Otherwise, the argument is established as the current     * security manager. If the argument is &lt;code&gt;null&lt;code&gt; and no     * security manager has been established, then no action is taken and     * the method simply returns.     *     * @param      s   the security manager.     * @exception  SecurityException  if the security manager has already     *             been set and its &lt;code&gt;checkPermission&lt;code&gt; method     *             doesnt allow it to be replaced.     * @see #getSecurityManager     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *    public static    void setSecurityManager(final SecurityManager s) &#123;        try &#123;            s.checkPackageAccess(java.lang);        &#125; catch (Exception e) &#123;             no-op        &#125;        setSecurityManager0(s);    &#125;    private static synchronized    void setSecurityManager0(final SecurityManager s) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;             ask the currently installed security manager if we             can replace it.            sm.checkPermission(new RuntimePermission                                     (setSecurityManager));        &#125;        if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) &#123;             New security manager class is not on bootstrap classpath.             Cause policy to get initialized before we install the new             security manager, in order to prevent infinite loops when             trying to initialize the policy (which usually involves             accessing some security andor system properties, which in turn             calls the installed security managers checkPermission method             which will loop infinitely if there is a non-system class             (in this case: the new security manager class) on the stack).            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;                public Object run() &#123;                    s.getClass().getProtectionDomain().implies                        (SecurityConstants.ALL_PERMISSION);                    return null;                &#125;            &#125;);        &#125;        security = s;    &#125;    **     * Gets the system security interface.     *     * @return  if a security manager has already been established for the     *          current application, then that security manager is returned;     *          otherwise, &lt;code&gt;null&lt;code&gt; is returned.     * @see     #setSecurityManager     *    public static SecurityManager getSecurityManager() &#123;        return security;    &#125;    **     * Returns the current time in milliseconds.  Note that     * while the unit of time of the return value is a millisecond,     * the granularity of the value depends on the underlying     * operating system and may be larger.  For example, many     * operating systems measure time in units of tens of     * milliseconds.     *     * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;code&gt; for     * a discussion of slight discrepancies that may arise between     * computer time and coordinated universal time (UTC).     *     * @return  the difference, measured in milliseconds, between     *          the current time and midnight, January 1, 1970 UTC.     * @see     java.util.Date     *    public static native long currentTimeMillis();    **     * Returns the current value of the running Java Virtual Machines     * high-resolution time source, in nanoseconds.     *     * &lt;p&gt;This method can only be used to measure elapsed time and is     * not related to any other notion of system or wall-clock time.     * The value returned represents nanoseconds since some fixed but     * arbitrary &lt;i&gt;origin&lt;i&gt; time (perhaps in the future, so values     * may be negative).  The same origin is used by all invocations of     * this method in an instance of a Java virtual machine; other     * virtual machine instances are likely to use a different origin.     *     * &lt;p&gt;This method provides nanosecond precision, but not necessarily     * nanosecond resolution (that is, how frequently the value changes)     * - no guarantees are made except that the resolution is at least as     * good as that of &#123;@link #currentTimeMillis()&#125;.     *     * &lt;p&gt;Differences in successive calls that span greater than     * approximately 292 years (2&lt;sup&gt;63&lt;sup&gt; nanoseconds) will not     * correctly compute elapsed time due to numerical overflow.     *     * &lt;p&gt;The values returned by this method become meaningful only when     * the difference between two such values, obtained within the same     * instance of a Java virtual machine, is computed.     *     * &lt;p&gt; For example, to measure how long some code takes to execute:     *  &lt;pre&gt; &#123;@code     * long startTime = System.nanoTime();     *  ... the code being measured ...     * long estimatedTime = System.nanoTime() - startTime;&#125;&lt;pre&gt;     *     * &lt;p&gt;To compare two nanoTime values     *  &lt;pre&gt; &#123;@code     * long t0 = System.nanoTime();     * ...     * long t1 = System.nanoTime();&#125;&lt;pre&gt;     *     * one should use &#123;@code t1 - t0 &lt; 0&#125;, not &#123;@code t1 &lt; t0&#125;,     * because of the possibility of numerical overflow.     *     * @return the current value of the running Java Virtual Machines     *         high-resolution time source, in nanoseconds     * @since 1.5     *    public static native long nanoTime();    **     * Copies an array from the specified source array, beginning at the     * specified position, to the specified position of the destination array.     * A subsequence of array components are copied from the source     * array referenced by &lt;code&gt;src&lt;code&gt; to the destination array     * referenced by &lt;code&gt;dest&lt;code&gt;. The number of components copied is     * equal to the &lt;code&gt;length&lt;code&gt; argument. The components at     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; in the source array are copied into     * positions &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+length-1&lt;code&gt;, respectively, of the destination     * array.     * &lt;p&gt;     * If the &lt;code&gt;src&lt;code&gt; and &lt;code&gt;dest&lt;code&gt; arguments refer to the     * same array object, then the copying is performed as if the     * components at positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; were first copied to a temporary     * array with &lt;code&gt;length&lt;code&gt; components and then the contents of     * the temporary array were copied into positions     * &lt;code&gt;destPos&lt;code&gt; through &lt;code&gt;destPos+length-1&lt;code&gt; of the     * destination array.     * &lt;p&gt;     * If &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown.     * &lt;p&gt;     * If &lt;code&gt;src&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown and the destination     * array is not modified.     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown and the destination is     * not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;dest&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument and &lt;code&gt;dest&lt;code&gt; argument refer     *     to arrays whose component types are different primitive types.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a primitive     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a reference component type.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a reference     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a primitive component type.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;IndexOutOfBoundsException&lt;code&gt; is     * thrown and the destination is not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;srcPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;destPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;length&lt;code&gt; argument is negative.     * &lt;li&gt;&lt;code&gt;srcPos+length&lt;code&gt; is greater than     *     &lt;code&gt;src.length&lt;code&gt;, the length of the source array.     * &lt;li&gt;&lt;code&gt;destPos+length&lt;code&gt; is greater than     *     &lt;code&gt;dest.length&lt;code&gt;, the length of the destination array.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any actual component of the source array from     * position &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; cannot be converted to the component     * type of the destination array by assignment conversion, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown. In this case, let     * &lt;b&gt;&lt;i&gt;k&lt;i&gt;&lt;b&gt; be the smallest nonnegative integer less than     * length such that &lt;code&gt;src[srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;]&lt;code&gt;     * cannot be converted to the component type of the destination     * array; when the exception is thrown, source array components from     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;-1&lt;code&gt;     * will already have been copied to destination array positions     * &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+&lt;code&gt;&lt;i&gt;k&lt;I&gt;&lt;code&gt;-1&lt;code&gt; and no other     * positions of the destination array will have been modified.     * (Because of the restrictions already itemized, this     * paragraph effectively applies only to the situation where both     * arrays have component types that are reference types.)     *     * @param      src      the source array.     * @param      srcPos   starting position in the source array.     * @param      dest     the destination array.     * @param      destPos  starting position in the destination data.     * @param      length   the number of array elements to be copied.     * @exception  IndexOutOfBoundsException  if copying would cause     *               access of data outside array bounds.     * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;code&gt;     *               array could not be stored into the &lt;code&gt;dest&lt;code&gt; array     *               because of a type mismatch.     * @exception  NullPointerException if either &lt;code&gt;src&lt;code&gt; or     *               &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     *    public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);    **     * Returns the same hash code for the given object as     * would be returned by the default method hashCode(),     * whether or not the given objects class overrides     * hashCode().     * The hash code for the null reference is zero.     *     * @param x object for which the hashCode is to be calculated     * @return  the hashCode     * @since   JDK1.1     *    public static native int identityHashCode(Object x);    **     * System properties. The following properties are guaranteed to be defined:     * &lt;dl&gt;     * &lt;dt&gt;java.version         &lt;dd&gt;Java version number     * &lt;dt&gt;java.vendor          &lt;dd&gt;Java vendor specific string     * &lt;dt&gt;java.vendor.url      &lt;dd&gt;Java vendor URL     * &lt;dt&gt;java.home            &lt;dd&gt;Java installation directory     * &lt;dt&gt;java.class.version   &lt;dd&gt;Java class version number     * &lt;dt&gt;java.class.path      &lt;dd&gt;Java classpath     * &lt;dt&gt;os.name              &lt;dd&gt;Operating System Name     * &lt;dt&gt;os.arch              &lt;dd&gt;Operating System Architecture     * &lt;dt&gt;os.version           &lt;dd&gt;Operating System Version     * &lt;dt&gt;file.separator       &lt;dd&gt;File separator ( on Unix)     * &lt;dt&gt;path.separator       &lt;dd&gt;Path separator (: on Unix)     * &lt;dt&gt;line.separator       &lt;dd&gt;Line separator (n on Unix)     * &lt;dt&gt;user.name            &lt;dd&gt;User account name     * &lt;dt&gt;user.home            &lt;dd&gt;User home directory     * &lt;dt&gt;user.dir             &lt;dd&gt;Users current working directory     * &lt;dl&gt;     *    private static Properties props;    private static native Properties initProperties(Properties props);    **     * Determines the current system properties.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The current set of system properties for use by the     * &#123;@link #getProperty(String)&#125; method is returned as a     * &lt;code&gt;Properties&lt;code&gt; object. If there is no current set of     * system properties, a set of system properties is first created and     * initialized. This set of system properties always includes values     * for the following keys:     * &lt;table summary=Shows property keys and associated values&gt;     * &lt;tr&gt;&lt;th&gt;Key&lt;th&gt;     *     &lt;th&gt;Description of Associated Value&lt;th&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor.url&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java vendor URL&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java installation directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class format version number&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.library.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;List of paths to search when loading libraries&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.io.tmpdir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Default temp file path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.compiler&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Name of JIT compiler to use&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.ext.dirs&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path of extension directory or directories     *         &lt;b&gt;Deprecated.&lt;b&gt; &lt;i&gt;This property, and the mechanism     *            which implements it, may be removed in a future     *            release.&lt;i&gt; &lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.arch&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system architecture&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;file.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;File separator ( on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;path.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path separator (: on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;line.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Line separator (n on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users account name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users home directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.dir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users current working directory&lt;td&gt;&lt;tr&gt;     * &lt;table&gt;     * &lt;p&gt;     * Multiple paths in a system property value are separated by the path     * separator character of the platform.     * &lt;p&gt;     * Note that even if the security manager does not permit the     * &lt;code&gt;getProperties&lt;code&gt; operation, it may choose to permit the     * &#123;@link #getProperty(String)&#125; operation.     *     * @return     the system properties     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #setProperties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @see        java.util.Properties     *    public static Properties getProperties() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        return props;    &#125;    **     * Returns the system-dependent line separator string.  It always     * returns the same value - the initial value of the &#123;@linkplain     * #getProperty(String) system property&#125; &#123;@code line.separator&#125;.     *     * &lt;p&gt;On UNIX systems, it returns &#123;@code n&#125;; on Microsoft     * Windows systems it returns &#123;@code rn&#125;.     *     * @return the system-dependent line separator string     * @since 1.7     *    public static String lineSeparator() &#123;        return lineSeparator;    &#125;    private static String lineSeparator;    **     * Sets the system properties to the &lt;code&gt;Properties&lt;code&gt;     * argument.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The argument becomes the current set of system properties for use     * by the &#123;@link #getProperty(String)&#125; method. If the argument is     * &lt;code&gt;null&lt;code&gt;, then the current set of system properties is     * forgotten.     *     * @param      props   the new system properties.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #getProperties     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     *    public static void setProperties(Properties props) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        if (props == null) &#123;            props = new Properties();            initProperties(props);        &#125;        System.props = props;    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the key as     * its argument. This may result in a SecurityException.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @return     the string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key);    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the     * &lt;code&gt;key&lt;code&gt; as its argument.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @param      def   a default value.     * @return     the string value of the system property,     *             or the default value if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *             access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key, String def) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key, def);    &#125;    **     * Sets the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is set to the given     * value.     * &lt;p&gt;     *     * @param      key   the name of the system property.     * @param      value the value of the system property.     * @return     the previous value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if it did not have one.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *             setting of the specified property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; or     *             &lt;code&gt;value&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        java.lang.System#getProperty(java.lang.String)     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)     * @see        java.util.PropertyPermission     * @see        SecurityManager#checkPermission     * @since      1.2     *    public static String setProperty(String key, String value) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key,                SecurityConstants.PROPERTY_WRITE_ACTION));        &#125;        return (String) props.setProperty(key, value);    &#125;    **     * Removes the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is removed.     * &lt;p&gt;     *     * @param      key   the name of the system property to be removed.     * @return     the previous string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there was no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        #setProperty     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @since 1.5     *    public static String clearProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key, write));        &#125;        return (String) props.remove(key);    &#125;    private static void checkKey(String key) &#123;        if (key == null) &#123;            throw new NullPointerException(key cant be null);        &#125;        if (key.equals()) &#123;            throw new IllegalArgumentException(key cant be empty);        &#125;    &#125;    **     * Gets the value of the specified environment variable. An     * environment variable is a system-dependent external named     * value.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.+name)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125;     * being thrown.  If no exception is thrown the value of the     * variable &lt;code&gt;name&lt;code&gt; is returned.     *     * &lt;p&gt;&lt;a name=EnvironmentVSSystemProperties&gt;&lt;i&gt;System     * properties&lt;i&gt; and &lt;i&gt;environment variables&lt;i&gt;&lt;a&gt; are both     * conceptually mappings between names and values.  Both     * mechanisms can be used to pass user-defined information to a     * Java process.  Environment variables have a more global effect,     * because they are visible to all descendants of the process     * which defines them, not just the immediate Java subprocess.     * They can have subtly different semantics, such as case     * insensitivity, on different operating systems.  For these     * reasons, environment variables are more likely to have     * unintended side effects.  It is best to use system properties     * where possible.  Environment variables should be used when a     * global effect is desired, or when an external system interface     * requires an environment variable (such as &lt;code&gt;PATH&lt;code&gt;).     *     * &lt;p&gt;On UNIX systems the alphabetic case of &lt;code&gt;name&lt;code&gt; is     * typically significant, while on Microsoft Windows systems it is     * typically not.  For example, the expression     * &lt;code&gt;System.getenv(FOO).equals(System.getenv(foo))&lt;code&gt;     * is likely to be true on Microsoft Windows.     *     * @param  name the name of the environment variable     * @return the string value of the variable, or &lt;code&gt;null&lt;code&gt;     *         if the variable is not defined in the system environment     * @throws NullPointerException if &lt;code&gt;name&lt;code&gt; is &lt;code&gt;null&lt;code&gt;     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the environment variable     *         &lt;code&gt;name&lt;code&gt;     * @see    #getenv()     * @see    ProcessBuilder#environment()     *    public static String getenv(String name) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.+name));        &#125;        return ProcessEnvironment.getenv(name);    &#125;    **     * Returns an unmodifiable string map view of the current system environment.     * The environment is a system-dependent mapping from names to     * values which is passed from parent to child processes.     *     * &lt;p&gt;If the system does not support environment variables, an     * empty map is returned.     *     * &lt;p&gt;The returned map will never contain null keys or values.     * Attempting to query the presence of a null key or value will     * throw a &#123;@link NullPointerException&#125;.  Attempting to query     * the presence of a key or value which is not of type     * &#123;@link String&#125; will throw a &#123;@link ClassCastException&#125;.     *     * &lt;p&gt;The returned map and its collection views may not obey the     * general contract of the &#123;@link Object#equals&#125; and     * &#123;@link Object#hashCode&#125; methods.     *     * &lt;p&gt;The returned map is typically case-sensitive on all platforms.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.*)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125; being     * thrown.     *     * &lt;p&gt;When passing information to a Java subprocess,     * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;a&gt;     * are generally preferred over environment variables.     *     * @return the environment as a map of variable names to values     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the process environment     * @see    #getenv(String)     * @see    ProcessBuilder#environment()     * @since  1.5     *    public static java.util.Map&lt;String,String&gt; getenv() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.*));        &#125;        return ProcessEnvironment.getenv();    &#125;    **     * Terminates the currently running Java Virtual Machine. The     * argument serves as a status code; by convention, a nonzero status     * code indicates abnormal termination.     * &lt;p&gt;     * This method calls the &lt;code&gt;exit&lt;code&gt; method in class     * &lt;code&gt;Runtime&lt;code&gt;. This method never returns normally.     * &lt;p&gt;     * The call &lt;code&gt;System.exit(n)&lt;code&gt; is effectively equivalent to     * the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().exit(n)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      status   exit status.     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow exit with the specified status.     * @see        java.lang.Runtime#exit(int)     *    public static void exit(int status) &#123;        Runtime.getRuntime().exit(status);    &#125;    **     * Runs the garbage collector.     * &lt;p&gt;     * Calling the &lt;code&gt;gc&lt;code&gt; method suggests that the Java Virtual     * Machine expend effort toward recycling unused objects in order to     * make the memory they currently occupy available for quick reuse.     * When control returns from the method call, the Java Virtual     * Machine has made a best effort to reclaim space from all discarded     * objects.     * &lt;p&gt;     * The call &lt;code&gt;System.gc()&lt;code&gt; is effectively equivalent to the     * call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().gc()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#gc()     *    public static void gc() &#123;        Runtime.getRuntime().gc();    &#125;    **     * Runs the finalization methods of any objects pending finalization.     * &lt;p&gt;     * Calling this method suggests that the Java Virtual Machine expend     * effort toward running the &lt;code&gt;finalize&lt;code&gt; methods of objects     * that have been found to be discarded but whose &lt;code&gt;finalize&lt;code&gt;     * methods have not yet been run. When control returns from the     * method call, the Java Virtual Machine has made a best effort to     * complete all outstanding finalizations.     * &lt;p&gt;     * The call &lt;code&gt;System.runFinalization()&lt;code&gt; is effectively     * equivalent to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().runFinalization()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#runFinalization()     *    public static void runFinalization() &#123;        Runtime.getRuntime().runFinalization();    &#125;    **     * Enable or disable finalization on exit; doing so specifies that the     * finalizers of all objects that have finalizers that have not yet been     * automatically invoked are to be run before the Java runtime exits.     * By default, finalization on exit is disabled.     *     * &lt;p&gt;If there is a security manager,     * its &lt;code&gt;checkExit&lt;code&gt; method is first called     * with 0 as its argument to ensure the exit is allowed.     * This could result in a SecurityException.     *     * @deprecated  This method is inherently unsafe.  It may result in     *      finalizers being called on live objects while other threads are     *      concurrently manipulating those objects, resulting in erratic     *      behavior or deadlock.     * @param value indicating enabling or disabling of finalization     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow the exit.     *     * @see     java.lang.Runtime#exit(int)     * @see     java.lang.Runtime#gc()     * @see     java.lang.SecurityManager#checkExit(int)     * @since   JDK1.1     *    @Deprecated    public static void runFinalizersOnExit(boolean value) &#123;        Runtime.runFinalizersOnExit(value);    &#125;    **     * Loads the native library specified by the filename argument.  The filename     * argument must be an absolute path name.     *     * If the filename argument, when stripped of any platform-specific library     * prefix, path, and file extension, indicates a library whose name is,     * for example, L, and a native library called L is statically linked     * with the VM, then the JNI_OnLoad_L function exported by the library     * is invoked rather than attempting to load a dynamic library.     * A filename matching the argument does not have to exist in the     * file system.     * See the JNI Specification for more details.     *     * Otherwise, the filename argument is mapped to a native library image in     * an implementation-dependent manner.     *     * &lt;p&gt;     * The call &lt;code&gt;System.load(name)&lt;code&gt; is effectively equivalent     * to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().load(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      filename   the file to load.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError  if either the filename is not an     *             absolute path name, the native library is not statically     *             linked with the VM, or the library cannot be mapped to     *             a native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;filename&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#load(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void load(String filename) &#123;        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);    &#125;    **     * Loads the native library specified by the &lt;code&gt;libname&lt;code&gt;     * argument.  The &lt;code&gt;libname&lt;code&gt; argument must not contain any platform     * specific prefix, file extension or path. If a native library     * called &lt;code&gt;libname&lt;code&gt; is statically linked with the VM, then the     * JNI_OnLoad_&lt;code&gt;libname&lt;code&gt; function exported by the library is invoked.     * See the JNI Specification for more details.     *     * Otherwise, the libname argument is loaded from a system library     * location and mapped to a native library image in an implementation-     * dependent manner.     * &lt;p&gt;     * The call &lt;code&gt;System.loadLibrary(name)&lt;code&gt; is effectively     * equivalent to the call     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().loadLibrary(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      libname   the name of the library.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError if either the libname argument     *             contains a file path, the native library is not statically     *             linked with the VM,  or the library cannot be mapped to a     *             native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#loadLibrary(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void loadLibrary(String libname) &#123;        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);    &#125;    **     * Maps a library name into a platform-specific string representing     * a native library.     *     * @param      libname the name of the library.     * @return     a platform-dependent native library name.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.System#loadLibrary(java.lang.String)     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)     * @since      1.2     *    public static native String mapLibraryName(String libname);    **     * Create PrintStream for stdouterr based on encoding.     *    private static PrintStream newPrintStream(FileOutputStream fos, String enc) &#123;       if (enc != null) &#123;            try &#123;                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);            &#125; catch (UnsupportedEncodingException uee) &#123;&#125;        &#125;        return new PrintStream(new BufferedOutputStream(fos, 128), true);    &#125;    **     * Initialize the system class.  Called after thread initialization.     *    private static void initializeSystemClass() &#123;         VM might invoke JNU_NewStringPlatform() to set those encoding         sensitive properties (user.home, user.name, boot.class.path, etc.)         during props initialization, in which it may need access, via         System.getProperty(), to the related system encoding property that         have been initialized (put into props) at early stage of the         initialization. So make sure the props is available at the         very beginning of the initialization and all system properties to         be put into it directly.        props = new Properties();        initProperties(props);   initialized by the VM         There are certain system configurations that may be controlled by         VM options such as the maximum amount of direct memory and         Integer cache size used to support the object identity semantics         of autoboxing.  Typically, the library will obtain these values         from the properties set by the VM.  If the properties are for         internal implementation use only, these properties should be         removed from the system properties.                 See java.lang.Integer.IntegerCache and the         sun.misc.VM.saveAndRemoveProperties method for example.                 Save a private copy of the system properties object that         can only be accessed by the internal implementation.  Remove         certain system properties that are not intended for public access.        sun.misc.VM.saveAndRemoveProperties(props);        lineSeparator = props.getProperty(line.separator);        sun.misc.Version.init();        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);        setIn0(new BufferedInputStream(fdIn));        setOut0(newPrintStream(fdOut, props.getProperty(sun.stdout.encoding)));        setErr0(newPrintStream(fdErr, props.getProperty(sun.stderr.encoding)));         Load the zip library now in order to keep java.util.zip.ZipFile         from trying to use itself to load this library later.        loadLibrary(zip);         Setup Java signal handlers for HUP, TERM, and INT (where available).        Terminator.setup();         Initialize any miscellenous operating system settings that need to be         set for the class libraries. Currently this is no-op everywhere except         for Windows where the process-wide error mode is set before the java.io         classes are used.        sun.misc.VM.initializeOSEnvironment();         The main thread is not added to its thread group in the same         way as other threads; we must do it ourselves here.        Thread current = Thread.currentThread();        current.getThreadGroup().add(current);         register shared secrets        setJavaLangAccess();         Subsystems that are invoked during initialization can invoke         sun.misc.VM.isBooted() in order to avoid doing things that should         wait until the application class loader has been set up.         IMPORTANT: Ensure that this remains the last initialization action!        sun.misc.VM.booted();    &#125;    private static void setJavaLangAccess() &#123;         Allow privileged classes outside of java.lang        sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess()&#123;            public sun.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) &#123;                return klass.getConstantPool();            &#125;            public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) &#123;                return klass.casAnnotationType(oldType, newType);            &#125;            public AnnotationType getAnnotationType(Class&lt;?&gt; klass) &#123;                return klass.getAnnotationType();            &#125;            public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) &#123;                return klass.getDeclaredAnnotationMap();            &#125;            public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawAnnotations();            &#125;            public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawTypeAnnotations();            &#125;            public byte[] getRawExecutableTypeAnnotations(Executable executable) &#123;                return Class.getExecutableTypeAnnotationBytes(executable);            &#125;            public &lt;E extends Enum&lt;E&gt;&gt;                    E[] getEnumConstantsShared(Class&lt;E&gt; klass) &#123;                return klass.getEnumConstantsShared();            &#125;            public void blockedOn(Thread t, Interruptible b) &#123;                t.blockedOn(b);            &#125;            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) &#123;                Shutdown.add(slot, registerShutdownInProgress, hook);            &#125;            public int getStackTraceDepth(Throwable t) &#123;                return t.getStackTraceDepth();            &#125;            public StackTraceElement getStackTraceElement(Throwable t, int i) &#123;                return t.getStackTraceElement(i);            &#125;            public String newStringUnsafe(char[] chars) &#123;                return new String(chars, true);            &#125;            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) &#123;                return new Thread(target, acc);            &#125;            public void invokeFinalize(Object o) throws Throwable &#123;                o.finalize();            &#125;        &#125;);    &#125;&#125;\n\n","tags":["编程","Java"],"path":"2019/09/06/System类/","external_link":""},{"title":"三阶魔方解法","date":"2019-09-12T10:09:12.000Z","content":"三阶魔方解法预备篇：三阶魔方相关知识在本教程中，统一使用官方配色（上黄、下白、左橙、右红、前蓝、后绿），并在还原的过程中，白色作为底色。\n下图中，A、B、C分别表示顶层、中层、底层；D为中心块，在还原的过程中以此作为参照色（即该面所最终还原的颜色）；E为棱块，每块有两个颜色；F为角块，每块有三个颜色。\n在本教程中，分别用Front、Back、Left、Right、Up、Down的首字母表示前面、后面、左面、右面、上面、下面的顺时针90度旋转，带撇号的为逆时针90度逆转，带数字2的为180度旋转。\n\n\n第一步：完成底层四棱子步骤一：拼成黄心白瓣小花如下图①所示，我们只要在黄色中心块的四周的棱块都挨着白色即可。\n对于在中层的白色棱，如②所示，只需转一个90度即可将白色朝上；对于在顶层、底层朝外的白色棱，如③所示，先在白色所在面转动90度后变成②的情况再处理；而在底层朝下的白色棱，如④所示，则通过180度旋转即可将白色朝上。\n值得留意的是⑤之类的情况，如果直接转90度将中层白色块朝上，那么会破坏掉上方原先已有的白色块。此时要先转动顶层（此例为U’），将空位转到对应位置，方可使该白色块转上去。\n\n子步骤二：找到相应颜色并掉落花瓣先随意选定一个白色棱（下图以白红棱为例），转动顶层（或扭转中底层），直到该棱侧面的颜色与中心块吻合时，以该中心块为轴转动180度，使其落到白色中心旁边。用同样的方法处理其他三个棱之后，在底层会形成白色的十字，棱的侧面也与中心块相连。\n\n第二步：完成底层四角这一步我们不仅要让白色的四角全都聚集在下面，还要留意其角块侧面的颜色也要吻合。\n如下图的上半部分所示，我们先在顶层寻找含白色的角块，同时观察该角块另外两种颜色，转动顶层（或扭转中底层），使之处在相应颜色的两个中心块之间。\n当角块转到相应位置后，观察白色的朝向，做相应的公式：\n①为白色朝右，做U’ F’ U F；②为白色朝前，做U R U’ R’；③为白色朝上，做三遍的公式①。当顶层无任何白色角块时，此时再观察底层有无错误朝向或位置的白色角块：\n④在底层，白色朝右，做两遍的公式①；⑤在底层，白色朝前，做两遍的公式②；⑥在底层，错误位置角块，先做公式①将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个角之后，底面为全白色，侧面会形成倒T字。\n\n第三步：完成中层四棱如下图的上半部分所示，我们先在顶层寻找不含黄色的棱块，同时观察该棱块另外两种颜色，转动顶层（或扭转中底层），使之朝外的颜色与中心块相吻合。\n当棱块转到相应位置后，观察最终所归的空位，并将空位置于右前方，做相应的公式（前面的公式①与②，在这里称为甲与乙）：\n①情况做U’ F’ U F U R U’ R’（先甲后乙）；②情况做U R U’ R’ U’ F’ U F（先乙后甲）；当顶层全为有黄色的棱块时，此时再观察中层有无错误朝向或位置的棱块：\n③与④情况，先做甲+乙将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个棱之后，第二层即完成。\n\n第四步：完成顶面十字现在观察顶面的棱与中心块所构成的图形（忽视角块黄色是否朝上与否）分为“点、线、拐、十字”四种情况。找到相应的情况并按图示朝向摆放后，按照下流程图每次做R’ U’ F’ U F R（R’+甲+R）直到变成十字为止。其中“线”的情况还有一条捷径，即F R U R’ U’ F’。\nCube solve 7a.png\n第五步：调整顶棱顺序先转动顶层（或扭转中底层），直到至少有两个棱侧面的颜色与中心块吻合。\n现在观察另外两个错误的棱处于相邻还是相对位置，如果没有，则此步跳过；如果是相邻的，则将两个错误的置一前一右，做丙公式U’ F’ U’ F U’ F’ U2 F；如果是相对的，则将两个错误的置一左一后，先做丙公式，然后转下顶层变为相邻的，再置一前一右做丙公式完成。\nCube solve 8.png\n第六步：调整顶角顺序观察顶角，找到在正确位置的一个角（朝向是否正确暂时不考虑）。如果四角都在正确位置，则此步跳过；如果只有一个，则将正确的角置于左前方，做丁公式U’ L’ U R U’ L U R’（做一遍仍未成功则再做第二遍）；如果没有一个角在正确位置，则先做丁公式然后变成有一个角在正确位置再相应处理。\nCube solve 9.png\n第七步：调整顶角朝向此时我们统一将蓝色中心块保持前面放置，需要注意的是在操作的过程中魔方的底层会被暂时性打乱，不过不要紧，只要正确操作完后魔方会正常还原。\n观察顶层前右方的角块的黄色朝向，做戊公式F’ R F R’二或四遍使黄色朝上。完成一个角块的朝向处理之后，要转动顶层（U、U’、U2），并保持蓝色中心块在前面不动，再处理其他角块朝向。(在每一角落都要扭)\nCube solve 10.png\n维基百科\n","tags":["魔方"],"path":"2019/09/12/三阶魔方解法/","external_link":""},{"title":"git教程","date":"2019-08-16T07:47:37.000Z","content":"名称git - 愚蠢的内容跟踪器\n概要git [--version] [ -  help] [-C &lt;path&gt;] [-c &lt;name&gt; = &lt;value&gt;]\n    [--exec-path [= &lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n    [-p | --paginate | -P | --no-pager] [ -  no-replace-objects] [--bare]\n    [--git-dir = &lt;path&gt;] [ -  work-tree = &lt;path&gt;] [--namespace = &lt;name&gt;]\n    [--super前缀= &lt;路径&gt;]\n    &lt;command&gt; [&lt;args&gt;]描述Git是一个快速，可扩展的分布式版本控制系统，具有异常丰富的命令集，可提供高级操作和对内部的完全访问。\n请参阅gittutorial [7]以开始使用，然后查看 giteveryday [7]以获取有用的最小命令集。在Git的用户手册有一个更深入的介绍。\n掌握了基本概念后，您可以回到此页面了解Git提供的命令。您可以使用“git help command”了解有关各个Git命令的更多信息。 gitcli [7] 手册页概述了命令行命令语法。\n可以在以下位置查看最新Git文档的格式化和超链接副本https:git.github.iohtmldocsgit.html。\nOPTIONS\n版打印git程序来自的Git套件版本。\n\n救命打印概要和最常用命令的列表。如果选择–all或-a已给出，则打印所有可用命令。如果命名了Git命令，则此选项将显示该命令的手册页。\n\n\n其他选项可用于控制手册页的显示方式。有关更多信息，请参阅git-help [1]，因为git –help …内部转换为git help …。\n-C &lt;路径&gt;运行就好像git是在而不是当前工作目录中启动的。当-C给出多个选项时，-C 相对于前面的每个后续非绝对值被解释-C 。如果存在但是为空，例如-C “”，则保持当前工作目录不变。\n此选项会影响预期的路径名的选项一样–git-dir，并 –work-tree在他们的路径名的解释，将相对于所造成的工作目录进行-C选择。例如，以下调用是等效的：\ngit --git-dir = a.git --work-tree = b -C c status\ngit --git-dir = c  a.git --work-tree = c  b status-c  = 将配置参数传递给命令。给定的值将覆盖配置文件中的值。的格式与git config列出的格式相同 （以点分隔的子键）。\n请注意，允许省略=in git -c foo.bar …并设置 foo.bar为布尔值true（就像[foo]bar在配置文件中一样）。包括equals但空值（如git -c foo.bar= …）设置foo.bar为git config –type=bool将转换为的空字符串false。\n–exec路径[= &lt;路径&gt;]安装核心Git程序的路径。这也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径，git将打印当前设置然后退出。\n–html路径打印路径，不带斜杠，安装Git的HTML文档并退出。\n–man路径打印manpath（请参阅参考资料man(1)）获取此版本Git的手册页并退出。\n–info路径打印安装记录此版本Git的Info文件的路径并退出。\n-p–paginate如果标准输出是终端，则将所有输出传输到较少（或如果设置为$ PAGER）。这将覆盖pager. 配置选项（请参阅下面的“配置机制”部分）。\n-P–no寻呼机不要将Git输出传输到寻呼机。\n–git-DIR = &lt;路径&gt;设置存储库的路径。这也可以通过设置GIT_DIR环境变量来控制。它可以是当前工作目录的绝对路径或相对路径。\n\n共同努力树= &lt;路径&gt;设置工作树的路径。它可以是绝对路径或相对于当前工作目录的路径。这也可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制（有关更详细的讨论，请参阅git-config [1]中的core.worktree ）。\n\n–namespace = &lt;路径&gt;设置Git名称空间。有关更多详细信息，请参阅gitnamespaces [7]。相当于设置GIT_NAMESPACE环境变量。\n–super前缀= &lt;路径&gt;目前仅供内部使用。设置一个前缀，该前缀提供从存储库上方到其根目录的路径。一个用途是给出调用它的超级项目的子模块上下文。\n\n裸将存储库视为裸存储库。如果未设置GIT_DIR环境，则将其设置为当前工作目录。\n\n–no替换对象不要使用替换引用来替换Git对象。有关更多信息，请参阅 git-replace [1]。\n–literal按本义，pathspecs按字面意思处理pathspecs（即没有globbing，没有pathspec魔法）。这相当于将GIT_LITERAL_PATHSPECS环境变量设置为1。\n–glob-pathspecs为所有pathspec添加“glob”魔法。这相当于将GIT_GLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( literal）”在各个pathspec上禁用通配符\n–noglob-pathspecs为所有pathspec添加“literal”魔法。这相当于将GIT_NOGLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( glob）”在各个pathspec上启用globbing\n–icase-pathspecs为所有pathspec添加“icase”魔法。这相当于将GIT_ICASE_PATHSPECS环境变量设置为1。\n–no-可选锁不要执行需要锁定的可选操作。这相当于设置GIT_OPTIONAL_LOCKS为0。\n–list-CMDS =基团[，组…]按组列出命令。这是一个内部实验选项，可能会在将来更改或删除。支持的组包括：builtins，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（所有其他命令$PATH都有git-前缀），list- （请参阅命令中的类别 - list.txt），nohelpers（排除帮助程序命令），别名和配置（从配置变量completion.commands检索命令列表）\n","tags":["文章","git"],"path":"2019/08/16/git教程/","external_link":""},{"title":"你也能懂相对论","date":"2019-09-08T11:25:53.000Z","content":"\n相对论\n光线在通过强引力场附近时会发生弯曲，这是广义相对论的重要预言之一\n\n\n如果我说，相对论与日常生用息息相关，你会信吗？或许就算我是一位知名的物理学教授，说服力相信也不会大得多少。以下我将要用比较浅白简单的文字和少许初等代数，说明并说服大家，相对论并不难懂，而且它在日常经验中是如此的明显、如此的必要！\n1905 年被称为爱因斯坦的「奇迹年」，爱因斯坦向世界提出了一套非常明显、非常合理，但却一直不为人所理解的理论狭义相对论(special relativity)。被称为「狭义」是因为这个理论只在惯性座标系中适用；换句话说，即是在所有没有加速度的系统中都适用。狭义相对论建基于两大假设：\n\n在所有的惯性系统中，所有有物理定律保持不变。\n对于所有系统中的所有观测者，光速永远不变，而且不是无限快的。\n\n假设(一)「所有自然定律不变」一般被称为相对性原理(principle of relativity)，明显比较合理，也比较容易理解。而乍看之下，光速相对于所有人都不变，而不论那人正在高速奔跑或者静止不动都没有关系，就显得较为奇怪了。要理解这一点，我们需要由速度的意义说起。速度，就是在说「每单位时间内走了多远」。说得再浅白一点，可以想像为「每秒走了多少米(ms)」。但这只是惯用单位的问题，你当然可以想成「每小时走了多少公里(kmh)」，这正是司机们惯用的单位。在科学中，单位是至关重要的，因为不同单位的东西就是不同性质的东西，不可以混为一谈的比较，好像一个苹果永远不会等于一个橙。\n假设(二)「光速相对所有人都不变」，就是说相对于所有人，光在每单位时间内走的距离都一样。就是说，当你向着一道光奔跑，「直觉上」你会认为你所看到的光速比起你在静止不动时快，因为在你向光跑去的「同时」，光亦向着你冲去。换成数学上的表达，就是说如果你用速度  v 向着光冲去，而我们用  c 代表你在静止时看到的光速，那你看到的光速就会变成了c + v。这就是所谓的伽俐略变换，亦被一般人叫做「常识」。当然了啊，两个物件互相冲去，当然会比其中一个不动、或两者互相远离快啊。但是，爱因斯坦却说不论你用什么速度，向着光或离开光移动，你到的光速都仍然为  c，不多也不少！\n你会说：「这怎可能！这是违反常识的！」我的回答是，一般人的常识存在非常明显的漏洞，可是在爱因斯坦之前却一直没有人留意到这个严重的错误！这个错误就是「同时」这一概念的演绎。什么是「同时」？就是说大家的时钟显示的时间都一样啊！对，这也是爱因斯坦对「同时」的理解。但现在要再问一道问题，如何知道两个时钟的时间一样？\n问题到肉了，可是你会觉得很无聊：「说什么废话！只要我看到两个钟的指针拍着的时间就是了！」好，停一停，想一想：我们能「看」到东西，是因为光进入到我们的眼球穿过水晶体折射后投影在视网膜上。总言之，我们能看到东西，是因为有光。光以一定的速度前进，而且因为光速有限，因此在不同距离发出的光相对于同一个观测者而言，会在不同时间到达。试想像，两个人相距非常远，而两个人都带着一个时钟，那么当然，任何一方都会觉得对方那个时钟所发出的光，会比自己手上的时钟所发出的光要用更多时间才能进入你的眼睛吧！好了，我希望大家想想，究竟事先要如何调整两个时钟，才能使你和对方都看到两个时钟是同步的呢？当然，这是办不到的！因为两个时钟相距两个人的距离都不同。若然你看到它们是同步的，对方就会看到他手上的走得较快，反之亦然。\n如果你不太理解的话，请从头思考一次，先不要跳过读下去，因为刚才所说的就是相对论的精髓所在。重点是，要知道世界上并没有「对所有人都同时」这个概念存在，因此也可以说，「同时」这个概念对每个人都不同；说「对大家来说都是同时」就是错误的，没有可能发生。这是非常明显的，但却一直被我们所忽略。这完全是因为对于人类的感觉来说，光速(每秒三十万公里，能够环绕地球七个半圈) 实在是太快、太快了。\n好了，接下来我要介绍相对论导致的两个非常重要的结果，这些结果令人类对时间及空间的概念有了根本上的改变：时间及空间其实是互相纠缠、难分难离的。在这部分我会以数学论证，狭义相对论所涉及的数学都只是基本数学运算以及向量微积分，相信对有会考物理根基的朋友来说不会太难。\n\n在我们生活的三维空间中，每一件事件都可以用座标系的四个变量决定，就是(长，阔，高，时间)，数学表达为( x , y , z , t )。假设在座标系  S 中有一原点  O，在  S 内观测的人都会对每一件事件测得一组座标( x , y , z , t )；而现在有另一座标系S’正在相对S以速度  v 向右移动，它的原点  O’ 在时间  t = 0的时候刚好与  O重叠，而在S’内观测的人都会对每一件事件测得一组座标( x’ , y’ , z’ ,       t’ )。那么，在我们的「常识」中， ( x , y , z , t )与 ( x’ , y’ , z’ , t’ )的关系就是由伽俐略变换来决定：\n\n这就是我们认为的「常识」的数学表达方法。留意当中t’ = t，因为在传统的观念里，「同时」这概念仍然存在。明显地，在伽俐略变换当中，时间是独立地流逝的，与空间( x , y , z )无关。可是，在上文中我们知道「同时」是不存在的。\n\n想像小明站在一节正在行进的列车车厢正中间，在车头及车尾都摆放了感应器。他向左右同时照射出两道光束。对小明来说，车厢并没有移动，所以他会看到两道光束同时到达感应器。可是，对于一位站在月台上的人来说，因为列车正在向右移动，右边的感应器不断远离光束，而左边的就不断靠边光束。所以他会看到左边那道光束首先到达感应器。因此，时间会因为观测者的运动状态不同而有所分别，而且这是非常明显的！请注意，上述两种情况都是正确的，没有谁对谁错，完全因为观点与角度而已。回到  S 和  S’ 座标系的讨论，因为两个座标系的运动状态不同，所以伽俐略变换就不是正确的描述了，我们必须改用另外一种座标变换方法，名为洛伦兹变换( Lorentz Transformation)：\n\n有关这组公式的推导过程，有兴趣的朋友可以参考任何相对论课本。在这里我们有兴趣的是：如果时间及空间确实根据以上方程组变换的话，会有什么有趣的事情发生？\n\n首先，考虑一个「光钟」，这是一个纯粹由两块互相平行的平面镜组成的计时器，有一束光在两块镜之间来回反弹。然后我们定义这束光来回反弹一次的时间Δ t = 2 h  c 为一个时间单位，故此我们就有了这样一种有趣的计时器。\n\n现在，我们让这个光钟在S座标系中以水平方向向右以均速  v 移动。所以我们就知道，如果我们称光钟为S’ 座标系，就有Δ t’ = 2 h  c。在S 座标系当中，光就是以斜线行进的，根据毕氐定理，我们得到  \n  \n使用简单代数运算求得Δ t：\n\n因为v &lt; c，所以分母必定小于1 ，故此Δ t’ &lt; Δ t。换句话说，移动中的座标系的时间流逝得比较慢。这就是著名的时间迟滞(Time Dilation) 。 \n除了移动中的人的时间在其他人眼中会变慢之外，移动中的物体看起来也会变短。这叫做长度收缩(Length Contraction)。如果L 0 是物体静止时的长度，L是物体相对于观测者以速度  v移动时的长度，那么我们就会得到   \n\n公式(3) 的推导过程与公式(2) 差不多，只要把光钟转个直角再考虑水平移动就可以了，有兴趣的朋友可以自己当做练习试试推导。\n以上两个「违反直觉」的现象都已经被实验观测所证实了。其中一个重要的证明是关于宇宙射线的问题。每分每秒都有大量的宇宙射线攻击着地球，这些射线多是带电粒子诸如质子及电子等等，能量很高。幸好地球有磁场以及大气层的保护，不然地球上就不可能有生命存在了。\n一些粒子与大气粒子碰撞后，会产生许多不同种类的粒子，向各个方向散射。这些粒子的寿命一般都非常短暂，就算在产生的一刻开始已经用接近光速前进，在它再衰变成其他粒子之前，前进的距离最多也只得几百米。但是，虽然地球的大气层厚度约为100公里，设置在地面上的仪器却可以探测到它们！这完全是因为这些粒子以接近光速行进，相对论的效应就会变得很大。如果在静止时这些粒子的寿命是  T，那么根据时间迟滞现象，地面上的人就会测得它们的寿命为\n\n其中  v 是粒子的速度。明显地，当  v 非常接近  c 的时候，T’ 就会变得非常大，所以它们有足够的时间可以穿过厚厚的大气层落到地面。\n我最后想介绍的是著名的爱因斯坦速度相加法则。在早前的讨论中，我们已经明白到，在光速不是无限快的条件下，时间必须是「相对」的。亦即是说，对于不同运动状态的观测者，时间的流逝速率各有不同。同样地对于空间来说也是如此。因此，我们就不能说两个互相靠近的人的相对速度  v’，会简单地为  v’ = v 1 + v 2，其中  v 1 和  v 2 分别为两个人的速度。那么  v’ 应该如何表达才对呢？其实简单得很，只要把洛伦兹公式对时间微分就可以了。详细的做法可以参考教科书，其结果为\n\n因此可以看到在相对论下，相对速度  v’ 比较小。如果代入文章开头的例子，你和光束互相冲向对方，就有\n\n所以你会惊讶地发现，c + v 仍然是  c！这是当然的，因为相对论本身必须符合它的假设：光速不变。\n其实狭义相对论还有许多有趣的题目可以讨论的，例如著名的质能公式E = mc^2、双生子悖论、能量-动量四维向量、以及相对论性电磁场理论等等，或许在以后我会和大家深入讨论。而爱因斯坦在1916 年提出的广义相对论(general relativity)，则是一套把重力与加速度都包含在内的时空理论，能够非常准确地描述我们身处的宇宙。广义相对论所涉及的数学非常深奥，需要使用到十分抽象的黎曼几何以及张量的概念，确实并非每个学生也能明白。在以后我会试试为大家说明广义相对论的重要性。总而言之，在这篇文章中，我希望大家明白的事，是相对论其实并非一般人想像的那么深奥难懂。至少，就狭义相对论而言，只需要中学程度的物理及数学知识就可以了。\n原文链接\n","tags":["相对论","爱因斯坦"],"path":"2019/09/08/你也能懂相对论/","external_link":""},{"title":"天平砝码摆放问题","date":"2019-09-02T04:41:41.000Z","content":"题目一个天平上有6个位置，左右各三个位置，有6个砝码，分别是1、2、3、4、5、6克重。要使天平平衡，有多少种方法？（对称摆放算作一种方法） \n\n题解暴力求解\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    int t = 6;    int count = 0;    vector&lt;string&gt; v;    for (int i = 1; i &lt;= t; ++i) &#123;        for (int j = 1; j &lt;= t; ++j) &#123;            for (int k = 1; k &lt;= t; ++k) &#123;                for (int l = 1; l &lt;= t; ++l) &#123;                    for (int m = 1; m &lt;= t; ++m) &#123;                        for (int n = 1; n &lt;= t; ++n) &#123;                            if (i == j ||                                i == k || j == k ||                                i == l || j == l || k == l ||                                i == m || j == m || k == m || l == m ||                                i == n || j == n || k == n || l == n || m == n)                                continue;                            if ((3 * i + 2 * j + k) == (l + 2 * m + 3 * n)) &#123;                                string s = to_string(i) + to_string(j) + to_string(k) + to_string(l) + to_string(m) +                                           to_string(n);                                int te = 0;                                if (v.size() &gt; 0) &#123;                                    string tem = s;                                    reverse(tem.begin(), tem.end());                                    vector&lt;string&gt;::iterator it;                                    for (it = v.begin(); it != v.end(); it++) &#123;                                        if (*it == tem) &#123;                                            cout&lt;&lt;tem&lt;&lt;endl;                                            te = 1;                                            break;                                        &#125;                                    &#125;                                &#125;                                if (te == 0) &#123;                                    v.push_back(s);                                    count++;                                    printf( %d %d %d | %d %d %dn, i, j, k, l, m, n);                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;    return 0;&#125;\n\n1234567891011121314151617181 4 6 | 5 3 21 5 6 | 2 4 31 5 6 | 3 2 41 6 4 | 3 5 21 6 5 | 2 3 42 4 6 | 1 5 32 4 6 | 3 1 52 6 3 | 4 1 52 6 4 | 1 3 53 2 6 | 5 1 43 4 5 | 2 1 63 5 4 | 1 2 63 6 2 | 1 5 44 2 6 | 1 3 54 3 5 | 1 2 65 2 4 | 3 1 65 4 2 | 1 3 617","tags":["算法","天平","暴力破解"],"path":"2019/09/02/天平砝码摆放问题/","external_link":""},{"title":"判断素数","date":"2019-09-05T18:53:05.000Z","content":"\n素数\n质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。\n0和1既不是质数也不是合数，最小的质数是2\n\n\n最直观，但效率最低的写法\n\n这里特殊处理了一下小于等于3的数，因为小于等于3的自然数只有2和3是质数。\n然后，我们只需要从2开始，一直到小于其自身，依次判断能否被n整除即可，能够整除则不是质数，否则是质数。\n1234567891011public static boolean isPrime(int n)&#123;    if (n &lt;= 3) &#123;        return n &gt; 1;    &#125;    for(int i = 2; i &lt; n; i++)&#123;        if (n % i == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n优化\n\n我们继续分析，其实质数还有一个特点，就是它总是等于 6x-1 或者 6x+1，其中 x 是大于等于1的自然数。\n如何论证这个结论呢，其实不难。首先 6x 肯定不是质数，因为它能被 6 整除；其次 6x+2 肯定也不是质数，因为它还能被2整除；依次类推，6x+3 肯定能被 3 整除；6x+4 肯定能被 2 整除。那么，就只有 6x+1 和 6x+5 (即等同于6x-1) 可能是质数了。所以循环的步长可以设为 6，然后每次只判断 6 两侧的数即可。\n12345678910111213141516public static boolean isPrime(int num) &#123;    if (num &lt;= 3) &#123;        return num &gt; 1;    &#125;     不在6的倍数两侧的一定不是质数    if (num % 6 != 1 &amp;&amp; num % 6 != 5) &#123;        return false;    &#125;    int sqrt = (int) Math.sqrt(num);    for (int i = 5; i &lt;= sqrt; i += 6) &#123;        if (num % i == 0 || num % (i + 2) == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n性能对比\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        Stack&lt;Integer&gt; a = new Stack&lt;&gt;(), b = new Stack&lt;&gt;();        int n = 100000;        long s = System.currentTimeMillis(), e;        for (int i = 1; i &lt; n; i++) &#123;            if (f(i))                a.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        s = System.currentTimeMillis();        for (int i = 1; i &lt; n; i++) &#123;            if (func(i))                b.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        System.gc();    &#125;    static boolean f(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        for (int i = 2; i &lt; n; i++) &#123;            if (n % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;    static boolean func(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        if (n % 6 != 1 &amp;&amp; n % 6 != 5) &#123;            return false;        &#125;        int tem = (int) Math.sqrt(n);        for (int i = 5; i &lt;= tem; i += 6) &#123;            if (n % i == 0 || n % (i + 2) == 0)                return false;        &#125;        return true;    &#125;&#125;\n\n121392 ms5 ms","author":"times","tags":["编程","Java","素数"],"path":"2019/09/06/判断素数/","external_link":""},{"title":"技术栈","date":"2019-08-18T15:30:34.000Z","content":"\nHTML  CSS\n【HTML】HTML，即超文本标记语言（Hyper Text Markup Language）\n【HTML5】HTML5 是下一代 HTML 标准\n【CSS】层叠样式表（Cascading StyleSheet）\n【CSS3】CSS3是CSS技术的升级版本\n【Bootstrap3】Bootstrap，来自 Twitter，是目前最受欢迎的前端框架\n【Bootstrap4】Bootstrap4 目前是 Bootstrap 的最新版本\n【Font Awesome】Font Awesome 是一套绝佳的图标字体库和CSS框架。\n【Foundation】Foundation 用于开发响应式的 HTML, CSS and JavaScript 框架JavaScript\n【JavaScript】JavaScript 是 Web 的编程语言\n【HTML DOM】HTML DOM 定义了访问和操作 HTML 文档的标准方法\n【jQuery】jQuery 是一个 JavaScript 库\n【AngularJS】AngularJS 通过新的属性和表达式扩展了 HTML\n【AngularJS2】AngularJS2 是一款开源JavaScript库，由Google维护。\n【Vue.js】Vue.js 是一套构建用户界面的渐进式框架。\n【React】React 是一个用于构建用户界面的 JAVASCRIPT 库\n【TypeScript】TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准\n【jQuery UI】jQuery UI 是建立在 jQuery上的一组用户界面交互、特效、小部件及主题\n【jQuery EasyUI 】jQuery EasyUI 是一个基于 jQuery 的框架，集成了各种用户界面插件\n【Node.js】Node.js 是运行在服务端的 JavaScript\n【AJAX】AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n【JSON】JSON 是存储和交换文本信息的语法\n【Highcharts】Highcharts 是一个用纯JavaScript编写的一个图表库\n【Google 地图】Google 地图接口使用说明\n\n服务端\n【PHP】PHP 是一种通用开源脚本语言\n【Python】Python 是一种面向对象、解释型计算机程序设计语言\n【Python3】Python 升级版，变化较大\n【Django】Django是一个开放源代码的Web应用框架，由Python写成\n【Linux】Linux是一套免费使用和自由传播的类Unix操作系统\n【Docker】Docker 是一个开源的应用容器引擎，基于 Go 语言\n【Ruby】一种为简单快捷的面向对象编程（面向对象程序设计）而创的脚本语言\n【Java】一种可以撰写跨平台应用软件的面向对象的程序设计语言\n【C】一门通用计算机编程语言\n【C++】C++是在C语言的基础上开发的一种通用编程语言\n【Perl】Perl 是高级、通用、直译式、动态的程序语言\n【Servlet 】运行在 Web 服务器或应用服务器上的程序\n【JSP】JSP与PHP、ASP、ASP.NET等语言类似，运行在服务端的语言\n【Lua】Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放\n【Scala】Scala 是一门多范式（multi-paradigm）的编程语言。\n【Go】Go语言是谷歌推出的一种全新的编程语言\n【设计模式】设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用\n【正则表达式】正则表达式是对字符串操作的一种逻辑公式\n【Maven】Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n【NumPy】NumPy 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算。\n【ASP】ASP（Active Server Pages 动态服务器页面）是一种生成动态交互性网页的强有力工具\n【AppML】AppML 是一个为web应用程序设计的HTML扩展框\n【VBScript】一种微软环境下的轻量级的解释型语言\n\n数据库\n【SQL】结构化查询语言(Structured Query Language)\n【Mysql】MySQL是一个关系型数据库管理系统\n【PostgreSQL】PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)\n【SQLite】一款轻型的数据库\n【MongoDB】Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql)\n【Redis】一个高性能的key-value数据库\n【Memcached】Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。\n\n移动端\n【Android】Android 是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备\n【Swift】Swift 是一种支持多编程范式和编译式的编程语言,用于开发 iOS，OS X 和 watchOS应用程序。\n【jQuery Mobile】jQuery Mobile是jQuery 在手机上和平板设备上的版本\n【ionic】ionic 是一个强大的 HTML5 应用程序开发框架(HTML5 Hybrid Mobile App Framework )\n【Kotlin】在 Java 虚拟机上运行的静态类型编程语言，Android 官方开发语言\n\nXML 教程\n【XML】XML 被设计用来传输和存储数据\n【DTD】DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块\n【XML DOM】XML DOM 定义访问和操作XML文档的标准方法\n【XSLT】XSL 是一个 XML 文档的样式表语言，XSLT 指 XSL 转换\n【XPath】XPath 是一门在 XML 文档中查找信息的语言\n【XQuery】XQuery 被设计用来查询 XML 数据\n【XLink】XLink 定义在 XML 文档中创建超级链接的标准方法\n【XPointer】XPointer是在可扩展标志语言（XML）文件中定位数据的一种语言\n【XML Schema】XML Schema 描述了 XML文档的结构\n【XSL-FO】XSL-FO 指可扩展样式表语言格式化对象\n【SVG】SVG 使用 XML 格式定义图像\n\nASP.NET\n【ASP.NET】ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架\n【C#】C# 是一个简单的、现代的、通用的、面向对象的编程语言\n【Web Pages】Web Pages 是三种网页编程模型中的一种，用于创建网站和web 应用程序\n【Razor】Razor 是一种标记语法，可以让您将基于服务器的代码（Visual Basic 和 C#）嵌入到网页中\n【MVC】MVC（Model View Controller 模型-视图-控制器）\n【Web Forms】Web Forms 是三种创建 ASP.NET 网站和 Web 应用程序的编程模式中的一种\n\nWeb Service\n【Web Service】Web Service 脚本平台需支持 XML + HTTP\n【WSDL】WSDL是一门基于 XML 的语言，用于描述 Web Service 以及如何对它们进行访问\n【SOAP】SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息\n【RSS】RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议\n【RDF】DF(资源描述框架)是描述网络资源的 W3C 标准\n\n开发工具\n【Eclipse】Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台\n【Git】Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目\n【Svn】SVN 是一个开放源代码的版本控制系统\n【Markdown】Markdown 是一种轻量级标记语\n\n网站建设\n【HTTP】HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议\n【网站建设指南】网站建设指导课程\n【浏览器信息】对于网站开发人员来说，浏览器信息和统计数据都是非常重要的\n【网站主机教程】如果您希望向全世界发布自己的网站，那么您的网站就需要被放置于一个 WEB 服务器\n【TCPIP】TCPIP 是因特网的通信协议\n【W3C】W3C 让每个人都能在互联网上分享资源\n【网站品质】何创建高质量的web网站\n\n菜鸟教程\n","tags":["文章","编程"],"path":"2019/08/18/技术栈/","external_link":""},{"title":"深入理解Node.js 中的进程与线程","date":"2019-09-05T13:26:58.000Z","content":"\n前言进程与线程是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解进程与线程，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用。\n面试会问\nNode.js是单线程吗？\n\n\nNode.js 做耗时的计算时候，如何避免阻塞？\n\n\nNode.js如何实现多进程的开启和关闭？\n\n\nNode.js可以创建线程吗？\n\n\n你们开发过程中如何实现进程守护的？\n\n\n除了使用第三方模块，你们自己是否封装过一个多进程架构?\n\n进程进程Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。\n1234567const http = require(http);const server = http.createServer();server.listen(3000,()=&gt;&#123;    process.title=程序员成长指北测试进程;    console.log(进程id,process.pid)&#125;)\n\n运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663\n线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。\n单线程单线程就是一个进程只开一个线程\nJavascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。\n123456789101112131415161718192021222324const http = require(http);const longComputation = () =&gt; &#123;  let sum = 0;  for (let i = 0; i &lt; 1e10; i++) &#123;    sum += i;  &#125;;  return sum;&#125;;const server = http.createServer();server.on(request, (req, res) =&gt; &#123;  if (req.url === compute) &#123;    console.info(计算开始,new Date());    const sum = longComputation();    console.info(计算结束,new Date());    return res.end(`Sum is $&#123;sum&#125;`);  &#125; else &#123;    res.end(Ok)  &#125;&#125;);server.listen(3000);打印结果计算开始 2019-07-28T07:08:49.849Z计算结束 2019-07-28T07:09:04.522Z\n\n查看打印结果，当我们调用127.0.0.1:3000compute的时候，如果想要调用其他的路由地址比如127.0.0.1大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。\n单线程的一些说明\n\nNode.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。\n当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。\nNode.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。\n单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。\n\n","tags":["Nodejs"],"path":"2019/09/05/深入理解Node-js-中的进程与线程/","external_link":""},{"title":"树的高度（小米2017秋招真题）","date":"2019-09-05T08:08:46.000Z","content":"\n树的高度（小米2017秋招真题）题目题目描述\n现在有一棵合法的二叉树，树的节点都是用数字表示，现在给定这棵树上所有的父子关系，求这棵树的高度\n时间限制CC++语言：1000MS 其它语言：3000MS\n内存限制CC++语言：65536KB 其它语言：589824KB\n输入\n输入的第一行表示节点的个数n（1&lt;=n&lt;=1000，节点的编号为0到n-1）组成，下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号\n输出\n输出树的高度，为一个整数\n样例输入\n1234550 10 21 31 4\n\n样例输出\n13\n\n题解java\n1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] parent = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            parent[i] = -1;        &#125;        for (int i = 0; i &lt; n - 1; i++) &#123;            int a = sc.nextInt();            int b = sc.nextInt();            parent[b] = a;        &#125;        int h = 0;        for (int i = 0; i &lt; n; i++) &#123;            int max = 1;            int j = i;            while (parent[j] != -1) &#123;                j = parent[j];                max++;            &#125;            h = max &gt; h ? max : h;        &#125;        System.out.println(h);    &#125;&#125;\n\npython\n1234567891011121314import sysdef get(x):    try:        return 1 + get(dic_s[x])    except KeyError:        return 1n = int(sys.stdin.readline().strip())dic_s = &#123;&#125;for i in range(int(n)-1):    j_1,j_2 = sys.stdin.readline().strip().split()    dic_s[j_2] = j_1print max([get(i) for i in set(dic_s.keys()) - set(dic_s.values())]) if n&gt;1 else 1\n\njavascript\n12345678910111213141516var n=readInt(),rec=&#123;&#125;,dps=&#123;&#125;,rs=1while(n--&gt;1) &#123;  var a=readInt(),b=readInt()  rec[a]=rec[a]||[]  rec[a].push(b)&#125;for(var k in rec) rs=Math.max(rs,maxDps(k))print(rs)function maxDps(n)&#123;  if(!rec[n]) return 1  if(dps[n]) return dps[n]  var r=1  for(var x of rec[n]) r=Math.max(r,maxDps(x)+1)  dps[n]=r  return dps[n]&#125;\n\n","tags":["算法","树","二叉树"],"path":"2019/09/05/树的高度（小米2017秋招真题）/","external_link":""},{"title":"灭霸脚本","date":"2019-09-08T23:20:36.000Z","content":"Thanos.shThis command could delete list half your files randomly.\ndon’t use it at home and other places. this is a real gun, use it wisely… \nfeel free to post your story on waiting.12345678910111213141516# 灭霸脚本这个命令会随机“删掉”您一半的文件。。请不要在家里或其他地方使用。这是真家伙，要小心…你可以在```Story.md```文件里发布你的故事，期待中…  ## 特别说明 &gt; 1. 支持mac系统，但是需要使用到```gshuf```命令，需要通过```brew```安装,安装命令如下：```shell    #安装brew    usrbinruby -e &quot;$(curl -fsSL https:raw.githubusercontent.comHomebrewinstallmasterinstall)&quot;    #安装gshuf    brew install coreutils`\n\n\n此脚本只会列出当前目录一半的文件。并且。。。总之小心点。。。  \n\n\nInvoke-Thanos.ps1Invokes Thanos to remove each object with probability 12. It works with files, registry, environment variables, functions, variables, aliases and certificates.\nFor help, use Get-Help .Invoke-Thanos.ps1. Be sure to not actually invoke it!\n123456789101112131415#!binshlet i=`find . -type f | wc -l`2;if [[ uname==Darwin ]]; then    find . -not -name Thanos.sh -type f -print0 | gshuf -z -n $i | xargs -0  -- cat;else    find . -not -name Thanos.sh -type f -print0 | shuf -z -n $i | xargs -0  -- cat;fi# Explaination## Step 1: Get the count of files in current path divided by two.## Step 2: Get all the files in current path and print in one line.## Step 3: Turn half of the second step output into standard input randomly.## Step 4: Show half of the files in terminal.# Key Point## If you want to make delete, what you need to do is turn cat into rm.\n\n本人在线上服务器上运行了一次，…\n\n\n","tags":["脚本"],"path":"2019/09/09/灭霸脚本/","external_link":""},{"title":"数据库备份恢复容器化项目实践经验总结","date":"2019-09-08T13:35:18.000Z","content":"数据库备份恢复容器化项目实践经验总结\n本文分享了唯品会数据库Docker的异地容灾项目实践经验，项目中针对用户数据库的异地恢复场景的需求进行开发和测试，整合了网络，存储、调度、监控，镜像等多个模块。在实施完成后，从技术上总结关于选型、开发、踩坑、测试等方面的经验。\n\n项目背景数据库Docker的异地备份恢复容灾项目，针对用户数据库的异地备份恢复场景的需求进行开发和测试，整合了容器网络、存储、调度、监控、镜像等多个模块。同时针对数据库的日常运维工作开发了监控、资源调度、日志、Puppet自动推送等工具。\n通过Docker天生隔离性和快速部署等特点，实现在单台物理机上运行多个数据库备份恢复实例，大大提高服务器使用率，节省大量成本。通过对Docker本身和相关组件的研究和改造，从普通开源产品落地到公司内部生产环境，积累宝贵的开发经验。通过对Docker已经在其上层运行的数据库日常运维和监控，也积累宝贵的Docker运维经验，为更大规模推广容器提供基础。\n\n关于容器技术通过实践，证明容器技术在易用性，可管理性，快速部署具备天然的优势。在资源利用率方面，容器部署在上百个物理节点上，提供约500多个数据库灾备实例，提升了硬件资源的利用率，节约了约400台物理机的采购成本。这些是容器技术带来的实实在在收益。在资源分配与隔离方面，又不输于虚拟机。CPU、内存、磁盘IO、网络IO限流等技术的应用，保证了资源的合理使用，从机制上阻止了单一实例的资源过分消耗的问题。\n稳定性是使用容器技术非常关注的一个点，也是基石。MySQL备份恢复属于CPU密集 + 磁盘IO密集 + 网络IO密集型业务，对于Docker daemon是个较大的考验。就目前来看，限制每台宿主机的容器数量（5个左右）的情况下，集群跑了三个多月没有出现因为容器负载过大导致的crash现象，还是值得信赖的。遇到的唯一相关问题是Docker daemon挂死，具体现象是docker info、docker ps没有响应，docker volume、docker images 正常，下面的容器运行正常。这是偶发事件，无法重现，以后需要继续观察。\n由于容器以进程方式存在，体现出几乎与物理机上相当的性能，Overheads极低（低于10%）。从数据抽取任务的结果来看，与物理机相比，使用容器对成功率没有影响，效率也差不多。这也很符合最初预想，不管跑容器还是外部服务从物理机角度来说它们之间是没有什么区别的，都是一个进程，唯一不同是父进程不一样而已。\n以上是容器“RUN”带来的好处，通过统一开发流程，应用微服务化，CICD等方面的改进，能够进一步利用容器“BUILD”、“SHIP” 优势，容器技术还来的潜力是巨大的。要说容器技术的缺点，还真的不明显。硬要提的话一个是需要一定的学习成本，改变开发流程与方式，一个是开发人员对容器技术的接受程度。这个项目仅用了不到二百人天，对于一个采用新技术的项目来说，真的是很低的了。一开始我们也担心因为采用新技术导致开发推广有困难，后来实际能通过技术上解决问题，打消了大部分用户对使用Docker的疑虑，反而有助于该技术的普遍应用。\n关于Docker daemon版本的选择，我们之前是有过一些讨论的。现在Docker社区非常活跃，当时我们用1.10.3， 到现在已经出了两个新版本了。在功能满足的前提下，稳定性是第一考量。Docker自1.9.0引入CNM网络模型，1.10算是比较成熟。CNM是我们希望在这个项目尝试的一部分。网络与Volume插件功能与稳定性的提升，开始支持磁盘IO读写限速，Device Mapper的支持，等等，都是选择了这个版本的原因。另外，Docker插件的引入，很好地解耦了Docker与底层模块的关系，使我们可以专注于底层（网络、存储）实现而不需要修改Docker daemon本身，同时避免产生升级依赖。\n关于容器存储容器外部卷使用Convoy，以插件的形式支持容器持久化数据。容器本身与外部卷均使用Device Mapper作为底层。没有选择分布式存储原因，主要是为了简化实现，更稳定。通过限制每个容器的BlkioDeviceReadBps、BlkioDeviceWriteBps、BlkioDeviceReadIOps、BlkioDeviceWriteIOps，使磁盘IO稳定地达到相当于95%物理机性能。\n\n对于Device Mapper，因为是红帽推荐的，而OS又是用的CentOS7.2, 所以就用了它。测试过程中发现Device Mapper健壮性不是很好，仅仅在低并发下，也会出现容器删除失败的情况，容器并发启停偶尔出现找不到设备的情况。这种使用映射关系的设备，功能是丰富，实现上过于复杂，每次对设备的修改都需要额外去更新Metadata，并发场景出错的机会就大了。让我再选的话我会考虑Overlay这种更简单的driver。\n对于Convoy，是来自Rancher的产品，Go语言，仍然处于未成熟阶段，版本号0.5, 并没有完全实现Volume Plugin接口。相比其它模块它的问题也是最多的，例如Volume创建失败，无法删除，UNIX Socket泄漏，重名冲突，异常自动退出等。属于能用，但未完善的状态，你自己得有一定开发调试能力去解决发现的问题。其它几个存储插件情况也差不多，Flocker、Blockbridge、Horcrux等等，有的连第一个正式发布版都还没有，Convoy反而相对好点，有点烂柿子堆里挑的感觉。\n关于容器监控容器监控在这个项目里还可以有很大的空间可以改进。项目里用的是cAdvisor，容器内top、free、iostat命令劫持，基于已有的Zabbix体系作数据收集与展示。结论是Zabbix完全不合适做容器监控，数据收集密度，展示质量，灵活度都没能满足需求。\n后来在测试中尝试使用Telegraf + InfluxDB + Grafana。 只需要Grafana简单的配置，能够帮忙我们清晰地展示容器及服务进程CPU、内存、网络、磁盘等情况。Grafana上SQL查询语句的调试与开发，确实需要不少的时间，但这个工作量是一次性的。因为是Go写的，Telegraf CPU占用属于比较低的水平（0.4 – 5%）。功能上比较丰富，同时支持外部进程与容器的数据收集，多达55种数据源插件，有它就不需要布cAdvisor了，个人比较推荐。需要告警的同学，可以考虑把influxDB改成Prometheus。它包含Alertmanager实现Email、PagerDuty等消息通知。数据Backend可以选择自带的DB，也可以外接influxDB、Graphite、OpenTSDB等流行方案。\n\n监控领域业界已经有很多开源方案可以参考，以下是要衡量的标准：易扩展、开销低、入侵小、大集中、易部署、实时性、展现清晰灵活。这方面希望与各位有更多的交流。\n","tags":["数据库","备份","Docker"],"path":"2019/09/08/数据库备份恢复容器化项目实践经验总结/","external_link":""},{"title":"狂野飙车9","date":"2019-09-04T18:19:56.000Z","content":"兰博基尼\n法拉利\n布加迪\n迈凯伦\n兰博基尼\n风神\n","tags":["狂野飙车","跑车"],"path":"2019/09/05/狂野飙车9/","external_link":""},{"title":"面试红黑树","date":"2019-09-08T02:43:14.000Z","content":"什么是红黑树红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。\n它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。\n由于 TreeMap 就是由红黑树实现的，因此本文将使用 TreeMap 的相关操作的代码进行分析、论证。\n黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。\n红黑树的 5 个特性\n红黑树在原有的二叉查找树基础上增加了如下几个要求：\n\nEvery node is either red or black.\nThe root is black.\nEvery leaf (NIL) is black.\nIf a node is red, then both its children are black.\nFor each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\n中文意思是：\n\n每个节点要么是红色，要么是黑色；\n根节点永远是黑色的；\n所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；\n每个红色节点的两个子节点一定都是黑色；\n从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；\n\n注意：性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。\n性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。\n性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。\n红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。\n红黑树的左旋右旋\n红黑树的左右旋是比较重要的操作，左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。\n比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。\n我们以 Java 集合框架中的 TreeMap 中的代码来看下左右旋的具体操作方法：\n指定节点 x 的左旋 (右图转成左图)：\n123456789101112131415161718 这里 p 代表 xprivate void rotateLeft(Entry p) &#123;    if (p != null) &#123;        Entry r = p.right;  p 是上图中的 x，r 就是 y        p.right = r.left;        左旋后，x 的右子树变成了 y 的左子树 β         if (r.left != null)                     r.left.parent = p;  β 确认父亲为 x        r.parent = p.parent;        y 取代 x 的第一步：认 x 的父亲为爹        if (p.parent == null)       要是 x 没有父亲，那 y 就是最老的根节点            root = r;        else if (p.parent.left == p) 如果 x 有父亲并且是它父亲的左孩子，x 的父亲现在认 y 为左孩子，不要 x 了            p.parent.left = r;        else                            如果 x 是父亲的右孩子，父亲就认 y 为右孩子，抛弃 x            p.parent.right = r;        r.left = p;     y 逆袭成功，以前的爸爸 x 现在成了它的左孩子        p.parent = r;    &#125;&#125;\n\n可以看到，x 节点的左旋就是把 x 变成 右孩子 y 的左孩子，同时把 y 的左孩子送给 x 当右子树。\n简单点记就是：左旋把右子树里的一个节点（上图 β）移动到了左子树。\n指定节点 y 的右旋（左图转成右图）：\n123456789101112131415private void rotateRight(Entry p) &#123;    if (p != null) &#123;        Entry l = p.left;        p.left = l.right;        if (l.right != null) l.right.parent = p;        l.parent = p.parent;        if (p.parent == null)            root = l;        else if (p.parent.right == p)            p.parent.right = l;        else p.parent.left = l;        l.right = p;        p.parent = l;    &#125;&#125;\n\n同理，y 节点的右旋就是把 y 变成 左孩子 x 的右孩子，同时把 x 的右孩子送给 x 当左子树。\n简单点记就是：右旋把左子树里的一个节点（上图 β）移动到了右子树。\n了解左旋、右旋的方法及意义后，就可以了解红黑树的主要操作：插入、删除。\n总结红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。\n红黑树的插入、删除调整逻辑比较复杂，但最终目的是满足红黑树的 5 个特性，尤其是 4 和 5。\n在插入调整时为了简化操作我们直接把插入的节点涂成红色，这样只要保证插入节点的父节点不是红色就可以了。\n而在删除后的调整中，针对删除黑色节点，所在子树缺少一个节点，需要进行弥补或者对别人造成一个黑色节点的伤害。具体调整方法取决于兄弟节点所在子树的情况。\n红黑树的插入、删除在树形数据结构中算比较复杂的，理解起来比较难，但只要记住，红黑树有其特殊的平衡规则，而我们为了维持平衡，根据邻树的状况进行旋转或者涂色。\n红黑树这么难理解，必定有其过人之处。它的有序、快速特性在很多场景下都有用到，比如 Java 集合框架的 TreeMap, TreeSet 等。\n","tags":["算法","面试","红黑树"],"path":"2019/09/08/面试红黑树/","external_link":""},{"title":"Airbnb JavaScript 代码规范() {","date":"2019-09-08T02:51:27.000Z","content":"Airbnb JavaScript 代码规范() {一种写JavaScript更合理的代码风格。\n\nNote: 本指南假设你使用了 Babel, 并且要求你使用 babel-preset-airbnb 或者其他同等资源。 并且假设你在你的应用中安装了 shimspolyfills ，使用airbnb-browser-shims 或者相同功能。\n\n\n\n\n其他代码风格指南\n\nES5 (Deprecated)\nReact\nCSS-in-JavaScript\nCSS &amp; Sass\nRuby\n\n目录\n类型\n引用\n对象\n数组\n解构\n字符\n方法\n箭头函数\n类和构造器\n模块\n迭代器和发生器\n属性\n变量\n提升\n比较运算符和等号\n块\n控制语句\n注释\n空白\n逗号\n分号\n类型转换和强制类型转换\n命名规范\n存取器\n事件\njQuery\nECMAScript 5 兼容性\nECMAScript 6+ (ES 2015+) 风格\n标准库\n测试\n性能\n资源\nJavaScript风格指南的指南\n许可证\n修正案\n\n类型  \n\n1.1 原始值: 当你访问一个原始类型的时候，你可以直接使用它的值。\n\nstring\nnumber\nboolean\nnull\nundefined\nsymbol\n\n123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar);  =&gt; 1, 9\n\n\nSymbols cannot be faithfully polyfilled, so they should not be used when targeting browsersenvironments that don’t support them natively.\n\n\n\n1.2  复杂类型: 当你访问一个复杂类型的时候，你需要一个值得引用。\n\nobject\narray\nfunction\n\n123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]);  =&gt; 9, 9\n\n\n\n⬆ 返回目录\n引用  \n\n2.1 使用 const 定义你的所有引用；避免使用 var。 eslint: prefer-const, no-const-assign\n\n为什么? 这样能够确保你不能从新分配你的引用，否则可能导致错误或者产生难以理解的代码。.\n\n1234567 badvar a = 1;var b = 2; goodconst a = 1;const b = 2;\n\n\n\n2.2 如果你必须重新分配你的引用， 使用 let 代替 var。 eslint: no-var\n\n为什么? let 是块级作用域，而不像 var 是函数作用域.\n\n1234567891011 badvar count = 1;if (true) &#123;  count += 1;&#125; good, use the let.let count = 1;if (true) &#123;  count += 1;&#125;\n\n\n\n2.3 注意，let 和 const 都是块级范围的。\n1234567 const 和 let 只存在于他们定义的块中。&#123;  let a = 1;  const b = 1;&#125;console.log(a);  ReferenceErrorconsole.log(b);  ReferenceError\n\n\n\n⬆ 返回目录\n对象  \n\n3.1 使用字面语法来创建对象。 eslint: no-new-object\n12345 badconst item = new Object(); goodconst item = &#123;&#125;;\n\n\n\n3.2 在创建具有动态属性名称的对象时使用计算属性名。\n\n为什么? 它允许你在一个地方定义对象的所有属性。\n\n123456789101112131415161718function getKey(k) &#123;  return `a key named $&#123;k&#125;`;&#125; badconst obj = &#123;  id: 5,  name: San Francisco,&#125;;obj[getKey(enabled)] = true; goodconst obj = &#123;  id: 5,  name: San Francisco,  [getKey(enabled)]: true,&#125;;\n\n\n\n3.3 使用对象方法的缩写。 eslint: object-shorthand\n1234567891011121314151617 badconst atom = &#123;  value: 1,  addValue: function (value) &#123;    return atom.value + value;  &#125;,&#125;; goodconst atom = &#123;  value: 1,  addValue(value) &#123;    return atom.value + value;  &#125;,&#125;;\n\n\n\n3.4 使用属性值的缩写。 eslint: object-shorthand\n\n为什么? 它的写法和描述较短。\n\n1234567891011const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  lukeSkywalker: lukeSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,&#125;;\n\n\n\n3.5 在对象声明的时候将简写的属性进行分组。\n\n为什么? 这样更容易的判断哪些属性使用的简写。\n\n12345678910111213141516171819202122const anakinSkywalker = Anakin Skywalker;const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  episodeOne: 1,  twoJediWalkIntoACantina: 2,  lukeSkywalker,  episodeThree: 3,  mayTheFourth: 4,  anakinSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,  anakinSkywalker,  episodeOne: 1,  twoJediWalkIntoACantina: 2,  episodeThree: 3,  mayTheFourth: 4,&#125;;\n\n\n\n3.6 只使用引号标注无效标识符的属性。 eslint: quote-props\n\n为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。\n\n12345678910111213 badconst bad = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;; goodconst good = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;;\n\n\n\n3.7 不能直接调用 Object.prototype 的方法，如： hasOwnProperty 、 propertyIsEnumerable 和 isPrototypeOf。\n\n为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 { hasOwnProperty: false } - 或者，对象是一个空对象 (Object.create(null))。\n\n123456789101112 badconsole.log(object.hasOwnProperty(key)); goodconsole.log(Object.prototype.hasOwnProperty.call(object, key)); bestconst has = Object.prototype.hasOwnProperty;  在模块范围内的缓存中查找一次* or *import has from has;  https:www.npmjs.compackagehas ...console.log(has.call(object, key));\n\n\n\n3.8 更喜欢对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n1234567891011121314 very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;);  变异的 `original` ಠ_ಠdelete copy.a;  这.... badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;);  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125; goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;;  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy;  noA =&gt; &#123; b: 2, c: 3 &#125;\n\n\n\n⬆ 返回目录\n数组  \n\n4.1 使用字面语法创建数组。 eslint: no-array-constructor\n12345 badconst items = new Array(); goodconst items = [];\n\n\n\n4.2 使用 Array#push 取代直接赋值来给数组添加项。\n1234567const someStack = []; badsomeStack[someStack.length] = abracadabra; goodsomeStack.push(abracadabra);\n\n\n\n4.3 使用数组展开方法 ... 来拷贝数组。\n1234567891011 badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) &#123;  itemsCopy[i] = items[i];&#125; goodconst itemsCopy = [...items];\n\n\n\n4.4 将一个类数组对象转换成一个数组， 使用展开方法 ... 代替 Array.from。\n1234567const foo = document.querySelectorAll(.foo); goodconst nodes = Array.from(foo); bestconst nodes = [...foo];\n\n\n\n4.5 对于对迭代器的映射，使用 Array.from 替代展开方法 ... ， 因为它避免了创建中间数组。\n12345 badconst baz = [...foo].map(bar); goodconst baz = Array.from(foo, bar);\n\n\n\n4.6 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 8.2。 eslint: array-callback-return\n1234567891011121314151617181920212223242526272829303132333435363738394041 good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map(x =&gt; x + 1); bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;&#125;); good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;  return flatten;&#125;); badinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125; else &#123;    return false;  &#125;&#125;); goodinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125;  return false;&#125;);\n\n\n\n4.7 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n12345678910111213141516171819202122232425262728293031 badconst arr = [  [0, 1], [2, 3], [4, 5],];const objectInArray = [&#123;  id: 1,&#125;, &#123;  id: 2,&#125;];const numberInArray = [  1, 2,]; goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [  &#123;    id: 1,  &#125;,  &#123;    id: 2,  &#125;,];const numberInArray = [  1,  2,];\n\n\n\n⬆ 返回目录\n解构  \n\n5.1 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: prefer-destructuring\n\n为什么? 解构可以避免为这些属性创建临时引用。\n\n123456789101112131415161718 badfunction getFullName(user) &#123;  const firstName = user.firstName;  const lastName = user.lastName;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; goodfunction getFullName(user) &#123;  const &#123; firstName, lastName &#125; = user;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;\n\n\n\n5.2 使用数组解构。 eslint: prefer-destructuring\n12345678const arr = [1, 2, 3, 4]; badconst first = arr[0];const second = arr[1]; goodconst [first, second] = arr;\n\n\n\n5.3 对于多个返回值使用对象解构，而不是数组解构。\n\n为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。\n\n1234567891011121314151617 badfunction processInput(input) &#123;   处理代码...  return [left, right, top, bottom];&#125; 调用者需要考虑返回数据的顺序。const [left, __, top] = processInput(input); goodfunction processInput(input) &#123;   处理代码...  return &#123; left, right, top, bottom &#125;;&#125; 调用者只选择他们需要的数据。const &#123; left, top &#125; = processInput(input);\n\n\n\n⬆ 返回目录\n字符  \n\n6.1 使用单引号 &#39;&#39; 定义字符串。 eslint: quotes\n12345678 badconst name = Capt. Janeway; bad - 模板文字应该包含插值或换行。const name = `Capt. Janeway`; goodconst name = Capt. Janeway;\n\n\n\n6.2 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n\n为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。\n\n12345678910111213 badconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.; badconst errorMessage = This is a super long error that was thrown because  +  of Batman. When you stop to think about how Batman had anything to do  +  with this, you would get nowhere fast.; goodconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.;\n\n\n\n6.3 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: prefer-template template-curly-spacing\n\n为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。\n\n12345678910111213141516171819 badfunction sayHi(name) &#123;  return How are you,  + name + ?;&#125; badfunction sayHi(name) &#123;  return [How are you, , name, ?].join();&#125; badfunction sayHi(name) &#123;  return `How are you, $&#123; name &#125;?`;&#125; goodfunction sayHi(name) &#123;  return `How are you, $&#123;name&#125;?`;&#125;\n\n\n\n6.4 不要在字符串上使用 eval() ，它打开了太多漏洞。 eslint: no-eval\n\n\n6.5 不要转义字符串中不必要的字符。 eslint: no-useless-escape\n\n为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。\n\n123456 badconst foo = this is quoted; goodconst foo = this is quoted;const foo = `my name is $&#123;name&#125;`;\n\n\n\n⬆ 返回目录\n方法  \n\n7.1 使用命名的函数表达式代替函数声明。 eslint: func-style\n\n为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (Discussion)\n\n123456789101112131415 badfunction foo() &#123;   ...&#125; badconst foo = function () &#123;   ...&#125;; good 从变量引用调用中区分的词汇名称const short = function longUniqueMoreDescriptiveLexicalFoo() &#123;   ...&#125;;\n\n\n\n7.2 Wrap立即调用函数表达式。 eslint: wrap-iife\n\n为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。\n\n1234 immediately-invoked function expression (IIFE) 立即调用的函数表达式(function () &#123;  console.log(Welcome to the Internet. Please follow me.);&#125;());\n\n\n\n7.3 切记不要在非功能块中声明函数 (if, while, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: no-loop-func\n\n\n7.4 注意: ECMA-262 将 block 定义为语句列表。 函数声明不是语句。\n1234567891011121314 badif (currentUser) &#123;  function test() &#123;    console.log(Nope.);  &#125;&#125; goodlet test;if (currentUser) &#123;  test = () =&gt; &#123;    console.log(Yup.);  &#125;;&#125;\n\n\n\n7.5 永远不要定义一个参数为 arguments。 这将会优先于每个函数给定范围的 arguments 对象。\n123456789 badfunction foo(name, options, arguments) &#123;   ...&#125; goodfunction foo(name, options, args) &#123;   ...&#125;\n\n\n\n7.6 不要使用 arguments, 选择使用 rest 语法 ... 代替。 eslint: prefer-rest-params\n\n为什么? ... 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 arguments 。\n\n12345678910 badfunction concatenateAll() &#123;  const args = Array.prototype.slice.call(arguments);  return args.join();&#125; goodfunction concatenateAll(...args) &#123;  return args.join();&#125;\n\n\n\n7.7 使用默认的参数语法，而不是改变函数参数。\n123456789101112131415161718192021 really badfunction handleThings(opts) &#123;   No! We shouldn’t mutate function arguments.   Double bad: if opts is falsy itll be set to an object which may   be what you want but it can introduce subtle bugs.  opts = opts || &#123;&#125;;   ...&#125; still badfunction handleThings(opts) &#123;  if (opts === void 0) &#123;    opts = &#123;&#125;;  &#125;   ...&#125; goodfunction handleThings(opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.8 避免使用默认参数的副作用。\n\n为什么? 他们很容易混淆。\n\n123456789var b = 1; badfunction count(a = b++) &#123;  console.log(a);&#125;count();   1count();   2count(3);  3count();   3\n\n\n\n7.9 总是把默认参数放在最后。\n123456789 badfunction handleThings(opts = &#123;&#125;, name) &#123;   ...&#125; goodfunction handleThings(name, opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.10 永远不要使用函数构造器来创建一个新函数。 eslint: no-new-func\n\n为什么? 以这种方式创建一个函数将对一个类似于 eval() 的字符串进行计算，这将打开漏洞。\n\n12345 badvar add = new Function(a, b, return a + b); still badvar subtract = Function(a, b, return a - b);\n\n\n\n7.11 函数签名中的间距。 eslint: space-before-function-paren space-before-blocks\n\n为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。\n\n12345678 badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;; goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;;\n\n\n\n7.12 没用变异参数。 eslint: no-param-reassign\n\n为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。\n\n123456789 badfunction f1(obj) &#123;  obj.key = 1;&#125; goodfunction f2(obj) &#123;  const key = Object.prototype.hasOwnProperty.call(obj, key) ? obj.key : 1;&#125;\n\n\n\n7.13 不要再分配参数。 eslint: no-param-reassign\n\n为什么? 重新分配参数会导致意外的行为，尤其是在访问 arguments 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。\n\n1234567891011121314151617181920 badfunction f1(a) &#123;  a = 1;   ...&#125;function f2(a) &#123;  if (!a) &#123; a = 1; &#125;   ...&#125; goodfunction f3(a) &#123;  const b = a || 1;   ...&#125;function f4(a = 1) &#123;   ...&#125;\n\n\n\n7.14 优先使用扩展运算符 ... 来调用可变参数函数。 eslint: prefer-spread\n\n为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 apply 来 new 。\n\n12345678910111213 badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x); goodconst x = [1, 2, 3, 4, 5];console.log(...x); badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5])); goodnew Date(...[2016, 8, 5]);\n\n\n\n7.15 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: function-paren-newline\n123456789101112131415161718192021222324252627 badfunction foo(bar,             baz,             quux) &#123;   ...&#125; goodfunction foo(  bar,  baz,  quux,) &#123;   ...&#125; badconsole.log(foo,  bar,  baz); goodconsole.log(  foo,  bar,  baz,);\n\n\n\n⬆ 返回目录\n箭头函数  \n\n8.1 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: prefer-arrow-callback, arrow-spacing\n\n为什么? 它创建了一个在 this 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。\n\n\n为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。\n\n1234567891011 bad[1, 2, 3].map(function (x) &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.2 如果函数体包含一个单独的语句，返回一个没有副作用的 expression ， 省略括号并使用隐式返回。否则，保留括号并使用 return 语句。 eslint: arrow-parens, arrow-body-style\n\n为什么? 语法糖。 多个函数被链接在一起时，提高可读性。\n\n12345678910111213141516171819202122232425262728293031323334353637 bad[1, 2, 3].map(number =&gt; &#123;  const nextNumber = number + 1;  `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`); good[1, 2, 3].map((number) =&gt; &#123;  const nextNumber = number + 1;  return `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map((number, index) =&gt; (&#123;  [index]: number,&#125;)); 没有副作用的隐式返回function foo(callback) &#123;  const val = callback();  if (val === true) &#123;     如果回调返回 true 执行  &#125;&#125;let bool = false; badfoo(() =&gt; bool = true); goodfoo(() =&gt; &#123;  bool = true;&#125;);\n\n\n\n8.3 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n\n为什么? 它清楚地显示了函数的起点和终点。\n\n1234567891011121314 bad[get, post, put].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )); good[get, post, put].map(httpMethod =&gt; (  Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )));\n\n\n\n8.4 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 “always” option 来配置 eslint. eslint: arrow-parens\n\n为什么? 减少视觉上的混乱。\n\n12345678910111213141516171819202122 bad[1, 2, 3].map((x) =&gt; x * x); good[1, 2, 3].map(x =&gt; x * x); good[1, 2, 3].map(number =&gt; (  `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`)); bad[1, 2, 3].map(x =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.5 避免箭头函数符号 (=&gt;) 和比较运算符 (&lt;=, &gt;=) 的混淆。 eslint: no-confusing-arrow\n1234567891011121314 badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize); goodconst itemHeight = (item) =&gt; &#123;  const &#123; height, largeSize, smallSize &#125; = item;  return height &gt; 256 ? largeSize : smallSize;&#125;;\n\n\n\n8.6 注意带有隐式返回的箭头函数函数体的位置。 eslint: implicit-arrow-linebreak\n12345678910111213 bad(foo) =&gt;  bar;(foo) =&gt;  (bar); good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; (   bar)\n\n\n\n⬆ 返回目录\n类和构造器  \n\n9.1 尽量使用 class. 避免直接操作 prototype .\n\n为什么? class 语法更简洁，更容易推理。\n\n123456789101112131415161718192021 badfunction Queue(contents = []) &#123;  this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123;  const value = this.queue[0];  this.queue.splice(0, 1);  return value;&#125;; goodclass Queue &#123;  constructor(contents = []) &#123;    this.queue = [...contents];  &#125;  pop() &#123;    const value = this.queue[0];    this.queue.splice(0, 1);    return value;  &#125;&#125;\n\n\n\n9.2 使用 extends 来扩展继承。\n\n为什么? 它是一个内置的方法，可以在不破坏 instanceof 的情况下继承原型功能。\n\n12345678910111213141516 badconst inherits = require(inherits);function PeekableQueue(contents) &#123;  Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123;  return this.queue[0];&#125;; goodclass PeekableQueue extends Queue &#123;  peek() &#123;    return this.queue[0];  &#125;&#125;\n\n\n\n9.3 方法返回了 this 来供其内部方法调用。\n12345678910111213141516171819202122232425262728293031 badJedi.prototype.jump = function () &#123;  this.jumping = true;  return true;&#125;;Jedi.prototype.setHeight = function (height) &#123;  this.height = height;&#125;;const luke = new Jedi();luke.jump();  =&gt; trueluke.setHeight(20);  =&gt; undefined goodclass Jedi &#123;  jump() &#123;    this.jumping = true;    return this;  &#125;  setHeight(height) &#123;    this.height = height;    return this;  &#125;&#125;const luke = new Jedi();luke.jump()  .setHeight(20);\n\n\n\n9.4 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 toString() 方法也是可以的。\n12345678910111213class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    this.name = options.name || no name;  &#125;  getName() &#123;    return this.name;  &#125;  toString() &#123;    return `Jedi - $&#123;this.getName()&#125;`;  &#125;&#125;\n\n\n\n9.5 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: no-useless-constructor\n1234567891011121314151617181920212223 badclass Jedi &#123;  constructor() &#123;&#125;  getName() &#123;    return this.name;  &#125;&#125; badclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125; goodclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);    this.name = Rey;  &#125;&#125;\n\n\n\n9.6 避免定义重复的类成员。 eslint: no-dupe-class-members\n\n为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。\n\n123456789101112131415 badclass Foo &#123;  bar() &#123; return 1; &#125;  bar() &#123; return 2; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 1; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 2; &#125;&#125;\n\n\n\n⬆ 返回目录\n模块  \n\n10.1 你可能经常使用模块 (importexport) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n\n为什么? 模块是未来的趋势，让我们拥抱未来。\n\n1234567891011 badconst AirbnbStyleGuide = require(.AirbnbStyleGuide);module.exports = AirbnbStyleGuide.es6; okimport AirbnbStyleGuide from .AirbnbStyleGuide;export default AirbnbStyleGuide.es6; bestimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.2 不要使用通配符导入。\n\n为什么? 这确定你有一个单独的默认导出。\n\n12345 badimport * as AirbnbStyleGuide from .AirbnbStyleGuide; goodimport AirbnbStyleGuide from .AirbnbStyleGuide;\n\n\n\n10.3 不要直接从导入导出。\n\n为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。\n\n12345678 bad filename es6.jsexport &#123; es6 as default &#125; from .AirbnbStyleGuide; good filename es6.jsimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.4 只从一个路径导入所有需要的东西。eslint: no-duplicate-imports\n\n为什么? 从同一个路径导入多个行，使代码更难以维护。\n\n12345678910111213 badimport foo from foo; … 其他导入 … import &#123; named1, named2 &#125; from foo; goodimport foo, &#123; named1, named2 &#125; from foo; goodimport foo, &#123;  named1,  named2,&#125; from foo;\n\n\n\n10.5 不要导出可变的引用。eslint: importno-mutable-exports\n\n为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。\n\n1234567 badlet foo = 3;export &#123; foo &#125;; goodconst foo = 3;export &#123; foo &#125;;\n\n\n\n10.6 在单个导出的模块中，选择默认模块而不是指定的导出。eslint: importprefer-default-export\n\n为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。\n\n12345 badexport function foo() &#123;&#125; goodexport default function foo() &#123;&#125;\n\n\n\n10.7 将所有的 imports 语句放在所有非导入语句的上边。eslint: importfirst\n\n为什么? 由于所有的 imports 都被提前，保持他们在顶部是为了防止意外发生。\n\n1234567891011 badimport foo from foo;foo.init();import bar from bar; goodimport foo from foo;import bar from bar;foo.init();\n\n\n\n10.8 多行导入应该像多行数组和对象一样缩进。\n\n为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。\n\n1234567891011 badimport &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from path; goodimport &#123;  longNameA,  longNameB,  longNameC,  longNameD,  longNameE,&#125; from path;\n\n\n\n10.9 在模块导入语句中禁止使用 Webpack 加载器语法。eslint: importno-webpack-loader-syntax\n\n为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 webpack.config.js 中使用加载器语法。\n\n1234567 badimport fooSass from css!sass!foo.scss;import barCss from style!css!bar.css; goodimport fooSass from foo.scss;import barCss from bar.css;\n\n\n\n⬆ 返回目录\n迭代器和发生器  \n\n11.1 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of。 eslint: no-iterator no-restricted-syntax\n\n为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。\n\n\n使用 map()  every()  filter()  find()  findIndex()  reduce()  some()  … 遍历数组， 和使用 Object.keys()  Object.values()  Object.entries() 迭代你的对象生成数组。\n\n12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5]; badlet sum = 0;for (let num of numbers) &#123;  sum += num;&#125;sum === 15; goodlet sum = 0;numbers.forEach((num) =&gt; &#123;  sum += num;&#125;);sum === 15; best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) &#123;  increasedByOne.push(numbers[i] + 1);&#125; goodconst increasedByOne = [];numbers.forEach((num) =&gt; &#123;  increasedByOne.push(num + 1);&#125;); best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1);\n\n\n\n11.2 不要使用发生器。\n\n为什么? They don’t transpile well to ES5.\n\n\n\n11.3 如果你必须使用发生器或者无视 我们的建议，请确保他们的函数签名是正常的间隔。 eslint: generator-star-spacing\n\n为什么? function 和 * 是同一个概念关键字的一部分 - * 不是 function 的修饰符， function* 是一个不同于 function 的构造器。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 badfunction * foo() &#123;   ...&#125; badconst bar = function * () &#123;   ...&#125;; badconst baz = function *() &#123;   ...&#125;; badconst quux = function*() &#123;   ...&#125;; badfunction*foo() &#123;   ...&#125; badfunction *foo() &#123;   ...&#125; very badfunction*foo() &#123;   ...&#125; very badconst wat = function*() &#123;   ...&#125;; goodfunction* foo() &#123;   ...&#125; goodconst foo = function* () &#123;   ...&#125;;\n\n\n\n⬆ 返回目录\n属性  \n\n12.1 访问属性时使用点符号。 eslint: dot-notation\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;; badconst isJedi = luke[jedi]; goodconst isJedi = luke.jedi;\n\n\n\n12.2 使用变量访问属性时，使用 []表示法。\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;;function getProp(prop) &#123;  return luke[prop];&#125;const isJedi = getProp(jedi);\n\n\n\n12.3 计算指数时，可以使用 ** 运算符。 eslint: no-restricted-properties.\n12345 badconst binary = Math.pow(2, 10); goodconst binary = 2 ** 10;\n\n\n\n⬆ 返回目录\n变量  \n\n13.1 使用 const 或者 let 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: no-undef prefer-const\n12345 badsuperPower = new SuperPower(); goodconst superPower = new SuperPower();\n\n\n\n13.2 使用 const 或者 let 声明每一个变量。 eslint: one-var\n\n为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 ; 还是使用 , 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。\n\n123456789101112131415 badconst items = getItems(),    goSportsTeam = true,    dragonball = z; bad (compare to above, and try to spot the mistake)const items = getItems(),    goSportsTeam = true;    dragonball = z; goodconst items = getItems();const goSportsTeam = true;const dragonball = z;\n\n\n\n13.3 把 const 声明的放在一起，把 let 声明的放在一起。.\n\n为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。\n\n123456789101112131415161718 badlet i, len, dragonball,    items = getItems(),    goSportsTeam = true; badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len; goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length;\n\n\n\n13.4 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n\n为什么? let 和 const 是块级作用域而不是函数作用域。\n\n12345678910111213141516171819202122232425262728293031 bad - 不必要的函数调用function checkName(hasName) &#123;  const name = getName();  if (hasName === test) &#123;    return false;  &#125;  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125; goodfunction checkName(hasName) &#123;  if (hasName === test) &#123;    return false;  &#125;  const name = getName();  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125;\n\n\n\n13.5 不要链式变量赋值。 eslint: no-multi-assign\n\n为什么? 链式变量赋值会创建隐式全局变量。\n\n123456789101112131415161718192021222324 bad(function example() &#123;   JavaScript 把它解释为   let a = ( b = ( c = 1 ) );   let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。  let a = b = c = 1;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  1console.log(c);  1 good(function example() &#123;  let a = 1;  let b = a;  let c = a;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  throws ReferenceErrorconsole.log(c);  throws ReferenceError 对于 `const` 也一样\n\n\n\n13.6 避免使用不必要的递增和递减 (++, --)。 eslint no-plusplus\n\n为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 num += 1 这样的语句来改变您的值，而不是使用 num++ 或 num ++ 。不允许不必要的增量和减量语句也会使您无法预先递增预递减值，这也会导致程序中的意外行为。\n\n1234567891011121314151617181920212223242526 badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) &#123;  let value = array[i];  sum += value;  if (value) &#123;    truthyCount++;  &#125;&#125; goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length;\n\n\n\n\n\n13.7 避免在赋值语句 = 前后换行。如果你的代码违反了 max-len， 使用括号包裹。 eslint operator-linebreak.\n\n为什么? 在 = 前后换行，可能混淆分配的值。\n\n123456789101112131415 badconst foo =  superLongLongLongLongLongLongLongLongFunctionName(); badconst foo  = superLongLongLongLongLongLongLongLongString; goodconst foo = (  superLongLongLongLongLongLongLongLongFunctionName()); goodconst foo = superLongLongLongLongLongLongLongLongString;\n\n\n\n⬆ 返回目录\n提升  \n\n14.1 var 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。const 和 let 声明的变量受到一个称之为 Temporal Dead Zones (TDZ) 的新概念保护。 知道为什么 typeof 不在安全 是很重要的。\n1234567891011121314151617181920212223242526 我们知道这个行不通 (假设没有未定义的全局变量)function example() &#123;  console.log(notDefined);  =&gt; throws a ReferenceError&#125; 在引用变量后创建变量声明将会因变量提升而起作用。 注意: 真正的值 `true` 不会被提升。function example() &#123;  console.log(declaredButNotAssigned);  =&gt; undefined  var declaredButNotAssigned = true;&#125; 解释器将变量提升到函数的顶部 这意味着我们可以将上边的例子重写为：function example() &#123;  let declaredButNotAssigned;  console.log(declaredButNotAssigned);  =&gt; undefined  declaredButNotAssigned = true;&#125; 使用 const 和 letfunction example() &#123;  console.log(declaredButNotAssigned);  =&gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned);  =&gt; throws a ReferenceError  const declaredButNotAssigned = true;&#125;\n\n\n\n14.2 匿名函数表达式提升变量名，而不是函数赋值。\n123456789function example() &#123;  console.log(anonymous);  =&gt; undefined  anonymous();  =&gt; TypeError anonymous is not a function  var anonymous = function () &#123;    console.log(anonymous function expression);  &#125;;&#125;\n\n\n\n14.3 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n12345678910111213141516171819202122function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  superPower();  =&gt; ReferenceError superPower is not defined  var named = function superPower() &#123;    console.log(Flying);  &#125;;&#125; 当函数名和变量名相同时也是如此。function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  var named = function named() &#123;    console.log(named);  &#125;;&#125;\n\n\n\n14.4 函数声明提升其名称和函数体。\n1234567function example() &#123;  superPower();  =&gt; Flying  function superPower() &#123;    console.log(Flying);  &#125;&#125;\n\n更多信息请参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。\n\n\n⬆ 返回目录\n比较运算符和等号  \n\n15.1 使用 === 和 !== 而不是 == 和 !=。 eslint: eqeqeq\n\n\n15.2 条件语句，例如 if 语句使用 ToBoolean 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：\n\nObjects 的取值为： true\nUndefined 的取值为： false\nNull 的取值为： false\nBooleans 的取值为： 布尔值的取值\nNumbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true\nStrings 的取值为: 如果是一个空字符串 &#39;&#39; 值为 false 否则为 true\n\n1234if ([0] &amp;&amp; []) &#123;   true   一个数组（既是是空的）是一个对象，对象的取值为 true&#125;\n\n\n\n15.3 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n1234567891011121314151617181920212223242526272829 badif (isValid === true) &#123;   ...&#125; goodif (isValid) &#123;   ...&#125; badif (name) &#123;   ...&#125; goodif (name !== ) &#123;   ...&#125; badif (collection.length) &#123;   ...&#125; goodif (collection.length &gt; 0) &#123;   ...&#125;\n\n\n\n15.4 获取更多信息请查看 Angus Croll 的 Truth Equality and JavaScript 。\n\n\n15.5 在 case 和 default 的子句中，如果存在声明 (例如. let, const, function, 和 class)，使用大括号来创建块 。 eslint: no-case-declarations\n\n为什么? 语法声明在整个 switch 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 case 条件达到才会发生。 当多个 case 语句定义相同的东西是，这会导致问题问题。\n\n12345678910111213141516171819202122232425262728293031323334353637383940 badswitch (foo) &#123;  case 1:    let x = 1;    break;  case 2:    const y = 2;    break;  case 3:    function f() &#123;       ...    &#125;    break;  default:    class C &#123;&#125;&#125; goodswitch (foo) &#123;  case 1: &#123;    let x = 1;    break;  &#125;  case 2: &#123;    const y = 2;    break;  &#125;  case 3: &#123;    function f() &#123;       ...    &#125;    break;  &#125;  case 4:    bar();    break;  default: &#123;    class C &#123;&#125;  &#125;&#125;\n\n\n\n15.6 三目表达式不应该嵌套，通常是单行表达式。 eslint: no-nested-ternary\n123456789101112131415 badconst foo = maybe1 &gt; maybe2  ? bar  : value1 &gt; value2 ? baz : null; 分离为两个三目表达式const maybeNull = value1 &gt; value2 ? baz : null; betterconst foo = maybe1 &gt; maybe2  ? bar  : maybeNull; bestconst foo = maybe1 &gt; maybe2 ? bar : maybeNull;\n\n\n\n15.7 避免不必要的三目表达式。 eslint: no-unneeded-ternary\n123456789 badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true; goodconst foo = a || b;const bar = !!c;const baz = !c;\n\n\n\n15.8 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (+, -, *, &amp; ) 因为他们的优先级被广泛理解。 eslint: no-mixed-operators\n\n为什么? 这能提高可读性并且表明开发人员的意图。\n\n12345678910111213141516171819202122232425 badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0; badconst bar = a ** b - 5 % d; bad 可能陷入一种 (a || b) &amp;&amp; c 的思考if (a || b &amp;&amp; c) &#123;  return d;&#125; goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0); goodconst bar = (a ** b) - (5 % d); goodif (a || (b &amp;&amp; c)) &#123;  return d;&#125; goodconst bar = a + b  c * d;\n\n\n\n⬆ 返回目录\n块  \n\n16.1 当有多行代码块的时候，使用大括号包裹。 eslint: nonblock-statement-body-position\n12345678910111213141516171819 badif (test)  return false; goodif (test) return false; goodif (test) &#123;  return false;&#125; badfunction foo() &#123; return false; &#125; goodfunction bar() &#123;  return false;&#125;\n\n\n\n16.2 如果你使用的是 if 和 else 的多行代码块，则将 else 语句放在 if 块闭括号同一行的位置。 eslint: brace-style\n12345678910111213141516 badif (test) &#123;  thing1();  thing2();&#125;else &#123;  thing3();&#125; goodif (test) &#123;  thing1();  thing2();&#125; else &#123;  thing3();&#125;\n\n\n\n16.3 如果一个 if 块总是执行一个 return 语句，那么接下来的 else 块就没有必要了。 如果一个包含 return 语句的 else if 块，在一个包含了 return 语句的 if 块之后，那么可以拆成多个 if 块。 eslint: no-else-return\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 badfunction foo() &#123;  if (x) &#123;    return x;  &#125; else &#123;    return y;  &#125;&#125; badfunction cats() &#123;  if (x) &#123;    return x;  &#125; else if (y) &#123;    return y;  &#125;&#125; badfunction dogs() &#123;  if (x) &#123;    return x;  &#125; else &#123;    if (y) &#123;      return y;    &#125;  &#125;&#125; goodfunction foo() &#123;  if (x) &#123;    return x;  &#125;  return y;&#125; goodfunction cats() &#123;  if (x) &#123;    return x;  &#125;  if (y) &#123;    return y;  &#125;&#125; goodfunction dogs(x) &#123;  if (x) &#123;    if (z) &#123;      return y;    &#125;  &#125; else &#123;    return z;  &#125;&#125;\n\n\n\n⬆ 返回目录\n控制语句  \n\n17.1 如果你的控制语句 (if, while 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n\n为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 badif ((foo === 123 || bar === abc) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; badif (foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; badif (foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; badif (  foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; goodif (  foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; goodif (  (foo === 123 || bar === abc)  &amp;&amp; doesItLookGoodWhenItBecomesThatLong()  &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; goodif (foo === 123 &amp;&amp; bar === abc) &#123;  thing1();&#125;\n\n\n\n17.2 不要使用选择操作符代替控制语句。\n1234567 bad!isRunning &amp;&amp; startRunning(); goodif (!isRunning) &#123;  startRunning();&#125;\n\n\n\n⬆ 返回目录\n注释  \n\n18.1 使用 ** ... * 来进行多行注释。\n123456789101112131415161718192021222324 bad make() returns a new element based on the passed in tag name @param &#123;String&#125; tag @return &#123;Element&#125; elementfunction make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.2 使用  进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n123456789101112131415161718192021222324252627282930313233 badconst active = true;   is current tab good is current tabconst active = true; badfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; goodfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; also goodfunction getType() &#123;   set the default type to no type  const type = this.type || no type;  return type;&#125;\n\n\n\n18.3 用一个空格开始所有的注释，使它更容易阅读。 eslint: spaced-comment\n12345678910111213141516171819202122232425262728293031 badis current tabconst active = true; good is current tabconst active = true; bad** *make() returns a new element *based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.4 使用 FIXME 或者 TODO 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 FIXME: -- 需要解决这个问题 或者 TODO: -- 需要被实现。\n\n\n18.5 使用  FIXME: 注释一个问题。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     FIXME: 这里不应该使用全局变量    total = 0;  &#125;&#125;\n\n\n\n18.6 使用  TODO: 注释解决问题的方法。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     TODO: total 应该由一个 param 的选项配置    this.total = 0;  &#125;&#125;\n\n\n\n⬆ 返回目录\n空白  \n\n19.1 使用 tabs (空格字符) 设置为 2 个空格。 eslint: indent\n1234567891011121314 badfunction foo() &#123;∙∙∙∙let name;&#125; badfunction bar() &#123;∙let name;&#125; goodfunction baz() &#123;∙∙let name;&#125;\n\n\n\n19.2 在主体前放置一个空格。 eslint: space-before-blocks\n123456789101112131415161718192021 badfunction test()&#123;  console.log(test);&#125; goodfunction test() &#123;  console.log(test);&#125; baddog.set(attr,&#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;); gooddog.set(attr, &#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;);\n\n\n\n19.3 在控制语句（if, while 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: keyword-spacing\n12345678910111213141516171819 badif(isJedi) &#123;  fight ();&#125; goodif (isJedi) &#123;  fight();&#125; badfunction fight () &#123;  console.log (Swooosh!);&#125; goodfunction fight() &#123;  console.log(Swooosh!);&#125;\n\n\n\n19.4 用空格分离操作符。 eslint: space-infix-ops\n12345 badconst x=y+5; goodconst x = y + 5;\n\n\n\n19.5 使用单个换行符结束文件。 eslint: eol-last\n1234 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;\n\n12345 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵↵\n\n1234 goodimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵\n\n\n\n19.6 在使用长方法连滴啊用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: newline-per-chained-call no-whitespace-before-property\n12345678910111213141516171819202122232425262728293031323334353637 bad$(#items).find(.selected).highlight().end().find(.open).updateCount(); bad$(#items).  find(.selected).    highlight().    end().  find(.open).    updateCount(); good$(#items)  .find(.selected)    .highlight()    .end()  .find(.open)    .updateCount(); badconst leds = stage.selectAll(.led).data(data).enter().append(svg:svg).classed(led, true)    .attr(width, (radius + margin) * 2).append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led)    .data(data)  .enter().append(svg:svg)    .classed(led, true)    .attr(width, (radius + margin) * 2)  .append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led).data(data);\n\n\n\n19.7 在块和下一个语句之前留下一空白行。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 badif (foo) &#123;  return bar;&#125;return baz; goodif (foo) &#123;  return bar;&#125;return baz; badconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; goodconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; badconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr; goodconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr;\n\n\n\n19.8 不要在块的开头使用空白行。 eslint: padded-blocks\n1234567891011121314151617181920212223242526272829303132333435 badfunction bar() &#123;  console.log(foo);&#125; badif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125; badclass Foo &#123;  constructor(bar) &#123;    this.bar = bar;  &#125;&#125; goodfunction bar() &#123;  console.log(foo);&#125; goodif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125;\n\n\n\n19.9 不要在括号内添加空格。 eslint: space-in-parens\n12345678910111213141516171819 badfunction bar( foo ) &#123;  return foo;&#125; goodfunction bar(foo) &#123;  return foo;&#125; badif ( foo ) &#123;  console.log(foo);&#125; goodif (foo) &#123;  console.log(foo);&#125;\n\n\n\n19.10 不要在中括号中添加空格。 eslint: array-bracket-spacing\n1234567 badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]); goodconst foo = [1, 2, 3];console.log(foo[0]);\n\n\n\n19.11 在花括号内添加空格。 eslint: object-curly-spacing\n12345 badconst foo = &#123;clark: kent&#125;; goodconst foo = &#123; clark: kent &#125;;\n\n\n\n19.12 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 约束，长字符串可免除此规定，不应分解。 eslint: max-len\n\n为什么? 这样能够确保可读性和可维护性。\n\n12345678910111213141516171819202122 badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; bad$.ajax(&#123; method: POST, url: https:airbnb.com, data: &#123; name: John &#125; &#125;).done(() =&gt; console.log(Congratulations!)).fail(() =&gt; console.log(You have failed this city.)); goodconst foo = jsonData  &amp;&amp; jsonData.foo  &amp;&amp; jsonData.foo.bar  &amp;&amp; jsonData.foo.bar.baz  &amp;&amp; jsonData.foo.bar.baz.quux  &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; good$.ajax(&#123;  method: POST,  url: https:airbnb.com,  data: &#123; name: John &#125;,&#125;)  .done(() =&gt; console.log(Congratulations!))  .fail(() =&gt; console.log(You have failed this city.));\n\n\n\n19.13 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: block-spacing\n1234567 badfunction foo() &#123;return true;&#125;if (foo) &#123; bar = 0;&#125; goodfunction foo() &#123; return true; &#125;if (foo) &#123; bar = 0; &#125;\n\n\n\n19.14 逗号之前避免使用空格，逗号之后需要使用空格。eslint: comma-spacing\n1234567 badvar foo = 1,bar = 2;var arr = [1 , 2]; goodvar foo = 1, bar = 2;var arr = [1, 2];\n\n\n\n19.15 在计算属性之间强化间距。eslint: computed-property-spacing\n1234567891011 badobj[foo ]obj[ foo]var x = &#123;[ b ]: a&#125;obj[foo[ bar ]] goodobj[foo]obj[foo]var x = &#123; [b]: a &#125;obj[foo[bar]]\n\n\n\n19.16 在函数和它的调用之间强化间距。 eslint: func-call-spacing\n12345678 badfunc ();func(); goodfunc();\n\n\n\n19.17 在对象的属性和值之间强化间距。 eslint: key-spacing\n123456 badvar obj = &#123; foo : 42 &#125;;var obj2 = &#123; foo:42 &#125;; goodvar obj = &#123; foo: 42 &#125;;\n\n\n\n19.18 在行的末尾避免使用空格。 eslint: no-trailing-spaces\n\n\n19.19 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: no-multiple-empty-lines\n\n1234567891011 badvar x = 1;var y = 2; goodvar x = 1;var y = 2;\n\n\n\n\n\n⬆ 返回目录\n逗号  \n\n20.1 逗号前置： 不行 eslint: comma-style\n1234567891011121314151617181920212223242526272829 badconst story = [    once  , upon  , aTime]; goodconst story = [  once,  upon,  aTime,]; badconst hero = &#123;    firstName: Ada  , lastName: Lovelace  , birthYear: 1815  , superPower: computers&#125;; goodconst hero = &#123;  firstName: Ada,  lastName: Lovelace,  birthYear: 1815,  superPower: computers,&#125;;\n\n\n\n20.2 添加尾随逗号： 可以 eslint: comma-dangle\n\n为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 尾随逗号问题 。\n\n1234567891011121314 bad - 没有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,-    lastName: Nightingale+    lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing]&#125;; good - 有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,     lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing],&#125;;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 badconst hero = &#123;  firstName: Dana,  lastName: Scully&#125;;const heroes = [  Batman,  Superman]; goodconst hero = &#123;  firstName: Dana,  lastName: Scully,&#125;;const heroes = [  Batman,  Superman,]; badfunction createHero(  firstName,  lastName,  inventorOf) &#123;   does nothing&#125; goodfunction createHero(  firstName,  lastName,  inventorOf,) &#123;   does nothing&#125; good (注意逗号不能出现在 rest 元素后边)function createHero(  firstName,  lastName,  inventorOf,  ...heroArgs) &#123;   does nothing&#125; badcreateHero(  firstName,  lastName,  inventorOf); goodcreateHero(  firstName,  lastName,  inventorOf,); good (注意逗号不能出现在 rest 元素后边)createHero(  firstName,  lastName,  inventorOf,  ...heroArgs);\n\n\n\n⬆ 返回目录\n分号  \n\n21.1 对 eslint: semi\n\n为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 Automatic Semicolon Insertion 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。\n\n123456789101112131415161718192021222324252627282930313233343536 bad - 可能异常const luke = &#123;&#125;const leia = &#123;&#125;[luke, leia].forEach(jedi =&gt; jedi.father = vader) bad - 可能异常const reaction = No! Thats impossible!(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()) bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生function foo() &#123;  return    search your feelings, you know it to be foo&#125; goodconst luke = &#123;&#125;;const leia = &#123;&#125;;[luke, leia].forEach((jedi) =&gt; &#123;  jedi.father = vader;&#125;); goodconst reaction = No! Thats impossible!;(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()); goodfunction foo() &#123;  return search your feelings, you know it to be foo;&#125;\n\n更多信息.\n\n\n⬆ 返回目录\n类型转换和强制类型转换  \n\n22.1 在语句开始前进行类型转换。\n\n\n22.2  字符类型： eslint: no-new-wrappers\n12345678910111213 =&gt; this.reviewScore = 9; badconst totalScore = new String(this.reviewScore);  typeof totalScore is object not string badconst totalScore = this.reviewScore + ;  invokes this.reviewScore.valueOf() badconst totalScore = this.reviewScore.toString();  isn’t guaranteed to return a string goodconst totalScore = String(this.reviewScore);\n\n\n\n22.3 数字类型：使用 Number 进行类型铸造和 parseInt 总是通过一个基数来解析一个字符串。 eslint: radix no-new-wrappers\n12345678910111213141516171819const inputValue = 4; badconst val = new Number(inputValue); badconst val = +inputValue; badconst val = inputValue &gt;&gt; 0; badconst val = parseInt(inputValue); goodconst val = Number(inputValue); goodconst val = parseInt(inputValue, 10);\n\n\n\n22.4 如果出于某种原因，你正在做一些疯狂的事情，而 parseInt 是你的瓶颈，并且出于 性能问题 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n123456 good** * parseInt 使我的代码变慢。 * 位运算将一个字符串转换成数字更快。 *const val = inputValue &gt;&gt; 0;\n\n\n\n22.5 注意： 当你使用位运算的时候要小心。 数字总是被以 64-bit 值 的形式表示，但是位运算总是返回一个 32-bit 的整数 (来源)。 对于大于 32 位的整数值，位运算可能会导致意外行为。讨论。 最大的 32 位整数是： 2,147,483,647。\n1232147483647 &gt;&gt; 0;  =&gt; 21474836472147483648 &gt;&gt; 0;  =&gt; -21474836482147483649 &gt;&gt; 0;  =&gt; -2147483647\n\n\n\n22.6 布尔类型： eslint: no-new-wrappers\n12345678910const age = 0; badconst hasAge = new Boolean(age); goodconst hasAge = Boolean(age); bestconst hasAge = !!age;\n\n\n\n⬆ 返回目录\n命名规范  \n\n23.1 避免单字母的名字。用你的命名来描述功能。 eslint: id-length\n123456789 badfunction q() &#123;   ...&#125; goodfunction query() &#123;   ...&#125;\n\n\n\n23.2 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: camelcase\n12345678 badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125; goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;\n\n\n\n23.3 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: new-cap\n12345678910111213141516171819 badfunction user(options) &#123;  this.name = options.name;&#125;const bad = new user(&#123;  name: nope,&#125;); goodclass User &#123;  constructor(options) &#123;    this.name = options.name;  &#125;&#125;const good = new User(&#123;  name: yup,&#125;);\n\n\n\n23.4 不要使用前置或者后置下划线。 eslint: no-underscore-dangle\n\n为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。\n\n123456789101112 badthis.__firstName__ = Panda;this.firstName_ = Panda;this._firstName = Panda; goodthis.firstName = Panda; 好，在 WeakMapx 可用的环境中 see https:kangax.github.iocompat-tablees6#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, Panda);\n\n\n\n23.5 不要保存 this 的引用。 使用箭头函数或者 函数#bind。\n12345678910111213141516171819202122 badfunction foo() &#123;  const self = this;  return function () &#123;    console.log(self);  &#125;;&#125; badfunction foo() &#123;  const that = this;  return function () &#123;    console.log(that);  &#125;;&#125; goodfunction foo() &#123;  return () =&gt; &#123;    console.log(this);  &#125;;&#125;\n\n\n\n23.6 文件名应该和默认导出的名称完全匹配。\n123456789101112131415161718192021222324252627282930 file 1 contentsclass CheckBox &#123;   ...&#125;export default CheckBox; file 2 contentsexport default function fortyTwo() &#123; return 42; &#125; file 3 contentsexport default function insideDirectory() &#123;&#125; in some other file badimport CheckBox from .checkBox;  PascalCase importexport, camelCase filenameimport FortyTwo from .FortyTwo;  PascalCase importfilename, camelCase exportimport InsideDirectory from .InsideDirectory;  PascalCase importfilename, camelCase export badimport CheckBox from .check_box;  PascalCase importexport, snake_case filenameimport forty_two from .forty_two;  snake_case importfilename, camelCase exportimport inside_directory from .inside_directory;  snake_case import, camelCase exportimport index from .inside_directoryindex;  requiring the index file explicitlyimport insideDirectory from .insideDirectoryindex;  requiring the index file explicitly goodimport CheckBox from .CheckBox;  PascalCase exportimportfilenameimport fortyTwo from .fortyTwo;  camelCase exportimportfilenameimport insideDirectory from .insideDirectory;  camelCase exportimportdirectory nameimplicit index ^ supports both insideDirectory.js and insideDirectoryindex.js\n\n\n\n23.7 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n12345function makeStyleGuide() &#123;   ...&#125;export default makeStyleGuide;\n\n\n\n23.8 当你导出一个构造器  类  单例  函数库  暴露的对象时应该使用帕斯卡命名法。\n123456const AirbnbStyleGuide = &#123;  es6: &#123;  &#125;,&#125;;export default AirbnbStyleGuide;\n\n\n\n23.9 缩略词和缩写都必须是全部大写或者全部小写。\n\n为什么? 名字是为了可读性，不是为了满足计算机算法。\n\n12345678910111213141516171819202122232425262728 badimport SmsContainer from .containersSmsContainer; badconst HttpRequests = [   ...]; goodimport SMSContainer from .containersSMSContainer; goodconst HTTPRequests = [   ...]; also goodconst httpRequests = [   ...]; bestimport TextMessageContainer from .containersTextMessageContainer; bestconst requests = [   ...];\n\n\n\n23.10 你可以大写一个常亮，如果它：（1）被导出，（2）使用 const 定义（不能被重新分配），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n\n为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。\n\n是否是对所有的 const 定义的变量？ - 这个是没哟必要的，不应该在文件中使用大学。但是，它应该用于导出常量。\n导出对象呢？ - 在顶级导出属性 (e.g. EXPORTED_OBJECT.key) 并且保持所有嵌套属性不变。\n\n\n12345678910111213141516171819202122232425262728 badconst PRIVATE_VARIABLE = should not be unnecessarily uppercased within a file; badexport const THING_TO_BE_CHANGED = should obviously not be uppercased; badexport let REASSIGNABLE_VARIABLE = do not use let with uppercase variables; --- 允许，但是不提供语义值export const apiKey = SOMEKEY; 多数情况下，很好export const API_KEY = SOMEKEY; --- bad - 不必要大写 key 没有增加语义值export const MAPPING = &#123;  KEY: value&#125;; goodexport const MAPPING = &#123;  key: value&#125;;\n\n\n\n⬆ 返回目录\n存取器  \n\n24.1 对于属性的的存取函数不是必须的。\n\n\n24.2 不要使用 JavaScript 的 getterssetters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 getVal() 和 setVal(&#39;hello&#39;)。\n123456789101112131415161718192021 badclass Dragon &#123;  get age() &#123;     ...  &#125;  set age(value) &#123;     ...  &#125;&#125; goodclass Dragon &#123;  getAge() &#123;     ...  &#125;  setAge(value) &#123;     ...  &#125;&#125;\n\n\n\n24.3 如果属性方法是一个 boolean 值，使用 isVal() 或者 hasVal()。\n123456789 badif (!dragon.age()) &#123;  return false;&#125; goodif (!dragon.hasAge()) &#123;  return false;&#125;\n\n\n\n24.4 可以创建 get() 和 set() 方法，但是要保证一致性。\n1234567891011121314class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    const lightsaber = options.lightsaber || blue;    this.set(lightsaber, lightsaber);  &#125;  set(key, val) &#123;    this[key] = val;  &#125;  get(key) &#123;    return this[key];  &#125;&#125;\n\n\n\n⬆ 返回目录\n事件  \n\n25.1 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n12345678 bad$(this).trigger(listingUpdated, listing.id); ...$(this).on(listingUpdated, (e, listingID) =&gt; &#123;   do something with listingID&#125;);\n\n更好的写法：\n12345678 good$(this).trigger(listingUpdated, &#123; listingID: listing.id &#125;); ...$(this).on(listingUpdated, (e, data) =&gt; &#123;   do something with data.listingID&#125;);\n\n\n  ⬆ 返回目录\njQuery  \n\n26.1 对于 jQuery 对象的变量使用 $ 作为前缀。\n12345678 badconst sidebar = $(.sidebar); goodconst $sidebar = $(.sidebar); goodconst $sidebarBtn = $(.sidebar-btn);\n\n\n\n26.2 缓存 jQuery 查询。\n12345678910111213141516171819202122 badfunction setSidebar() &#123;  $(.sidebar).hide();   ...  $(.sidebar).css(&#123;    background-color: pink,  &#125;);&#125; goodfunction setSidebar() &#123;  const $sidebar = $(.sidebar);  $sidebar.hide();   ...  $sidebar.css(&#123;    background-color: pink,  &#125;);&#125;\n\n\n\n26.3 对于 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;) 的格式。 jsPerf\n\n\n26.4 对于有作用域的 jQuery 对象查询使用 find 。\n1234567891011121314 bad$(ul, .sidebar).hide(); bad$(.sidebar).find(ul).hide(); good$(.sidebar ul).hide(); good$(.sidebar &gt; ul).hide(); good$sidebar.find(ul).hide();\n\n\n\n⬆ 返回目录\nECMAScript 5 兼容性  \n\n27.1 参考 Kangax的 ES5 兼容性表格。\n\n⬆ 返回目录\n\nECMAScript 6+ (ES 2015+) Styles  \n\n28.1 这是一个链接到各种 ES6+ 特性的集合。\n\n\n箭头函数\n\n类\n\n对象简写\n\n对象简洁\n\n对象计算属性\n\n字符串模板\n\n解构\n\n默认参数\n\nRest\n\n数组展开\n\nLet 和 Const\n\n求幂运算符\n\n迭代器和发生器\n\n模块\n\n\n28.2 不要使用尚未达到第3阶段的 TC39 建议。\n\n为什么? 它们没有最终确定， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。\n\n\n\n\n\n⬆ 返回目录\n标准库  标准库  包含功能已损坏的实用工具，但因为遗留原因而保留。\n  \n\n29.1 使用 Number.isNaN 代替全局的 isNaN.eslint: no-restricted-globals\n\n为什么? 全局的 isNaN 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n1234567 badisNaN(1.2);  falseisNaN(1.2.3);  true goodNumber.isNaN(1.2.3);  falseNumber.isNaN(Number(1.2.3));  true\n\n\n\n29.2 使用 Number.isFinite 代替全局的 isFinite.eslint: no-restricted-globals\n\n为什么? 全局的 isFinite 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n123456 badisFinite(2e3);  true goodNumber.isFinite(2e3);  falseNumber.isFinite(parseInt(2e3, 10));  true\n\n\n\n⬆ 返回目录\nTesting  \n\n30.1 是的.\n123function foo() &#123;  return true;&#125;\n\n\n\n30.2 没有，但是认真:\n\n无论你使用那种测试框架，都应该编写测试！\n努力写出许多小的纯函数，并尽量减少发生错误的地方。\n对于静态方法和 mock 要小心—-它们会使你的测试更加脆弱。\n我们主要在 Airbnb 上使用 mocha 和 jest 。 tape 也会用在一些小的独立模块上。\n100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。\n无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。\n\n\n\n⬆ 返回目录\n性能\nOn Layout &amp; Web Performance\nString vs Array Concat\nTryCatch Cost In a Loop\nBang Function\njQuery Find vs Context, Selector\ninnerHTML vs textContent for script text\nLong String Concatenation\nAre Javascript functions like map(), reduce(), and filter() optimized for traversing arrays?\nLoading…\n\n⬆ 返回目录\n资源学习 ES6+\n\nLatest ECMA spec\nExploringJS\nES6 Compatibility Table\nComprehensive Overview of ES6 Features\n\n读这个\n\nStandard ECMA-262\n\n工具\n\nCode Style Linters\nESlint - Airbnb Style .eslintrc\nJSHint - Airbnb Style .jshintrc\n\n\nNeutrino preset - neutrino-preset-airbnb-base\n\n其他编码规范\n\nGoogle JavaScript Style Guide\njQuery Core Style Guidelines\nPrinciples of Writing Consistent, Idiomatic JavaScript\nStandardJS\n\n其他风格\n\nNaming this in nested functions - Christian Johansen\nConditional Callbacks - Ross Allen\nPopular JavaScript Coding Conventions on GitHub - JeongHoon Byun\nMultiple var statements in JavaScript, not superfluous - Ben Alman\n\n进一步阅读\n\nUnderstanding JavaScript Closures - Angus Croll\nBasic JavaScript for the impatient programmer - Dr. Axel Rauschmayer\nYou Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz\nES6 Features - Luke Hoban\nFrontend Guidelines - Benjamin De Cock\n\n书籍\n\nJavaScript: The Good Parts - Douglas Crockford\nJavaScript Patterns - Stoyan Stefanov\nPro JavaScript Design Patterns  - Ross Harmes and Dustin Diaz\nHigh Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders\nMaintainable JavaScript - Nicholas C. Zakas\nJavaScript Web Applications - Alex MacCaw\nPro JavaScript Techniques - John Resig\nSmashing Node.js: JavaScript Everywhere - Guillermo Rauch\nSecrets of the JavaScript Ninja - John Resig and Bear Bibeault\nHuman JavaScript - Henrik Joreteg\nSuperhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy\nJSBooks - Julien Bouquillon\nThird Party JavaScript - Ben Vinegar and Anton Kovalyov\nEffective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman\nEloquent JavaScript - Marijn Haverbeke\nYou Don’t Know JS: ES6 &amp; Beyond - Kyle Simpson\n\n博客\n\nJavaScript Weekly\nJavaScript, JavaScript…\nBocoup Weblog\nAdequately Good\nNCZOnline\nPerfection Kills\nBen Alman\nDmitry Baranovskiy\nnettuts\n\n播客\n\nJavaScript Air\nJavaScript Jabber\n\n⬆ 返回目录\nJavaScript风格指南的指南\nReference\n\n许可证(The MIT License)\nCopyright (c) 2012 康兵奎\nPermission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, andor sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:\nThe above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n⬆ 返回目录\n修正案我们鼓励您使用此指南并更改规则以适应您的团队的风格指南。下面，你可以列出一些对风格指南的修正。这允许您定期更新您的样式指南，而不必处理合并冲突。\n};","tags":["javascript"],"path":"2019/09/08/Airbnb-JavaScript-代码规范/","external_link":""},{"title":"骨传导","date":"2019-09-12T11:49:16.000Z","content":"骨传导\n骨传导是一种声音传导方式，即通过将声音转化为不同频率的机械振动，通过人的颅骨、骨迷路、内耳淋巴液传递、螺旋器、听神经、听觉中枢来传递声波。相对于通过振膜产生声波的经典声音传导方式，骨传导省去了许多声波传递的步骤，能在嘈杂的环境中实现清晰的声音还原，而且声波也不会因为在空气中扩散而影响到他人。\n骨传导技术分为骨传导扬声器技术和骨传导麦克风技术：\n\n骨传导扬声器技术 用于受话，受话即听取声音。气导扬声器是把电信号转化为的声波（振动信号传至听神经。而骨传导扬声器则是电信号转化的声波（振动信号）直接通过骨头传至听神经。声波（振动信号）的传递介质不同。\n骨传导麦克风技术 用于送话，送话即收集声音。气导送话是声波通过空气传至麦克风，而骨传导送话则直接通过骨头传递。\n\n利用这些骨传导技术制造的耳机，称之为骨传导耳机，也被称作骨导耳机、骨感耳机、骨传耳机和骨传感耳机。\n原文链接\n","tags":["百科"],"path":"2019/09/12/骨传导/","external_link":""},{"title":"nohup:在linux后台运行程序","date":"2019-09-12T13:15:04.000Z","content":"\nnohup:在linux后台运行程序今天在工作中，lz要在Linux系统上运行一个java程序，这个程序要在系统中持续运行。随后lz无意将ssh窗口关掉了，发现java程序停止了。原来，当使用ssh连接到系统运行程序的时候，该程序已经和你的ssh连接绑定了。如果你关闭连接，该程序就会停止。还有一个情景：如果要在后台运行多个java程序的时候，就需要启动多个ssh窗口，这样很麻烦。有没有方法来解决这个问题呢？答案是肯定的。\n1.使用nohup来执行命令，它会把命令自动调到linux后台运行，不锁定当前ssh窗口，也不会被ctrl + c，alt + F4之类打断程序的动行。\n1nohup java -jar test.jar &amp;\n\n执行完该命令后，终端会显示如下信息：\n12[1] 27945nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;\n\n[1]：该后台任务的jobid27945：是该进程的pidnohup.out：是该任务的输出位置\n2.要指定重定向的文件，如下：\n1nohup java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp;\n\n3.如果一个任务已经在前台执行，那就使用以下方法来将任务调整到后台：\n（1）首先，在正在执行任务的终端使用ctrl+z\n1[1]+  已停止               java -jar test.jar\n\n（2）使用bg命令将该任务调整至后台（fg与之相反，将后台任务调整至前台）\n1bg %1(1是jobid)\n\n如果不知道jobid，也可以使用jobs命令来查询。\n但是任务的输出还是会打印到终端上的（具体怎么将输出重定向到别的地方，lz也不造）。而且，这时该任务还是与当前终端相关联的，关闭终端还是会断掉该任务的。使用下面命令来解决：\n1disown -h %1\n\n这样再也不用担心关掉终端会停止掉任务喽！！！\nPS：再来说说nohup吧。nohup的意思是no hang up，就是说关掉终端是不会挂掉程序的。如果开始执行命令时只使用&amp;：\n1java -jar test.jar &amp;\n\n那么该任务也会在后台执行，但是一旦关掉终端该任务还是会挂掉，所以这就是nohup的用处了。\n原文链接\n","tags":["linux","nohup"],"path":"2019/09/12/nohup-在linux后台运行程序/","external_link":""},{"title":"TensorFlow 2.0 RC is available","date":"2019-09-12T13:41:44.000Z","content":"\nTensorFlow 2.0 RC工具探索可支持和加速 TensorFlow 工作流程的工具。\n\nCoLabColaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您只需点击一下鼠标，即可在浏览器中执行 TensorFlow 代码。\nTensorBoard一套可视化工具，用于理解、调试和优化TensorFlow程序。\nWhat-If工具一种无代码的方式探究机器学习模型的工具，对模型的理解、调试和公平性很有用。可在TensorFlow和Jupyter或CoLab笔记本中使用。\nML Perf全面的机器学习基准测试套件，用于衡量机器学习软件框架、机器学习硬件加速器和机器学习云端平台的性能。\nXLAXLA(加速线性代数)是一种特定领域的线性代数编译器，能够优化TensorFlow计算，它可以提高服务器和移动平台的运行速度改进内存使用情况和可移植性。\nTensorFlow Playground在浏览器中设计神经网络。别担心，不会使浏览器崩溃。\nTensorFlow Research Cloud加入TensorFlow Research Cloud（TFRC）计划后，研究人员可于申请访问Cloud TPU来加快实现下一波研究突破；我们免费提供1000个Cloud TPU.\n","tags":["TensorFlow","机器学习"],"path":"2019/09/12/TensorFlow-2-0-RC-is-available/","external_link":""},{"title":"Java面试题","date":"2019-09-13T07:57:44.000Z","content":"基础与框架String类能被继承吗，为什么?\n不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。\n\n1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence\n\n根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。　　final类不能被继承，没有子类，final类中的方法默认是final的。　　final方法不能被子类的方法覆盖，但可以被继承。　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。　　final不能用于修饰构造方法。　　注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。\n如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。　　使用final方法的原因有二：　　第一、把方法锁定，防止任何继承类修改它的意义和实现。　　第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑）\n\n下面这段话摘自《Java编程思想》第四版第143页：“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。”\n\n关于String类，要了解常量池的概念\n1String s = new String(“xyz”);  创建了几个对象\n\n答案： 1个或2个， 如果”xyz”已经存在于常量池中，则只在堆中创建”xyz”对象的一个拷贝，否则还要在常量池中在创建一份\n1String s = a+b+c+d; 创建了几个对象\n\n答案： 这个和JVM实现有关， 如果常量池为空，可能是1个也可能是7个等\nString，Stringbuffer，StringBuilder的区别？1、用来处理字符串常用的类有3种：String、StringBuffer和StringBuilder2、三者之间的区别：都是final类，都不允许被继承；String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；StringBuffer类是线程安全的，StringBuilder不是线程安全的；\nString 和 StringBuffer：1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；\n2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；\n3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如：\n12String s1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);\n\n生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：\n12345Java Compiler直接把上述第一条语句编译为：String s2 = “This is only a”;String s3 = “ simple”;String s4 = “ test”;String s1 = s2 + s3 + s4;\n\n传送门\nArrayList和LinkedList有什么区别ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。\n数据的更新和查找ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻\n数据的增加和删除对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。\n传送门\n类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序\n此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量（父类实例成员变量）、父类构造函数、子类非静态变量（子类实例成员变量）、子类构造函数。 \n\n传送门\n用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等\nHashtable,HashMap,ConcurrentHashMap\n\n线程不安全的HashMap因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。\nHashMapHashMap内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。其中每个结点存储的是一个键值对整体（Entry），HashMap采用拉链法解决哈希冲突\n传送门\n效率低下的HashTable容器     HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。\nConcurrentHashMap的锁分段技术     HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n传送门\n\nhashcode() 方法，在object类中定义如下：\n\n1public native int hashCode();\n\nnative说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double。。。。等等这些类都是覆盖了hashcode()方法的例如String类中:就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。(为什么取31?主要是因为31是一个奇质数，所以31i=32i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多).\n123456789101112public int hashCode() &#123;    int h = hash;    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;        char val[] = value;        for (int i = 0; i &lt; value.length; i++) &#123;            h = 31 * h + val[i];        &#125;        hash = h;    &#125;    return h;&#125;\n\nHashMap为什么get和set那么快，concurrentHashMap为什么能提高并发\nHashMap 底层是基于 数组 + 链表 组成的\n\n传送门\n抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\n实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。抽象类和接口的区别\n\n\n由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。\n\n\n接口可以继承多个接口。java类是单继承的。classB Extends classAjava接口可以多继承。Interface3 Extends Interface0, Interface1, interface……不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。\n\n什么情况下会发生栈内存溢出方法递归调用产生这种结果\n\n栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）\n\n所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。栈溢出(StackOverflowError)\n什么是nio，原理\nNIO是为了弥补传统IO工作模式的不足而研发的，NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型IO能力。\n\nNIO的工作原理是什么？\n　　在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞IO的通信方式，不要求阻塞等待IO操作完成即可返回，从而减少了管理IO连接导致的系统开销，大幅度提高了系统性能。\n　　当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络IO中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络IO无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。\n　　并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络IO设计的并发型服务器程序与以往基于阻塞IO的实现程序有很大不同，在使用非阻塞网络IO的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。\n　　使用非阻塞型IO进行并发型服务器程序设计分三个部分：1. 向Selector对象注册感兴趣的事件；2.从Selector中获取所感兴趣的事件；3. 根据不同的事件进行相应的处理。\n　　在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展。\n传送门\n反射中，Class.forName和ClassLoader区别Java中Class.forName和classloader都可以用来对类进行加载。\n\nClass.forName(“className”);\n其实这种方法调运的是：Class.forName(className, true, ClassLoader.getCallerClassLoader())方法\n参数一：className，需要加载的类的名称。\n参数二：true，是否对class进行初始化（需要initialize）\n参数三：classLoader，对应的类加载器\nClassLoader.laodClass(“className”);\n其实这种方法调运的是：ClassLoader.loadClass(name, false)方法\n参数一：name,需要加载的类的名称\n参数二：false，这个类加载以后是否需要去连接（不需要linking）\n\n可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。\n而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。\n传送门\ntomcat结构，类加载器流程\nTomcat 的总体结构\n\n\n从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。\n什么是类加载器？虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。\n传送门\n讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式Spring的beanFactory和factoryBean的区别Spring加载流程Spring如何管理事务的多线程线城池的最大线程数目根据什么确定多线程的几种实现方式，什么是线程安全，什么是重排序volatile的原理，作用，能代替锁么sleep和wait的区别，以及wait的实现原理Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁用过哪些原子类，他们的参数以及原理是什么用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。spring的controller是单例还是多例，怎么保证并发的安全用三个线程按顺序循环打印abc三个字母，比如abcabcabcThreadLocal用过么，原理是什么，用的时候要注意什么如果让你实现一个并发安全的链表，你会怎么做JVM相关jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms当出现了内存溢出，你怎么排错JVM内存模型的相关知识了解多少简单说说你了解的类加载器JAVA的反射机制网络http1.0和http1.1有什么区别TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么TIME_WAIT和CLOSE_WAIT的区别说说你知道的几种HTTP响应码当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤Linux下IO模型有几种，各自的含义是什么TCPIP如何保证可靠性，数据包有哪些数据组成架构设计与分布式：tomcat如何调优，各种参数的意义常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等如何防止缓存雪崩12.用java自己实现一个LRU分布式集群下如何做到唯一序列号设计一个秒杀系统，30分钟没付款就自动关闭交易如何做一个分布式锁用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗MQ系统的数据如何保证不丢失分布式事务的原理，如何使用分布式事务什么是一致性hash什么是restful，讲讲你理解的restful如何设计建立和保持100w的长连接？解释什么是MESI协议(缓存一致性)说说你知道的几种HASH算法，简单的也可以什么是paxos算法redis和memcached 的内存管理的区别一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新算法10亿个数字里里面找最小的10个有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优2亿个随机生成的无序整数,找出中间大小的值遍历二叉树数据库数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁MYsql的索引实现方式聚集索引和非聚集索引的区别数据库中 BTREE和B+tree区别","tags":["面试","Java"],"path":"2019/09/13/Java面试题/","external_link":""},{"title":"OpenCV边缘检测","date":"2019-09-14T06:04:05.000Z","content":"OpenCV边缘检测\n12345678910111213import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(1024.jpg,0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap=gray)plt.title(original),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap=gray)plt.title(edge),plt.xticks([]),plt.yticks([])plt.show()\n\n","tags":["OpenCV","边缘检测"],"path":"2019/09/14/OpenCV边缘检测/","external_link":""},{"title":"2019年度机器学习49个顶级工程汇总","date":"2019-09-16T01:56:47.000Z","content":"2019年度机器学习49个顶级工程汇总\n过去一年中，我们比较了近22000个机器学习开源工程，并筛选了49个顶级项目（筛选率0.22%）。\n\n其中包括以下6个分类\n\n计算机视觉（1~5）\n强化学习（6~13）\nNLP（14~20）\nGAN（21~26）\nNeural Network（27~35）\nToolkit（36~49）\n\n\n我们花了很大的精力筛选这个list，并小心的选择出2018年1月到12月间最好的工程。为了保证名单质量，Mybridge AI协同考虑了流行度、参与度、发布时间等多重因素。\n\n计算机视觉1、Detectron：facebook发布的目标检测工具【18913 star on Github】项目地址：https:github.comfacebookresearchDetectron?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n2、Openpost：多人实时特征点检测工具【11052 stars on GitHub】项目地址：https:github.comCMU-Perceptual-Computing-Labopenpose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n3、DensePost：2维人体图片转3维的实时映射方法。【4165 stars on Github】项目地址：https:github.comfacebookresearchDensepose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n4、Maskrcnn-benchmark：（Pytorch）语义分割与目标检测工具包。【3888 stars on Github】项目地址：https:github.comfacebookresearchmaskrcnn-benchmark?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n5、SNIPER：多尺度目标检测算法。【1963 stars on Github】项目地址：https:github.commahyarnajibiSNIPER?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n强化学习6、Psychlab：Psychlab实验范例。【5595 stars on Github】项目地址：https:github.comdeepmindlabtreemastergame_scriptslevelscontributedpsychlab?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n7、ELF：一个灵活、轻量、可扩展的游戏研究平台。【2406 stars on Github】项目地址：https:github.compytorchelf?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n8、TRFL：（TensorFlow）强化学习agent工具包。【2312 stars on Github】项目地址：https:github.comdeepmindtrfl?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n9、Horizon：首个用于大规模需求的开源强化学习平台。【1703 stars on Github】项目地址：https:github.comfacebookresearchHorizon?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n10、Chess-alpha-zero：国际象棋强化学习项目（基于AlphaGo Zero方法）。【1307 stars on Github】项目地址：https:github.comZeta36chess-alpha-zero?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n11、Dm_control：DeepMind工具包。【1231 stars on Github】项目地址：https:github.comdeepminddm_control?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n12、MAMEToolkit：基于强化学习的电子游戏python库。【437 stars on Github】项目地址：https:github.comM-J-MurrayMAMEToolkit?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n13、Reaver：模块化的深度强化学习框架（星际争霸2）。【355 stars on Github】项目地址：https:github.cominoryyreaver?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\nNLP14、Bert：BERT的TensorFlow代码，以及预训练模型。【11703 stars on Github】项目地址：https:github.comgoogle-researchbert?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n15、Pytext：基于Pytorch的神经语言模型框架。【4466 stars on Github】项目地址：https:github.comfacebookresearchpytext?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n16、Bert-as-service：BERT模型的网络服务版本项目地址：https:github.comhanxiaobert-as-service?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n17、UnsupervisedMT：基于Phrase的无监督机器翻译方法。【1068 stars on Github】项目地址：https:github.comfacebookresearchUnsupervisedMT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n18、DecaNLP：NLP十项全能工具，多任务模型。【1648 stars on Github】项目地址：https:github.comsalesforcedecaNLP?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n19、NLP-architect：来自英特尔AI实验室的python工具包，包含了当前NLP领域的多种最佳模型。【1751 stars on Github】项目地址：https:github.comNervanaSystemsnlp-architect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n20、Gluon-nlp：NLP工具包。【1263 stars on Github】项目地址：https:github.comdmlcgluon-nlp?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\nGAN21、DeOldify：一个基于深度学习的图像补全工具包。【5060 stars on Github】项目地址：https:github.comjanticDeOldify?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n22、Progressive_growing_of_gans：GAN的变种实现，提高生产质量、稳定性以及多样性。项目地址：https:github.comtkarrasprogressive_growing_of_gans?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n23、MUNIT：多模态无监督图像翻译。【1339 stars on Github】项目地址：https:github.comNVlabsMUNIT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n24、Transparent_latent_gan：使用监督学习来解释GAN的隐空间信息。【1337 stars on Github】项目地址：https:github.comSummitKwantransparent_latent_gan?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n25、Gandissect：基于Pytorch的可视化以及理解GAN的神经元信息。【1065 stars on Github】项目地址：https:github.comCSAILVisiongandissect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n26、GANimation：单张图片的表情变换。【869 stars on Github】项目地址：https:github.comalbertpumarolaGANimation?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more神经网络27、Fastai：加速神经网络训练过程，并提高准确率。【11597 stars on Github】项目地址：https:github.comfastaifastai?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n28、DeepCreamPy：图像修复。【7046 stars on Github】项目地址：https:github.comdeeppomfDeepCreamPy?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n29、Augmentor v0.2、图像增强工具包。【2805 stars on Github】项目地址：https:github.commdbloiceAugmentor?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n30、Graph_nets：Tensorflow的图网络构建工具。【2723 stars on Github】项目地址：https:github.comdeepmindgraph_nets?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n31、Textgenrnn：使用预训练字符级RNN生成文本。【1900 stars on Github】项目地址：https:github.comminimaxirtextgenrnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n32、Person-blocker：图像中自动删除人像。【1806 stars on Github】项目地址：https:github.comminimaxirperson-blocker?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n33、Deepvariant：DNA序列数据的分析工具项目地址：https:github.comgoogledeepvariant?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n34、Video-nolocal-net：non-local神经网络的视频分类方法。【1049 stars on Github】项目地址：https:github.comfacebookresearchvideo-nonlocal-net?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n35、Ann-visualizer：神经网络可视化工具。【922 stars on Github】项目地址：https:github.comProdicodeann-visualizer?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n工具包36、Tfjs：一个基于JS的ML模型训练部署工具包。【10268 stars on Github】项目地址：https:github.comtensorflowtfjs?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n37：Dopamine：快速的强化学习研究框架。【7142 stars on Github】项目地址：https:github.comgoogledopamine?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n38、Lime：分类器解释工具包。【5173 stars on Github】项目地址：https:github.commarcotcrlime?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n39、Autokeras：自动机器学习的开源软件库。【4520 stars on Github】项目地址：https:github.comjhfjhfj1autokeras?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n40、Shap：神经网络解释工具。【3496 stars on Github】项目地址：https:github.comslundbergshap?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n41、MMdnn：模型适配器。【3021 stars on Github】项目地址：https:github.comMicrosoftMMdnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n42、Mlflow：机器学习生命周期管理。【3013 stars on Github】项目地址：https:github.commlflowmlflow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n43、Mace：面向移动计算平台的深度学习推断框架。【2979 stars on Github】项目地址：https:github.comXiaoMimace?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n44、PySyft：关注安全性的深度学习库。【2595 stars on Github】项目地址：https:github.comOpenMinedPySyft?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n45、Adanet：AutoML计算库。【2293 stars on Github】项目地址：https:github.comtensorflowadanet?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n46、Tencent-ml-images：最大的多标签图像数据库。【2094 stars on Github】项目地址：https:github.comTencenttencent-ml-images?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n47、Donkeycar、开源的软硬件自动驾驶平台。【1207 stars on Github】\n项目地址：https:github.comautoropedonkeycar?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n48、PocketFlow：自动模型压缩框架。【1677 stars on Github】项目地址：https:github.comTencentPocketFlow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n49、DALI：深度学习应用的优化工具包以及数据处理扩展引擎。【1013 stars on Github】项目地址：https:github.comNVIDIAdali?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n传送门\n","tags":["机器学习"],"path":"2019/09/16/2019年度机器学习49个顶级工程汇总/","external_link":""},{"title":"Java12的新特性","date":"2019-09-16T14:20:54.000Z","content":"Java12的新特性\nJava5的新特性Java6的新特性Java7的新特性Java8的新特性Java9的新特性Java10的新特性Java11的新特性Java12的新特性Java13的新特性\n\n\n版本号1234java -versionopenjdk version &quot;12&quot; 2019-03-19OpenJDK Runtime Environment (build 12+33)OpenJDK 64-Bit Server VM (build 12+33, mixed mode)\n\n\n从version信息可以看出是build 12+33\n\n特性列表\n189:    Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)\n\n\nShenandoah GC是一个面向low-pause-time的垃圾收集器，它最初由Red Hat实现，支持aarch64及amd64 architecture；ZGC也是面向low-pause-time的垃圾收集器，不过ZGC是基于colored pointers来实现，而Shenandoah GC是基于brooks pointers来实现；如果要使用Shenandoah GC需要编译时–with-jvm-features选项带有shenandoahgc，然后启动时使用-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC\n\n\n230:    Microbenchmark Suite\n\n\n在jdk源码里头新增了一套基础的microbenchmarks suite\n\n\n325:    Switch Expressions (Preview)\n\n\n对switch进行了增强，除了使用statement还可以使用expression，比如原来的写法如下：\n\n1234567891011121314151617switch (day) &#123;    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;&#125;\n\n现在可以改为如下写法：\n123456switch (day) &#123;    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);&#125;\n\n以及在表达式返回值\n123456int numLetters = switch (day) &#123;    case MONDAY, FRIDAY, SUNDAY -&gt; 6;    case TUESDAY                -&gt; 7;    case THURSDAY, SATURDAY     -&gt; 8;    case WEDNESDAY              -&gt; 9;&#125;;\n\n对于需要返回值的switch expression要么正常返回值要么抛出异常，以下这两种写法都是错误的\n1234567891011121314int i = switch (day) &#123;    case MONDAY -&gt; &#123;        System.out.println(Monday);          ERROR! Block doesnt contain a break with value    &#125;    default -&gt; 1;&#125;;i = switch (day) &#123;    case MONDAY, TUESDAY, WEDNESDAY:         break 0;    default:         System.out.println(Second half of the week);         ERROR! Group doesnt contain a break with value&#125;;\n\n\n334:    JVM Constants API\n\n\n新增了JVM Constants API，具体来说就是java.base模块新增了java.lang.constant包，引入了ConstantDesc接口(ClassDesc、MethodTypeDesc、MethodHandleDesc这几个接口直接继承了ConstantDesc接口)以及Constable接口；ConstantDesc接口定义了resolveConstantDesc方法，Constable接口定义了describeConstable方法；String、Integer、Long、Float、Double均实现了这两个接口，而EnumDesc实现了ConstantDesc接口\n\n\n340:    One AArch64 Port, Not Two\n\n\n64-bit Arm platform (arm64)，也可以称之为aarch64；之前JDK有两个关于aarch64的实现，分别是srchotspotcpuarm以及opensrchotspotcpuaarch64，它们的实现重复了，为了集中精力更好地实现aarch64，该特性在源码中删除了opensrchotspotcpuarm中关于64-bit的实现，保留其中32-bit的实现，于是opensrchotspotcpuaarch64部分就成了64-bit ARM architecture的默认实现\n\n\n341:    Default CDS Archives\n\n\njava10的新特性JEP 310: Application Class-Data Sharing扩展了JDK5引入的Class-Data Sharing，支持application的Class-Data Sharing；Class-Data Sharing可以用于多个JVM共享class，提升启动速度，最早只支持system classes及serial GC，JDK9对其进行扩展以支持application classes及其他GC算法，并在JDK10中开源出来(以前是commercial feature)；JDK11将-Xshare:off改为默认-Xshare:auto，以更加方便使用CDS特性；JDK12的这个特性即在64-bit平台上编译jdk的时候就默认在${JAVA_HOME}libserver目录下生成一份名为classes.jsa的默认archive文件(大概有18M)方便大家使用\n\n\n344:    Abortable Mixed Collections for G1\n\n\nG1在garbage collection的时候，一旦确定了collection set(CSet)开始垃圾收集这个过程是without stopping的，当collection set过大的时候，此时的STW时间会过长超出目标pause time，这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，允许将其分为mandatory及optional两部分(当完成mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标\n\n\n346:    Promptly Return Unused Committed Memory from G1\n\n\nG1目前只有在full GC或者concurrent cycle的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时会还committed Java heap memory给操作系统。JDK12的这个特性新增了两个参数分别是G1PeriodicGCInterval及G1PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。当上一次garbage collection pause过去G1PeriodicGCInterval(milliseconds)时间之后，如果getloadavg()(one-minute)低于G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(如果开启G1PeriodicGCInvokesConcurrent)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统\n\n细项解读上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见JDK 12 Release Notes，这里举几个例子。添加项\n\n支持unicode 11\n支持Compact Number Formatting\n\n\n使用实例如下\n\n12345678910@Testpublic void testCompactNumberFormat()&#123;    var cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);    System.out.println(cnf.format(1_0000));    System.out.println(cnf.format(1_9200));    System.out.println(cnf.format(1_000_000));    System.out.println(cnf.format(1L &lt;&lt; 30));    System.out.println(cnf.format(1L &lt;&lt; 40));    System.out.println(cnf.format(1L &lt;&lt; 50));&#125;\n\n输出\n1234561万2万100万11亿1兆1126兆\n\n\nString支持transform、indent操作\n\n1234567891011121314@Testpublic void testStringTransform()&#123;    System.out.println(hello.transform(new Function&lt;String, Integer&gt;() &#123;        @Override        public Integer apply(String s) &#123;            return s.hashCode();        &#125;    &#125;));&#125;@Testpublic void testStringIndent()&#123;    System.out.println(hello.indent(3));&#125;\n\nFiles新增mismatch方法\n12345678910111213141516@Testpublic void testFilesMismatch() throws IOException &#123;    FileWriter fileWriter = new FileWriter(tmpa.txt);    fileWriter.write(a);    fileWriter.write(b);    fileWriter.write(c);    fileWriter.close();    FileWriter fileWriterB = new FileWriter(tmpb.txt);    fileWriterB.write(a);    fileWriterB.write(1);    fileWriterB.write(c);    fileWriterB.close();    System.out.println(Files.mismatch(Path.of(tmpa.txt),Path.of(tmpb.txt)));&#125;\n\n\nCollectors新增teeing方法用于聚合两个downstream的结果\n\n1234567891011@Testpublic void testCollectorTeeing()&#123;    var result = Stream.of(Devoxx,Voxxed Days,Code One,Basel One)            .collect(Collectors.teeing(Collectors.filtering(n -&gt; n.contains(xx),Collectors.toList()),                                        Collectors.filtering(n -&gt; n.endsWith(One),Collectors.toList()),                    (List&lt;String&gt; list1, List&lt;String&gt; list2) -&gt; List.of(list1,list2)                                        ));    System.out.println(result.get(0));    System.out.println(result.get(1));&#125;\n\n\nCompletionStage新增exceptionallyAsync、exceptionallyCompose、exceptionallyComposeAsync方法\n\n1234567891011121314@Testpublic void testExceptionallyAsync() throws ExecutionException, InterruptedException &#123;    LOGGER.info(begin);    int result = CompletableFuture.supplyAsync(() -&gt; &#123;        LOGGER.info(calculate);        int i = 10;        return 100;    &#125;).exceptionallyAsync((t) -&gt; &#123;        LOGGER.info(error error:&#123;&#125;,t.getMessage());        return 0;    &#125;).get();    LOGGER.info(result:&#123;&#125;,result);&#125;\n\n\nJDK12之前CompletionStage只有一个exceptionally，该方法体在主线程执行，JDK12新增了exceptionallyAsync、exceptionallyComposeAsync方法允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage\n\nAllocation of Old Generation of Java Heap on Alternate Memory Devices\n\n\n\nG1及Parallel GC引入experimental特性，允许将old generation分配在诸如NV-DIMM memory的alternative memory device\n\n\nZGC: Concurrent Class Unloading\n\n\nZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用\n\n\n新增-XX:+ExtensiveErrorReports\n\n\n-XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数\n\n\n新增安全相关的改进\n\n\n支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationExceptionkeytool新增-groupname选项允许在生成key pair的时候指定一个named group新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成Java Flight Recorder新增了security-related的event支持ChaCha20 and Poly1305 TLS Cipher Suites\n\n\njdeps Reports Transitive Dependences\n\n\njdeps的–print-module-deps, –list-deps, 以及–list-reduce-deps选项得到增强，新增–no-recursive用于non-transitive的依赖分析，–ignore-missing-deps用于suppress missing dependence errors\n\n移除项\n移除com.sun.awt.SecurityWarnin\n移除FileInputStream、FileOutputStream、Java.util.ZipFileInflatorDeflator的finalize方法\n移除GTE CyberTrust Global Root\n移除javac的-source, -target对6及1.6的支持，同时移除–release选项\n\n废弃项\n废弃的API列表见deprecated-list\n废弃-XX:+-MonitorInUseLists选项\n废弃Default Keytool的-keyalg值\n\n已知问题\nSwing不支持GTK+ 3.20及以后的版本\n在使用JVMCI Compiler(比如Graal)的时候，JVMTI的can_pop_frame及can_force_early_return的capabilities是被禁用的\n\n其他事项\n如果用户没有指定user.timezone且从操作系统获取的为空，那么user.timezone属性的初始值为空变为null\njava.net.URLPermission的行为发生轻微变化，以前它会忽略url中的query及fragment部分，这次改动新增query及fragment部分，即scheme :  authority [  path ]变动为scheme :  authority [  path ] [ ignored-query-or-fragment ]\njavax.net.ssl.SSLContext API及Java Security Standard Algorithm Names规范移除了必须实现TLSv1及TLSv1.1的规定\n\n小结\njava12不是LTS(Long-Term Support)版本(oracle版本才有LTS)，oracle对该版本的support周期为6个月。这个版本主要有几个更新点，一个是语法层更新，一个是API层面的更新，另外主要是GC方面的更新。\n语法层面引入了preview版本的Switch Expressions；API层面引入了JVM Constants API，引入CompactNumberFormat，让NumberFormat支持COMPACTSTYLE，对String、Files、Collectors、CompletionStage等新增方法；GC方面引入了experimental版本的Shenandoah GC，不过oracle build的openjdk没有enable Shenandoah GC support；另外主要对ZGC及G1 GC进行了改进\n其中JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用；对于G1 GC则新增支持Abortable Mixed Collections以及Promptly Return Unused Committed Memory特性\n\n\n作者：go4it链接：https:juejin.impost5c91fcc9e51d45563b62382c来源：掘金\n\n","tags":["Java"],"path":"2019/09/16/Java12的新特性/","external_link":""},{"title":"440. 字典序的第K小数字","date":"2019-09-17T08:37:24.000Z","content":"440. 字典序的第K小数字题目\n给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。\n\n\n注意：1 ≤ k ≤ n ≤ 109。\n\n示例 :\n12345678输入:n: 13   k: 2输出:10解释:字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n\n题解乍一看这一题貌似毫无头绪，什么是字典序？如何定位这个数？没错，刚接触这个题目的时候，我的脑筋里也是一团乱麻。\n但是我觉得作为一个拥有聪明才智的程序员来说，最重要的能力就是迅速抽象问题、拆解问题的能力。经过一段时间的思考，我的脑筋里还是没有答案。\n哈哈。\n言归正传，我们来分析一下这个问题。\n首先，什么是字典序？\n什么是字典序？简而言之，就是根据数字的前缀进行排序，\n比如10 &lt; 9，因为10的前缀是1，比9小，\n再比如112 &lt; 12，因为112的前缀11小于12。\n这样排序下来，会跟平常的升序排序会有非常大的不同。先给你一个直观的感受，一个数乘10，或者加1，哪个大？可能你会吃惊，后者会更大。\n但其实掌握它的本质之后，你一点都不会吃惊。\n问题建模画一个图你就懂了。\n\n每一个节点都拥有10个孩子节点，因为作为一个前缀 ，它后面可以接0~9这十个数字。而且你可以非常容易地发现，整个字典序排列也就是对十叉树进行层序遍历。1, 10, 11, 12, 13 … 100, 101, …\n回到题目的意思，我们需要找到排在第k位的数。找到他的排位，需要搞清楚三件事情:\n怎么确定一个前缀下所有子节点的个数？如果第k个数在当前的前缀下，怎么继续往下面的子节点找？如果第k个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？接下来 ，我们一一拆解这些问题。\n理顺思路\n\n确定指定前缀下所有子节点数现在的任务就是给定一个前缀，返回下面子节点总数。\n\n我们现在的思路就是用下一个前缀的起点减去当前前缀的起点，那么就是当前前缀下的所有子节点数总和啦。\n123456789101112131415161718prefix是前缀，n是上界var getCount = (prefix, n) =&gt; &#123;    let cur = prefix;    let next = prefix + 1;下一个前缀    let count = 0;    当前的前缀当然不能大于上界    while(cur &lt;= n) &#123;        count += next - cur;下一个前缀的起点减去当前前缀的起点        cur *= 10;         next *= 10;         如果说刚刚prefix是1，next是2，那么现在分别变成10和20         1为前缀的子节点增加10个，十叉树增加一层, 变成了两层                 如果说现在prefix是10，next是20，那么现在分别变成100和200，         1为前缀的子节点增加100个，十叉树又增加了一层，变成了三层    &#125;    return count;把当前前缀下的子节点和返回去。&#125;\n\n当然，不知道大家发现一个问题没有，当next的值大于上界的时候，那以这个前缀为根节点的十叉树就不是满十叉树了啊，应该到上界那里，后面都不再有子节点。因此，count += next - cur还是有些问题的，我们来修正这个问题:\n1count += Math.max(n+1, next) - cur;\n\n你可能会问:咦？怎么是n+1,而不是n呢？不是说好了n是上界吗？\n我举个例子，假若现在上界n为12，算出以1为前缀的子节点数，首先1本身是一个节点，接下来要算下面10，11，12，一共有4个子节点。\n那么如果用Math.max(n, next) - cur会怎么样？\n这时候算出来会少一个，12 - 10加上根节点，最后只有3个。因此我们务必要写n+1。\n现在，我们搞定了前缀的子节点数问题。\n\n第k个数在当前前缀下现在无非就是往子树里面去看。\n\nprefix这样处理就可以了。\n1prefix *= 10\n\n3.第k个数不在当前前缀下说白了，当前的前缀小了嘛，我们扩大前缀。\n1prefix ++;\n\n框架搭建整合一下刚刚的思路。\n123456789101112131415let findKthNumber = function(n, k) &#123;  let p = 1;作为一个指针，指向当前所在位置，当p==k时，也就是到了排位第k的数  let prefix = 1;前缀  while(p &lt; k) &#123;    let count = getNumber(prefix, n);获得当前前缀下所有子节点的和    if(p + count &gt; k) &#123; 第k个数在当前前缀下      prefix *= 10;      p++; 把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110    &#125; else if(p + count &lt;= k) &#123; 第k个数不在当前前缀下      prefix ++;      p += count;注意这里的操作，把指针指向了下一前缀的起点    &#125;  &#125;  return prefix;&#125;;\n\n完整代码展示\n1234567891011121314151617181920212223242526** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number&#125; *var findKthNumber = function(n, k) &#123;  let getCount = (prefix, n) =&gt; &#123;    let count =  0;    for(let cur = prefix, next = prefix + 1; cur &lt;= n; cur *= 10, next *= 10)       count += Math.min(next, n+1) - cur;    return count;  &#125;  let p = 1;  let prefix = 1;  while(p &lt; k) &#123;    let count = getCount(prefix, n);    if(p + count &gt; k) &#123;      prefix *= 10;      p++;    &#125; else if(p + count &lt;= k) &#123;      prefix ++;      p += count;    &#125;  &#125;  return prefix;&#125;;\n\n123456789101112131415161718192021222324252627282930313233public class Solution &#123;    **     * @param n: a integer     * @param k: a integer     * @return: return a integer     *    public int findKthNumber(int n, int k) &#123;        int curr = 1;        k = k - 1;        while (k &gt; 0) &#123;            int steps = calSteps(n, curr, curr + 1);            if (steps &lt;= k) &#123;   如果不在当前层，减去steps                curr += 1;                      k -= steps;              &#125;             else &#123;              说明在当前层,curr*10缩小搜索范围继续查找                curr *= 10;                k -= 1;            &#125;        &#125;        return curr;    &#125;    use long in case of overflow    public int calSteps(int n, long n1, long n2) &#123; 计算curr开头和curr+1开头之间的字符串数量        int steps = 0;        while (n1 &lt;= n) &#123;            steps += Math.min(n + 1, n2) - n1;  每次加上当前的字符串数量            n1 *= 10;       每次均扩大10倍            n2 *= 10;        &#125;        return steps;    &#125;&#125;\n\n","tags":["算法","leetcode"],"path":"2019/09/17/440-字典序的第K小数字/","external_link":""},{"title":"面试笔记","date":"2019-09-18T15:44:09.000Z","content":"牛客许愿的小米一面，贡献面经1许愿能挺进二面，加油，向着目标冲呀~~~~\n——java集合相关\nobject类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）\nhashmap的put过程 主要就是根据自己看过的源码说一下流程ArrayList LinkList的特点\n——多线程相关\nsynchronized\nreettrantLock 除了可重入还有什么关键特性\nthreadLocal threadLocal 会造成什么问题 为什么会造成内存泄漏\n单例模式 synchronized实现懒汉模式 答 内部类 为什么用内部类是线程安全的？\n——数据库相关\n添加索引的时候要注意什么\n索引优化以及在使用索引的时候要注意什么\nredis的键的淘汰策略，会达成了redis缓存的淘汰策略\n——网络相关\ntcp四次握手，最后的状态是什么，回答等待2MSL\n为什么要等着2MSL，等待多了会造成什么\nhttp请求的报文结构，keep-alive是用来做什么的\n——spring spingboot\nspring中对象增强如何实现 回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程\n——口述算法思路\n给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）\n之前一直没明白是要做什么，后来想到做过类似的题。幸好只是说思路，没有要手写，那个时候已经被前面几个回答的不太好的问题难的很紧张，说做个简单的算法题的时候，我的心紧紧一颤，心想，你确定会简单，还好，还好，结果下来没那么难\n——网络编程\n哪几种IO类型\n还有一个问题 有点忘了，这一块在简历上写了，不过掌握的不是很好\n——JVM\n类加载机制——回答了一下双亲委派模型相关的内容\n——有什么想问我的\n面试官蛮年轻，真的很好，一直在引导我回答问题，不会的也没有揪着不放很喜欢说，我们接下来问一个简单的问题，哈哈哈，简单简单着就变得不简单了\n是自己比较满意的一次面试\n既展示了自己所掌握的知识，也暴露了掌握知识中的问题，给自己后面的复习有了一定的指引\n感谢CYC大佬的秘籍1234最后，重要的话再来几次许愿能挺进二面，加油，向着目标冲呀~~~~\n许愿能挺进二面，加油，向着目标冲呀1许愿能挺进二面，加油，向着目标冲呀\n","tags":["面试"],"path":"2019/09/18/面试笔记/","external_link":""},{"title":"Java知识点","date":"2019-09-20T02:24:00.000Z","content":"Java相关请问JDK和JRE的区别是什么？\nJDK ：Java 开发工具包,jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。JRE ：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。\n\nspringboot的注解有什么，原理？@Bean用来代替 XML 配置文件里面的 &lt;bean …&gt; 配置。@ImportResource如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 @Configuration 方式配置的非常管用。@Import用来引入额外的一个或者多个 @Configuration 修饰的配置文件类。@SpringBootConfiguration这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。@EnableAutoConfiguration 自动配置。@ComponentScan 组件扫描，可自动发现和装配一些Bean。@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。@Autowired自动导入。@PathVariable获取参数。@JsonBackReference解决嵌套外链问题。@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\n@RequestMapping：@RequestMapping(“path”)表示该控制器处理所有“path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如applicationjson,texthtml;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n@RequestParam：用在方法的参数前面。@RequestParamString a =request.getParameter(“a”)。\n@PathVariable:路径变量。如\n1234@RequestMapping(“usergetmac&#123;macAddress&#125;”) public String getByMacAddress(@PathVariable String macAddress)&#123; do something; &#125;\n\nSpring Boot的自动配置看起来神奇，其实原理非常简单，背后全依赖于@Conditional注解来实现的。\nobject类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:\n1public native int hashCode();\n\n根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。\nhashCode方法的作用\n对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。\n　　为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）\n　　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。\nhash 算法\n1234static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。\n如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。\n但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。\n总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。\nhashmap的put过程 主要就是根据自己看过的源码说一下流程put 方法通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。\n123public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;\n\n\n判断数组是否为空，如果是空，则创建默认长度位 16 的数组。\n通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。\n如果有元素，说明 hash 冲突了，则再次进行 3 种判断。\n判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。\n如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。\n如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。\n\n\n最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。\n对维护着迭代器的modCount 变量加一。\n最后判断，如果当前数组的长度已经大于阀值了。则重新hash。\n\nArrayList LinkList的特点ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。\n数据的更新和查找ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻\n数据的增加和删除对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。\n红黑树定义红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。\n它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。\n由于 TreeMap 就是由红黑树实现的。\n黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。\n\n每个节点要么是红色，要么是黑色；\n根节点永远是黑色的；\n所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；\n每个红色节点的两个子节点一定都是黑色；\n从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；\n\nJava 反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。\n123456public class FatherClass &#123;    public String mFatherName;    public int mFatherAge;    public void printFatherMsg()&#123;&#125;&#125;\n\n多线程相关synchronizedsynchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。\n锁机制有如下两种特性：\n\n互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。\n\n可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。\n\n\nsynchronized 可以修饰方法和代码块\n\nsynchronized(this|object) {}\nsynchronized(类.class) {}\n修饰非静态方法\n修饰静态方法\n\nreentrantLock 除了可重入还有什么关键特性\n可重入\n\n现在有方法 m1 和 m2，两个方法均使用了同一把锁对方法进行同步控制，同时方法 m1 会调用 m2。线程 t 进入方法 m1 成功获得了锁，此时线程 t 要在没有释放锁的情况下，调用 m2 方法。由于 m1 和 m2 使用的是同一把可重入锁，所以线程 t 可以进入方法 m2，并再次获得锁，而不会被阻塞住。\n\n公平和非公平锁\n\n公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法ReentrantLock(boolean fair)调整加锁的模式。\nThreadLocal 会造成什么问题? 为什么会造成内存泄漏?\nThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型。 总结：ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。 \nThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。\n\nThreadLocal类提供了四个对外开放的接口方法\n(1) void set(Object value)设置当前线程的线程局部变量的值。(2) public Object get()该方法返回当前线程所对应的线程局部变量。(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用。(4) protected Object initialValue()返回该线程局部变量的初始值。\n在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。\n最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的就可能出现内存泄露。（在web应用中，每次http请求都是一个线程，tomcat容器配置使用线程池时会出现内存泄漏问题）\n\n使用ThreadLocal，建议用static修饰 static ThreadLocal headerLocal = new ThreadLocal();\n使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。\n\n单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？内部类\n单例模式，有“懒汉式”和“饿汉式”两种。懒汉式单例类的实例在第一次被引用时候才被初始化。饿汉式单例类的实例在加载的时候就被初始化。\n静态内部类模式\n12345678910public class Singleton &#123;     private Singleton()&#123;    &#125;      public static Singleton getSingleton()&#123;          return Inner.instance;      &#125;      private static class Inner &#123;          private static final Singleton instance = new Singleton();      &#125;  &#125;\n\n\n实现代码简洁。和双重检查单例对比，静态内部类单例实现代码真的是太简洁，又清晰明了。\n延迟初始化。调用getSingleton才初始化Singleton对象。\n线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。\n\n线程A和线程B同时试图获得Singleton对象的初始化锁，假设线程A获取到了，那么线程B一直等待初始化锁。线程A执行类初始化，就算双重检查模式中伪代码发生了重排序，也不会影响线程A的初始化结果。初始化完后，释放锁。线程B获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。\n数据库相关添加索引的时候要注意什么索引可以提高数据的访问速度，但同时也增加了插入、更新和删除操作的处理时间。所以是否要为表增加索引、索引建立在那些字段上，是创建索引前必须要考虑的问题。解决此问题就是分析应用程序的业务处理、数据使用，为经常被用作查询条件、或者被要求排序的字段建立索引。\n1、表的主键、外键必须有索引；2、数据量超过300的表应该有索引；3、经常与其他表进行连接的表，在连接字段上应该建立索引；4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；5、索引应该建在选择性高的字段上；6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；7、复合索引的建立需要进行仔细分析；\n聚簇索引:通常由主键或者非空唯一索引实现的，叶子节点存储了一整行数据非聚簇索引：又称二级索引，就是我们常用的普通索引，叶子节点存了索引值和主键值，在根据主键从聚簇索引查\n索引优化以及在使用索引的时候要注意什么1.索引列不要使用函数和运算\n\n尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符\n当查询条件为多个的时候，可以采用复合索引\n范围查询对多列查询的影响\n遵循最左匹配原则 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。\n索引列不会包含NULL值\n尽量避免使用 or 来连接条件\n隐式转换的影响\nlike 语句的索引失效问题\n\nredis的键的淘汰策略，会达成了redis缓存的淘汰策略Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。事实上，实例中的内存除了保存原始的键值对所需的开销外，还有一些运行时产生的额外内存，包括：\n\n垃圾数据和过期Key所占空间\n字典渐进式Rehash导致未及时删除的空间\nRedis管理数据，包括底层数据结构开销，客户端信息，读写缓冲区等\n主从复制，bgsave时的额外开销\n\n为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。\n\n访问Key时，会判断Key是否过期，逐出过期Key;\nCPU空闲时在定期serverCron任务中，逐出部分过期Key;\n每次事件循环执行的时候，逐出部分过期Key;\n\n网络相关tcp四次握手，最后的状态是什么?等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2）\n为什么要等着2MSL，等待多了会造成什么\n保证A发送的最后一个ACK报文段能够到达B。\n防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\nhttp请求的报文结构，keep-alive是用来做什么的当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。\n12Keep-Alive: timeout=5, max=100timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接\n\nspring spingbootspring为什么要注入接口，而不是实现类首先说明，注入的对象确实为实现类的对象。（并不是实现类的代理对象，注入并不涉及代理）\n　　如果只是单纯注入是可以用实现类接收注入对象的，但是往往开发中会对实现类做增强，如事务，日志等，实现增强的AOP技术是通过动态代理实现的，而spring默认是JDK动态代理，对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。\n回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程\nJava动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果目标对象没有实现接口我们该如何代理呢？这时候我们就需要使用CGLIB来实现AOP了。\n假如我们要使用动态代理实现AOP，那么我们只能在写一个增强的接口，然后让目标类实现增强接口，然后我们就可以使用动态代理实现目标类的增强，可是假如我们不想让目标类实现其他的接口，那么我们就只能使用CGLIB技术来实现目标类的增强了。CGLIB实现目标类增强的原理是这样的：CGLIB会动态创建一个目标类的子类，然后返回该子类的对象，也就是增强对象，至于增强的逻辑则是在子类中完成的。我们知道子类要么和父类有一样的功能，要么就比父类功能强大，所以CGLIB是通过创建目标类的子类对象来实现增强的，所以：\n1目标子类 = 目标类 + 增强逻辑\n\n口述算法思路给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）最小值思路：用一个辅助栈stack2记住每次入栈stack1的当前最小值:在stack1入栈时，往stack2中加入当前最小值；stack1元素出栈时，stack2也出栈一个元素。最小值从stack2中获取及栈顶元素。O(1)\n最大值思路：同上O(1)\n\n网络编程哪几种IO类型\n阻塞IO（blocking IO）\n非阻塞IO (nonblocking IO)\nIO 复用 (IO multiplexing)\n信号驱动IO (signal driven IO (SIGIO))\n异步IO (asynchronous IO)\n\nJVMJVM的内存结构\n堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。\n方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。\n方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。\n本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。\n程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。\n\n\n类加载机制Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。\n\n双亲委派模型双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。\n双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。\n有什么想问我的有的\n\n你怎样形容小米公司的企业文化？\n什么类型的员工能在小米公司有比较好的发展？\n关于软件开发工程师-Java方向岗位的技术栈、日常主要工作是什么、期间可以获得晋升机会？\n能给我多讲讲招聘程序吗？\n我没有其他问题了，与您交流非常愉快，能留一张您的名片么？（或者方便加一下您的微信么？）\n\n","tags":["Java"],"path":"2019/09/20/Java知识点/","external_link":""},{"title":"客户端面试","date":"2019-09-21T09:14:08.000Z","content":"\n100级台阶，每次上一步或两步，有多少种走法。\n\n57314784401381708410121\n\n如果200级，你估计有多少种走法（不用编程）。\n\n45397369416530795319729696969741061923382642\n\n不用编程，估算\n\n123456789101112131415161718import java.math.BigInteger;public class Main &#123;    public static void main(String[] args) &#123;        int n = 200;        BigInteger a = BigInteger.ONE;        BigInteger b = BigInteger.ONE;        BigInteger res = BigInteger.ZERO;        for (int i = 2; i &lt;= n; i++) &#123;            res = a.add(b);            a = b;            b = res;        &#125;        System.out.println(res);        System.out.println(res.toString().length());    &#125;&#125;\n\n\n给出一个数组，找出两个数[a,b]和为n，不存在则返回[-1,-1]。写出两种解法，不能暴力穷举。\n\n讲讲面向过程、面向对象、面向切面。\n\n指针和数组的关系和区别。\n\n讲讲Android handler。\n\n队列和栈的区别和用途。\n\n两个栈实现队列。\n\n输入Url到浏览器显示过程。\n\nhttp请求方法。\n\nget和post区别。\n\nsurficeView和view的区别。\n\napp从点击图标开始的启动全过程。\n\n什么是线程安全。\n\n线程安全有哪些机制。\n\n如何保证 int加加（加号打不出来）线程安全。\n\nAndroid线程间通信有哪些机制。\n\ncpu调度方式有哪些。\n\n空间局部性和时间局部性。\n\n数据库乐观锁和悲观锁。\n\n数据库索引作用，优缺点。\n\nTCP拥塞控制。\n\nhttps加密传输过程。\n\njava内存模型。\n\njava垃圾回收算法有哪些。\n\n讲讲标记清除算法。\n\njava四中引用。\n\n\n","tags":["面试"],"path":"2019/09/21/客户端面试/","external_link":""},{"title":"BigInteger类","date":"2019-09-21T11:00:03.000Z","content":"BigInteger类\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016 Source code recreated from a .class file by IntelliJ IDEA (powered by Fernflower decompiler)package java.math;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.ObjectStreamField;import java.io.StreamCorruptedException;import java.io.ObjectInputStream.GetField;import java.io.ObjectOutputStream.PutField;import java.util.Arrays;import java.util.Objects;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;import jdk.internal.HotSpotIntrinsicCandidate;import jdk.internal.misc.Unsafe;public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; &#123;    final int signum;    final int[] mag;    private int bitCountPlusOne;    private int bitLengthPlusOne;    private int lowestSetBitPlusTwo;    private int firstNonzeroIntNumPlusTwo;    static final long LONG_MASK = 4294967295L;    private static final int MAX_MAG_LENGTH = 67108864;    private static final int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;    private static final int KARATSUBA_THRESHOLD = 80;    private static final int TOOM_COOK_THRESHOLD = 240;    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;    static final int BURNIKEL_ZIEGLER_OFFSET = 40;    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;    private static final int MULTIPLY_SQUARE_THRESHOLD = 20;    private static final int MONTGOMERY_INTRINSIC_THRESHOLD = 512;    private static long[] bitsPerDigit = new long[]&#123;0L, 0L, 1024L, 1624L, 2048L, 2378L, 2648L, 2875L, 3072L, 3247L, 3402L, 3543L, 3672L, 3790L, 3899L, 4001L, 4096L, 4186L, 4271L, 4350L, 4426L, 4498L, 4567L, 4633L, 4696L, 4756L, 4814L, 4870L, 4923L, 4975L, 5025L, 5074L, 5120L, 5166L, 5210L, 5253L, 5295L&#125;;    private static final int SMALL_PRIME_THRESHOLD = 95;    private static final int DEFAULT_PRIME_CERTAINTY = 100;    private static final BigInteger SMALL_PRIME_PRODUCT = valueOf(152125131763605L);    private static final int MAX_CONSTANT = 16;    private static BigInteger[] posConst = new BigInteger[17];    private static BigInteger[] negConst = new BigInteger[17];    private static volatile BigInteger[][] powerCache;    private static final double[] logCache;    private static final double LOG_TWO = Math.log(2.0D);    public static final BigInteger ZERO;    public static final BigInteger ONE;    public static final BigInteger TWO;    private static final BigInteger NEGATIVE_ONE;    public static final BigInteger TEN;    static int[] bnExpModThreshTable;    private static String[] zeros;    private static int[] digitsPerLong;    private static BigInteger[] longRadix;    private static int[] digitsPerInt;    private static int[] intRadix;    private static final long serialVersionUID = -8287574255936472291L;    private static final ObjectStreamField[] serialPersistentFields;    public BigInteger(byte[] val, int off, int len) &#123;        if (val.length == 0) &#123;            throw new NumberFormatException(Zero length BigInteger);        &#125; else &#123;            Objects.checkFromIndexSize(off, len, val.length);            if (val[off] &lt; 0) &#123;                this.mag = makePositive(val, off, len);                this.signum = -1;            &#125; else &#123;                this.mag = stripLeadingZeroBytes(val, off, len);                this.signum = this.mag.length == 0 ? 0 : 1;            &#125;            if (this.mag.length &gt;= 67108864) &#123;                this.checkRange();            &#125;        &#125;    &#125;    public BigInteger(byte[] val) &#123;        this((byte[])val, 0, val.length);    &#125;    private BigInteger(int[] val) &#123;        if (val.length == 0) &#123;            throw new NumberFormatException(Zero length BigInteger);        &#125; else &#123;            if (val[0] &lt; 0) &#123;                this.mag = makePositive(val);                this.signum = -1;            &#125; else &#123;                this.mag = trustedStripLeadingZeroInts(val);                this.signum = this.mag.length == 0 ? 0 : 1;            &#125;            if (this.mag.length &gt;= 67108864) &#123;                this.checkRange();            &#125;        &#125;    &#125;    public BigInteger(int signum, byte[] magnitude, int off, int len) &#123;        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) &#123;            Objects.checkFromIndexSize(off, len, magnitude.length);            this.mag = stripLeadingZeroBytes(magnitude, off, len);            if (this.mag.length == 0) &#123;                this.signum = 0;            &#125; else &#123;                if (signum == 0) &#123;                    throw new NumberFormatException(signum-magnitude mismatch);                &#125;                this.signum = signum;            &#125;            if (this.mag.length &gt;= 67108864) &#123;                this.checkRange();            &#125;        &#125; else &#123;            throw new NumberFormatException(Invalid signum value);        &#125;    &#125;    public BigInteger(int signum, byte[] magnitude) &#123;        this(signum, magnitude, 0, magnitude.length);    &#125;    private BigInteger(int signum, int[] magnitude) &#123;        this.mag = stripLeadingZeroInts(magnitude);        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) &#123;            if (this.mag.length == 0) &#123;                this.signum = 0;            &#125; else &#123;                if (signum == 0) &#123;                    throw new NumberFormatException(signum-magnitude mismatch);                &#125;                this.signum = signum;            &#125;            if (this.mag.length &gt;= 67108864) &#123;                this.checkRange();            &#125;        &#125; else &#123;            throw new NumberFormatException(Invalid signum value);        &#125;    &#125;    public BigInteger(String val, int radix) &#123;        int cursor = 0;        int len = val.length();        if (radix &gt;= 2 &amp;&amp; radix &lt;= 36) &#123;            if (len == 0) &#123;                throw new NumberFormatException(Zero length BigInteger);            &#125; else &#123;                int sign = 1;                int index1 = val.lastIndexOf(45);                int index2 = val.lastIndexOf(43);                if (index1 &gt;= 0) &#123;                    if (index1 != 0 || index2 &gt;= 0) &#123;                        throw new NumberFormatException(Illegal embedded sign character);                    &#125;                    sign = -1;                    cursor = 1;                &#125; else if (index2 &gt;= 0) &#123;                    if (index2 != 0) &#123;                        throw new NumberFormatException(Illegal embedded sign character);                    &#125;                    cursor = 1;                &#125;                if (cursor == len) &#123;                    throw new NumberFormatException(Zero length BigInteger);                &#125; else &#123;                    while(cursor &lt; len &amp;&amp; Character.digit(val.charAt(cursor), radix) == 0) &#123;                        ++cursor;                    &#125;                    if (cursor == len) &#123;                        this.signum = 0;                        this.mag = ZERO.mag;                    &#125; else &#123;                        int numDigits = len - cursor;                        this.signum = sign;                        long numBits = ((long)numDigits * bitsPerDigit[radix] &gt;&gt;&gt; 10) + 1L;                        if (numBits + 31L &gt;= 4294967296L) &#123;                            reportOverflow();                        &#125;                        int numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;                        int[] magnitude = new int[numWords];                        int firstGroupLen = numDigits % digitsPerInt[radix];                        if (firstGroupLen == 0) &#123;                            firstGroupLen = digitsPerInt[radix];                        &#125;                        String group = val.substring(cursor, cursor += firstGroupLen);                        magnitude[numWords - 1] = Integer.parseInt(group, radix);                        if (magnitude[numWords - 1] &lt; 0) &#123;                            throw new NumberFormatException(Illegal digit);                        &#125; else &#123;                            int superRadix = intRadix[radix];                            boolean var16 = false;                            while(cursor &lt; len) &#123;                                group = val.substring(cursor, cursor += digitsPerInt[radix]);                                int groupVal = Integer.parseInt(group, radix);                                if (groupVal &lt; 0) &#123;                                    throw new NumberFormatException(Illegal digit);                                &#125;                                destructiveMulAdd(magnitude, superRadix, groupVal);                            &#125;                            this.mag = trustedStripLeadingZeroInts(magnitude);                            if (this.mag.length &gt;= 67108864) &#123;                                this.checkRange();                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125; else &#123;            throw new NumberFormatException(Radix out of range);        &#125;    &#125;    BigInteger(char[] val, int sign, int len) &#123;        int cursor;        for(cursor = 0; cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0; ++cursor) &#123;        &#125;        if (cursor == len) &#123;            this.signum = 0;            this.mag = ZERO.mag;        &#125; else &#123;            int numDigits = len - cursor;            this.signum = sign;            int numWords;            if (len &lt; 10) &#123;                numWords = 1;            &#125; else &#123;                long numBits = ((long)numDigits * bitsPerDigit[10] &gt;&gt;&gt; 10) + 1L;                if (numBits + 31L &gt;= 4294967296L) &#123;                    reportOverflow();                &#125;                numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;            &#125;            int[] magnitude = new int[numWords];            int firstGroupLen = numDigits % digitsPerInt[10];            if (firstGroupLen == 0) &#123;                firstGroupLen = digitsPerInt[10];            &#125;            magnitude[numWords - 1] = this.parseInt(val, cursor, cursor += firstGroupLen);            while(cursor &lt; len) &#123;                int groupVal = this.parseInt(val, cursor, cursor += digitsPerInt[10]);                destructiveMulAdd(magnitude, intRadix[10], groupVal);            &#125;            this.mag = trustedStripLeadingZeroInts(magnitude);            if (this.mag.length &gt;= 67108864) &#123;                this.checkRange();            &#125;        &#125;    &#125;    private int parseInt(char[] source, int start, int end) &#123;        int result = Character.digit(source[start++], 10);        if (result == -1) &#123;            throw new NumberFormatException(new String(source));        &#125; else &#123;            for(int index = start; index &lt; end; ++index) &#123;                int nextVal = Character.digit(source[index], 10);                if (nextVal == -1) &#123;                    throw new NumberFormatException(new String(source));                &#125;                result = 10 * result + nextVal;            &#125;            return result;        &#125;    &#125;    private static void destructiveMulAdd(int[] x, int y, int z) &#123;        long ylong = (long)y &amp; 4294967295L;        long zlong = (long)z &amp; 4294967295L;        int len = x.length;        long product = 0L;        long carry = 0L;        for(int i = len - 1; i &gt;= 0; --i) &#123;            product = ylong * ((long)x[i] &amp; 4294967295L) + carry;            x[i] = (int)product;            carry = product &gt;&gt;&gt; 32;        &#125;        long sum = ((long)x[len - 1] &amp; 4294967295L) + zlong;        x[len - 1] = (int)sum;        carry = sum &gt;&gt;&gt; 32;        for(int i = len - 2; i &gt;= 0; --i) &#123;            sum = ((long)x[i] &amp; 4294967295L) + carry;            x[i] = (int)sum;            carry = sum &gt;&gt;&gt; 32;        &#125;    &#125;    public BigInteger(String val) &#123;        this((String)val, 10);    &#125;    public BigInteger(int numBits, Random rnd) &#123;        this(1, (byte[])randomBits(numBits, rnd));    &#125;    private static byte[] randomBits(int numBits, Random rnd) &#123;        if (numBits &lt; 0) &#123;            throw new IllegalArgumentException(numBits must be non-negative);        &#125; else &#123;            int numBytes = (int)(((long)numBits + 7L)  8L);            byte[] randomBits = new byte[numBytes];            if (numBytes &gt; 0) &#123;                rnd.nextBytes(randomBits);                int excessBits = 8 * numBytes - numBits;                randomBits[0] = (byte)(randomBits[0] &amp; (1 &lt;&lt; 8 - excessBits) - 1);            &#125;            return randomBits;        &#125;    &#125;    public BigInteger(int bitLength, int certainty, Random rnd) &#123;        if (bitLength &lt; 2) &#123;            throw new ArithmeticException(bitLength &lt; 2);        &#125; else &#123;            BigInteger prime = bitLength &lt; 95 ? smallPrime(bitLength, certainty, rnd) : largePrime(bitLength, certainty, rnd);            this.signum = 1;            this.mag = prime.mag;        &#125;    &#125;    public static BigInteger probablePrime(int bitLength, Random rnd) &#123;        if (bitLength &lt; 2) &#123;            throw new ArithmeticException(bitLength &lt; 2);        &#125; else &#123;            return bitLength &lt; 95 ? smallPrime(bitLength, 100, rnd) : largePrime(bitLength, 100, rnd);        &#125;    &#125;    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) &#123;        int magLen = bitLength + 31 &gt;&gt;&gt; 5;        int[] temp = new int[magLen];        int highBit = 1 &lt;&lt; (bitLength + 31 &amp; 31);        int highMask = (highBit &lt;&lt; 1) - 1;        BigInteger p;        do &#123;            long r;            do &#123;                for(int i = 0; i &lt; magLen; ++i) &#123;                    temp[i] = rnd.nextInt();                &#125;                temp[0] = temp[0] &amp; highMask | highBit;                if (bitLength &gt; 2) &#123;                    temp[magLen - 1] |= 1;                &#125;                p = new BigInteger(temp, 1);                if (bitLength &lt;= 6) &#123;                    break;                &#125;                r = p.remainder(SMALL_PRIME_PRODUCT).longValue();            &#125; while(r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L);            if (bitLength &lt; 4) &#123;                return p;            &#125;        &#125; while(!p.primeToCertainty(certainty, rnd));        return p;    &#125;    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) &#123;        BigInteger p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);        int[] var10000 = p.mag;        int var10001 = p.mag.length - 1;        var10000[var10001] &amp;= -2;        int searchLen = getPrimeSearchLen(bitLength);        BitSieve searchSieve = new BitSieve(p, searchLen);        BigInteger candidate;        for(candidate = searchSieve.retrieve(p, certainty, rnd); candidate == null || candidate.bitLength() != bitLength; candidate = searchSieve.retrieve(p, certainty, rnd)) &#123;            p = p.add(valueOf((long)(2 * searchLen)));            if (p.bitLength() != bitLength) &#123;                p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);            &#125;            var10000 = p.mag;            var10001 = p.mag.length - 1;            var10000[var10001] &amp;= -2;            searchSieve = new BitSieve(p, searchLen);        &#125;        return candidate;    &#125;    public BigInteger nextProbablePrime() &#123;        if (this.signum &lt; 0) &#123;            throw new ArithmeticException(start &lt; 0:  + this);        &#125; else if (this.signum != 0 &amp;&amp; !this.equals(ONE)) &#123;            BigInteger result = this.add(ONE);            if (result.bitLength() &lt; 95) &#123;                if (!result.testBit(0)) &#123;                    result = result.add(ONE);                &#125;                while(true) &#123;                    while(true) &#123;                        if (result.bitLength() &gt; 6) &#123;                            long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();                            if (r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L) &#123;                                result = result.add(TWO);                                continue;                            &#125;                        &#125;                        if (result.bitLength() &lt; 4) &#123;                            return result;                        &#125;                        if (result.primeToCertainty(100, (Random)null)) &#123;                            return result;                        &#125;                        result = result.add(TWO);                    &#125;                &#125;            &#125; else &#123;                if (result.testBit(0)) &#123;                    result = result.subtract(ONE);                &#125;                int searchLen = getPrimeSearchLen(result.bitLength());                while(true) &#123;                    BitSieve searchSieve = new BitSieve(result, searchLen);                    BigInteger candidate = searchSieve.retrieve(result, 100, (Random)null);                    if (candidate != null) &#123;                        return candidate;                    &#125;                    result = result.add(valueOf((long)(2 * searchLen)));                &#125;            &#125;        &#125; else &#123;            return TWO;        &#125;    &#125;    private static int getPrimeSearchLen(int bitLength) &#123;        if (bitLength &gt; 500000001) &#123;            throw new ArithmeticException(Prime search implementation restriction on bitLength);        &#125; else &#123;            return bitLength  20 * 64;        &#125;    &#125;    boolean primeToCertainty(int certainty, Random random) &#123;        int rounds = false;        int n = (Math.min(certainty, 2147483646) + 1)  2;        int sizeInBits = this.bitLength();        byte rounds;        int rounds;        if (sizeInBits &lt; 100) &#123;            rounds = 50;            rounds = n &lt; rounds ? n : rounds;            return this.passesMillerRabin(rounds, random);        &#125; else &#123;            if (sizeInBits &lt; 256) &#123;                rounds = 27;            &#125; else if (sizeInBits &lt; 512) &#123;                rounds = 15;            &#125; else if (sizeInBits &lt; 768) &#123;                rounds = 8;            &#125; else if (sizeInBits &lt; 1024) &#123;                rounds = 4;            &#125; else &#123;                rounds = 2;            &#125;            rounds = n &lt; rounds ? n : rounds;            return this.passesMillerRabin(rounds, random) &amp;&amp; this.passesLucasLehmer();        &#125;    &#125;    private boolean passesLucasLehmer() &#123;        BigInteger thisPlusOne = this.add(ONE);        int d;        for(d = 5; jacobiSymbol(d, this) != -1; d = d &lt; 0 ? Math.abs(d) + 2 : -(d + 2)) &#123;        &#125;        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);        return u.mod(this).equals(ZERO);    &#125;    private static int jacobiSymbol(int p, BigInteger n) &#123;        if (p == 0) &#123;            return 0;        &#125; else &#123;            int j = 1;            int u = n.mag[n.mag.length - 1];            int t;            if (p &lt; 0) &#123;                p = -p;                t = u &amp; 7;                if (t == 3 || t == 7) &#123;                    j = -j;                &#125;            &#125;            while((p &amp; 3) == 0) &#123;                p &gt;&gt;= 2;            &#125;            if ((p &amp; 1) == 0) &#123;                p &gt;&gt;= 1;                if (((u ^ u &gt;&gt; 1) &amp; 2) != 0) &#123;                    j = -j;                &#125;            &#125;            if (p == 1) &#123;                return j;            &#125; else &#123;                if ((p &amp; u &amp; 2) != 0) &#123;                    j = -j;                &#125;                for(u = n.mod(valueOf((long)p)).intValue(); u != 0; u %= t) &#123;                    while((u &amp; 3) == 0) &#123;                        u &gt;&gt;= 2;                    &#125;                    if ((u &amp; 1) == 0) &#123;                        u &gt;&gt;= 1;                        if (((p ^ p &gt;&gt; 1) &amp; 2) != 0) &#123;                            j = -j;                        &#125;                    &#125;                    if (u == 1) &#123;                        return j;                    &#125;                    assert u &lt; p;                    t = u;                    u = p;                    p = t;                    if ((u &amp; t &amp; 2) != 0) &#123;                        j = -j;                    &#125;                &#125;                return 0;            &#125;        &#125;    &#125;    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) &#123;        BigInteger d = valueOf((long)z);        BigInteger u = ONE;        BigInteger v = ONE;        for(int i = k.bitLength() - 2; i &gt;= 0; --i) &#123;            BigInteger u2 = u.multiply(v).mod(n);            BigInteger v2 = v.square().add(d.multiply(u.square())).mod(n);            if (v2.testBit(0)) &#123;                v2 = v2.subtract(n);            &#125;            v2 = v2.shiftRight(1);            u = u2;            v = v2;            if (k.testBit(i)) &#123;                u2 = u2.add(v2).mod(n);                if (u2.testBit(0)) &#123;                    u2 = u2.subtract(n);                &#125;                u2 = u2.shiftRight(1);                v2 = v2.add(d.multiply(u)).mod(n);                if (v2.testBit(0)) &#123;                    v2 = v2.subtract(n);                &#125;                v2 = v2.shiftRight(1);                u = u2;                v = v2;            &#125;        &#125;        return u;    &#125;    private boolean passesMillerRabin(int iterations, Random rnd) &#123;        BigInteger thisMinusOne = this.subtract(ONE);        int a = thisMinusOne.getLowestSetBit();        BigInteger m = thisMinusOne.shiftRight(a);        if (rnd == null) &#123;            rnd = ThreadLocalRandom.current();        &#125;        for(int i = 0; i &lt; iterations; ++i) &#123;            BigInteger b;            do &#123;                do &#123;                    b = new BigInteger(this.bitLength(), (Random)rnd);                &#125; while(b.compareTo(ONE) &lt;= 0);            &#125; while(b.compareTo(this) &gt;= 0);            int j = 0;            for(BigInteger z = b.modPow(m, this); (j != 0 || !z.equals(ONE)) &amp;&amp; !z.equals(thisMinusOne); z = z.modPow(TWO, this)) &#123;                if (j &gt; 0 &amp;&amp; z.equals(ONE)) &#123;                    return false;                &#125;                ++j;                if (j == a) &#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;    BigInteger(int[] magnitude, int signum) &#123;        this.signum = magnitude.length == 0 ? 0 : signum;        this.mag = magnitude;        if (this.mag.length &gt;= 67108864) &#123;            this.checkRange();        &#125;    &#125;    private BigInteger(byte[] magnitude, int signum) &#123;        this.signum = magnitude.length == 0 ? 0 : signum;        this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);        if (this.mag.length &gt;= 67108864) &#123;            this.checkRange();        &#125;    &#125;    private void checkRange() &#123;        if (this.mag.length &gt; 67108864 || this.mag.length == 67108864 &amp;&amp; this.mag[0] &lt; 0) &#123;            reportOverflow();        &#125;    &#125;    private static void reportOverflow() &#123;        throw new ArithmeticException(BigInteger would overflow supported range);    &#125;    public static BigInteger valueOf(long val) &#123;        if (val == 0L) &#123;            return ZERO;        &#125; else if (val &gt; 0L &amp;&amp; val &lt;= 16L) &#123;            return posConst[(int)val];        &#125; else &#123;            return val &lt; 0L &amp;&amp; val &gt;= -16L ? negConst[(int)(-val)] : new BigInteger(val);        &#125;    &#125;    private BigInteger(long val) &#123;        if (val &lt; 0L) &#123;            val = -val;            this.signum = -1;        &#125; else &#123;            this.signum = 1;        &#125;        int highWord = (int)(val &gt;&gt;&gt; 32);        if (highWord == 0) &#123;            this.mag = new int[1];            this.mag[0] = (int)val;        &#125; else &#123;            this.mag = new int[2];            this.mag[0] = highWord;            this.mag[1] = (int)val;        &#125;    &#125;    private static BigInteger valueOf(int[] val) &#123;        return val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val);    &#125;    public BigInteger add(BigInteger val) &#123;        if (val.signum == 0) &#123;            return this;        &#125; else if (this.signum == 0) &#123;            return val;        &#125; else if (val.signum == this.signum) &#123;            return new BigInteger(add(this.mag, val.mag), this.signum);        &#125; else &#123;            int cmp = this.compareMagnitude(val);            if (cmp == 0) &#123;                return ZERO;            &#125; else &#123;                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);                resultMag = trustedStripLeadingZeroInts(resultMag);                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);            &#125;        &#125;    &#125;    BigInteger add(long val) &#123;        if (val == 0L) &#123;            return this;        &#125; else if (this.signum == 0) &#123;            return valueOf(val);        &#125; else if (Long.signum(val) == this.signum) &#123;            return new BigInteger(add(this.mag, Math.abs(val)), this.signum);        &#125; else &#123;            int cmp = this.compareMagnitude(val);            if (cmp == 0) &#123;                return ZERO;            &#125; else &#123;                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, Math.abs(val)) : subtract(Math.abs(val), this.mag);                resultMag = trustedStripLeadingZeroInts(resultMag);                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);            &#125;        &#125;    &#125;    private static int[] add(int[] x, long val) &#123;        long sum = 0L;        int xIndex = x.length;        int highWord = (int)(val &gt;&gt;&gt; 32);        int[] result;        if (highWord == 0) &#123;            result = new int[xIndex];            --xIndex;            sum = ((long)x[xIndex] &amp; 4294967295L) + val;            result[xIndex] = (int)sum;        &#125; else &#123;            if (xIndex == 1) &#123;                result = new int[2];                sum = val + ((long)x[0] &amp; 4294967295L);                result[1] = (int)sum;                result[0] = (int)(sum &gt;&gt;&gt; 32);                return result;            &#125;            result = new int[xIndex];            --xIndex;            sum = ((long)x[xIndex] &amp; 4294967295L) + (val &amp; 4294967295L);            result[xIndex] = (int)sum;            --xIndex;            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)highWord &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);            result[xIndex] = (int)sum;        &#125;        boolean carry;        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) &#123;            --xIndex;        &#125;        while(xIndex &gt; 0) &#123;            --xIndex;            result[xIndex] = x[xIndex];        &#125;        if (carry) &#123;            int[] bigger = new int[result.length + 1];            System.arraycopy(result, 0, bigger, 1, result.length);            bigger[0] = 1;            return bigger;        &#125; else &#123;            return result;        &#125;    &#125;    private static int[] add(int[] x, int[] y) &#123;        if (x.length &lt; y.length) &#123;            int[] tmp = x;            x = y;            y = tmp;        &#125;        int xIndex = x.length;        int yIndex = y.length;        int[] result = new int[xIndex];        long sum = 0L;        if (yIndex == 1) &#123;            --xIndex;            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)y[0] &amp; 4294967295L);            result[xIndex] = (int)sum;        &#125; else &#123;            while(yIndex &gt; 0) &#123;                --xIndex;                long var10000 = (long)x[xIndex] &amp; 4294967295L;                --yIndex;                sum = var10000 + ((long)y[yIndex] &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);                result[xIndex] = (int)sum;            &#125;        &#125;        boolean carry;        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) &#123;            --xIndex;        &#125;        while(xIndex &gt; 0) &#123;            --xIndex;            result[xIndex] = x[xIndex];        &#125;        if (carry) &#123;            int[] bigger = new int[result.length + 1];            System.arraycopy(result, 0, bigger, 1, result.length);            bigger[0] = 1;            return bigger;        &#125; else &#123;            return result;        &#125;    &#125;    private static int[] subtract(long val, int[] little) &#123;        int highWord = (int)(val &gt;&gt;&gt; 32);        int[] result;        if (highWord == 0) &#123;            result = new int[]&#123;(int)(val - ((long)little[0] &amp; 4294967295L))&#125;;            return result;        &#125; else &#123;            result = new int[2];            long difference;            if (little.length == 1) &#123;                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L);                result[1] = (int)difference;                boolean borrow = difference &gt;&gt; 32 != 0L;                if (borrow) &#123;                    result[0] = highWord - 1;                &#125; else &#123;                    result[0] = highWord;                &#125;                return result;            &#125; else &#123;                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[1] &amp; 4294967295L);                result[1] = (int)difference;                difference = ((long)highWord &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L) + (difference &gt;&gt; 32);                result[0] = (int)difference;                return result;            &#125;        &#125;    &#125;    private static int[] subtract(int[] big, long val) &#123;        int highWord = (int)(val &gt;&gt;&gt; 32);        int bigIndex = big.length;        int[] result = new int[bigIndex];        long difference = 0L;        if (highWord == 0) &#123;            --bigIndex;            difference = ((long)big[bigIndex] &amp; 4294967295L) - val;            result[bigIndex] = (int)difference;        &#125; else &#123;            --bigIndex;            difference = ((long)big[bigIndex] &amp; 4294967295L) - (val &amp; 4294967295L);            result[bigIndex] = (int)difference;            --bigIndex;            difference = ((long)big[bigIndex] &amp; 4294967295L) - ((long)highWord &amp; 4294967295L) + (difference &gt;&gt; 32);            result[bigIndex] = (int)difference;        &#125;        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) &#123;            --bigIndex;        &#125;        while(bigIndex &gt; 0) &#123;            --bigIndex;            result[bigIndex] = big[bigIndex];        &#125;        return result;    &#125;    public BigInteger subtract(BigInteger val) &#123;        if (val.signum == 0) &#123;            return this;        &#125; else if (this.signum == 0) &#123;            return val.negate();        &#125; else if (val.signum != this.signum) &#123;            return new BigInteger(add(this.mag, val.mag), this.signum);        &#125; else &#123;            int cmp = this.compareMagnitude(val);            if (cmp == 0) &#123;                return ZERO;            &#125; else &#123;                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);                resultMag = trustedStripLeadingZeroInts(resultMag);                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);            &#125;        &#125;    &#125;    private static int[] subtract(int[] big, int[] little) &#123;        int bigIndex = big.length;        int[] result = new int[bigIndex];        int littleIndex = little.length;        long difference;        for(difference = 0L; littleIndex &gt; 0; result[bigIndex] = (int)difference) &#123;            --bigIndex;            long var10000 = (long)big[bigIndex] &amp; 4294967295L;            --littleIndex;            difference = var10000 - ((long)little[littleIndex] &amp; 4294967295L) + (difference &gt;&gt; 32);        &#125;        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) &#123;            --bigIndex;        &#125;        while(bigIndex &gt; 0) &#123;            --bigIndex;            result[bigIndex] = big[bigIndex];        &#125;        return result;    &#125;    public BigInteger multiply(BigInteger val) &#123;        return this.multiply(val, false);    &#125;    private BigInteger multiply(BigInteger val, boolean isRecursion) &#123;        if (val.signum != 0 &amp;&amp; this.signum != 0) &#123;            int xlen = this.mag.length;            if (val == this &amp;&amp; xlen &gt; 20) &#123;                return this.square();            &#125; else &#123;                int ylen = val.mag.length;                if (xlen &gt;= 80 &amp;&amp; ylen &gt;= 80) &#123;                    if (xlen &lt; 240 &amp;&amp; ylen &lt; 240) &#123;                        return multiplyKaratsuba(this, val);                    &#125; else &#123;                        if (!isRecursion &amp;&amp; (long)(bitLength(this.mag, this.mag.length) + bitLength(val.mag, val.mag.length)) &gt; 2147483648L) &#123;                            reportOverflow();                        &#125;                        return multiplyToomCook3(this, val);                    &#125;                &#125; else &#123;                    int resultSign = this.signum == val.signum ? 1 : -1;                    if (val.mag.length == 1) &#123;                        return multiplyByInt(this.mag, val.mag[0], resultSign);                    &#125; else if (this.mag.length == 1) &#123;                        return multiplyByInt(val.mag, this.mag[0], resultSign);                    &#125; else &#123;                        int[] result = multiplyToLen(this.mag, xlen, val.mag, ylen, (int[])null);                        result = trustedStripLeadingZeroInts(result);                        return new BigInteger(result, resultSign);                    &#125;                &#125;            &#125;        &#125; else &#123;            return ZERO;        &#125;    &#125;    private static BigInteger multiplyByInt(int[] x, int y, int sign) &#123;        if (Integer.bitCount(y) == 1) &#123;            return new BigInteger(shiftLeft(x, Integer.numberOfTrailingZeros(y)), sign);        &#125; else &#123;            int xlen = x.length;            int[] rmag = new int[xlen + 1];            long carry = 0L;            long yl = (long)y &amp; 4294967295L;            int rstart = rmag.length - 1;            for(int i = xlen - 1; i &gt;= 0; --i) &#123;                long product = ((long)x[i] &amp; 4294967295L) * yl + carry;                rmag[rstart--] = (int)product;                carry = product &gt;&gt;&gt; 32;            &#125;            if (carry == 0L) &#123;                rmag = Arrays.copyOfRange(rmag, 1, rmag.length);            &#125; else &#123;                rmag[rstart] = (int)carry;            &#125;            return new BigInteger(rmag, sign);        &#125;    &#125;    BigInteger multiply(long v) &#123;        if (v != 0L &amp;&amp; this.signum != 0) &#123;            if (v == -9223372036854775808L) &#123;                return this.multiply(valueOf(v));            &#125; else &#123;                int rsign = v &gt; 0L ? this.signum : -this.signum;                if (v &lt; 0L) &#123;                    v = -v;                &#125;                long dh = v &gt;&gt;&gt; 32;                long dl = v &amp; 4294967295L;                int xlen = this.mag.length;                int[] value = this.mag;                int[] rmag = dh == 0L ? new int[xlen + 1] : new int[xlen + 2];                long carry = 0L;                int rstart = rmag.length - 1;                int i;                long product;                for(i = xlen - 1; i &gt;= 0; --i) &#123;                    product = ((long)value[i] &amp; 4294967295L) * dl + carry;                    rmag[rstart--] = (int)product;                    carry = product &gt;&gt;&gt; 32;                &#125;                rmag[rstart] = (int)carry;                if (dh != 0L) &#123;                    carry = 0L;                    rstart = rmag.length - 2;                    for(i = xlen - 1; i &gt;= 0; --i) &#123;                        product = ((long)value[i] &amp; 4294967295L) * dh + ((long)rmag[rstart] &amp; 4294967295L) + carry;                        rmag[rstart--] = (int)product;                        carry = product &gt;&gt;&gt; 32;                    &#125;                    rmag[0] = (int)carry;                &#125;                if (carry == 0L) &#123;                    rmag = Arrays.copyOfRange(rmag, 1, rmag.length);                &#125;                return new BigInteger(rmag, rsign);            &#125;        &#125; else &#123;            return ZERO;        &#125;    &#125;    private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) &#123;        multiplyToLenCheck(x, xlen);        multiplyToLenCheck(y, ylen);        return implMultiplyToLen(x, xlen, y, ylen, z);    &#125;    @HotSpotIntrinsicCandidate    private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) &#123;        int xstart = xlen - 1;        int ystart = ylen - 1;        if (z == null || z.length &lt; xlen + ylen) &#123;            z = new int[xlen + ylen];        &#125;        long carry = 0L;        int i = ystart;        int j;        for(j = ystart + 1 + xstart; i &gt;= 0; --j) &#123;            long product = ((long)y[i] &amp; 4294967295L) * ((long)x[xstart] &amp; 4294967295L) + carry;            z[j] = (int)product;            carry = product &gt;&gt;&gt; 32;            --i;        &#125;        z[xstart] = (int)carry;        for(i = xstart - 1; i &gt;= 0; --i) &#123;            carry = 0L;            j = ystart;            for(int k = ystart + 1 + i; j &gt;= 0; --k) &#123;                long product = ((long)y[j] &amp; 4294967295L) * ((long)x[i] &amp; 4294967295L) + ((long)z[k] &amp; 4294967295L) + carry;                z[k] = (int)product;                carry = product &gt;&gt;&gt; 32;                --j;            &#125;            z[i] = (int)carry;        &#125;        return z;    &#125;    private static void multiplyToLenCheck(int[] array, int length) &#123;        if (length &gt; 0) &#123;            Objects.requireNonNull(array);            if (length &gt; array.length) &#123;                throw new ArrayIndexOutOfBoundsException(length - 1);            &#125;        &#125;    &#125;    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) &#123;        int xlen = x.mag.length;        int ylen = y.mag.length;        int half = (Math.max(xlen, ylen) + 1)  2;        BigInteger xl = x.getLower(half);        BigInteger xh = x.getUpper(half);        BigInteger yl = y.getLower(half);        BigInteger yh = y.getUpper(half);        BigInteger p1 = xh.multiply(yh);        BigInteger p2 = xl.multiply(yl);        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));        BigInteger result = p1.shiftLeft(32 * half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32 * half).add(p2);        return x.signum != y.signum ? result.negate() : result;    &#125;    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) &#123;        int alen = a.mag.length;        int blen = b.mag.length;        int largest = Math.max(alen, blen);        int k = (largest + 2)  3;        int r = largest - 2 * k;        BigInteger a2 = a.getToomSlice(k, r, 0, largest);        BigInteger a1 = a.getToomSlice(k, r, 1, largest);        BigInteger a0 = a.getToomSlice(k, r, 2, largest);        BigInteger b2 = b.getToomSlice(k, r, 0, largest);        BigInteger b1 = b.getToomSlice(k, r, 1, largest);        BigInteger b0 = b.getToomSlice(k, r, 2, largest);        BigInteger v0 = a0.multiply(b0, true);        BigInteger da1 = a2.add(a0);        BigInteger db1 = b2.add(b0);        BigInteger vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);        da1 = da1.add(a1);        db1 = db1.add(b1);        BigInteger v1 = da1.multiply(db1, true);        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(db1.add(b2).shiftLeft(1).subtract(b0), true);        BigInteger vinf = a2.multiply(b2, true);        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);        BigInteger t1 = v1.subtract(v0);        t2 = t2.subtract(t1).shiftRight(1);        t1 = t1.subtract(tm1).subtract(vinf);        t2 = t2.subtract(vinf.shiftLeft(1));        tm1 = tm1.subtract(t2);        int ss = k * 32;        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);        return a.signum != b.signum ? result.negate() : result;    &#125;    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice, int fullsize) &#123;        int len = this.mag.length;        int offset = fullsize - len;        int start;        int end;        if (slice == 0) &#123;            start = 0 - offset;            end = upperSize - 1 - offset;        &#125; else &#123;            start = upperSize + (slice - 1) * lowerSize - offset;            end = start + lowerSize - 1;        &#125;        if (start &lt; 0) &#123;            start = 0;        &#125;        if (end &lt; 0) &#123;            return ZERO;        &#125; else &#123;            int sliceSize = end - start + 1;            if (sliceSize &lt;= 0) &#123;                return ZERO;            &#125; else if (start == 0 &amp;&amp; sliceSize &gt;= len) &#123;                return this.abs();            &#125; else &#123;                int[] intSlice = new int[sliceSize];                System.arraycopy(this.mag, start, intSlice, 0, sliceSize);                return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);            &#125;        &#125;    &#125;    private BigInteger exactDivideBy3() &#123;        int len = this.mag.length;        int[] result = new int[len];        long borrow = 0L;        for(int i = len - 1; i &gt;= 0; --i) &#123;            long x = (long)this.mag[i] &amp; 4294967295L;            long w = x - borrow;            if (borrow &gt; x) &#123;                borrow = 1L;            &#125; else &#123;                borrow = 0L;            &#125;            long q = w * 2863311531L &amp; 4294967295L;            result[i] = (int)q;            if (q &gt;= 1431655766L) &#123;                ++borrow;                if (q &gt;= 2863311531L) &#123;                    ++borrow;                &#125;            &#125;        &#125;        result = trustedStripLeadingZeroInts(result);        return new BigInteger(result, this.signum);    &#125;    private BigInteger getLower(int n) &#123;        int len = this.mag.length;        if (len &lt;= n) &#123;            return this.abs();        &#125; else &#123;            int[] lowerInts = new int[n];            System.arraycopy(this.mag, len - n, lowerInts, 0, n);            return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);        &#125;    &#125;    private BigInteger getUpper(int n) &#123;        int len = this.mag.length;        if (len &lt;= n) &#123;            return ZERO;        &#125; else &#123;            int upperLen = len - n;            int[] upperInts = new int[upperLen];            System.arraycopy(this.mag, 0, upperInts, 0, upperLen);            return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);        &#125;    &#125;    private BigInteger square() &#123;        return this.square(false);    &#125;    private BigInteger square(boolean isRecursion) &#123;        if (this.signum == 0) &#123;            return ZERO;        &#125; else &#123;            int len = this.mag.length;            if (len &lt; 128) &#123;                int[] z = squareToLen(this.mag, len, (int[])null);                return new BigInteger(trustedStripLeadingZeroInts(z), 1);            &#125; else if (len &lt; 216) &#123;                return this.squareKaratsuba();            &#125; else &#123;                if (!isRecursion &amp;&amp; (long)bitLength(this.mag, this.mag.length) &gt; 1073741824L) &#123;                    reportOverflow();                &#125;                return this.squareToomCook3();            &#125;        &#125;    &#125;    private static final int[] squareToLen(int[] x, int len, int[] z) &#123;        int zlen = len &lt;&lt; 1;        if (z == null || z.length &lt; zlen) &#123;            z = new int[zlen];        &#125;        implSquareToLenChecks(x, len, z, zlen);        return implSquareToLen(x, len, z, zlen);    &#125;    private static void implSquareToLenChecks(int[] x, int len, int[] z, int zlen) throws RuntimeException &#123;        if (len &lt; 1) &#123;            throw new IllegalArgumentException(invalid input length:  + len);        &#125; else if (len &gt; x.length) &#123;            throw new IllegalArgumentException(input length out of bound:  + len +  &gt;  + x.length);        &#125; else if (len * 2 &gt; z.length) &#123;            throw new IllegalArgumentException(input length out of bound:  + len * 2 +  &gt;  + z.length);        &#125; else if (zlen &lt; 1) &#123;            throw new IllegalArgumentException(invalid input length:  + zlen);        &#125; else if (zlen &gt; z.length) &#123;            throw new IllegalArgumentException(input length out of bound:  + len +  &gt;  + z.length);        &#125;    &#125;    @HotSpotIntrinsicCandidate    private static final int[] implSquareToLen(int[] x, int len, int[] z, int zlen) &#123;        int lastProductLowWord = 0;        int i = 0;        int offset;        for(offset = 0; i &lt; len; ++i) &#123;            long piece = (long)x[i] &amp; 4294967295L;            long product = piece * piece;            z[offset++] = lastProductLowWord &lt;&lt; 31 | (int)(product &gt;&gt;&gt; 33);            z[offset++] = (int)(product &gt;&gt;&gt; 1);            lastProductLowWord = (int)product;        &#125;        i = len;        for(offset = 1; i &gt; 0; offset += 2) &#123;            int t = x[i - 1];            t = mulAdd(z, x, offset, i - 1, t);            addOne(z, offset - 1, i, t);            --i;        &#125;        primitiveLeftShift(z, zlen, 1);        z[zlen - 1] |= x[len - 1] &amp; 1;        return z;    &#125;    private BigInteger squareKaratsuba() &#123;        int half = (this.mag.length + 1)  2;        BigInteger xl = this.getLower(half);        BigInteger xh = this.getUpper(half);        BigInteger xhs = xh.square();        BigInteger xls = xl.square();        return xhs.shiftLeft(half * 32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half * 32).add(xls);    &#125;    private BigInteger squareToomCook3() &#123;        int len = this.mag.length;        int k = (len + 2)  3;        int r = len - 2 * k;        BigInteger a2 = this.getToomSlice(k, r, 0, len);        BigInteger a1 = this.getToomSlice(k, r, 1, len);        BigInteger a0 = this.getToomSlice(k, r, 2, len);        BigInteger v0 = a0.square(true);        BigInteger da1 = a2.add(a0);        BigInteger vm1 = da1.subtract(a1).square(true);        da1 = da1.add(a1);        BigInteger v1 = da1.square(true);        BigInteger vinf = a2.square(true);        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);        BigInteger t1 = v1.subtract(v0);        t2 = t2.subtract(t1).shiftRight(1);        t1 = t1.subtract(tm1).subtract(vinf);        t2 = t2.subtract(vinf.shiftLeft(1));        tm1 = tm1.subtract(t2);        int ss = k * 32;        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);    &#125;    public BigInteger divide(BigInteger val) &#123;        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideBurnikelZiegler(val) : this.divideKnuth(val);    &#125;    private BigInteger divideKnuth(BigInteger val) &#123;        MutableBigInteger q = new MutableBigInteger();        MutableBigInteger a = new MutableBigInteger(this.mag);        MutableBigInteger b = new MutableBigInteger(val.mag);        a.divideKnuth(b, q, false);        return q.toBigInteger(this.signum * val.signum);    &#125;    public BigInteger[] divideAndRemainder(BigInteger val) &#123;        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideAndRemainderBurnikelZiegler(val) : this.divideAndRemainderKnuth(val);    &#125;    private BigInteger[] divideAndRemainderKnuth(BigInteger val) &#123;        BigInteger[] result = new BigInteger[2];        MutableBigInteger q = new MutableBigInteger();        MutableBigInteger a = new MutableBigInteger(this.mag);        MutableBigInteger b = new MutableBigInteger(val.mag);        MutableBigInteger r = a.divideKnuth(b, q);        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);        result[1] = r.toBigInteger(this.signum);        return result;    &#125;    public BigInteger remainder(BigInteger val) &#123;        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.remainderBurnikelZiegler(val) : this.remainderKnuth(val);    &#125;    private BigInteger remainderKnuth(BigInteger val) &#123;        MutableBigInteger q = new MutableBigInteger();        MutableBigInteger a = new MutableBigInteger(this.mag);        MutableBigInteger b = new MutableBigInteger(val.mag);        return a.divideKnuth(b, q).toBigInteger(this.signum);    &#125;    private BigInteger divideBurnikelZiegler(BigInteger val) &#123;        return this.divideAndRemainderBurnikelZiegler(val)[0];    &#125;    private BigInteger remainderBurnikelZiegler(BigInteger val) &#123;        return this.divideAndRemainderBurnikelZiegler(val)[1];    &#125;    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) &#123;        MutableBigInteger q = new MutableBigInteger();        MutableBigInteger r = (new MutableBigInteger(this)).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(this.signum * val.signum);        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(this.signum);        return new BigInteger[]&#123;qBigInt, rBigInt&#125;;    &#125;    public BigInteger pow(int exponent) &#123;        if (exponent &lt; 0) &#123;            throw new ArithmeticException(Negative exponent);        &#125; else if (this.signum == 0) &#123;            return exponent == 0 ? ONE : this;        &#125; else &#123;            BigInteger partToSquare = this.abs();            int powersOfTwo = partToSquare.getLowestSetBit();            long bitsToShiftLong = (long)powersOfTwo * (long)exponent;            if (bitsToShiftLong &gt; 2147483647L) &#123;                reportOverflow();            &#125;            int bitsToShift = (int)bitsToShiftLong;            int remainingBits;            if (powersOfTwo &gt; 0) &#123;                partToSquare = partToSquare.shiftRight(powersOfTwo);                remainingBits = partToSquare.bitLength();                if (remainingBits == 1) &#123;                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) &#123;                        return NEGATIVE_ONE.shiftLeft(bitsToShift);                    &#125;                    return ONE.shiftLeft(bitsToShift);                &#125;            &#125; else &#123;                remainingBits = partToSquare.bitLength();                if (remainingBits == 1) &#123;                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) &#123;                        return NEGATIVE_ONE;                    &#125;                    return ONE;                &#125;            &#125;            long scaleFactor = (long)remainingBits * (long)exponent;            if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62L) &#123;                int newSign = this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1 ? -1 : 1;                long result = 1L;                long baseToPow2 = (long)partToSquare.mag[0] &amp; 4294967295L;                int workingExponent = exponent;                while(workingExponent != 0) &#123;                    if ((workingExponent &amp; 1) == 1) &#123;                        result *= baseToPow2;                    &#125;                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) &#123;                        baseToPow2 *= baseToPow2;                    &#125;                &#125;                if (powersOfTwo &gt; 0) &#123;                    if ((long)bitsToShift + scaleFactor &lt;= 62L) &#123;                        return valueOf((result &lt;&lt; bitsToShift) * (long)newSign);                    &#125; else &#123;                        return valueOf(result * (long)newSign).shiftLeft(bitsToShift);                    &#125;                &#125; else &#123;                    return valueOf(result * (long)newSign);                &#125;            &#125; else &#123;                if ((long)this.bitLength() * (long)exponent  32L &gt; 67108864L) &#123;                    reportOverflow();                &#125;                BigInteger answer = ONE;                int workingExponent = exponent;                while(workingExponent != 0) &#123;                    if ((workingExponent &amp; 1) == 1) &#123;                        answer = answer.multiply(partToSquare);                    &#125;                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) &#123;                        partToSquare = partToSquare.square();                    &#125;                &#125;                if (powersOfTwo &gt; 0) &#123;                    answer = answer.shiftLeft(bitsToShift);                &#125;                if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) &#123;                    return answer.negate();                &#125; else &#123;                    return answer;                &#125;            &#125;        &#125;    &#125;    public BigInteger sqrt() &#123;        if (this.signum &lt; 0) &#123;            throw new ArithmeticException(Negative BigInteger);        &#125; else &#123;            return (new MutableBigInteger(this.mag)).sqrt().toBigInteger();        &#125;    &#125;    public BigInteger[] sqrtAndRemainder() &#123;        BigInteger s = this.sqrt();        BigInteger r = this.subtract(s.square());        assert r.compareTo(ZERO) &gt;= 0;        return new BigInteger[]&#123;s, r&#125;;    &#125;    public BigInteger gcd(BigInteger val) &#123;        if (val.signum == 0) &#123;            return this.abs();        &#125; else if (this.signum == 0) &#123;            return val.abs();        &#125; else &#123;            MutableBigInteger a = new MutableBigInteger(this);            MutableBigInteger b = new MutableBigInteger(val);            MutableBigInteger result = a.hybridGCD(b);            return result.toBigInteger(1);        &#125;    &#125;    static int bitLengthForInt(int n) &#123;        return 32 - Integer.numberOfLeadingZeros(n);    &#125;    private static int[] leftShift(int[] a, int len, int n) &#123;        int nInts = n &gt;&gt;&gt; 5;        int nBits = n &amp; 31;        int bitsInHighWord = bitLengthForInt(a[0]);        if (n &lt;= 32 - bitsInHighWord) &#123;            primitiveLeftShift(a, len, nBits);            return a;        &#125; else &#123;            int[] result;            if (nBits &lt;= 32 - bitsInHighWord) &#123;                result = new int[nInts + len];                System.arraycopy(a, 0, result, 0, len);                primitiveLeftShift(result, result.length, nBits);                return result;            &#125; else &#123;                result = new int[nInts + len + 1];                System.arraycopy(a, 0, result, 0, len);                primitiveRightShift(result, result.length, 32 - nBits);                return result;            &#125;        &#125;    &#125;    static void primitiveRightShift(int[] a, int len, int n) &#123;        int n2 = 32 - n;        int i = len - 1;        for(int c = a[i]; i &gt; 0; --i) &#123;            int b = c;            c = a[i - 1];            a[i] = c &lt;&lt; n2 | b &gt;&gt;&gt; n;        &#125;        a[0] &gt;&gt;&gt;= n;    &#125;    static void primitiveLeftShift(int[] a, int len, int n) &#123;        if (len != 0 &amp;&amp; n != 0) &#123;            int n2 = 32 - n;            int i = 0;            int c = a[i];            for(int m = i + len - 1; i &lt; m; ++i) &#123;                int b = c;                c = a[i + 1];                a[i] = b &lt;&lt; n | c &gt;&gt;&gt; n2;            &#125;            a[len - 1] &lt;&lt;= n;        &#125;    &#125;    private static int bitLength(int[] val, int len) &#123;        return len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(val[0]);    &#125;    public BigInteger abs() &#123;        return this.signum &gt;= 0 ? this : this.negate();    &#125;    public BigInteger negate() &#123;        return new BigInteger(this.mag, -this.signum);    &#125;    public int signum() &#123;        return this.signum;    &#125;    public BigInteger mod(BigInteger m) &#123;        if (m.signum &lt;= 0) &#123;            throw new ArithmeticException(BigInteger: modulus not positive);        &#125; else &#123;            BigInteger result = this.remainder(m);            return result.signum &gt;= 0 ? result : result.add(m);        &#125;    &#125;    public BigInteger modPow(BigInteger exponent, BigInteger m) &#123;        if (m.signum &lt;= 0) &#123;            throw new ArithmeticException(BigInteger: modulus not positive);        &#125; else if (exponent.signum == 0) &#123;            return m.equals(ONE) ? ZERO : ONE;        &#125; else if (this.equals(ONE)) &#123;            return m.equals(ONE) ? ZERO : ONE;        &#125; else if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0) &#123;            return ZERO;        &#125; else if (this.equals(negConst[1]) &amp;&amp; !exponent.testBit(0)) &#123;            return m.equals(ONE) ? ZERO : ONE;        &#125; else &#123;            boolean invertResult;            if (invertResult = exponent.signum &lt; 0) &#123;                exponent = exponent.negate();            &#125;            BigInteger base = this.signum &gt;= 0 &amp;&amp; this.compareTo(m) &lt; 0 ? this : this.mod(m);            BigInteger result;            if (m.testBit(0)) &#123;                result = base.oddModPow(exponent, m);            &#125; else &#123;                int p = m.getLowestSetBit();                BigInteger m1 = m.shiftRight(p);                BigInteger m2 = ONE.shiftLeft(p);                BigInteger base2 = this.signum &gt;= 0 &amp;&amp; this.compareTo(m1) &lt; 0 ? this : this.mod(m1);                BigInteger a1 = m1.equals(ONE) ? ZERO : base2.oddModPow(exponent, m1);                BigInteger a2 = base.modPow2(exponent, p);                BigInteger y1 = m2.modInverse(m1);                BigInteger y2 = m1.modInverse(m2);                if (m.mag.length &lt; 33554432) &#123;                    result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);                &#125; else &#123;                    MutableBigInteger t1 = new MutableBigInteger();                    (new MutableBigInteger(a1.multiply(m2))).multiply(new MutableBigInteger(y1), t1);                    MutableBigInteger t2 = new MutableBigInteger();                    (new MutableBigInteger(a2.multiply(m1))).multiply(new MutableBigInteger(y2), t2);                    t1.add(t2);                    MutableBigInteger q = new MutableBigInteger();                    result = t1.divide(new MutableBigInteger(m), q).toBigInteger();                &#125;            &#125;            return invertResult ? result.modInverse(m) : result;        &#125;    &#125;    private static int[] montgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) &#123;        implMontgomeryMultiplyChecks(a, b, n, len, product);        if (len &gt; 512) &#123;            product = multiplyToLen(a, len, b, len, product);            return montReduce(product, n, len, (int)inv);        &#125; else &#123;            return implMontgomeryMultiply(a, b, n, len, inv, materialize(product, len));        &#125;    &#125;    private static int[] montgomerySquare(int[] a, int[] n, int len, long inv, int[] product) &#123;        implMontgomeryMultiplyChecks(a, a, n, len, product);        if (len &gt; 512) &#123;            product = squareToLen(a, len, product);            return montReduce(product, n, len, (int)inv);        &#125; else &#123;            return implMontgomerySquare(a, n, len, inv, materialize(product, len));        &#125;    &#125;    private static void implMontgomeryMultiplyChecks(int[] a, int[] b, int[] n, int len, int[] product) throws RuntimeException &#123;        if (len % 2 != 0) &#123;            throw new IllegalArgumentException(input array length must be even:  + len);        &#125; else if (len &lt; 1) &#123;            throw new IllegalArgumentException(invalid input length:  + len);        &#125; else if (len &gt; a.length || len &gt; b.length || len &gt; n.length || product != null &amp;&amp; len &gt; product.length) &#123;            throw new IllegalArgumentException(input array length out of bound:  + len);        &#125;    &#125;    private static int[] materialize(int[] z, int len) &#123;        if (z == null || z.length &lt; len) &#123;            z = new int[len];        &#125;        return z;    &#125;    @HotSpotIntrinsicCandidate    private static int[] implMontgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) &#123;        product = multiplyToLen(a, len, b, len, product);        return montReduce(product, n, len, (int)inv);    &#125;    @HotSpotIntrinsicCandidate    private static int[] implMontgomerySquare(int[] a, int[] n, int len, long inv, int[] product) &#123;        product = squareToLen(a, len, product);        return montReduce(product, n, len, (int)inv);    &#125;    private BigInteger oddModPow(BigInteger y, BigInteger z) &#123;        if (y.equals(ONE)) &#123;            return this;        &#125; else if (this.signum == 0) &#123;            return ZERO;        &#125; else &#123;            int[] base = (int[])this.mag.clone();            int[] exp = y.mag;            int[] mod = z.mag;            int modLen = mod.length;            if ((modLen &amp; 1) != 0) &#123;                int[] x = new int[modLen + 1];                System.arraycopy(mod, 0, x, 1, modLen);                mod = x;                ++modLen;            &#125;            int wbits = 0;            int ebits = bitLength(exp, exp.length);            if (ebits != 17 || exp[0] != 65537) &#123;                while(ebits &gt; bnExpModThreshTable[wbits]) &#123;                    ++wbits;                &#125;            &#125;            int tblmask = 1 &lt;&lt; wbits;            int[][] table = new int[tblmask][];            for(int i = 0; i &lt; tblmask; ++i) &#123;                table[i] = new int[modLen];            &#125;            long n0 = ((long)mod[modLen - 1] &amp; 4294967295L) + (((long)mod[modLen - 2] &amp; 4294967295L) &lt;&lt; 32);            long inv = -MutableBigInteger.inverseMod64(n0);            int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);            MutableBigInteger q = new MutableBigInteger();            MutableBigInteger a2 = new MutableBigInteger(a);            MutableBigInteger b2 = new MutableBigInteger(mod);            b2.normalize();            MutableBigInteger r = a2.divide(b2, q);            table[0] = r.toIntArray();            int[] t;            if (table[0].length &lt; modLen) &#123;                int offset = modLen - table[0].length;                t = new int[modLen];                System.arraycopy(table[0], 0, t, offset, table[0].length);                table[0] = t;            &#125;            int[] b = montgomerySquare(table[0], mod, modLen, inv, (int[])null);            t = Arrays.copyOf(b, modLen);            int bitpos;            for(bitpos = 1; bitpos &lt; tblmask; ++bitpos) &#123;                table[bitpos] = montgomeryMultiply(t, table[bitpos - 1], mod, modLen, inv, (int[])null);            &#125;            bitpos = 1 &lt;&lt; (ebits - 1 &amp; 31);            int buf = 0;            int elen = exp.length;            int eIndex = 0;            int multpos;            for(multpos = 0; multpos &lt;= wbits; ++multpos) &#123;                buf = buf &lt;&lt; 1 | ((exp[eIndex] &amp; bitpos) != 0 ? 1 : 0);                bitpos &gt;&gt;&gt;= 1;                if (bitpos == 0) &#123;                    ++eIndex;                    bitpos = -2147483648;                    --elen;                &#125;            &#125;            --ebits;            boolean isone = true;            for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) &#123;                buf &gt;&gt;&gt;= 1;            &#125;            int[] mult = table[buf &gt;&gt;&gt; 1];            buf = 0;            if (multpos == ebits) &#123;                isone = false;            &#125;            while(true) &#123;                --ebits;                buf &lt;&lt;= 1;                if (elen != 0) &#123;                    buf |= (exp[eIndex] &amp; bitpos) != 0 ? 1 : 0;                    bitpos &gt;&gt;&gt;= 1;                    if (bitpos == 0) &#123;                        ++eIndex;                        bitpos = -2147483648;                        --elen;                    &#125;                &#125;                if ((buf &amp; tblmask) != 0) &#123;                    for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) &#123;                        buf &gt;&gt;&gt;= 1;                    &#125;                    mult = table[buf &gt;&gt;&gt; 1];                    buf = 0;                &#125;                if (ebits == multpos) &#123;                    if (isone) &#123;                        b = (int[])mult.clone();                        isone = false;                    &#125; else &#123;                        a = montgomeryMultiply(b, mult, mod, modLen, inv, a);                        t = a;                        a = b;                        b = t;                    &#125;                &#125;                if (ebits == 0) &#123;                    int[] t2 = new int[2 * modLen];                    System.arraycopy(b, 0, t2, modLen, modLen);                    b = montReduce(t2, mod, modLen, (int)inv);                    t2 = Arrays.copyOf(b, modLen);                    return new BigInteger(1, t2);                &#125;                if (!isone) &#123;                    a = montgomerySquare(b, mod, modLen, inv, a);                    t = a;                    a = b;                    b = t;                &#125;            &#125;        &#125;    &#125;    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) &#123;        int c = 0;        int len = mlen;        int offset = 0;        do &#123;            int nEnd = n[n.length - 1 - offset];            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);            c += addOne(n, offset, mlen, carry);            ++offset;            --len;        &#125; while(len &gt; 0);        while(c &gt; 0) &#123;            c += subN(n, mod, mlen);        &#125;        while(intArrayCmpToLen(n, mod, mlen) &gt;= 0) &#123;            subN(n, mod, mlen);        &#125;        return n;    &#125;    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) &#123;        for(int i = 0; i &lt; len; ++i) &#123;            long b1 = (long)arg1[i] &amp; 4294967295L;            long b2 = (long)arg2[i] &amp; 4294967295L;            if (b1 &lt; b2) &#123;                return -1;            &#125;            if (b1 &gt; b2) &#123;                return 1;            &#125;        &#125;        return 0;    &#125;    private static int subN(int[] a, int[] b, int len) &#123;        long sum = 0L;        while(true) &#123;            --len;            if (len &lt; 0) &#123;                return (int)(sum &gt;&gt; 32);            &#125;            sum = ((long)a[len] &amp; 4294967295L) - ((long)b[len] &amp; 4294967295L) + (sum &gt;&gt; 32);            a[len] = (int)sum;        &#125;    &#125;    static int mulAdd(int[] out, int[] in, int offset, int len, int k) &#123;        implMulAddCheck(out, in, offset, len, k);        return implMulAdd(out, in, offset, len, k);    &#125;    private static void implMulAddCheck(int[] out, int[] in, int offset, int len, int k) &#123;        if (len &gt; in.length) &#123;            throw new IllegalArgumentException(input length is out of bound:  + len +  &gt;  + in.length);        &#125; else if (offset &lt; 0) &#123;            throw new IllegalArgumentException(input offset is invalid:  + offset);        &#125; else if (offset &gt; out.length - 1) &#123;            throw new IllegalArgumentException(input offset is out of bound:  + offset +  &gt;  + (out.length - 1));        &#125; else if (len &gt; out.length - offset) &#123;            throw new IllegalArgumentException(input len is out of bound:  + len +  &gt;  + (out.length - offset));        &#125;    &#125;    @HotSpotIntrinsicCandidate    private static int implMulAdd(int[] out, int[] in, int offset, int len, int k) &#123;        long kLong = (long)k &amp; 4294967295L;        long carry = 0L;        offset = out.length - offset - 1;        for(int j = len - 1; j &gt;= 0; --j) &#123;            long product = ((long)in[j] &amp; 4294967295L) * kLong + ((long)out[offset] &amp; 4294967295L) + carry;            out[offset--] = (int)product;            carry = product &gt;&gt;&gt; 32;        &#125;        return (int)carry;    &#125;    static int addOne(int[] a, int offset, int mlen, int carry) &#123;        offset = a.length - 1 - mlen - offset;        long t = ((long)a[offset] &amp; 4294967295L) + ((long)carry &amp; 4294967295L);        a[offset] = (int)t;        if (t &gt;&gt;&gt; 32 == 0L) &#123;            return 0;        &#125; else &#123;            do &#123;                --mlen;                if (mlen &lt; 0) &#123;                    return 1;                &#125;                --offset;                if (offset &lt; 0) &#123;                    return 1;                &#125;                int var10002 = a[offset]++;            &#125; while(a[offset] == 0);            return 0;        &#125;    &#125;    private BigInteger modPow2(BigInteger exponent, int p) &#123;        BigInteger result = ONE;        BigInteger baseToPow2 = this.mod2(p);        int expOffset = 0;        int limit = exponent.bitLength();        if (this.testBit(0)) &#123;            limit = p - 1 &lt; limit ? p - 1 : limit;        &#125;        while(expOffset &lt; limit) &#123;            if (exponent.testBit(expOffset)) &#123;                result = result.multiply(baseToPow2).mod2(p);            &#125;            ++expOffset;            if (expOffset &lt; limit) &#123;                baseToPow2 = baseToPow2.square().mod2(p);            &#125;        &#125;        return result;    &#125;    private BigInteger mod2(int p) &#123;        if (this.bitLength() &lt;= p) &#123;            return this;        &#125; else &#123;            int numInts = p + 31 &gt;&gt;&gt; 5;            int[] mag = new int[numInts];            System.arraycopy(this.mag, this.mag.length - numInts, mag, 0, numInts);            int excessBits = (numInts &lt;&lt; 5) - p;            mag[0] = (int)((long)mag[0] &amp; (1L &lt;&lt; 32 - excessBits) - 1L);            return mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1);        &#125;    &#125;    public BigInteger modInverse(BigInteger m) &#123;        if (m.signum != 1) &#123;            throw new ArithmeticException(BigInteger: modulus not positive);        &#125; else if (m.equals(ONE)) &#123;            return ZERO;        &#125; else &#123;            BigInteger modVal = this;            if (this.signum &lt; 0 || this.compareMagnitude(m) &gt;= 0) &#123;                modVal = this.mod(m);            &#125;            if (modVal.equals(ONE)) &#123;                return ONE;            &#125; else &#123;                MutableBigInteger a = new MutableBigInteger(modVal);                MutableBigInteger b = new MutableBigInteger(m);                MutableBigInteger result = a.mutableModInverse(b);                return result.toBigInteger(1);            &#125;        &#125;    &#125;    public BigInteger shiftLeft(int n) &#123;        if (this.signum == 0) &#123;            return ZERO;        &#125; else if (n &gt; 0) &#123;            return new BigInteger(shiftLeft(this.mag, n), this.signum);        &#125; else &#123;            return n == 0 ? this : this.shiftRightImpl(-n);        &#125;    &#125;    private static int[] shiftLeft(int[] mag, int n) &#123;        int nInts = n &gt;&gt;&gt; 5;        int nBits = n &amp; 31;        int magLen = mag.length;        int[] newMag = null;        int[] newMag;        if (nBits == 0) &#123;            newMag = new int[magLen + nInts];            System.arraycopy(mag, 0, newMag, 0, magLen);        &#125; else &#123;            int i = 0;            int nBits2 = 32 - nBits;            int highBits = mag[0] &gt;&gt;&gt; nBits2;            if (highBits != 0) &#123;                newMag = new int[magLen + nInts + 1];                newMag[i++] = highBits;            &#125; else &#123;                newMag = new int[magLen + nInts];            &#125;            int j;            for(j = 0; j &lt; magLen - 1; newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2) &#123;            &#125;            newMag[i] = mag[j] &lt;&lt; nBits;        &#125;        return newMag;    &#125;    public BigInteger shiftRight(int n) &#123;        if (this.signum == 0) &#123;            return ZERO;        &#125; else if (n &gt; 0) &#123;            return this.shiftRightImpl(n);        &#125; else &#123;            return n == 0 ? this : new BigInteger(shiftLeft(this.mag, -n), this.signum);        &#125;    &#125;    private BigInteger shiftRightImpl(int n) &#123;        int nInts = n &gt;&gt;&gt; 5;        int nBits = n &amp; 31;        int magLen = this.mag.length;        int[] newMag = null;        if (nInts &gt;= magLen) &#123;            return this.signum &gt;= 0 ? ZERO : negConst[1];        &#125; else &#123;            int newMagLen;            int i;            int nBits2;            int[] newMag;            if (nBits == 0) &#123;                newMagLen = magLen - nInts;                newMag = Arrays.copyOf(this.mag, newMagLen);            &#125; else &#123;                newMagLen = 0;                i = this.mag[0] &gt;&gt;&gt; nBits;                if (i != 0) &#123;                    newMag = new int[magLen - nInts];                    newMag[newMagLen++] = i;                &#125; else &#123;                    newMag = new int[magLen - nInts - 1];                &#125;                nBits2 = 32 - nBits;                for(int j = 0; j &lt; magLen - nInts - 1; newMag[newMagLen++] = this.mag[j++] &lt;&lt; nBits2 | this.mag[j] &gt;&gt;&gt; nBits) &#123;                &#125;            &#125;            if (this.signum &lt; 0) &#123;                boolean onesLost = false;                i = magLen - 1;                for(nBits2 = magLen - nInts; i &gt;= nBits2 &amp;&amp; !onesLost; --i) &#123;                    onesLost = this.mag[i] != 0;                &#125;                if (!onesLost &amp;&amp; nBits != 0) &#123;                    onesLost = this.mag[magLen - nInts - 1] &lt;&lt; 32 - nBits != 0;                &#125;                if (onesLost) &#123;                    newMag = this.javaIncrement(newMag);                &#125;            &#125;            return new BigInteger(newMag, this.signum);        &#125;    &#125;    int[] javaIncrement(int[] val) &#123;        int lastSum = 0;        for(int i = val.length - 1; i &gt;= 0 &amp;&amp; lastSum == 0; --i) &#123;            lastSum = ++val[i];        &#125;        if (lastSum == 0) &#123;            val = new int[val.length + 1];            val[0] = 1;        &#125;        return val;    &#125;    public BigInteger and(BigInteger val) &#123;        int[] result = new int[Math.max(this.intLength(), val.intLength())];        for(int i = 0; i &lt; result.length; ++i) &#123;            result[i] = this.getInt(result.length - i - 1) &amp; val.getInt(result.length - i - 1);        &#125;        return valueOf(result);    &#125;    public BigInteger or(BigInteger val) &#123;        int[] result = new int[Math.max(this.intLength(), val.intLength())];        for(int i = 0; i &lt; result.length; ++i) &#123;            result[i] = this.getInt(result.length - i - 1) | val.getInt(result.length - i - 1);        &#125;        return valueOf(result);    &#125;    public BigInteger xor(BigInteger val) &#123;        int[] result = new int[Math.max(this.intLength(), val.intLength())];        for(int i = 0; i &lt; result.length; ++i) &#123;            result[i] = this.getInt(result.length - i - 1) ^ val.getInt(result.length - i - 1);        &#125;        return valueOf(result);    &#125;    public BigInteger not() &#123;        int[] result = new int[this.intLength()];        for(int i = 0; i &lt; result.length; ++i) &#123;            result[i] = ~this.getInt(result.length - i - 1);        &#125;        return valueOf(result);    &#125;    public BigInteger andNot(BigInteger val) &#123;        int[] result = new int[Math.max(this.intLength(), val.intLength())];        for(int i = 0; i &lt; result.length; ++i) &#123;            result[i] = this.getInt(result.length - i - 1) &amp; ~val.getInt(result.length - i - 1);        &#125;        return valueOf(result);    &#125;    public boolean testBit(int n) &#123;        if (n &lt; 0) &#123;            throw new ArithmeticException(Negative bit address);        &#125; else &#123;            return (this.getInt(n &gt;&gt;&gt; 5) &amp; 1 &lt;&lt; (n &amp; 31)) != 0;        &#125;    &#125;    public BigInteger setBit(int n) &#123;        if (n &lt; 0) &#123;            throw new ArithmeticException(Negative bit address);        &#125; else &#123;            int intNum = n &gt;&gt;&gt; 5;            int[] result = new int[Math.max(this.intLength(), intNum + 2)];            for(int i = 0; i &lt; result.length; ++i) &#123;                result[result.length - i - 1] = this.getInt(i);            &#125;            result[result.length - intNum - 1] |= 1 &lt;&lt; (n &amp; 31);            return valueOf(result);        &#125;    &#125;    public BigInteger clearBit(int n) &#123;        if (n &lt; 0) &#123;            throw new ArithmeticException(Negative bit address);        &#125; else &#123;            int intNum = n &gt;&gt;&gt; 5;            int[] result = new int[Math.max(this.intLength(), (n + 1 &gt;&gt;&gt; 5) + 1)];            for(int i = 0; i &lt; result.length; ++i) &#123;                result[result.length - i - 1] = this.getInt(i);            &#125;            result[result.length - intNum - 1] &amp;= ~(1 &lt;&lt; (n &amp; 31));            return valueOf(result);        &#125;    &#125;    public BigInteger flipBit(int n) &#123;        if (n &lt; 0) &#123;            throw new ArithmeticException(Negative bit address);        &#125; else &#123;            int intNum = n &gt;&gt;&gt; 5;            int[] result = new int[Math.max(this.intLength(), intNum + 2)];            for(int i = 0; i &lt; result.length; ++i) &#123;                result[result.length - i - 1] = this.getInt(i);            &#125;            result[result.length - intNum - 1] ^= 1 &lt;&lt; (n &amp; 31);            return valueOf(result);        &#125;    &#125;    public int getLowestSetBit() &#123;        int lsb = this.lowestSetBitPlusTwo - 2;        if (lsb == -2) &#123;            int lsb = 0;            if (this.signum == 0) &#123;                lsb = lsb - 1;            &#125; else &#123;                int i;                int b;                for(i = 0; (b = this.getInt(i)) == 0; ++i) &#123;                &#125;                lsb = lsb + (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);            &#125;            this.lowestSetBitPlusTwo = lsb + 2;        &#125;        return lsb;    &#125;    public int bitLength() &#123;        int n = this.bitLengthPlusOne - 1;        if (n == -1) &#123;            int[] m = this.mag;            int len = m.length;            if (len == 0) &#123;                n = 0;            &#125; else &#123;                int magBitLength = (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);                if (this.signum &gt;= 0) &#123;                    n = magBitLength;                &#125; else &#123;                    boolean pow2 = Integer.bitCount(this.mag[0]) == 1;                    for(int i = 1; i &lt; len &amp;&amp; pow2; ++i) &#123;                        pow2 = this.mag[i] == 0;                    &#125;                    n = pow2 ? magBitLength - 1 : magBitLength;                &#125;            &#125;            this.bitLengthPlusOne = n + 1;        &#125;        return n;    &#125;    public int bitCount() &#123;        int bc = this.bitCountPlusOne - 1;        if (bc == -1) &#123;            bc = 0;            int magTrailingZeroCount;            for(magTrailingZeroCount = 0; magTrailingZeroCount &lt; this.mag.length; ++magTrailingZeroCount) &#123;                bc += Integer.bitCount(this.mag[magTrailingZeroCount]);            &#125;            if (this.signum &lt; 0) &#123;                magTrailingZeroCount = 0;                int j;                for(j = this.mag.length - 1; this.mag[j] == 0; --j) &#123;                    magTrailingZeroCount += 32;                &#125;                magTrailingZeroCount += Integer.numberOfTrailingZeros(this.mag[j]);                bc += magTrailingZeroCount - 1;            &#125;            this.bitCountPlusOne = bc + 1;        &#125;        return bc;    &#125;    public boolean isProbablePrime(int certainty) &#123;        if (certainty &lt;= 0) &#123;            return true;        &#125; else &#123;            BigInteger w = this.abs();            if (w.equals(TWO)) &#123;                return true;            &#125; else &#123;                return w.testBit(0) &amp;&amp; !w.equals(ONE) ? w.primeToCertainty(certainty, (Random)null) : false;            &#125;        &#125;    &#125;    public int compareTo(BigInteger val) &#123;        if (this.signum == val.signum) &#123;            switch(this.signum) &#123;            case -1:                return val.compareMagnitude(this);            case 1:                return this.compareMagnitude(val);            default:                return 0;            &#125;        &#125; else &#123;            return this.signum &gt; val.signum ? 1 : -1;        &#125;    &#125;    final int compareMagnitude(BigInteger val) &#123;        int[] m1 = this.mag;        int len1 = m1.length;        int[] m2 = val.mag;        int len2 = m2.length;        if (len1 &lt; len2) &#123;            return -1;        &#125; else if (len1 &gt; len2) &#123;            return 1;        &#125; else &#123;            for(int i = 0; i &lt; len1; ++i) &#123;                int a = m1[i];                int b = m2[i];                if (a != b) &#123;                    return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;                &#125;            &#125;            return 0;        &#125;    &#125;    final int compareMagnitude(long val) &#123;        assert val != -9223372036854775808L;        int[] m1 = this.mag;        int len = m1.length;        if (len &gt; 2) &#123;            return 1;        &#125; else &#123;            if (val &lt; 0L) &#123;                val = -val;            &#125;            int highWord = (int)(val &gt;&gt;&gt; 32);            int a;            int b;            if (highWord == 0) &#123;                if (len &lt; 1) &#123;                    return -1;                &#125; else if (len &gt; 1) &#123;                    return 1;                &#125; else &#123;                    a = m1[0];                    b = (int)val;                    if (a != b) &#123;                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;                    &#125; else &#123;                        return 0;                    &#125;                &#125;            &#125; else if (len &lt; 2) &#123;                return -1;            &#125; else &#123;                a = m1[0];                if (a != highWord) &#123;                    return ((long)a &amp; 4294967295L) &lt; ((long)highWord &amp; 4294967295L) ? -1 : 1;                &#125; else &#123;                    a = m1[1];                    b = (int)val;                    if (a != b) &#123;                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;                    &#125; else &#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;    public boolean equals(Object x) &#123;        if (x == this) &#123;            return true;        &#125; else if (!(x instanceof BigInteger)) &#123;            return false;        &#125; else &#123;            BigInteger xInt = (BigInteger)x;            if (xInt.signum != this.signum) &#123;                return false;            &#125; else &#123;                int[] m = this.mag;                int len = m.length;                int[] xm = xInt.mag;                if (len != xm.length) &#123;                    return false;                &#125; else &#123;                    for(int i = 0; i &lt; len; ++i) &#123;                        if (xm[i] != m[i]) &#123;                            return false;                        &#125;                    &#125;                    return true;                &#125;            &#125;        &#125;    &#125;    public BigInteger min(BigInteger val) &#123;        return this.compareTo(val) &lt; 0 ? this : val;    &#125;    public BigInteger max(BigInteger val) &#123;        return this.compareTo(val) &gt; 0 ? this : val;    &#125;    public int hashCode() &#123;        int hashCode = 0;        for(int i = 0; i &lt; this.mag.length; ++i) &#123;            hashCode = (int)((long)(31 * hashCode) + ((long)this.mag[i] &amp; 4294967295L));        &#125;        return hashCode * this.signum;    &#125;    public String toString(int radix) &#123;        if (this.signum == 0) &#123;            return 0;        &#125; else &#123;            if (radix &lt; 2 || radix &gt; 36) &#123;                radix = 10;            &#125;            if (this.mag.length &lt;= 20) &#123;                return this.smallToString(radix);            &#125; else &#123;                StringBuilder sb = new StringBuilder();                if (this.signum &lt; 0) &#123;                    toString(this.negate(), sb, radix, 0);                    sb.insert(0, -);                &#125; else &#123;                    toString(this, sb, radix, 0);                &#125;                return sb.toString();            &#125;        &#125;    &#125;    private String smallToString(int radix) &#123;        if (this.signum == 0) &#123;            return 0;        &#125; else &#123;            int maxNumDigitGroups = (4 * this.mag.length + 6)  7;            String[] digitGroup = new String[maxNumDigitGroups];            BigInteger tmp = this.abs();            int numGroups;            BigInteger q2;            for(numGroups = 0; tmp.signum != 0; tmp = q2) &#123;                BigInteger d = longRadix[radix];                MutableBigInteger q = new MutableBigInteger();                MutableBigInteger a = new MutableBigInteger(tmp.mag);                MutableBigInteger b = new MutableBigInteger(d.mag);                MutableBigInteger r = a.divide(b, q);                q2 = q.toBigInteger(tmp.signum * d.signum);                BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);                digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);            &#125;            StringBuilder buf = new StringBuilder(numGroups * digitsPerLong[radix] + 1);            if (this.signum &lt; 0) &#123;                buf.append(-);            &#125;            buf.append(digitGroup[numGroups - 1]);            for(int i = numGroups - 2; i &gt;= 0; --i) &#123;                int numLeadingZeros = digitsPerLong[radix] - digitGroup[i].length();                if (numLeadingZeros != 0) &#123;                    buf.append(zeros[numLeadingZeros]);                &#125;                buf.append(digitGroup[i]);            &#125;            return buf.toString();        &#125;    &#125;    private static void toString(BigInteger u, StringBuilder sb, int radix, int digits) &#123;        int i;        if (u.mag.length &gt; 20) &#123;            int b = u.bitLength();            i = (int)Math.round(Math.log((double)b * LOG_TWO  logCache[radix])  LOG_TWO - 1.0D);            BigInteger v = getRadixConversionCache(radix, i);            BigInteger[] results = u.divideAndRemainder(v);            int expectedDigits = 1 &lt;&lt; i;            toString(results[0], sb, radix, digits - expectedDigits);            toString(results[1], sb, radix, expectedDigits);        &#125; else &#123;            String s = u.smallToString(radix);            if (s.length() &lt; digits &amp;&amp; sb.length() &gt; 0) &#123;                for(i = s.length(); i &lt; digits; ++i) &#123;                    sb.append(0);                &#125;            &#125;            sb.append(s);        &#125;    &#125;    private static BigInteger getRadixConversionCache(int radix, int exponent) &#123;        BigInteger[] cacheLine = powerCache[radix];        if (exponent &lt; cacheLine.length) &#123;            return cacheLine[exponent];        &#125; else &#123;            int oldLength = cacheLine.length;            cacheLine = (BigInteger[])Arrays.copyOf(cacheLine, exponent + 1);            for(int i = oldLength; i &lt;= exponent; ++i) &#123;                cacheLine[i] = cacheLine[i - 1].pow(2);            &#125;            BigInteger[][] pc = powerCache;            if (exponent &gt;= pc[radix].length) &#123;                pc = (BigInteger[][])pc.clone();                pc[radix] = cacheLine;                powerCache = pc;            &#125;            return cacheLine[exponent];        &#125;    &#125;    public String toString() &#123;        return this.toString(10);    &#125;    public byte[] toByteArray() &#123;        int byteLen = this.bitLength()  8 + 1;        byte[] byteArray = new byte[byteLen];        int i = byteLen - 1;        int bytesCopied = 4;        int nextInt = 0;        for(int var6 = 0; i &gt;= 0; --i) &#123;            if (bytesCopied == 4) &#123;                nextInt = this.getInt(var6++);                bytesCopied = 1;            &#125; else &#123;                nextInt &gt;&gt;&gt;= 8;                ++bytesCopied;            &#125;            byteArray[i] = (byte)nextInt;        &#125;        return byteArray;    &#125;    public int intValue() &#123;        int result = false;        int result = this.getInt(0);        return result;    &#125;    public long longValue() &#123;        long result = 0L;        for(int i = 1; i &gt;= 0; --i) &#123;            result = (result &lt;&lt; 32) + ((long)this.getInt(i) &amp; 4294967295L);        &#125;        return result;    &#125;    public float floatValue() &#123;        if (this.signum == 0) &#123;            return 0.0F;        &#125; else &#123;            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;            if (exponent &lt; 63) &#123;                return (float)this.longValue();            &#125; else if (exponent &gt; 127) &#123;                return this.signum &gt; 0 ? 1.0F  0.0 : -1.0F  0.0;            &#125; else &#123;                int shift = exponent - 24;                int nBits = shift &amp; 31;                int nBits2 = 32 - nBits;                int twiceSignifFloor;                if (nBits == 0) &#123;                    twiceSignifFloor = this.mag[0];                &#125; else &#123;                    twiceSignifFloor = this.mag[0] &gt;&gt;&gt; nBits;                    if (twiceSignifFloor == 0) &#123;                        twiceSignifFloor = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;                    &#125;                &#125;                int signifFloor = twiceSignifFloor &gt;&gt; 1;                signifFloor &amp;= 8388607;                boolean increment = (twiceSignifFloor &amp; 1) != 0 &amp;&amp; ((signifFloor &amp; 1) != 0 || this.abs().getLowestSetBit() &lt; shift);                int signifRounded = increment ? signifFloor + 1 : signifFloor;                int bits = exponent + 127 &lt;&lt; 23;                bits += signifRounded;                bits |= this.signum &amp; -2147483648;                return Float.intBitsToFloat(bits);            &#125;        &#125;    &#125;    public double doubleValue() &#123;        if (this.signum == 0) &#123;            return 0.0D;        &#125; else &#123;            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;            if (exponent &lt; 63) &#123;                return (double)this.longValue();            &#125; else if (exponent &gt; 1023) &#123;                return this.signum &gt; 0 ? 1.0D  0.0 : -1.0D  0.0;            &#125; else &#123;                int shift = exponent - 53;                int nBits = shift &amp; 31;                int nBits2 = 32 - nBits;                int highBits;                int lowBits;                if (nBits == 0) &#123;                    highBits = this.mag[0];                    lowBits = this.mag[1];                &#125; else &#123;                    highBits = this.mag[0] &gt;&gt;&gt; nBits;                    lowBits = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;                    if (highBits == 0) &#123;                        highBits = lowBits;                        lowBits = this.mag[1] &lt;&lt; nBits2 | this.mag[2] &gt;&gt;&gt; nBits;                    &#125;                &#125;                long twiceSignifFloor = ((long)highBits &amp; 4294967295L) &lt;&lt; 32 | (long)lowBits &amp; 4294967295L;                long signifFloor = twiceSignifFloor &gt;&gt; 1;                signifFloor &amp;= 4503599627370495L;                boolean increment = (twiceSignifFloor &amp; 1L) != 0L &amp;&amp; ((signifFloor &amp; 1L) != 0L || this.abs().getLowestSetBit() &lt; shift);                long signifRounded = increment ? signifFloor + 1L : signifFloor;                long bits = (long)(exponent + 1023) &lt;&lt; 52;                bits += signifRounded;                bits |= (long)this.signum &amp; -9223372036854775808L;                return Double.longBitsToDouble(bits);            &#125;        &#125;    &#125;    private static int[] stripLeadingZeroInts(int[] val) &#123;        int vlen = val.length;        int keep;        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) &#123;        &#125;        return Arrays.copyOfRange(val, keep, vlen);    &#125;    private static int[] trustedStripLeadingZeroInts(int[] val) &#123;        int vlen = val.length;        int keep;        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) &#123;        &#125;        return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen);    &#125;    private static int[] stripLeadingZeroBytes(byte[] a, int off, int len) &#123;        int indexBound = off + len;        int keep;        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == 0; ++keep) &#123;        &#125;        int intLength = indexBound - keep + 3 &gt;&gt;&gt; 2;        int[] result = new int[intLength];        int b = indexBound - 1;        for(int i = intLength - 1; i &gt;= 0; --i) &#123;            result[i] = a[b--] &amp; 255;            int bytesRemaining = b - keep + 1;            int bytesToTransfer = Math.min(3, bytesRemaining);            for(int j = 8; j &lt;= bytesToTransfer &lt;&lt; 3; j += 8) &#123;                result[i] |= (a[b--] &amp; 255) &lt;&lt; j;            &#125;        &#125;        return result;    &#125;    private static int[] makePositive(byte[] a, int off, int len) &#123;        int indexBound = off + len;        int keep;        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == -1; ++keep) &#123;        &#125;        int k;        for(k = keep; k &lt; indexBound &amp;&amp; a[k] == 0; ++k) &#123;        &#125;        int extraByte = k == indexBound ? 1 : 0;        int intLength = indexBound - keep + extraByte + 3 &gt;&gt;&gt; 2;        int[] result = new int[intLength];        int b = indexBound - 1;        int i;        for(i = intLength - 1; i &gt;= 0; --i) &#123;            result[i] = a[b--] &amp; 255;            int numBytesToTransfer = Math.min(3, b - keep + 1);            if (numBytesToTransfer &lt; 0) &#123;                numBytesToTransfer = 0;            &#125;            int mask;            for(mask = 8; mask &lt;= 8 * numBytesToTransfer; mask += 8) &#123;                result[i] |= (a[b--] &amp; 255) &lt;&lt; mask;            &#125;            mask = -1 &gt;&gt;&gt; 8 * (3 - numBytesToTransfer);            result[i] = ~result[i] &amp; mask;        &#125;        for(i = result.length - 1; i &gt;= 0; --i) &#123;            result[i] = (int)(((long)result[i] &amp; 4294967295L) + 1L);            if (result[i] != 0) &#123;                break;            &#125;        &#125;        return result;    &#125;    private static int[] makePositive(int[] a) &#123;        int keep;        for(keep = 0; keep &lt; a.length &amp;&amp; a[keep] == -1; ++keep) &#123;        &#125;        int j;        for(j = keep; j &lt; a.length &amp;&amp; a[j] == 0; ++j) &#123;        &#125;        int extraInt = j == a.length ? 1 : 0;        int[] result = new int[a.length - keep + extraInt];        int i;        for(i = keep; i &lt; a.length; ++i) &#123;            result[i - keep + extraInt] = ~a[i];        &#125;        for(i = result.length - 1; ++result[i] == 0; --i) &#123;        &#125;        return result;    &#125;    private int intLength() &#123;        return (this.bitLength() &gt;&gt;&gt; 5) + 1;    &#125;    private int signBit() &#123;        return this.signum &lt; 0 ? 1 : 0;    &#125;    private int signInt() &#123;        return this.signum &lt; 0 ? -1 : 0;    &#125;    private int getInt(int n) &#123;        if (n &lt; 0) &#123;            return 0;        &#125; else if (n &gt;= this.mag.length) &#123;            return this.signInt();        &#125; else &#123;            int magInt = this.mag[this.mag.length - n - 1];            return this.signum &gt;= 0 ? magInt : (n &lt;= this.firstNonzeroIntNum() ? -magInt : ~magInt);        &#125;    &#125;    private int firstNonzeroIntNum() &#123;        int fn = this.firstNonzeroIntNumPlusTwo - 2;        if (fn == -2) &#123;            int mlen = this.mag.length;            int i;            for(i = mlen - 1; i &gt;= 0 &amp;&amp; this.mag[i] == 0; --i) &#123;            &#125;            fn = mlen - i - 1;            this.firstNonzeroIntNumPlusTwo = fn + 2;        &#125;        return fn;    &#125;    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123;        GetField fields = s.readFields();        int sign = fields.get(signum, -2);        byte[] magnitude = (byte[])fields.get(magnitude, (Object)null);        if (sign &gt;= -1 &amp;&amp; sign &lt;= 1) &#123;            int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);            if (mag.length == 0 != (sign == 0)) &#123;                String message = BigInteger: signum-magnitude mismatch;                if (fields.defaulted(magnitude)) &#123;                    message = BigInteger: Magnitude not present in stream;                &#125;                throw new StreamCorruptedException(message);            &#125; else &#123;                BigInteger.UnsafeHolder.putSign(this, sign);                BigInteger.UnsafeHolder.putMag(this, mag);                if (mag.length &gt;= 67108864) &#123;                    try &#123;                        this.checkRange();                    &#125; catch (ArithmeticException var7) &#123;                        throw new StreamCorruptedException(BigInteger: Out of the supported range);                    &#125;                &#125;            &#125;        &#125; else &#123;            String message = BigInteger: Invalid signum value;            if (fields.defaulted(signum)) &#123;                message = BigInteger: Signum not present in stream;            &#125;            throw new StreamCorruptedException(message);        &#125;    &#125;    private void writeObject(ObjectOutputStream s) throws IOException &#123;        PutField fields = s.putFields();        fields.put(signum, this.signum);        fields.put(magnitude, this.magSerializedForm());        fields.put(bitCount, -1);        fields.put(bitLength, -1);        fields.put(lowestSetBit, -2);        fields.put(firstNonzeroByteNum, -2);        s.writeFields();    &#125;    private byte[] magSerializedForm() &#123;        int len = this.mag.length;        int bitLen = len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);        int byteLen = bitLen + 7 &gt;&gt;&gt; 3;        byte[] result = new byte[byteLen];        int i = byteLen - 1;        int bytesCopied = 4;        int intIndex = len - 1;        for(int nextInt = 0; i &gt;= 0; --i) &#123;            if (bytesCopied == 4) &#123;                nextInt = this.mag[intIndex--];                bytesCopied = 1;            &#125; else &#123;                nextInt &gt;&gt;&gt;= 8;                ++bytesCopied;            &#125;            result[i] = (byte)nextInt;        &#125;        return result;    &#125;    public long longValueExact() &#123;        if (this.mag.length &lt;= 2 &amp;&amp; this.bitLength() &lt;= 63) &#123;            return this.longValue();        &#125; else &#123;            throw new ArithmeticException(BigInteger out of long range);        &#125;    &#125;    public int intValueExact() &#123;        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) &#123;            return this.intValue();        &#125; else &#123;            throw new ArithmeticException(BigInteger out of int range);        &#125;    &#125;    public short shortValueExact() &#123;        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) &#123;            int value = this.intValue();            if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) &#123;                return this.shortValue();            &#125;        &#125;        throw new ArithmeticException(BigInteger out of short range);    &#125;    public byte byteValueExact() &#123;        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) &#123;            int value = this.intValue();            if (value &gt;= -128 &amp;&amp; value &lt;= 127) &#123;                return this.byteValue();            &#125;        &#125;        throw new ArithmeticException(BigInteger out of byte range);    &#125;    static &#123;        int i;        for(i = 1; i &lt;= 16; ++i) &#123;            int[] magnitude = new int[]&#123;i&#125;;            posConst[i] = new BigInteger(magnitude, 1);            negConst[i] = new BigInteger(magnitude, -1);        &#125;        powerCache = new BigInteger[37][];        logCache = new double[37];        for(i = 2; i &lt;= 36; ++i) &#123;            powerCache[i] = new BigInteger[]&#123;valueOf((long)i)&#125;;            logCache[i] = Math.log((double)i);        &#125;        ZERO = new BigInteger(new int[0], 0);        ONE = valueOf(1L);        TWO = valueOf(2L);        NEGATIVE_ONE = valueOf(-1L);        TEN = valueOf(10L);        bnExpModThreshTable = new int[]&#123;7, 25, 81, 241, 673, 1793, 2147483647&#125;;        zeros = new String[64];        zeros[63] = 000000000000000000000000000000000000000000000000000000000000000;        for(i = 0; i &lt; 63; ++i) &#123;            zeros[i] = zeros[63].substring(0, i);        &#125;        digitsPerLong = new int[]&#123;0, 0, 62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12&#125;;        longRadix = new BigInteger[]&#123;null, null, valueOf(4611686018427387904L), valueOf(4052555153018976267L), valueOf(4611686018427387904L), valueOf(7450580596923828125L), valueOf(4738381338321616896L), valueOf(3909821048582988049L), valueOf(1152921504606846976L), valueOf(1350851717672992089L), valueOf(1000000000000000000L), valueOf(5559917313492231481L), valueOf(2218611106740436992L), valueOf(8650415919381337933L), valueOf(2177953337809371136L), valueOf(6568408355712890625L), valueOf(1152921504606846976L), valueOf(2862423051509815793L), valueOf(6746640616477458432L), valueOf(799006685782884121L), valueOf(1638400000000000000L), valueOf(3243919932521508681L), valueOf(6221821273427820544L), valueOf(504036361936467383L), valueOf(876488338465357824L), valueOf(1490116119384765625L), valueOf(2481152873203736576L), valueOf(4052555153018976267L), valueOf(6502111422497947648L), valueOf(353814783205469041L), valueOf(531441000000000000L), valueOf(787662783788549761L), valueOf(1152921504606846976L), valueOf(1667889514952984961L), valueOf(2386420683693101056L), valueOf(3379220508056640625L), valueOf(4738381338321616896L)&#125;;        digitsPerInt = new int[]&#123;0, 0, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5&#125;;        intRadix = new int[]&#123;0, 0, 1073741824, 1162261467, 1073741824, 1220703125, 362797056, 1977326743, 1073741824, 387420489, 1000000000, 214358881, 429981696, 815730721, 1475789056, 170859375, 268435456, 410338673, 612220032, 893871739, 1280000000, 1801088541, 113379904, 148035889, 191102976, 244140625, 308915776, 387420489, 481890304, 594823321, 729000000, 887503681, 1073741824, 1291467969, 1544804416, 1838265625, 60466176&#125;;        serialPersistentFields = new ObjectStreamField[]&#123;new ObjectStreamField(signum, Integer.TYPE), new ObjectStreamField(magnitude, byte[].class), new ObjectStreamField(bitCount, Integer.TYPE), new ObjectStreamField(bitLength, Integer.TYPE), new ObjectStreamField(firstNonzeroByteNum, Integer.TYPE), new ObjectStreamField(lowestSetBit, Integer.TYPE)&#125;;    &#125;    private static class UnsafeHolder &#123;        private static final Unsafe unsafe = Unsafe.getUnsafe();        private static final long signumOffset;        private static final long magOffset;        private UnsafeHolder() &#123;        &#125;        static void putSign(BigInteger bi, int sign) &#123;            unsafe.putInt(bi, signumOffset, sign);        &#125;        static void putMag(BigInteger bi, int[] magnitude) &#123;            unsafe.putObject(bi, magOffset, magnitude);        &#125;        static &#123;            signumOffset = unsafe.objectFieldOffset(BigInteger.class, signum);            magOffset = unsafe.objectFieldOffset(BigInteger.class, mag);        &#125;    &#125;&#125;\n\n","tags":["Java"],"path":"2019/09/21/BigInteger类/","external_link":""},{"title":"HashMap类","date":"2019-09-23T03:50:26.000Z","content":"HashMap类\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392* * Copyright (c) 1997, 2017, Oracle andor its affiliates. All rights reserved. * ORACLE PROPRIETARYCONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * *package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;** * Hash table based implementation of the &lt;tt&gt;Map&lt;tt&gt; interface.  This * implementation provides all of the optional map operations, and permits * &lt;tt&gt;null&lt;tt&gt; values and the &lt;tt&gt;null&lt;tt&gt; key.  (The &lt;tt&gt;HashMap&lt;tt&gt; * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;tt&gt;, except that it is * unsynchronized and permits nulls.)  This class makes no guarantees as to * the order of the map; in particular, it does not guarantee that the order * will remain constant over time. * * &lt;p&gt;This implementation provides constant-time performance for the basic * operations (&lt;tt&gt;get&lt;tt&gt; and &lt;tt&gt;put&lt;tt&gt;), assuming the hash function * disperses the elements properly among the buckets.  Iteration over * collection views requires time proportional to the capacity of the * &lt;tt&gt;HashMap&lt;tt&gt; instance (the number of buckets) plus its size (the number * of key-value mappings).  Thus, its very important not to set the initial * capacity too high (or the load factor too low) if iteration performance is * important. * * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;tt&gt; has two parameters that affect its * performance: &lt;i&gt;initial capacity&lt;i&gt; and &lt;i&gt;load factor&lt;i&gt;.  The * &lt;i&gt;capacity&lt;i&gt; is the number of buckets in the hash table, and the initial * capacity is simply the capacity at the time the hash table is created.  The * &lt;i&gt;load factor&lt;i&gt; is a measure of how full the hash table is allowed to * get before its capacity is automatically increased.  When the number of * entries in the hash table exceeds the product of the load factor and the * current capacity, the hash table is &lt;i&gt;rehashed&lt;i&gt; (that is, internal data * structures are rebuilt) so that the hash table has approximately twice the * number of buckets. * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good * tradeoff between time and space costs.  Higher values decrease the * space overhead but increase the lookup cost (reflected in most of * the operations of the &lt;tt&gt;HashMap&lt;tt&gt; class, including * &lt;tt&gt;get&lt;tt&gt; and &lt;tt&gt;put&lt;tt&gt;).  The expected number of entries in * the map and its load factor should be taken into account when * setting its initial capacity, so as to minimize the number of * rehash operations.  If the initial capacity is greater than the * maximum number of entries divided by the load factor, no rehash * operations will ever occur. * * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;tt&gt; * instance, creating it with a sufficiently large capacity will allow * the mappings to be stored more efficiently than letting it perform * automatic rehashing as needed to grow the table.  Note that using * many keys with the same &#123;@code hashCode()&#125; is a sure way to slow * down performance of any hash table. To ameliorate impact, when keys * are &#123;@link Comparable&#125;, this class may use comparison order among * keys to help break ties. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;strong&gt; * If multiple threads access a hash map concurrently, and at least one of * the threads modifies the map structurally, it &lt;i&gt;must&lt;i&gt; be * synchronized externally.  (A structural modification is any operation * that adds or deletes one or more mappings; merely changing the value * associated with a key that an instance already contains is not a * structural modification.)  This is typically accomplished by * synchronizing on some object that naturally encapsulates the map. * * If no such object exists, the map should be wrapped using the * &#123;@link Collections#synchronizedMap Collections.synchronizedMap&#125; * method.  This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;pre&gt; * * &lt;p&gt;The iterators returned by all of this classs collection view methods * are &lt;i&gt;fail-fast&lt;i&gt;: if the map is structurally modified at any time after * the iterator is created, in any way except through the iterators own * &lt;tt&gt;remove&lt;tt&gt; method, the iterator will throw a * &#123;@link ConcurrentModificationException&#125;.  Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than risking * arbitrary, non-deterministic behavior at an undetermined time in the * future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification.  Fail-fast iterators * throw &lt;tt&gt;ConcurrentModificationException&lt;tt&gt; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=&#123;@docRoot&#125;..technotesguidescollectionsindex.html&gt; * Java Collections Framework&lt;a&gt;. * * @param &lt;K&gt; the type of keys maintained by this map * @param &lt;V&gt; the type of mapped values * * @author  Doug Lea * @author  Josh Bloch * @author  Arthur van Hoff * @author  Neal Gafter * @see     Object#hashCode() * @see     Collection * @see     Map * @see     TreeMap * @see     Hashtable * @since   1.2 *public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;    private static final long serialVersionUID = 362498820763181265L;    *     * Implementation notes.     *     * This map usually acts as a binned (bucketed) hash table, but     * when bins get too large, they are transformed into bins of     * TreeNodes, each structured similarly to those in     * java.util.TreeMap. Most methods try to use normal bins, but     * relay to TreeNode methods when applicable (simply by checking     * instanceof a node).  Bins of TreeNodes may be traversed and     * used like any others, but additionally support faster lookup     * when overpopulated. However, since the vast majority of bins in     * normal use are not overpopulated, checking for existence of     * tree bins may be delayed in the course of table methods.     *     * Tree bins (i.e., bins whose elements are all TreeNodes) are     * ordered primarily by hashCode, but in the case of ties, if two     * elements are of the same class C implements Comparable&lt;C&gt;,     * type then their compareTo method is used for ordering. (We     * conservatively check generic types via reflection to validate     * this -- see method comparableClassFor).  The added complexity     * of tree bins is worthwhile in providing worst-case O(log n)     * operations when keys either have distinct hashes or are     * orderable, Thus, performance degrades gracefully under     * accidental or malicious usages in which hashCode() methods     * return values that are poorly distributed, as well as those in     * which many keys share a hashCode, so long as they are also     * Comparable. (If neither of these apply, we may waste about a     * factor of two in time and space compared to taking no     * precautions. But the only known cases stem from poor user     * programming practices that are already so slow that this makes     * little difference.)     *     * Because TreeNodes are about twice the size of regular nodes, we     * use them only when bins contain enough nodes to warrant use     * (see TREEIFY_THRESHOLD). And when they become too small (due to     * removal or resizing) they are converted back to plain bins.  In     * usages with well-distributed user hashCodes, tree bins are     * rarely used.  Ideally, under random hashCodes, the frequency of     * nodes in bins follows a Poisson distribution     * (http:en.wikipedia.orgwikiPoisson_distribution) with a     * parameter of about 0.5 on average for the default resizing     * threshold of 0.75, although with a large variance because of     * resizing granularity. Ignoring variance, the expected     * occurrences of list size k are (exp(-0.5) * pow(0.5, k)      * factorial(k)). The first values are:     *     * 0:    0.60653066     * 1:    0.30326533     * 2:    0.07581633     * 3:    0.01263606     * 4:    0.00157952     * 5:    0.00015795     * 6:    0.00001316     * 7:    0.00000094     * 8:    0.00000006     * more: less than 1 in ten million     *     * The root of a tree bin is normally its first node.  However,     * sometimes (currently only upon Iterator.remove), the root might     * be elsewhere, but can be recovered following parent links     * (method TreeNode.root()).     *     * All applicable internal methods accept a hash code as an     * argument (as normally supplied from a public method), allowing     * them to call each other without recomputing user hashCodes.     * Most internal methods also accept a tab argument, that is     * normally the current table, but may be a new or old one when     * resizing or converting.     *     * When bin lists are treeified, split, or untreeified, we keep     * them in the same relative accesstraversal order (i.e., field     * Node.next) to better preserve locality, and to slightly     * simplify handling of splits and traversals that invoke     * iterator.remove. When using comparators on insertion, to keep a     * total ordering (or as close as is required here) across     * rebalancings, we compare classes and identityHashCodes as     * tie-breakers.     *     * The use and transitions among plain vs tree modes is     * complicated by the existence of subclass LinkedHashMap. See     * below for hook methods defined to be invoked upon insertion,     * removal and access that allow LinkedHashMap internals to     * otherwise remain independent of these mechanics. (This also     * requires that a map instance be passed to some utility methods     * that may create new nodes.)     *     * The concurrent-programming-like SSA-based coding style helps     * avoid aliasing errors amid all of the twisty pointer operations.     *    **     * The default initial capacity - MUST be a power of two.     *    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;  aka 16    **     * The maximum capacity, used if a higher value is implicitly specified     * by either of the constructors with arguments.     * MUST be a power of two &lt;= 1&lt;&lt;30.     *    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    **     * The load factor used when none specified in constructor.     *    static final float DEFAULT_LOAD_FACTOR = 0.75f;    **     * The bin count threshold for using a tree rather than list for a     * bin.  Bins are converted to trees when adding an element to a     * bin with at least this many nodes. The value must be greater     * than 2 and should be at least 8 to mesh with assumptions in     * tree removal about conversion back to plain bins upon     * shrinkage.     *    static final int TREEIFY_THRESHOLD = 8;    **     * The bin count threshold for untreeifying a (split) bin during a     * resize operation. Should be less than TREEIFY_THRESHOLD, and at     * most 6 to mesh with shrinkage detection under removal.     *    static final int UNTREEIFY_THRESHOLD = 6;    **     * The smallest table capacity for which bins may be treeified.     * (Otherwise the table is resized if too many nodes in a bin.)     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts     * between resizing and treeification thresholds.     *    static final int MIN_TREEIFY_CAPACITY = 64;    **     * Basic hash bin node, used for most entries.  (See below for     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)     *    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        &#125;        public final K getKey()        &#123; return key; &#125;        public final V getValue()      &#123; return value; &#125;        public final String toString() &#123; return key + = + value; &#125;        public final int hashCode() &#123;            return Objects.hashCode(key) ^ Objects.hashCode(value);        &#125;        public final V setValue(V newValue) &#123;            V oldValue = value;            value = newValue;            return oldValue;        &#125;        public final boolean equals(Object o) &#123;            if (o == this)                return true;            if (o instanceof Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            &#125;            return false;        &#125;    &#125;    * ---------------- Static utilities -------------- *    **     * Computes key.hashCode() and spreads (XORs) higher bits of hash     * to lower.  Because the table uses power-of-two masking, sets of     * hashes that vary only in bits above the current mask will     * always collide. (Among known examples are sets of Float keys     * holding consecutive whole numbers in small tables.)  So we     * apply a transform that spreads the impact of higher bits     * downward. There is a tradeoff between speed, utility, and     * quality of bit-spreading. Because many common sets of hashes     * are already reasonably distributed (so dont benefit from     * spreading), and because we use trees to handle large sets of     * collisions in bins, we just XOR some shifted bits in the     * cheapest possible way to reduce systematic lossage, as well as     * to incorporate impact of the highest bits that would otherwise     * never be used in index calculations because of table bounds.     *    static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;    **     * Returns xs Class if it is of the form class C implements     * Comparable&lt;C&gt;, else null.     *    static Class&lt;?&gt; comparableClassFor(Object x) &#123;        if (x instanceof Comparable) &#123;            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;            if ((c = x.getClass()) == String.class)  bypass checks                return c;            if ((ts = c.getGenericInterfaces()) != null) &#123;                for (int i = 0; i &lt; ts.length; ++i) &#123;                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;                        ((p = (ParameterizedType)t).getRawType() ==                         Comparable.class) &amp;&amp;                        (as = p.getActualTypeArguments()) != null &amp;&amp;                        as.length == 1 &amp;&amp; as[0] == c)  type arg is c                        return c;                &#125;            &#125;        &#125;        return null;    &#125;    **     * Returns k.compareTo(x) if x matches kc (ks screened comparable     * class), else 0.     *    @SuppressWarnings(&#123;rawtypes,unchecked&#125;)  for cast to Comparable    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123;        return (x == null || x.getClass() != kc ? 0 :                ((Comparable)k).compareTo(x));    &#125;    **     * Returns a power of two size for the given target capacity.     *    static final int tableSizeFor(int cap) &#123;        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    &#125;    * ---------------- Fields -------------- *    **     * The table, initialized on first use, and resized as     * necessary. When allocated, length is always a power of two.     * (We also tolerate length zero in some operations to allow     * bootstrapping mechanics that are currently not needed.)     *    transient Node&lt;K,V&gt;[] table;    **     * Holds cached entrySet(). Note that AbstractMap fields are used     * for keySet() and values().     *    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    **     * The number of key-value mappings contained in this map.     *    transient int size;    **     * The number of times this HashMap has been structurally modified     * Structural modifications are those that change the number of mappings in     * the HashMap or otherwise modify its internal structure (e.g.,     * rehash).  This field is used to make iterators on Collection-views of     * the HashMap fail-fast.  (See ConcurrentModificationException).     *    transient int modCount;    **     * The next size value at which to resize (capacity * load factor).     *     * @serial     *     (The javadoc description is true upon serialization.     Additionally, if the table array has not been allocated, this     field holds the initial array capacity, or zero signifying     DEFAULT_INITIAL_CAPACITY.)    int threshold;    **     * The load factor for the hash table.     *     * @serial     *    final float loadFactor;    * ---------------- Public operations -------------- *    **     * Constructs an empty &lt;tt&gt;HashMap&lt;tt&gt; with the specified initial     * capacity and load factor.     *     * @param  initialCapacity the initial capacity     * @param  loadFactor      the load factor     * @throws IllegalArgumentException if the initial capacity is negative     *         or the load factor is nonpositive     *    public HashMap(int initialCapacity, float loadFactor) &#123;        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(Illegal initial capacity:  +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(Illegal load factor:  +                                               loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    &#125;    **     * Constructs an empty &lt;tt&gt;HashMap&lt;tt&gt; with the specified initial     * capacity and the default load factor (0.75).     *     * @param  initialCapacity the initial capacity.     * @throws IllegalArgumentException if the initial capacity is negative.     *    public HashMap(int initialCapacity) &#123;        this(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;    **     * Constructs an empty &lt;tt&gt;HashMap&lt;tt&gt; with the default initial capacity     * (16) and the default load factor (0.75).     *    public HashMap() &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR;  all other fields defaulted    &#125;    **     * Constructs a new &lt;tt&gt;HashMap&lt;tt&gt; with the same mappings as the     * specified &lt;tt&gt;Map&lt;tt&gt;.  The &lt;tt&gt;HashMap&lt;tt&gt; is created with     * default load factor (0.75) and an initial capacity sufficient to     * hold the mappings in the specified &lt;tt&gt;Map&lt;tt&gt;.     *     * @param   m the map whose mappings are to be placed in this map     * @throws  NullPointerException if the specified map is null     *    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    &#125;    **     * Implements Map.putAll and Map constructor     *     * @param m the map     * @param evict false when initially constructing this map, else     * true (relayed to method afterNodeInsertion).     *    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;        int s = m.size();        if (s &gt; 0) &#123;            if (table == null) &#123;  pre-size                float ft = ((float)s  loadFactor) + 1.0F;                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                if (t &gt; threshold)                    threshold = tableSizeFor(t);            &#125;            else if (s &gt; threshold)                resize();            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            &#125;        &#125;    &#125;    **     * Returns the number of key-value mappings in this map.     *     * @return the number of key-value mappings in this map     *    public int size() &#123;        return size;    &#125;    **     * Returns &lt;tt&gt;true&lt;tt&gt; if this map contains no key-value mappings.     *     * @return &lt;tt&gt;true&lt;tt&gt; if this map contains no key-value mappings     *    public boolean isEmpty() &#123;        return size == 0;    &#125;    **     * Returns the value to which the specified key is mapped,     * or &#123;@code null&#125; if this map contains no mapping for the key.     *     * &lt;p&gt;More formally, if this map contains a mapping from a key     * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null :     * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise     * it returns &#123;@code null&#125;.  (There can be at most one such mapping.)     *     * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;i&gt;     * indicate that the map contains no mapping for the key; its also     * possible that the map explicitly maps the key to &#123;@code null&#125;.     * The &#123;@link #containsKey containsKey&#125; operation may be used to     * distinguish these two cases.     *     * @see #put(Object, Object)     *    public V get(Object key) &#123;        Node&lt;K,V&gt; e;        return (e = getNode(hash(key), key)) == null ? null : e.value;    &#125;    **     * Implements Map.get and related methods     *     * @param hash hash for key     * @param key the key     * @return the node, or null if none     *    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (first = tab[(n - 1) &amp; hash]) != null) &#123;            if (first.hash == hash &amp;&amp;  always check first node                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))                return first;            if ((e = first.next) != null) &#123;                if (first instanceof TreeNode)                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        return e;                &#125; while ((e = e.next) != null);            &#125;        &#125;        return null;    &#125;    **     * Returns &lt;tt&gt;true&lt;tt&gt; if this map contains a mapping for the     * specified key.     *     * @param   key   The key whose presence in this map is to be tested     * @return &lt;tt&gt;true&lt;tt&gt; if this map contains a mapping for the specified     * key.     *    public boolean containsKey(Object key) &#123;        return getNode(hash(key), key) != null;    &#125;    **     * Associates the specified value with the specified key in this map.     * If the map previously contained a mapping for the key, the old     * value is replaced.     *     * @param key key with which the specified value is to be associated     * @param value value to be associated with the specified key     * @return the previous value associated with &lt;tt&gt;key&lt;tt&gt;, or     *         &lt;tt&gt;null&lt;tt&gt; if there was no mapping for &lt;tt&gt;key&lt;tt&gt;.     *         (A &lt;tt&gt;null&lt;tt&gt; return can also indicate that the map     *         previously associated &lt;tt&gt;null&lt;tt&gt; with &lt;tt&gt;key&lt;tt&gt;.)     *    public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;    **     * Implements Map.put and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, dont change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     *    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123;  existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;    **     * Initializes or doubles table size.  If null, allocates in     * accord with initial capacity target held in field threshold.     * Otherwise, because we are using power-of-two expansion, the     * elements from each bin must either stay at same index, or move     * with a power of two offset in the new table.     *     * @return the table     *    final Node&lt;K,V&gt;[] resize() &#123;        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) &#123;            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                return oldTab;            &#125;            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1;  double threshold        &#125;        else if (oldThr &gt; 0)  initial capacity was placed in threshold            newCap = oldThr;        else &#123;                zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        if (newThr == 0) &#123;            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        @SuppressWarnings(&#123;rawtypes,unchecked&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) &#123;            for (int j = 0; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) &#123;                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else &#123;  preserve order                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do &#123;                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) &#123;                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            &#125;                            else &#123;                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; while ((e = next) != null);                        if (loTail != null) &#123;                            loTail.next = null;                            newTab[j] = loHead;                        &#125;                        if (hiTail != null) &#123;                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return newTab;    &#125;    **     * Replaces all linked nodes in bin at index for given hash unless     * table is too small, in which case resizes instead.     *    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;        int n, index; Node&lt;K,V&gt; e;        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            resize();        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;            TreeNode&lt;K,V&gt; hd = null, tl = null;            do &#123;                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);                if (tl == null)                    hd = p;                else &#123;                    p.prev = tl;                    tl.next = p;                &#125;                tl = p;            &#125; while ((e = e.next) != null);            if ((tab[index] = hd) != null)                hd.treeify(tab);        &#125;    &#125;    **     * Copies all of the mappings from the specified map to this map.     * These mappings will replace any mappings that this map had for     * any of the keys currently in the specified map.     *     * @param m mappings to be stored in this map     * @throws NullPointerException if the specified map is null     *    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;        putMapEntries(m, true);    &#125;    **     * Removes the mapping for the specified key from this map if present.     *     * @param  key key whose mapping is to be removed from the map     * @return the previous value associated with &lt;tt&gt;key&lt;tt&gt;, or     *         &lt;tt&gt;null&lt;tt&gt; if there was no mapping for &lt;tt&gt;key&lt;tt&gt;.     *         (A &lt;tt&gt;null&lt;tt&gt; return can also indicate that the map     *         previously associated &lt;tt&gt;null&lt;tt&gt; with &lt;tt&gt;key&lt;tt&gt;.)     *    public V remove(Object key) &#123;        Node&lt;K,V&gt; e;        return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;    &#125;    **     * Implements Map.remove and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to match if matchValue, else ignored     * @param matchValue if true only remove if value is equal     * @param movable if false do not move other nodes while removing     * @return the node, or null if none     *    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                               boolean matchValue, boolean movable) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (p = tab[index = (n - 1) &amp; hash]) != null) &#123;            Node&lt;K,V&gt; node = null, e; K k; V v;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                node = p;            else if ((e = p.next) != null) &#123;                if (p instanceof TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                else &#123;                    do &#123;                        if (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != null &amp;&amp; key.equals(k)))) &#123;                            node = e;                            break;                        &#125;                        p = e;                    &#125; while ((e = e.next) != null);                &#125;            &#125;            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != null &amp;&amp; value.equals(v)))) &#123;                if (node instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);                else if (node == p)                    tab[index] = node.next;                else                    p.next = node.next;                ++modCount;                --size;                afterNodeRemoval(node);                return node;            &#125;        &#125;        return null;    &#125;    **     * Removes all of the mappings from this map.     * The map will be empty after this call returns.     *    public void clear() &#123;        Node&lt;K,V&gt;[] tab;        modCount++;        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;            size = 0;            for (int i = 0; i &lt; tab.length; ++i)                tab[i] = null;        &#125;    &#125;    **     * Returns &lt;tt&gt;true&lt;tt&gt; if this map maps one or more keys to the     * specified value.     *     * @param value value whose presence in this map is to be tested     * @return &lt;tt&gt;true&lt;tt&gt; if this map maps one or more keys to the     *         specified value     *    public boolean containsValue(Object value) &#123;        Node&lt;K,V&gt;[] tab; V v;        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;            for (int i = 0; i &lt; tab.length; ++i) &#123;                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;                    if ((v = e.value) == value ||                        (value != null &amp;&amp; value.equals(v)))                        return true;                &#125;            &#125;        &#125;        return false;    &#125;    **     * Returns a &#123;@link Set&#125; view of the keys contained in this map.     * The set is backed by the map, so changes to the map are     * reflected in the set, and vice-versa.  If the map is modified     * while an iteration over the set is in progress (except through     * the iterators own &lt;tt&gt;remove&lt;tt&gt; operation), the results of     * the iteration are undefined.  The set supports element removal,     * which removes the corresponding mapping from the map, via the     * &lt;tt&gt;Iterator.remove&lt;tt&gt;, &lt;tt&gt;Set.remove&lt;tt&gt;,     * &lt;tt&gt;removeAll&lt;tt&gt;, &lt;tt&gt;retainAll&lt;tt&gt;, and &lt;tt&gt;clear&lt;tt&gt;     * operations.  It does not support the &lt;tt&gt;add&lt;tt&gt; or &lt;tt&gt;addAll&lt;tt&gt;     * operations.     *     * @return a set view of the keys contained in this map     *    public Set&lt;K&gt; keySet() &#123;        Set&lt;K&gt; ks = keySet;        if (ks == null) &#123;            ks = new KeySet();            keySet = ks;        &#125;        return ks;    &#125;    final class KeySet extends AbstractSet&lt;K&gt; &#123;        public final int size()                 &#123; return size; &#125;        public final void clear()               &#123; HashMap.this.clear(); &#125;        public final Iterator&lt;K&gt; iterator()     &#123; return new KeyIterator(); &#125;        public final boolean contains(Object o) &#123; return containsKey(o); &#125;        public final boolean remove(Object key) &#123;            return removeNode(hash(key), key, null, false, true) != null;        &#125;        public final Spliterator&lt;K&gt; spliterator() &#123;            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);        &#125;        public final void forEach(Consumer&lt;? super K&gt; action) &#123;            Node&lt;K,V&gt;[] tab;            if (action == null)                throw new NullPointerException();            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;                int mc = modCount;                for (int i = 0; i &lt; tab.length; ++i) &#123;                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)                        action.accept(e.key);                &#125;                if (modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;    &#125;    **     * Returns a &#123;@link Collection&#125; view of the values contained in this map.     * The collection is backed by the map, so changes to the map are     * reflected in the collection, and vice-versa.  If the map is     * modified while an iteration over the collection is in progress     * (except through the iterators own &lt;tt&gt;remove&lt;tt&gt; operation),     * the results of the iteration are undefined.  The collection     * supports element removal, which removes the corresponding     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;tt&gt;,     * &lt;tt&gt;Collection.remove&lt;tt&gt;, &lt;tt&gt;removeAll&lt;tt&gt;,     * &lt;tt&gt;retainAll&lt;tt&gt; and &lt;tt&gt;clear&lt;tt&gt; operations.  It does not     * support the &lt;tt&gt;add&lt;tt&gt; or &lt;tt&gt;addAll&lt;tt&gt; operations.     *     * @return a view of the values contained in this map     *    public Collection&lt;V&gt; values() &#123;        Collection&lt;V&gt; vs = values;        if (vs == null) &#123;            vs = new Values();            values = vs;        &#125;        return vs;    &#125;    final class Values extends AbstractCollection&lt;V&gt; &#123;        public final int size()                 &#123; return size; &#125;        public final void clear()               &#123; HashMap.this.clear(); &#125;        public final Iterator&lt;V&gt; iterator()     &#123; return new ValueIterator(); &#125;        public final boolean contains(Object o) &#123; return containsValue(o); &#125;        public final Spliterator&lt;V&gt; spliterator() &#123;            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);        &#125;        public final void forEach(Consumer&lt;? super V&gt; action) &#123;            Node&lt;K,V&gt;[] tab;            if (action == null)                throw new NullPointerException();            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;                int mc = modCount;                for (int i = 0; i &lt; tab.length; ++i) &#123;                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)                        action.accept(e.value);                &#125;                if (modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;    &#125;    **     * Returns a &#123;@link Set&#125; view of the mappings contained in this map.     * The set is backed by the map, so changes to the map are     * reflected in the set, and vice-versa.  If the map is modified     * while an iteration over the set is in progress (except through     * the iterators own &lt;tt&gt;remove&lt;tt&gt; operation, or through the     * &lt;tt&gt;setValue&lt;tt&gt; operation on a map entry returned by the     * iterator) the results of the iteration are undefined.  The set     * supports element removal, which removes the corresponding     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;tt&gt;,     * &lt;tt&gt;Set.remove&lt;tt&gt;, &lt;tt&gt;removeAll&lt;tt&gt;, &lt;tt&gt;retainAll&lt;tt&gt; and     * &lt;tt&gt;clear&lt;tt&gt; operations.  It does not support the     * &lt;tt&gt;add&lt;tt&gt; or &lt;tt&gt;addAll&lt;tt&gt; operations.     *     * @return a set view of the mappings contained in this map     *    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;    &#125;    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;        public final int size()                 &#123; return size; &#125;        public final void clear()               &#123; HashMap.this.clear(); &#125;        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;            return new EntryIterator();        &#125;        public final boolean contains(Object o) &#123;            if (!(o instanceof Map.Entry))                return false;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;            Object key = e.getKey();            Node&lt;K,V&gt; candidate = getNode(hash(key), key);            return candidate != null &amp;&amp; candidate.equals(e);        &#125;        public final boolean remove(Object o) &#123;            if (o instanceof Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;                Object key = e.getKey();                Object value = e.getValue();                return removeNode(hash(key), key, value, true, true) != null;            &#125;            return false;        &#125;        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);        &#125;        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;            Node&lt;K,V&gt;[] tab;            if (action == null)                throw new NullPointerException();            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;                int mc = modCount;                for (int i = 0; i &lt; tab.length; ++i) &#123;                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)                        action.accept(e);                &#125;                if (modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;    &#125;     Overrides of JDK8 Map extension methods    @Override    public V getOrDefault(Object key, V defaultValue) &#123;        Node&lt;K,V&gt; e;        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;    &#125;    @Override    public V putIfAbsent(K key, V value) &#123;        return putVal(hash(key), key, value, true, true);    &#125;    @Override    public boolean remove(Object key, Object value) &#123;        return removeNode(hash(key), key, value, true, true) != null;    &#125;    @Override    public boolean replace(K key, V oldValue, V newValue) &#123;        Node&lt;K,V&gt; e; V v;        if ((e = getNode(hash(key), key)) != null &amp;&amp;            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123;            e.value = newValue;            afterNodeAccess(e);            return true;        &#125;        return false;    &#125;    @Override    public V replace(K key, V value) &#123;        Node&lt;K,V&gt; e;        if ((e = getNode(hash(key), key)) != null) &#123;            V oldValue = e.value;            e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;        return null;    &#125;    @Override    public V computeIfAbsent(K key,                             Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;        if (mappingFunction == null)            throw new NullPointerException();        int hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;        int binCount = 0;        TreeNode&lt;K,V&gt; t = null;        Node&lt;K,V&gt; old = null;        if (size &gt; threshold || (tab = table) == null ||            (n = tab.length) == 0)            n = (tab = resize()).length;        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;            if (first instanceof TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            else &#123;                Node&lt;K,V&gt; e = first; K k;                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;                        old = e;                        break;                    &#125;                    ++binCount;                &#125; while ((e = e.next) != null);            &#125;            V oldValue;            if (old != null &amp;&amp; (oldValue = old.value) != null) &#123;                afterNodeAccess(old);                return oldValue;            &#125;        &#125;        V v = mappingFunction.apply(key);        if (v == null) &#123;            return null;        &#125; else if (old != null) &#123;            old.value = v;            afterNodeAccess(old);            return v;        &#125;        else if (t != null)            t.putTreeVal(this, tab, hash, key, v);        else &#123;            tab[i] = newNode(hash, key, v, first);            if (binCount &gt;= TREEIFY_THRESHOLD - 1)                treeifyBin(tab, hash);        &#125;        ++modCount;        ++size;        afterNodeInsertion(true);        return v;    &#125;    public V computeIfPresent(K key,                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;        if (remappingFunction == null)            throw new NullPointerException();        Node&lt;K,V&gt; e; V oldValue;        int hash = hash(key);        if ((e = getNode(hash, key)) != null &amp;&amp;            (oldValue = e.value) != null) &#123;            V v = remappingFunction.apply(key, oldValue);            if (v != null) &#123;                e.value = v;                afterNodeAccess(e);                return v;            &#125;            else                removeNode(hash, key, null, false, true);        &#125;        return null;    &#125;    @Override    public V compute(K key,                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;        if (remappingFunction == null)            throw new NullPointerException();        int hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;        int binCount = 0;        TreeNode&lt;K,V&gt; t = null;        Node&lt;K,V&gt; old = null;        if (size &gt; threshold || (tab = table) == null ||            (n = tab.length) == 0)            n = (tab = resize()).length;        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;            if (first instanceof TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            else &#123;                Node&lt;K,V&gt; e = first; K k;                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;                        old = e;                        break;                    &#125;                    ++binCount;                &#125; while ((e = e.next) != null);            &#125;        &#125;        V oldValue = (old == null) ? null : old.value;        V v = remappingFunction.apply(key, oldValue);        if (old != null) &#123;            if (v != null) &#123;                old.value = v;                afterNodeAccess(old);            &#125;            else                removeNode(hash, key, null, false, true);        &#125;        else if (v != null) &#123;            if (t != null)                t.putTreeVal(this, tab, hash, key, v);            else &#123;                tab[i] = newNode(hash, key, v, first);                if (binCount &gt;= TREEIFY_THRESHOLD - 1)                    treeifyBin(tab, hash);            &#125;            ++modCount;            ++size;            afterNodeInsertion(true);        &#125;        return v;    &#125;    @Override    public V merge(K key, V value,                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123;        if (value == null)            throw new NullPointerException();        if (remappingFunction == null)            throw new NullPointerException();        int hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;        int binCount = 0;        TreeNode&lt;K,V&gt; t = null;        Node&lt;K,V&gt; old = null;        if (size &gt; threshold || (tab = table) == null ||            (n = tab.length) == 0)            n = (tab = resize()).length;        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;            if (first instanceof TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            else &#123;                Node&lt;K,V&gt; e = first; K k;                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;                        old = e;                        break;                    &#125;                    ++binCount;                &#125; while ((e = e.next) != null);            &#125;        &#125;        if (old != null) &#123;            V v;            if (old.value != null)                v = remappingFunction.apply(old.value, value);            else                v = value;            if (v != null) &#123;                old.value = v;                afterNodeAccess(old);            &#125;            else                removeNode(hash, key, null, false, true);            return v;        &#125;        if (value != null) &#123;            if (t != null)                t.putTreeVal(this, tab, hash, key, value);            else &#123;                tab[i] = newNode(hash, key, value, first);                if (binCount &gt;= TREEIFY_THRESHOLD - 1)                    treeifyBin(tab, hash);            &#125;            ++modCount;            ++size;            afterNodeInsertion(true);        &#125;        return value;    &#125;    @Override    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123;        Node&lt;K,V&gt;[] tab;        if (action == null)            throw new NullPointerException();        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;            int mc = modCount;            for (int i = 0; i &lt; tab.length; ++i) &#123;                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)                    action.accept(e.key, e.value);            &#125;            if (modCount != mc)                throw new ConcurrentModificationException();        &#125;    &#125;    @Override    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123;        Node&lt;K,V&gt;[] tab;        if (function == null)            throw new NullPointerException();        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;            int mc = modCount;            for (int i = 0; i &lt; tab.length; ++i) &#123;                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;                    e.value = function.apply(e.key, e.value);                &#125;            &#125;            if (modCount != mc)                throw new ConcurrentModificationException();        &#125;    &#125;    * ------------------------------------------------------------ *     Cloning and serialization    **     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;tt&gt; instance: the keys and     * values themselves are not cloned.     *     * @return a shallow copy of this map     *    @SuppressWarnings(unchecked)    @Override    public Object clone() &#123;        HashMap&lt;K,V&gt; result;        try &#123;            result = (HashMap&lt;K,V&gt;)super.clone();        &#125; catch (CloneNotSupportedException e) &#123;             this shouldnt happen, since we are Cloneable            throw new InternalError(e);        &#125;        result.reinitialize();        result.putMapEntries(this, false);        return result;    &#125;     These methods are also used when serializing HashSets    final float loadFactor() &#123; return loadFactor; &#125;    final int capacity() &#123;        return (table != null) ? table.length :            (threshold &gt; 0) ? threshold :            DEFAULT_INITIAL_CAPACITY;    &#125;    **     * Save the state of the &lt;tt&gt;HashMap&lt;tt&gt; instance to a stream (i.e.,     * serialize it).     *     * @serialData The &lt;i&gt;capacity&lt;i&gt; of the HashMap (the length of the     *             bucket array) is emitted (int), followed by the     *             &lt;i&gt;size&lt;i&gt; (an int, the number of key-value     *             mappings), followed by the key (Object) and value (Object)     *             for each key-value mapping.  The key-value mappings are     *             emitted in no particular order.     *    private void writeObject(java.io.ObjectOutputStream s)        throws IOException &#123;        int buckets = capacity();         Write out the threshold, loadfactor, and any hidden stuff        s.defaultWriteObject();        s.writeInt(buckets);        s.writeInt(size);        internalWriteEntries(s);    &#125;    **     * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e.,     * deserialize it).     *    private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException &#123;         Read in the threshold (ignored), loadfactor, and any hidden stuff        s.defaultReadObject();        reinitialize();        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new InvalidObjectException(Illegal load factor:  +                                             loadFactor);        s.readInt();                 Read and ignore number of buckets        int mappings = s.readInt();  Read number of mappings (size)        if (mappings &lt; 0)            throw new InvalidObjectException(Illegal mappings count:  +                                             mappings);        else if (mappings &gt; 0) &#123;  (if zero, use defaults)             Size the table using given load factor only if within             range of 0.25...4.0            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);            float fc = (float)mappings  lf + 1.0f;            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                       DEFAULT_INITIAL_CAPACITY :                       (fc &gt;= MAXIMUM_CAPACITY) ?                       MAXIMUM_CAPACITY :                       tableSizeFor((int)fc));            float ft = (float)cap * lf;            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                         (int)ft : Integer.MAX_VALUE);             Check Map.Entry[].class since its the nearest public type to             what were actually creating.            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);            @SuppressWarnings(&#123;rawtypes,unchecked&#125;)            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];            table = tab;             Read the keys and values, and put the mappings in the HashMap            for (int i = 0; i &lt; mappings; i++) &#123;                @SuppressWarnings(unchecked)                    K key = (K) s.readObject();                @SuppressWarnings(unchecked)                    V value = (V) s.readObject();                putVal(hash(key), key, value, false, false);            &#125;        &#125;    &#125;    * ------------------------------------------------------------ *     iterators    abstract class HashIterator &#123;        Node&lt;K,V&gt; next;         next entry to return        Node&lt;K,V&gt; current;      current entry        int expectedModCount;   for fast-fail        int index;              current slot        HashIterator() &#123;            expectedModCount = modCount;            Node&lt;K,V&gt;[] t = table;            current = next = null;            index = 0;            if (t != null &amp;&amp; size &gt; 0) &#123;  advance to first entry                do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            &#125;        &#125;        public final boolean hasNext() &#123;            return next != null;        &#125;        final Node&lt;K,V&gt; nextNode() &#123;            Node&lt;K,V&gt;[] t;            Node&lt;K,V&gt; e = next;            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            if (e == null)                throw new NoSuchElementException();            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;                do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            &#125;            return e;        &#125;        public final void remove() &#123;            Node&lt;K,V&gt; p = current;            if (p == null)                throw new IllegalStateException();            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            current = null;            K key = p.key;            removeNode(hash(key), key, null, false, false);            expectedModCount = modCount;        &#125;    &#125;    final class KeyIterator extends HashIterator        implements Iterator&lt;K&gt; &#123;        public final K next() &#123; return nextNode().key; &#125;    &#125;    final class ValueIterator extends HashIterator        implements Iterator&lt;V&gt; &#123;        public final V next() &#123; return nextNode().value; &#125;    &#125;    final class EntryIterator extends HashIterator        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;        public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;    &#125;    * ------------------------------------------------------------ *     spliterators    static class HashMapSpliterator&lt;K,V&gt; &#123;        final HashMap&lt;K,V&gt; map;        Node&lt;K,V&gt; current;           current node        int index;                   current index, modified on advancesplit        int fence;                   one past last index        int est;                     size estimate        int expectedModCount;        for comodification checks        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,                           int fence, int est,                           int expectedModCount) &#123;            this.map = m;            this.index = origin;            this.fence = fence;            this.est = est;            this.expectedModCount = expectedModCount;        &#125;        final int getFence() &#123;  initialize fence and size on first use            int hi;            if ((hi = fence) &lt; 0) &#123;                HashMap&lt;K,V&gt; m = map;                est = m.size;                expectedModCount = m.modCount;                Node&lt;K,V&gt;[] tab = m.table;                hi = fence = (tab == null) ? 0 : tab.length;            &#125;            return hi;        &#125;        public final long estimateSize() &#123;            getFence();  force init            return (long) est;        &#125;    &#125;    static final class KeySpliterator&lt;K,V&gt;        extends HashMapSpliterator&lt;K,V&gt;        implements Spliterator&lt;K&gt; &#123;        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,                       int expectedModCount) &#123;            super(m, origin, fence, est, expectedModCount);        &#125;        public KeySpliterator&lt;K,V&gt; trySplit() &#123;            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;            return (lo &gt;= mid || current != null) ? null :                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,                                        expectedModCount);        &#125;        public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123;            int i, hi, mc;            if (action == null)                throw new NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            if ((hi = fence) &lt; 0) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == null) ? 0 : tab.length;            &#125;            else                mc = expectedModCount;            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;                Node&lt;K,V&gt; p = current;                current = null;                do &#123;                    if (p == null)                        p = tab[i++];                    else &#123;                        action.accept(p.key);                        p = p.next;                    &#125;                &#125; while (p != null || i &lt; hi);                if (m.modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;        public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123;            int hi;            if (action == null)                throw new NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;                while (current != null || index &lt; hi) &#123;                    if (current == null)                        current = tab[index++];                    else &#123;                        K k = current.key;                        current = current.next;                        action.accept(k);                        if (map.modCount != expectedModCount)                            throw new ConcurrentModificationException();                        return true;                    &#125;                &#125;            &#125;            return false;        &#125;        public int characteristics() &#123;            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |                Spliterator.DISTINCT;        &#125;    &#125;    static final class ValueSpliterator&lt;K,V&gt;        extends HashMapSpliterator&lt;K,V&gt;        implements Spliterator&lt;V&gt; &#123;        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,                         int expectedModCount) &#123;            super(m, origin, fence, est, expectedModCount);        &#125;        public ValueSpliterator&lt;K,V&gt; trySplit() &#123;            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;            return (lo &gt;= mid || current != null) ? null :                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,                                          expectedModCount);        &#125;        public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123;            int i, hi, mc;            if (action == null)                throw new NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            if ((hi = fence) &lt; 0) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == null) ? 0 : tab.length;            &#125;            else                mc = expectedModCount;            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;                Node&lt;K,V&gt; p = current;                current = null;                do &#123;                    if (p == null)                        p = tab[i++];                    else &#123;                        action.accept(p.value);                        p = p.next;                    &#125;                &#125; while (p != null || i &lt; hi);                if (m.modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;        public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123;            int hi;            if (action == null)                throw new NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;                while (current != null || index &lt; hi) &#123;                    if (current == null)                        current = tab[index++];                    else &#123;                        V v = current.value;                        current = current.next;                        action.accept(v);                        if (map.modCount != expectedModCount)                            throw new ConcurrentModificationException();                        return true;                    &#125;                &#125;            &#125;            return false;        &#125;        public int characteristics() &#123;            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);        &#125;    &#125;    static final class EntrySpliterator&lt;K,V&gt;        extends HashMapSpliterator&lt;K,V&gt;        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,                         int expectedModCount) &#123;            super(m, origin, fence, est, expectedModCount);        &#125;        public EntrySpliterator&lt;K,V&gt; trySplit() &#123;            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;            return (lo &gt;= mid || current != null) ? null :                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,                                          expectedModCount);        &#125;        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;            int i, hi, mc;            if (action == null)                throw new NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            if ((hi = fence) &lt; 0) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == null) ? 0 : tab.length;            &#125;            else                mc = expectedModCount;            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;                Node&lt;K,V&gt; p = current;                current = null;                do &#123;                    if (p == null)                        p = tab[i++];                    else &#123;                        action.accept(p);                        p = p.next;                    &#125;                &#125; while (p != null || i &lt; hi);                if (m.modCount != mc)                    throw new ConcurrentModificationException();            &#125;        &#125;        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;            int hi;            if (action == null)                throw new NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;                while (current != null || index &lt; hi) &#123;                    if (current == null)                        current = tab[index++];                    else &#123;                        Node&lt;K,V&gt; e = current;                        current = current.next;                        action.accept(e);                        if (map.modCount != expectedModCount)                            throw new ConcurrentModificationException();                        return true;                    &#125;                &#125;            &#125;            return false;        &#125;        public int characteristics() &#123;            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |                Spliterator.DISTINCT;        &#125;    &#125;    * ------------------------------------------------------------ *     LinkedHashMap support    *     * The following package-protected methods are designed to be     * overridden by LinkedHashMap, but not by any other subclass.     * Nearly all other internal methods are also package-protected     * but are declared final, so can be used by LinkedHashMap, view     * classes, and HashSet.     *     Create a regular (non-tree) node    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        return new Node&lt;&gt;(hash, key, value, next);    &#125;     For conversion from TreeNodes to plain nodes    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;        return new Node&lt;&gt;(p.hash, p.key, p.value, next);    &#125;     Create a tree bin node    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        return new TreeNode&lt;&gt;(hash, key, value, next);    &#125;     For treeifyBin    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);    &#125;    **     * Reset to initial default state.  Called by clone and readObject.     *    void reinitialize() &#123;        table = null;        entrySet = null;        keySet = null;        values = null;        modCount = 0;        threshold = 0;        size = 0;    &#125;     Callbacks to allow LinkedHashMap post-actions    void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;    void afterNodeInsertion(boolean evict) &#123; &#125;    void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;     Called only from writeObject, to ensure compatible ordering.    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;        Node&lt;K,V&gt;[] tab;        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;            for (int i = 0; i &lt; tab.length; ++i) &#123;                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;                    s.writeObject(e.key);                    s.writeObject(e.value);                &#125;            &#125;        &#125;    &#125;    * ------------------------------------------------------------ *     Tree bins    **     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn     * extends Node) so can be used as extension of either regular or     * linked node.     *    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;        TreeNode&lt;K,V&gt; parent;   red-black tree links        TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;     needed to unlink next upon deletion        boolean red;        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;            super(hash, key, val, next);        &#125;        **         * Returns root of tree containing this node.         *        final TreeNode&lt;K,V&gt; root() &#123;            for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;                if ((p = r.parent) == null)                    return r;                r = p;            &#125;        &#125;        **         * Ensures that the given root is the first node of its bin.         *        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;            int n;            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123;                int index = (n - 1) &amp; root.hash;                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];                if (root != first) &#123;                    Node&lt;K,V&gt; rn;                    tab[index] = root;                    TreeNode&lt;K,V&gt; rp = root.prev;                    if ((rn = root.next) != null)                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;                    if (rp != null)                        rp.next = rn;                    if (first != null)                        first.prev = root;                    root.next = first;                    root.prev = null;                &#125;                assert checkInvariants(root);            &#125;        &#125;        **         * Finds the node starting at root p with the given hash and key.         * The kc argument caches comparableClassFor(key) upon first use         * comparing keys.         *        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;            TreeNode&lt;K,V&gt; p = this;            do &#123;                int ph, dir; K pk;                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;                if ((ph = p.hash) &gt; h)                    p = pl;                else if (ph &lt; h)                    p = pr;                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))                    return p;                else if (pl == null)                    p = pr;                else if (pr == null)                    p = pl;                else if ((kc != null ||                          (kc = comparableClassFor(k)) != null) &amp;&amp;                         (dir = compareComparables(kc, k, pk)) != 0)                    p = (dir &lt; 0) ? pl : pr;                else if ((q = pr.find(h, k, kc)) != null)                    return q;                else                    p = pl;            &#125; while (p != null);            return null;        &#125;        **         * Calls find for root node.         *        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;            return ((parent != null) ? root() : this).find(h, k, null);        &#125;        **         * Tie-breaking utility for ordering insertions when equal         * hashCodes and non-comparable. We dont require a total         * order, just a consistent insertion rule to maintain         * equivalence across rebalancings. Tie-breaking further than         * necessary simplifies testing a bit.         *        static int tieBreakOrder(Object a, Object b) &#123;            int d;            if (a == null || b == null ||                (d = a.getClass().getName().                 compareTo(b.getClass().getName())) == 0)                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?                     -1 : 1);            return d;        &#125;        **         * Forms tree of the nodes linked from this node.         * @return root of tree         *        final void treeify(Node&lt;K,V&gt;[] tab) &#123;            TreeNode&lt;K,V&gt; root = null;            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;                next = (TreeNode&lt;K,V&gt;)x.next;                x.left = x.right = null;                if (root == null) &#123;                    x.parent = null;                    x.red = false;                    root = x;                &#125;                else &#123;                    K k = x.key;                    int h = x.hash;                    Class&lt;?&gt; kc = null;                    for (TreeNode&lt;K,V&gt; p = root;;) &#123;                        int dir, ph;                        K pk = p.key;                        if ((ph = p.hash) &gt; h)                            dir = -1;                        else if (ph &lt; h)                            dir = 1;                        else if ((kc == null &amp;&amp;                                  (kc = comparableClassFor(k)) == null) ||                                 (dir = compareComparables(kc, k, pk)) == 0)                            dir = tieBreakOrder(k, pk);                        TreeNode&lt;K,V&gt; xp = p;                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;                            x.parent = xp;                            if (dir &lt;= 0)                                xp.left = x;                            else                                xp.right = x;                            root = balanceInsertion(root, x);                            break;                        &#125;                    &#125;                &#125;            &#125;            moveRootToFront(tab, root);        &#125;        **         * Returns a list of non-TreeNodes replacing those linked from         * this node.         *        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;            Node&lt;K,V&gt; hd = null, tl = null;            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123;                Node&lt;K,V&gt; p = map.replacementNode(q, null);                if (tl == null)                    hd = p;                else                    tl.next = p;                tl = p;            &#125;            return hd;        &#125;        **         * Tree version of putVal.         *        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                                       int h, K k, V v) &#123;            Class&lt;?&gt; kc = null;            boolean searched = false;            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;            for (TreeNode&lt;K,V&gt; p = root;;) &#123;                int dir, ph; K pk;                if ((ph = p.hash) &gt; h)                    dir = -1;                else if (ph &lt; h)                    dir = 1;                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))                    return p;                else if ((kc == null &amp;&amp;                          (kc = comparableClassFor(k)) == null) ||                         (dir = compareComparables(kc, k, pk)) == 0) &#123;                    if (!searched) &#123;                        TreeNode&lt;K,V&gt; q, ch;                        searched = true;                        if (((ch = p.left) != null &amp;&amp;                             (q = ch.find(h, k, kc)) != null) ||                            ((ch = p.right) != null &amp;&amp;                             (q = ch.find(h, k, kc)) != null))                            return q;                    &#125;                    dir = tieBreakOrder(k, pk);                &#125;                TreeNode&lt;K,V&gt; xp = p;                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;                    Node&lt;K,V&gt; xpn = xp.next;                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);                    if (dir &lt;= 0)                        xp.left = x;                    else                        xp.right = x;                    xp.next = x;                    x.parent = x.prev = xp;                    if (xpn != null)                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;                    moveRootToFront(tab, balanceInsertion(root, x));                    return null;                &#125;            &#125;        &#125;        **         * Removes the given node, that must be present before this call.         * This is messier than typical red-black deletion code because we         * cannot swap the contents of an interior node with a leaf         * successor that is pinned by next pointers that are accessible         * independently during traversal. So instead we swap the tree         * linkages. If the current tree appears to have too few nodes,         * the bin is converted back to a plain bin. (The test triggers         * somewhere between 2 and 6 nodes, depending on tree structure).         *        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                                  boolean movable) &#123;            int n;            if (tab == null || (n = tab.length) == 0)                return;            int index = (n - 1) &amp; hash;            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;            if (pred == null)                tab[index] = first = succ;            else                pred.next = succ;            if (succ != null)                succ.prev = pred;            if (first == null)                return;            if (root.parent != null)                root = root.root();            if (root == null || root.right == null ||                (rl = root.left) == null || rl.left == null) &#123;                tab[index] = first.untreeify(map);   too small                return;            &#125;            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;            if (pl != null &amp;&amp; pr != null) &#123;                TreeNode&lt;K,V&gt; s = pr, sl;                while ((sl = s.left) != null)  find successor                    s = sl;                boolean c = s.red; s.red = p.red; p.red = c;  swap colors                TreeNode&lt;K,V&gt; sr = s.right;                TreeNode&lt;K,V&gt; pp = p.parent;                if (s == pr) &#123;  p was ss direct parent                    p.parent = s;                    s.right = p;                &#125;                else &#123;                    TreeNode&lt;K,V&gt; sp = s.parent;                    if ((p.parent = sp) != null) &#123;                        if (s == sp.left)                            sp.left = p;                        else                            sp.right = p;                    &#125;                    if ((s.right = pr) != null)                        pr.parent = s;                &#125;                p.left = null;                if ((p.right = sr) != null)                    sr.parent = p;                if ((s.left = pl) != null)                    pl.parent = s;                if ((s.parent = pp) == null)                    root = s;                else if (p == pp.left)                    pp.left = s;                else                    pp.right = s;                if (sr != null)                    replacement = sr;                else                    replacement = p;            &#125;            else if (pl != null)                replacement = pl;            else if (pr != null)                replacement = pr;            else                replacement = p;            if (replacement != p) &#123;                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;                if (pp == null)                    root = replacement;                else if (p == pp.left)                    pp.left = replacement;                else                    pp.right = replacement;                p.left = p.right = p.parent = null;            &#125;            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);            if (replacement == p) &#123;   detach                TreeNode&lt;K,V&gt; pp = p.parent;                p.parent = null;                if (pp != null) &#123;                    if (p == pp.left)                        pp.left = null;                    else if (p == pp.right)                        pp.right = null;                &#125;            &#125;            if (movable)                moveRootToFront(tab, r);        &#125;        **         * Splits nodes in a tree bin into lower and upper tree bins,         * or untreeifies if now too small. Called only from resize;         * see above discussion about split bits and indices.         *         * @param map the map         * @param tab the table for recording bin heads         * @param index the index of the table being split         * @param bit the bit of hash to split on         *        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;            TreeNode&lt;K,V&gt; b = this;             Relink into lo and hi lists, preserving order            TreeNode&lt;K,V&gt; loHead = null, loTail = null;            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;            int lc = 0, hc = 0;            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123;                next = (TreeNode&lt;K,V&gt;)e.next;                e.next = null;                if ((e.hash &amp; bit) == 0) &#123;                    if ((e.prev = loTail) == null)                        loHead = e;                    else                        loTail.next = e;                    loTail = e;                    ++lc;                &#125;                else &#123;                    if ((e.prev = hiTail) == null)                        hiHead = e;                    else                        hiTail.next = e;                    hiTail = e;                    ++hc;                &#125;            &#125;            if (loHead != null) &#123;                if (lc &lt;= UNTREEIFY_THRESHOLD)                    tab[index] = loHead.untreeify(map);                else &#123;                    tab[index] = loHead;                    if (hiHead != null)  (else is already treeified)                        loHead.treeify(tab);                &#125;            &#125;            if (hiHead != null) &#123;                if (hc &lt;= UNTREEIFY_THRESHOLD)                    tab[index + bit] = hiHead.untreeify(map);                else &#123;                    tab[index + bit] = hiHead;                    if (loHead != null)                        hiHead.treeify(tab);                &#125;            &#125;        &#125;        * ------------------------------------------------------------ *         Red-black tree methods, all adapted from CLR        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,                                              TreeNode&lt;K,V&gt; p) &#123;            TreeNode&lt;K,V&gt; r, pp, rl;            if (p != null &amp;&amp; (r = p.right) != null) &#123;                if ((rl = p.right = r.left) != null)                    rl.parent = p;                if ((pp = r.parent = p.parent) == null)                    (root = r).red = false;                else if (pp.left == p)                    pp.left = r;                else                    pp.right = r;                r.left = p;                p.parent = r;            &#125;            return root;        &#125;        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,                                               TreeNode&lt;K,V&gt; p) &#123;            TreeNode&lt;K,V&gt; l, pp, lr;            if (p != null &amp;&amp; (l = p.left) != null) &#123;                if ((lr = p.left = l.right) != null)                    lr.parent = p;                if ((pp = l.parent = p.parent) == null)                    (root = l).red = false;                else if (pp.right == p)                    pp.right = l;                else                    pp.left = l;                l.right = p;                p.parent = l;            &#125;            return root;        &#125;        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,                                                    TreeNode&lt;K,V&gt; x) &#123;            x.red = true;            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;                if ((xp = x.parent) == null) &#123;                    x.red = false;                    return x;                &#125;                else if (!xp.red || (xpp = xp.parent) == null)                    return root;                if (xp == (xppl = xpp.left)) &#123;                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;                        xppr.red = false;                        xp.red = false;                        xpp.red = true;                        x = xpp;                    &#125;                    else &#123;                        if (x == xp.right) &#123;                            root = rotateLeft(root, x = xp);                            xpp = (xp = x.parent) == null ? null : xp.parent;                        &#125;                        if (xp != null) &#123;                            xp.red = false;                            if (xpp != null) &#123;                                xpp.red = true;                                root = rotateRight(root, xpp);                            &#125;                        &#125;                    &#125;                &#125;                else &#123;                    if (xppl != null &amp;&amp; xppl.red) &#123;                        xppl.red = false;                        xp.red = false;                        xpp.red = true;                        x = xpp;                    &#125;                    else &#123;                        if (x == xp.left) &#123;                            root = rotateRight(root, x = xp);                            xpp = (xp = x.parent) == null ? null : xp.parent;                        &#125;                        if (xp != null) &#123;                            xp.red = false;                            if (xpp != null) &#123;                                xpp.red = true;                                root = rotateLeft(root, xpp);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,                                                   TreeNode&lt;K,V&gt; x) &#123;            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;                if (x == null || x == root)                    return root;                else if ((xp = x.parent) == null) &#123;                    x.red = false;                    return x;                &#125;                else if (x.red) &#123;                    x.red = false;                    return root;                &#125;                else if ((xpl = xp.left) == x) &#123;                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;                        xpr.red = false;                        xp.red = true;                        root = rotateLeft(root, xp);                        xpr = (xp = x.parent) == null ? null : xp.right;                    &#125;                    if (xpr == null)                        x = xp;                    else &#123;                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;                        if ((sr == null || !sr.red) &amp;&amp;                            (sl == null || !sl.red)) &#123;                            xpr.red = true;                            x = xp;                        &#125;                        else &#123;                            if (sr == null || !sr.red) &#123;                                if (sl != null)                                    sl.red = false;                                xpr.red = true;                                root = rotateRight(root, xpr);                                xpr = (xp = x.parent) == null ?                                    null : xp.right;                            &#125;                            if (xpr != null) &#123;                                xpr.red = (xp == null) ? false : xp.red;                                if ((sr = xpr.right) != null)                                    sr.red = false;                            &#125;                            if (xp != null) &#123;                                xp.red = false;                                root = rotateLeft(root, xp);                            &#125;                            x = root;                        &#125;                    &#125;                &#125;                else &#123;  symmetric                    if (xpl != null &amp;&amp; xpl.red) &#123;                        xpl.red = false;                        xp.red = true;                        root = rotateRight(root, xp);                        xpl = (xp = x.parent) == null ? null : xp.left;                    &#125;                    if (xpl == null)                        x = xp;                    else &#123;                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;                        if ((sl == null || !sl.red) &amp;&amp;                            (sr == null || !sr.red)) &#123;                            xpl.red = true;                            x = xp;                        &#125;                        else &#123;                            if (sl == null || !sl.red) &#123;                                if (sr != null)                                    sr.red = false;                                xpl.red = true;                                root = rotateLeft(root, xpl);                                xpl = (xp = x.parent) == null ?                                    null : xp.left;                            &#125;                            if (xpl != null) &#123;                                xpl.red = (xp == null) ? false : xp.red;                                if ((sl = xpl.left) != null)                                    sl.red = false;                            &#125;                            if (xp != null) &#123;                                xp.red = false;                                root = rotateRight(root, xp);                            &#125;                            x = root;                        &#125;                    &#125;                &#125;            &#125;        &#125;        **         * Recursive invariant check         *        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123;            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;            if (tb != null &amp;&amp; tb.next != t)                return false;            if (tn != null &amp;&amp; tn.prev != t)                return false;            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)                return false;            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))                return false;            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))                return false;            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)                return false;            if (tl != null &amp;&amp; !checkInvariants(tl))                return false;            if (tr != null &amp;&amp; !checkInvariants(tr))                return false;            return true;        &#125;    &#125;&#125;\n\n","tags":["Java","HashMap"],"path":"2019/09/23/HashMap类/","external_link":""},{"title":"LinkedList类","date":"2019-09-25T10:28:49.000Z","content":"LinkedList类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242* * Copyright (c) 1997, 2013, Oracle andor its affiliates. All rights reserved. * ORACLE PROPRIETARYCONFIDENTIAL. Use is subject to license terms. *package java.util;import java.util.function.Consumer;** * Doubly-linked list implementation of the &#123;@code List&#125; and &#123;@code Deque&#125; * interfaces.  Implements all optional list operations, and permits all * elements (including &#123;@code null&#125;). * * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked * list.  Operations that index into the list will traverse the list from * the beginning or the end, whichever is closer to the specified index. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;strong&gt; * If multiple threads access a linked list concurrently, and at least * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;i&gt; be * synchronized externally.  (A structural modification is any operation * that adds or deletes one or more elements; merely setting the value of * an element is not a structural modification.)  This is typically * accomplished by synchronizing on some object that naturally * encapsulates the list. * * If no such object exists, the list should be wrapped using the * &#123;@link Collections#synchronizedList Collections.synchronizedList&#125; * method.  This is best done at creation time, to prevent accidental * unsynchronized access to the list:&lt;pre&gt; *   List list = Collections.synchronizedList(new LinkedList(...));&lt;pre&gt; * * &lt;p&gt;The iterators returned by this classs &#123;@code iterator&#125; and * &#123;@code listIterator&#125; methods are &lt;i&gt;fail-fast&lt;i&gt;: if the list is * structurally modified at any time after the iterator is created, in * any way except through the Iterators own &#123;@code remove&#125; or * &#123;@code add&#125; methods, the iterator will throw a &#123;@link * ConcurrentModificationException&#125;.  Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than * risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification.  Fail-fast iterators * throw &#123;@code ConcurrentModificationException&#125; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=&#123;@docRoot&#125;..technotesguidescollectionsindex.html&gt; * Java Collections Framework&lt;a&gt;. * * @author  Josh Bloch * @see     List * @see     ArrayList * @since 1.2 * @param &lt;E&gt; the type of elements held in this collection *public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;    transient int size = 0;    **     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     *    transient Node&lt;E&gt; first;    **     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     *    transient Node&lt;E&gt; last;    **     * Constructs an empty list.     *    public LinkedList() &#123;    &#125;    **     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collections     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     *    public LinkedList(Collection&lt;? extends E&gt; c) &#123;        this();        addAll(c);    &#125;    **     * Links e as first element.     *    private void linkFirst(E e) &#123;        final Node&lt;E&gt; f = first;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);        first = newNode;        if (f == null)            last = newNode;        else            f.prev = newNode;        size++;        modCount++;    &#125;    **     * Links e as last element.     *    void linkLast(E e) &#123;        final Node&lt;E&gt; l = last;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);        last = newNode;        if (l == null)            first = newNode;        else            l.next = newNode;        size++;        modCount++;    &#125;    **     * Inserts element e before non-null Node succ.     *    void linkBefore(E e, Node&lt;E&gt; succ) &#123;         assert succ != null;        final Node&lt;E&gt; pred = succ.prev;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);        succ.prev = newNode;        if (pred == null)            first = newNode;        else            pred.next = newNode;        size++;        modCount++;    &#125;    **     * Unlinks non-null first node f.     *    private E unlinkFirst(Node&lt;E&gt; f) &#123;         assert f == first &amp;&amp; f != null;        final E element = f.item;        final Node&lt;E&gt; next = f.next;        f.item = null;        f.next = null;  help GC        first = next;        if (next == null)            last = null;        else            next.prev = null;        size--;        modCount++;        return element;    &#125;    **     * Unlinks non-null last node l.     *    private E unlinkLast(Node&lt;E&gt; l) &#123;         assert l == last &amp;&amp; l != null;        final E element = l.item;        final Node&lt;E&gt; prev = l.prev;        l.item = null;        l.prev = null;  help GC        last = prev;        if (prev == null)            first = null;        else            prev.next = null;        size--;        modCount++;        return element;    &#125;    **     * Unlinks non-null node x.     *    E unlink(Node&lt;E&gt; x) &#123;         assert x != null;        final E element = x.item;        final Node&lt;E&gt; next = x.next;        final Node&lt;E&gt; prev = x.prev;        if (prev == null) &#123;            first = next;        &#125; else &#123;            prev.next = next;            x.prev = null;        &#125;        if (next == null) &#123;            last = prev;        &#125; else &#123;            next.prev = prev;            x.next = null;        &#125;        x.item = null;        size--;        modCount++;        return element;    &#125;    **     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     *    public E getFirst() &#123;        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    &#125;    **     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     *    public E getLast() &#123;        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    &#125;    **     * Removes and returns the first element from this list.     *     * @return the first element from this list     * @throws NoSuchElementException if this list is empty     *    public E removeFirst() &#123;        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return unlinkFirst(f);    &#125;    **     * Removes and returns the last element from this list.     *     * @return the last element from this list     * @throws NoSuchElementException if this list is empty     *    public E removeLast() &#123;        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return unlinkLast(l);    &#125;    **     * Inserts the specified element at the beginning of this list.     *     * @param e the element to add     *    public void addFirst(E e) &#123;        linkFirst(e);    &#125;    **     * Appends the specified element to the end of this list.     *     * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.     *     * @param e the element to add     *    public void addLast(E e) &#123;        linkLast(e);    &#125;    **     * Returns &#123;@code true&#125; if this list contains the specified element.     * More formally, returns &#123;@code true&#125; if and only if this list contains     * at least one element &#123;@code e&#125; such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;tt&gt;.     *     * @param o element whose presence in this list is to be tested     * @return &#123;@code true&#125; if this list contains the specified element     *    public boolean contains(Object o) &#123;        return indexOf(o) != -1;    &#125;    **     * Returns the number of elements in this list.     *     * @return the number of elements in this list     *    public int size() &#123;        return size;    &#125;    **     * Appends the specified element to the end of this list.     *     * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.     *     * @param e element to be appended to this list     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)     *    public boolean add(E e) &#123;        linkLast(e);        return true;    &#125;    **     * Removes the first occurrence of the specified element from this list,     * if it is present.  If this list does not contain the element, it is     * unchanged.  More formally, removes the element with the lowest index     * &#123;@code i&#125; such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;tt&gt;     * (if such an element exists).  Returns &#123;@code true&#125; if this list     * contained the specified element (or equivalently, if this list     * changed as a result of the call).     *     * @param o element to be removed from this list, if present     * @return &#123;@code true&#125; if this list contained the specified element     *    public boolean remove(Object o) &#123;        if (o == null) &#123;            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;                if (x.item == null) &#123;                    unlink(x);                    return true;                &#125;            &#125;        &#125; else &#123;            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;                if (o.equals(x.item)) &#123;                    unlink(x);                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    **     * Appends all of the elements in the specified collection to the end of     * this list, in the order that they are returned by the specified     * collections iterator.  The behavior of this operation is undefined if     * the specified collection is modified while the operation is in     * progress.  (Note that this will occur if the specified collection is     * this list, and its nonempty.)     *     * @param c collection containing elements to be added to this list     * @return &#123;@code true&#125; if this list changed as a result of the call     * @throws NullPointerException if the specified collection is null     *    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;        return addAll(size, c);    &#125;    **     * Inserts all of the elements in the specified collection into this     * list, starting at the specified position.  Shifts the element     * currently at that position (if any) and any subsequent elements to     * the right (increases their indices).  The new elements will appear     * in the list in the order that they are returned by the     * specified collections iterator.     *     * @param index index at which to insert the first element     *              from the specified collection     * @param c collection containing elements to be added to this list     * @return &#123;@code true&#125; if this list changed as a result of the call     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     * @throws NullPointerException if the specified collection is null     *    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;        checkPositionIndex(index);        Object[] a = c.toArray();        int numNew = a.length;        if (numNew == 0)            return false;        Node&lt;E&gt; pred, succ;        if (index == size) &#123;            succ = null;            pred = last;        &#125; else &#123;            succ = node(index);            pred = succ.prev;        &#125;        for (Object o : a) &#123;            @SuppressWarnings(unchecked) E e = (E) o;            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);            if (pred == null)                first = newNode;            else                pred.next = newNode;            pred = newNode;        &#125;        if (succ == null) &#123;            last = pred;        &#125; else &#123;            pred.next = succ;            succ.prev = pred;        &#125;        size += numNew;        modCount++;        return true;    &#125;    **     * Removes all of the elements from this list.     * The list will be empty after this call returns.     *    public void clear() &#123;         Clearing all of the links between nodes is unnecessary, but:         - helps a generational GC if the discarded nodes inhabit           more than one generation         - is sure to free memory even if there is a reachable Iterator        for (Node&lt;E&gt; x = first; x != null; ) &#123;            Node&lt;E&gt; next = x.next;            x.item = null;            x.next = null;            x.prev = null;            x = next;        &#125;        first = last = null;        size = 0;        modCount++;    &#125;     Positional Access Operations    **     * Returns the element at the specified position in this list.     *     * @param index index of the element to return     * @return the element at the specified position in this list     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     *    public E get(int index) &#123;        checkElementIndex(index);        return node(index).item;    &#125;    **     * Replaces the element at the specified position in this list with the     * specified element.     *     * @param index index of the element to replace     * @param element element to be stored at the specified position     * @return the element previously at the specified position     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     *    public E set(int index, E element) &#123;        checkElementIndex(index);        Node&lt;E&gt; x = node(index);        E oldVal = x.item;        x.item = element;        return oldVal;    &#125;    **     * Inserts the specified element at the specified position in this list.     * Shifts the element currently at that position (if any) and any     * subsequent elements to the right (adds one to their indices).     *     * @param index index at which the specified element is to be inserted     * @param element element to be inserted     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     *    public void add(int index, E element) &#123;        checkPositionIndex(index);        if (index == size)            linkLast(element);        else            linkBefore(element, node(index));    &#125;    **     * Removes the element at the specified position in this list.  Shifts any     * subsequent elements to the left (subtracts one from their indices).     * Returns the element that was removed from the list.     *     * @param index the index of the element to be removed     * @return the element previously at the specified position     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     *    public E remove(int index) &#123;        checkElementIndex(index);        return unlink(node(index));    &#125;    **     * Tells if the argument is the index of an existing element.     *    private boolean isElementIndex(int index) &#123;        return index &gt;= 0 &amp;&amp; index &lt; size;    &#125;    **     * Tells if the argument is the index of a valid position for an     * iterator or an add operation.     *    private boolean isPositionIndex(int index) &#123;        return index &gt;= 0 &amp;&amp; index &lt;= size;    &#125;    **     * Constructs an IndexOutOfBoundsException detail message.     * Of the many possible refactorings of the error handling code,     * this outlining performs best with both server and client VMs.     *    private String outOfBoundsMsg(int index) &#123;        return Index: +index+, Size: +size;    &#125;    private void checkElementIndex(int index) &#123;        if (!isElementIndex(index))            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    private void checkPositionIndex(int index) &#123;        if (!isPositionIndex(index))            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    **     * Returns the (non-null) Node at the specified element index.     *    Node&lt;E&gt; node(int index) &#123;         assert isElementIndex(index);        if (index &lt; (size &gt;&gt; 1)) &#123;            Node&lt;E&gt; x = first;            for (int i = 0; i &lt; index; i++)                x = x.next;            return x;        &#125; else &#123;            Node&lt;E&gt; x = last;            for (int i = size - 1; i &gt; index; i--)                x = x.prev;            return x;        &#125;    &#125;     Search Operations    **     * Returns the index of the first occurrence of the specified element     * in this list, or -1 if this list does not contain the element.     * More formally, returns the lowest index &#123;@code i&#125; such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;tt&gt;,     * or -1 if there is no such index.     *     * @param o element to search for     * @return the index of the first occurrence of the specified element in     *         this list, or -1 if this list does not contain the element     *    public int indexOf(Object o) &#123;        int index = 0;        if (o == null) &#123;            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;                if (x.item == null)                    return index;                index++;            &#125;        &#125; else &#123;            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;                if (o.equals(x.item))                    return index;                index++;            &#125;        &#125;        return -1;    &#125;    **     * Returns the index of the last occurrence of the specified element     * in this list, or -1 if this list does not contain the element.     * More formally, returns the highest index &#123;@code i&#125; such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;tt&gt;,     * or -1 if there is no such index.     *     * @param o element to search for     * @return the index of the last occurrence of the specified element in     *         this list, or -1 if this list does not contain the element     *    public int lastIndexOf(Object o) &#123;        int index = size;        if (o == null) &#123;            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;                index--;                if (x.item == null)                    return index;            &#125;        &#125; else &#123;            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;                index--;                if (o.equals(x.item))                    return index;            &#125;        &#125;        return -1;    &#125;     Queue operations.    **     * Retrieves, but does not remove, the head (first element) of this list.     *     * @return the head of this list, or &#123;@code null&#125; if this list is empty     * @since 1.5     *    public E peek() &#123;        final Node&lt;E&gt; f = first;        return (f == null) ? null : f.item;    &#125;    **     * Retrieves, but does not remove, the head (first element) of this list.     *     * @return the head of this list     * @throws NoSuchElementException if this list is empty     * @since 1.5     *    public E element() &#123;        return getFirst();    &#125;    **     * Retrieves and removes the head (first element) of this list.     *     * @return the head of this list, or &#123;@code null&#125; if this list is empty     * @since 1.5     *    public E poll() &#123;        final Node&lt;E&gt; f = first;        return (f == null) ? null : unlinkFirst(f);    &#125;    **     * Retrieves and removes the head (first element) of this list.     *     * @return the head of this list     * @throws NoSuchElementException if this list is empty     * @since 1.5     *    public E remove() &#123;        return removeFirst();    &#125;    **     * Adds the specified element as the tail (last element) of this list.     *     * @param e the element to add     * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)     * @since 1.5     *    public boolean offer(E e) &#123;        return add(e);    &#125;     Deque operations    **     * Inserts the specified element at the front of this list.     *     * @param e the element to insert     * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerFirst&#125;)     * @since 1.6     *    public boolean offerFirst(E e) &#123;        addFirst(e);        return true;    &#125;    **     * Inserts the specified element at the end of this list.     *     * @param e the element to insert     * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerLast&#125;)     * @since 1.6     *    public boolean offerLast(E e) &#123;        addLast(e);        return true;    &#125;    **     * Retrieves, but does not remove, the first element of this list,     * or returns &#123;@code null&#125; if this list is empty.     *     * @return the first element of this list, or &#123;@code null&#125;     *         if this list is empty     * @since 1.6     *    public E peekFirst() &#123;        final Node&lt;E&gt; f = first;        return (f == null) ? null : f.item;     &#125;    **     * Retrieves, but does not remove, the last element of this list,     * or returns &#123;@code null&#125; if this list is empty.     *     * @return the last element of this list, or &#123;@code null&#125;     *         if this list is empty     * @since 1.6     *    public E peekLast() &#123;        final Node&lt;E&gt; l = last;        return (l == null) ? null : l.item;    &#125;    **     * Retrieves and removes the first element of this list,     * or returns &#123;@code null&#125; if this list is empty.     *     * @return the first element of this list, or &#123;@code null&#125; if     *     this list is empty     * @since 1.6     *    public E pollFirst() &#123;        final Node&lt;E&gt; f = first;        return (f == null) ? null : unlinkFirst(f);    &#125;    **     * Retrieves and removes the last element of this list,     * or returns &#123;@code null&#125; if this list is empty.     *     * @return the last element of this list, or &#123;@code null&#125; if     *     this list is empty     * @since 1.6     *    public E pollLast() &#123;        final Node&lt;E&gt; l = last;        return (l == null) ? null : unlinkLast(l);    &#125;    **     * Pushes an element onto the stack represented by this list.  In other     * words, inserts the element at the front of this list.     *     * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;.     *     * @param e the element to push     * @since 1.6     *    public void push(E e) &#123;        addFirst(e);    &#125;    **     * Pops an element from the stack represented by this list.  In other     * words, removes and returns the first element of this list.     *     * &lt;p&gt;This method is equivalent to &#123;@link #removeFirst()&#125;.     *     * @return the element at the front of this list (which is the top     *         of the stack represented by this list)     * @throws NoSuchElementException if this list is empty     * @since 1.6     *    public E pop() &#123;        return removeFirst();    &#125;    **     * Removes the first occurrence of the specified element in this     * list (when traversing the list from head to tail).  If the list     * does not contain the element, it is unchanged.     *     * @param o element to be removed from this list, if present     * @return &#123;@code true&#125; if the list contained the specified element     * @since 1.6     *    public boolean removeFirstOccurrence(Object o) &#123;        return remove(o);    &#125;    **     * Removes the last occurrence of the specified element in this     * list (when traversing the list from head to tail).  If the list     * does not contain the element, it is unchanged.     *     * @param o element to be removed from this list, if present     * @return &#123;@code true&#125; if the list contained the specified element     * @since 1.6     *    public boolean removeLastOccurrence(Object o) &#123;        if (o == null) &#123;            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;                if (x.item == null) &#123;                    unlink(x);                    return true;                &#125;            &#125;        &#125; else &#123;            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;                if (o.equals(x.item)) &#123;                    unlink(x);                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    **     * Returns a list-iterator of the elements in this list (in proper     * sequence), starting at the specified position in the list.     * Obeys the general contract of &#123;@code List.listIterator(int)&#125;.&lt;p&gt;     *     * The list-iterator is &lt;i&gt;fail-fast&lt;i&gt;: if the list is structurally     * modified at any time after the Iterator is created, in any way except     * through the list-iterators own &#123;@code remove&#125; or &#123;@code add&#125;     * methods, the list-iterator will throw a     * &#123;@code ConcurrentModificationException&#125;.  Thus, in the face of     * concurrent modification, the iterator fails quickly and cleanly, rather     * than risking arbitrary, non-deterministic behavior at an undetermined     * time in the future.     *     * @param index index of the first element to be returned from the     *              list-iterator (by a call to &#123;@code next&#125;)     * @return a ListIterator of the elements in this list (in proper     *         sequence), starting at the specified position in the list     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     * @see List#listIterator(int)     *    public ListIterator&lt;E&gt; listIterator(int index) &#123;        checkPositionIndex(index);        return new ListItr(index);    &#125;    private class ListItr implements ListIterator&lt;E&gt; &#123;        private Node&lt;E&gt; lastReturned;        private Node&lt;E&gt; next;        private int nextIndex;        private int expectedModCount = modCount;        ListItr(int index) &#123;             assert isPositionIndex(index);            next = (index == size) ? null : node(index);            nextIndex = index;        &#125;        public boolean hasNext() &#123;            return nextIndex &lt; size;        &#125;        public E next() &#123;            checkForComodification();            if (!hasNext())                throw new NoSuchElementException();            lastReturned = next;            next = next.next;            nextIndex++;            return lastReturned.item;        &#125;        public boolean hasPrevious() &#123;            return nextIndex &gt; 0;        &#125;        public E previous() &#123;            checkForComodification();            if (!hasPrevious())                throw new NoSuchElementException();            lastReturned = next = (next == null) ? last : next.prev;            nextIndex--;            return lastReturned.item;        &#125;        public int nextIndex() &#123;            return nextIndex;        &#125;        public int previousIndex() &#123;            return nextIndex - 1;        &#125;        public void remove() &#123;            checkForComodification();            if (lastReturned == null)                throw new IllegalStateException();            Node&lt;E&gt; lastNext = lastReturned.next;            unlink(lastReturned);            if (next == lastReturned)                next = lastNext;            else                nextIndex--;            lastReturned = null;            expectedModCount++;        &#125;        public void set(E e) &#123;            if (lastReturned == null)                throw new IllegalStateException();            checkForComodification();            lastReturned.item = e;        &#125;        public void add(E e) &#123;            checkForComodification();            lastReturned = null;            if (next == null)                linkLast(e);            else                linkBefore(e, next);            nextIndex++;            expectedModCount++;        &#125;        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;            Objects.requireNonNull(action);            while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;                action.accept(next.item);                lastReturned = next;                next = next.next;                nextIndex++;            &#125;            checkForComodification();        &#125;        final void checkForComodification() &#123;            if (modCount != expectedModCount)                throw new ConcurrentModificationException();        &#125;    &#125;    private static class Node&lt;E&gt; &#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            this.item = element;            this.next = next;            this.prev = prev;        &#125;    &#125;    **     * @since 1.6     *    public Iterator&lt;E&gt; descendingIterator() &#123;        return new DescendingIterator();    &#125;    **     * Adapter to provide descending iterators via ListItr.previous     *    private class DescendingIterator implements Iterator&lt;E&gt; &#123;        private final ListItr itr = new ListItr(size());        public boolean hasNext() &#123;            return itr.hasPrevious();        &#125;        public E next() &#123;            return itr.previous();        &#125;        public void remove() &#123;            itr.remove();        &#125;    &#125;    @SuppressWarnings(unchecked)    private LinkedList&lt;E&gt; superClone() &#123;        try &#123;            return (LinkedList&lt;E&gt;) super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            throw new InternalError(e);        &#125;    &#125;    **     * Returns a shallow copy of this &#123;@code LinkedList&#125;. (The elements     * themselves are not cloned.)     *     * @return a shallow copy of this &#123;@code LinkedList&#125; instance     *    public Object clone() &#123;        LinkedList&lt;E&gt; clone = superClone();         Put clone into virgin state        clone.first = clone.last = null;        clone.size = 0;        clone.modCount = 0;         Initialize clone with our elements        for (Node&lt;E&gt; x = first; x != null; x = x.next)            clone.add(x.item);        return clone;    &#125;    **     * Returns an array containing all of the elements in this list     * in proper sequence (from first to last element).     *     * &lt;p&gt;The returned array will be safe in that no references to it are     * maintained by this list.  (In other words, this method must allocate     * a new array).  The caller is thus free to modify the returned array.     *     * &lt;p&gt;This method acts as bridge between array-based and collection-based     * APIs.     *     * @return an array containing all of the elements in this list     *         in proper sequence     *    public Object[] toArray() &#123;        Object[] result = new Object[size];        int i = 0;        for (Node&lt;E&gt; x = first; x != null; x = x.next)            result[i++] = x.item;        return result;    &#125;    **     * Returns an array containing all of the elements in this list in     * proper sequence (from first to last element); the runtime type of     * the returned array is that of the specified array.  If the list fits     * in the specified array, it is returned therein.  Otherwise, a new     * array is allocated with the runtime type of the specified array and     * the size of this list.     *     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,     * the array has more elements than the list), the element in the array     * immediately following the end of the list is set to &#123;@code null&#125;.     * (This is useful in determining the length of the list &lt;i&gt;only&lt;i&gt; if     * the caller knows that the list does not contain any null elements.)     *     * &lt;p&gt;Like the &#123;@link #toArray()&#125; method, this method acts as bridge between     * array-based and collection-based APIs.  Further, this method allows     * precise control over the runtime type of the output array, and may,     * under certain circumstances, be used to save allocation costs.     *     * &lt;p&gt;Suppose &#123;@code x&#125; is a list known to contain only strings.     * The following code can be used to dump the list into a newly     * allocated array of &#123;@code String&#125;:     *     * &lt;pre&gt;     *     String[] y = x.toArray(new String[0]);&lt;pre&gt;     *     * Note that &#123;@code toArray(new Object[0])&#125; is identical in function to     * &#123;@code toArray()&#125;.     *     * @param a the array into which the elements of the list are to     *          be stored, if it is big enough; otherwise, a new array of the     *          same runtime type is allocated for this purpose.     * @return an array containing the elements of the list     * @throws ArrayStoreException if the runtime type of the specified array     *         is not a supertype of the runtime type of every element in     *         this list     * @throws NullPointerException if the specified array is null     *    @SuppressWarnings(unchecked)    public &lt;T&gt; T[] toArray(T[] a) &#123;        if (a.length &lt; size)            a = (T[])java.lang.reflect.Array.newInstance(                                a.getClass().getComponentType(), size);        int i = 0;        Object[] result = a;        for (Node&lt;E&gt; x = first; x != null; x = x.next)            result[i++] = x.item;        if (a.length &gt; size)            a[size] = null;        return a;    &#125;    private static final long serialVersionUID = 876323262645176354L;    **     * Saves the state of this &#123;@code LinkedList&#125; instance to a stream     * (that is, serializes it).     *     * @serialData The size of the list (the number of elements it     *             contains) is emitted (int), followed by all of its     *             elements (each an Object) in the proper order.     *    private void writeObject(java.io.ObjectOutputStream s)        throws java.io.IOException &#123;         Write out any hidden serialization magic        s.defaultWriteObject();         Write out size        s.writeInt(size);         Write out all elements in the proper order.        for (Node&lt;E&gt; x = first; x != null; x = x.next)            s.writeObject(x.item);    &#125;    **     * Reconstitutes this &#123;@code LinkedList&#125; instance from a stream     * (that is, deserializes it).     *    @SuppressWarnings(unchecked)    private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;         Read in any hidden serialization magic        s.defaultReadObject();         Read in size        int size = s.readInt();         Read in all elements in the proper order.        for (int i = 0; i &lt; size; i++)            linkLast((E)s.readObject());    &#125;    **     * Creates a &lt;em&gt;&lt;a href=Spliterator.html#binding&gt;late-binding&lt;a&gt;&lt;em&gt;     * and &lt;em&gt;fail-fast&lt;em&gt; &#123;@link Spliterator&#125; over the elements in this     * list.     *     * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125; and     * &#123;@link Spliterator#ORDERED&#125;.  Overriding implementations should document     * the reporting of additional characteristic values.     *     * @implNote     * The &#123;@code Spliterator&#125; additionally reports &#123;@link Spliterator#SUBSIZED&#125;     * and implements &#123;@code trySplit&#125; to permit limited parallelism..     *     * @return a &#123;@code Spliterator&#125; over the elements in this list     * @since 1.8     *    @Override    public Spliterator&lt;E&gt; spliterator() &#123;        return new LLSpliterator&lt;E&gt;(this, -1, 0);    &#125;    ** A customized variant of Spliterators.IteratorSpliterator *    static final class LLSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123;        static final int BATCH_UNIT = 1 &lt;&lt; 10;   batch array size increment        static final int MAX_BATCH = 1 &lt;&lt; 25;   max batch array size;        final LinkedList&lt;E&gt; list;  null OK unless traversed        Node&lt;E&gt; current;       current node; null until initialized        int est;               size estimate; -1 until first needed        int expectedModCount;  initialized when est set        int batch;             batch size for splits        LLSpliterator(LinkedList&lt;E&gt; list, int est, int expectedModCount) &#123;            this.list = list;            this.est = est;            this.expectedModCount = expectedModCount;        &#125;        final int getEst() &#123;            int s;  force initialization            final LinkedList&lt;E&gt; lst;            if ((s = est) &lt; 0) &#123;                if ((lst = list) == null)                    s = est = 0;                else &#123;                    expectedModCount = lst.modCount;                    current = lst.first;                    s = est = lst.size;                &#125;            &#125;            return s;        &#125;        public long estimateSize() &#123; return (long) getEst(); &#125;        public Spliterator&lt;E&gt; trySplit() &#123;            Node&lt;E&gt; p;            int s = getEst();            if (s &gt; 1 &amp;&amp; (p = current) != null) &#123;                int n = batch + BATCH_UNIT;                if (n &gt; s)                    n = s;                if (n &gt; MAX_BATCH)                    n = MAX_BATCH;                Object[] a = new Object[n];                int j = 0;                do &#123; a[j++] = p.item; &#125; while ((p = p.next) != null &amp;&amp; j &lt; n);                current = p;                batch = j;                est = s - j;                return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED);            &#125;            return null;        &#125;        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;            Node&lt;E&gt; p; int n;            if (action == null) throw new NullPointerException();            if ((n = getEst()) &gt; 0 &amp;&amp; (p = current) != null) &#123;                current = null;                est = 0;                do &#123;                    E e = p.item;                    p = p.next;                    action.accept(e);                &#125; while (p != null &amp;&amp; --n &gt; 0);            &#125;            if (list.modCount != expectedModCount)                throw new ConcurrentModificationException();        &#125;        public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123;            Node&lt;E&gt; p;            if (action == null) throw new NullPointerException();            if (getEst() &gt; 0 &amp;&amp; (p = current) != null) &#123;                --est;                E e = p.item;                current = p.next;                action.accept(e);                if (list.modCount != expectedModCount)                    throw new ConcurrentModificationException();                return true;            &#125;            return false;        &#125;        public int characteristics() &#123;            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;        &#125;    &#125;&#125;\n\n","tags":["Java"],"path":"2019/09/25/LinkedList类/","external_link":""},{"title":"os.py","date":"2019-09-27T03:54:11.000Z","content":"os.py\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078rOS routines for NT or Posix depending on what system were on.This exports:  - all functions from posix or nt, e.g. unlink, stat, etc.  - os.path is either posixpath or ntpath  - os.name is either posix or nt  - os.curdir is a string representing the current directory (always .)  - os.pardir is a string representing the parent directory (always ..)  - os.sep is the (or a most common) pathname separator ( or )  - os.extsep is the extension separator (always .)  - os.altsep is the alternate pathname separator (None or )  - os.pathsep is the component separator used in $PATH etc  - os.linesep is the line separator in text files (r or n or rn)  - os.defpath is the default search path for executables  - os.devnull is the file path of the null device (devnull, etc.)Programs that import and use os stand a better chance of beingportable between different platforms.  Of course, they must thenonly use functions that are defined by all platforms (e.g., unlinkand opendir), and leave all pathname manipulation to os.path(e.g., split and join).#import abcimport sysimport stat as st_names = sys.builtin_module_names# Note:  more names are added to __all__ later.__all__ = [altsep, curdir, pardir, sep, pathsep, linesep,           defpath, name, path, devnull, SEEK_SET, SEEK_CUR,           SEEK_END, fsencode, fsdecode, get_exec_path, fdopen,           popen, extsep]def _exists(name):    return name in globals()def _get_exports_list(module):    try:        return list(module.__all__)    except AttributeError:        return [n for n in dir(module) if n[0] != _]# Any new dependencies of the os module andor changes in path separator# requires updating importlib as well.if posix in _names:    name = posix    linesep = n    from posix import *    try:        from posix import _exit        __all__.append(_exit)    except ImportError:        pass    import posixpath as path    try:        from posix import _have_functions    except ImportError:        pass    import posix    __all__.extend(_get_exports_list(posix))    del posixelif nt in _names:    name = nt    linesep = rn    from nt import *    try:        from nt import _exit        __all__.append(_exit)    except ImportError:        pass    import ntpath as path    import nt    __all__.extend(_get_exports_list(nt))    del nt    try:        from nt import _have_functions    except ImportError:        passelse:    raise ImportError(no os specific module found)sys.modules[os.path] = pathfrom os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,    devnull)del _namesif _exists(_have_functions):    _globals = globals()    def _add(str, fn):        if (fn in _globals) and (str in _have_functions):            _set.add(_globals[fn])    _set = set()    _add(HAVE_FACCESSAT,  access)    _add(HAVE_FCHMODAT,   chmod)    _add(HAVE_FCHOWNAT,   chown)    _add(HAVE_FSTATAT,    stat)    _add(HAVE_FUTIMESAT,  utime)    _add(HAVE_LINKAT,     link)    _add(HAVE_MKDIRAT,    mkdir)    _add(HAVE_MKFIFOAT,   mkfifo)    _add(HAVE_MKNODAT,    mknod)    _add(HAVE_OPENAT,     open)    _add(HAVE_READLINKAT, readlink)    _add(HAVE_RENAMEAT,   rename)    _add(HAVE_SYMLINKAT,  symlink)    _add(HAVE_UNLINKAT,   unlink)    _add(HAVE_UNLINKAT,   rmdir)    _add(HAVE_UTIMENSAT,  utime)    supports_dir_fd = _set    _set = set()    _add(HAVE_FACCESSAT,  access)    supports_effective_ids = _set    _set = set()    _add(HAVE_FCHDIR,     chdir)    _add(HAVE_FCHMOD,     chmod)    _add(HAVE_FCHOWN,     chown)    _add(HAVE_FDOPENDIR,  listdir)    _add(HAVE_FDOPENDIR,  scandir)    _add(HAVE_FEXECVE,    execve)    _set.add(stat) # fstat always works    _add(HAVE_FTRUNCATE,  truncate)    _add(HAVE_FUTIMENS,   utime)    _add(HAVE_FUTIMES,    utime)    _add(HAVE_FPATHCONF,  pathconf)    if _exists(statvfs) and _exists(fstatvfs): # mac os x10.3        _add(HAVE_FSTATVFS, statvfs)    supports_fd = _set    _set = set()    _add(HAVE_FACCESSAT,  access)    # Some platforms dont support lchmod().  Often the function exists    # anyway, as a stub that always returns ENOSUP or perhaps EOPNOTSUPP.    # (No, I dont know why thats a good design.)  .configure will detect    # this and reject it--so HAVE_LCHMOD still wont be defined on such    # platforms.  This is Very Helpful.    #    # However, sometimes platforms without a working lchmod() *do* have    # fchmodat().  (Examples: Linux kernel 3.2 with glibc 2.15,    # OpenIndiana 3.x.)  And fchmodat() has a flag that theoretically makes    # it behave like lchmod().  So in theory it would be a suitable    # replacement for lchmod().  But when lchmod() doesnt work, fchmodat()s    # flag doesnt work *either*.  Sadly .configure isnt sophisticated    # enough to detect this condition--it only determines whether or not    # fchmodat() minimally works.    #    # Therefore we simply ignore fchmodat() when deciding whether or not    # os.chmod supports follow_symlinks.  Just checking lchmod() is    # sufficient.  After all--if you have a working fchmodat(), your    # lchmod() almost certainly works too.    #    # _add(HAVE_FCHMODAT,   chmod)    _add(HAVE_FCHOWNAT,   chown)    _add(HAVE_FSTATAT,    stat)    _add(HAVE_LCHFLAGS,   chflags)    _add(HAVE_LCHMOD,     chmod)    if _exists(lchown): # mac os x10.3        _add(HAVE_LCHOWN, chown)    _add(HAVE_LINKAT,     link)    _add(HAVE_LUTIMES,    utime)    _add(HAVE_LSTAT,      stat)    _add(HAVE_FSTATAT,    stat)    _add(HAVE_UTIMENSAT,  utime)    _add(MS_WINDOWS,      stat)    supports_follow_symlinks = _set    del _set    del _have_functions    del _globals    del _add# Python uses fixed values for the SEEK_ constants; they are mapped# to native constants if necessary in posixmodule.c# Other possible SEEK values are directly imported from posixmodule.cSEEK_SET = 0SEEK_CUR = 1SEEK_END = 2# Super directory utilities.# (Inspired by Eric Raymond; the doc strings are mostly his)def makedirs(name, mode=0o777, exist_ok=False):    makedirs(name [, mode=0o777][, exist_ok=False])    Super-mkdir; create a leaf directory and all intermediate ones.  Works like    mkdir, except that any intermediate path segment (not just the rightmost)    will be created if it does not exist. If the target directory already    exists, raise an OSError if exist_ok is False. Otherwise no exception is    raised.  This is recursive.        head, tail = path.split(name)    if not tail:        head, tail = path.split(head)    if head and tail and not path.exists(head):        try:            makedirs(head, exist_ok=exist_ok)        except FileExistsError:            # Defeats race condition when another thread created the path            pass        cdir = curdir        if isinstance(tail, bytes):            cdir = bytes(curdir, ASCII)        if tail == cdir:           # xxxnewdir. exists if xxxnewdir exists            return    try:        mkdir(name, mode)    except OSError:        # Cannot rely on checking for EEXIST, since the operating system        # could give priority to other errors like EACCES or EROFS        if not exist_ok or not path.isdir(name):            raisedef removedirs(name):    removedirs(name)    Super-rmdir; remove a leaf directory and all empty intermediate    ones.  Works like rmdir except that, if the leaf directory is    successfully removed, directories corresponding to rightmost path    segments will be pruned away until either the whole path is    consumed or an error occurs.  Errors during this latter phase are    ignored -- they generally mean that a directory was not empty.        rmdir(name)    head, tail = path.split(name)    if not tail:        head, tail = path.split(head)    while head and tail:        try:            rmdir(head)        except OSError:            break        head, tail = path.split(head)def renames(old, new):    renames(old, new)    Super-rename; create directories as necessary and delete any left    empty.  Works like rename, except creation of any intermediate    directories needed to make the new pathname good is attempted    first.  After the rename, directories corresponding to rightmost    path segments of the old name will be pruned until either the    whole path is consumed or a nonempty directory is found.    Note: this function can fail with the new directory structure made    if you lack permissions needed to unlink the leaf directory or    file.        head, tail = path.split(new)    if head and tail and not path.exists(head):        makedirs(head)    rename(old, new)    head, tail = path.split(old)    if head and tail:        try:            removedirs(head)        except OSError:            pass__all__.extend([makedirs, removedirs, renames])def walk(top, topdown=True, onerror=None, followlinks=False):    Directory tree generator.    For each directory in the directory tree rooted at top (including top    itself, but excluding . and ..), yields a 3-tuple        dirpath, dirnames, filenames    dirpath is a string, the path to the directory.  dirnames is a list of    the names of the subdirectories in dirpath (excluding . and ..).    filenames is a list of the names of the non-directory files in dirpath.    Note that the names in the lists are just names, with no path components.    To get a full path (which begins with top) to a file or directory in    dirpath, do os.path.join(dirpath, name).    If optional arg topdown is true or not specified, the triple for a    directory is generated before the triples for any of its subdirectories    (directories are generated top down).  If topdown is false, the triple    for a directory is generated after the triples for all of its    subdirectories (directories are generated bottom up).    When topdown is true, the caller can modify the dirnames list in-place    (e.g., via del or slice assignment), and walk will only recurse into the    subdirectories whose names remain in dirnames; this can be used to prune the    search, or to impose a specific order of visiting.  Modifying dirnames when    topdown is false is ineffective, since the directories in dirnames have    already been generated by the time dirnames itself is generated. No matter    the value of topdown, the list of subdirectories is retrieved before the    tuples for the directory and its subdirectories are generated.    By default errors from the os.scandir() call are ignored.  If    optional arg onerror is specified, it should be a function; it    will be called with one argument, an OSError instance.  It can    report the error to continue with the walk, or raise the exception    to abort the walk.  Note that the filename is available as the    filename attribute of the exception object.    By default, os.walk does not follow symbolic links to subdirectories on    systems that support them.  In order to get this functionality, set the    optional argument followlinks to true.    Caution:  if you pass a relative pathname for top, dont change the    current working directory between resumptions of walk.  walk never    changes the current directory, and assumes that the client doesnt    either.    Example:    import os    from os.path import join, getsize    for root, dirs, files in os.walk(pythonLibemail):        print(root, consumes, end=)        print(sum([getsize(join(root, name)) for name in files]), end=)        print(bytes in, len(files), non-directory files)        if CVS in dirs:            dirs.remove(CVS)  # dont visit CVS directories        top = fspath(top)    dirs = []    nondirs = []    walk_dirs = []    # We may not have read permission for top, in which case we cant    # get a list of the files the directory contains.  os.walk    # always suppressed the exception then, rather than blow up for a    # minor reason when (say) a thousand readable directories are still    # left to visit.  That logic is copied here.    try:        # Note that scandir is global in this module due        # to earlier import-*.        scandir_it = scandir(top)    except OSError as error:        if onerror is not None:            onerror(error)        return    with scandir_it:        while True:            try:                try:                    entry = next(scandir_it)                except StopIteration:                    break            except OSError as error:                if onerror is not None:                    onerror(error)                return            try:                is_dir = entry.is_dir()            except OSError:                # If is_dir() raises an OSError, consider that the entry is not                # a directory, same behaviour than os.path.isdir().                is_dir = False            if is_dir:                dirs.append(entry.name)            else:                nondirs.append(entry.name)            if not topdown and is_dir:                # Bottom-up: recurse into sub-directory, but exclude symlinks to                # directories if followlinks is False                if followlinks:                    walk_into = True                else:                    try:                        is_symlink = entry.is_symlink()                    except OSError:                        # If is_symlink() raises an OSError, consider that the                        # entry is not a symbolic link, same behaviour than                        # os.path.islink().                        is_symlink = False                    walk_into = not is_symlink                if walk_into:                    walk_dirs.append(entry.path)    # Yield before recursion if going top down    if topdown:        yield top, dirs, nondirs        # Recurse into sub-directories        islink, join = path.islink, path.join        for dirname in dirs:            new_path = join(top, dirname)            # Issue #23605: os.path.islink() is used instead of caching            # entry.is_symlink() result during the loop on os.scandir() because            # the caller can replace the directory entry during the yield            # above.            if followlinks or not islink(new_path):                yield from walk(new_path, topdown, onerror, followlinks)    else:        # Recurse into sub-directories        for new_path in walk_dirs:            yield from walk(new_path, topdown, onerror, followlinks)        # Yield after recursion if going bottom up        yield top, dirs, nondirs__all__.append(walk)if &#123;open, stat&#125; &lt;= supports_dir_fd and &#123;scandir, stat&#125; &lt;= supports_fd:    def fwalk(top=., topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None):        Directory tree generator.        This behaves exactly like walk(), except that it yields a 4-tuple            dirpath, dirnames, filenames, dirfd        `dirpath`, `dirnames` and `filenames` are identical to walk() output,        and `dirfd` is a file descriptor referring to the directory `dirpath`.        The advantage of fwalk() over walk() is that its safe against symlink        races (when follow_symlinks is False).        If dir_fd is not None, it should be a file descriptor open to a directory,          and top should be relative; top will then be relative to that directory.          (dir_fd is always supported for fwalk.)        Caution:        Since fwalk() yields file descriptors, those are only valid until the        next iteration step, so you should dup() them if you want to keep them        for a longer period.        Example:        import os        for root, dirs, files, rootfd in os.fwalk(pythonLibemail):            print(root, consumes, end=)            print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),                  end=)            print(bytes in, len(files), non-directory files)            if CVS in dirs:                dirs.remove(CVS)  # dont visit CVS directories                if not isinstance(top, int) or not hasattr(top, __index__):            top = fspath(top)        # Note: To guard against symlink races, we use the standard        # lstat()open()fstat() trick.        if not follow_symlinks:            orig_st = stat(top, follow_symlinks=False, dir_fd=dir_fd)        topfd = open(top, O_RDONLY, dir_fd=dir_fd)        try:            if (follow_symlinks or (st.S_ISDIR(orig_st.st_mode) and                                    path.samestat(orig_st, stat(topfd)))):                yield from _fwalk(topfd, top, isinstance(top, bytes),                                  topdown, onerror, follow_symlinks)        finally:            close(topfd)    def _fwalk(topfd, toppath, isbytes, topdown, onerror, follow_symlinks):        # Note: This uses O(depth of the directory tree) file descriptors: if        # necessary, it can be adapted to only require O(1) FDs, see issue        # #13734.        scandir_it = scandir(topfd)        dirs = []        nondirs = []        entries = None if topdown or follow_symlinks else []        for entry in scandir_it:            name = entry.name            if isbytes:                name = fsencode(name)            try:                if entry.is_dir():                    dirs.append(name)                    if entries is not None:                        entries.append(entry)                else:                    nondirs.append(name)            except OSError:                try:                    # Add dangling symlinks, ignore disappeared files                    if entry.is_symlink():                        nondirs.append(name)                except OSError:                    pass        if topdown:            yield toppath, dirs, nondirs, topfd        for name in dirs if entries is None else zip(dirs, entries):            try:                if not follow_symlinks:                    if topdown:                        orig_st = stat(name, dir_fd=topfd, follow_symlinks=False)                    else:                        assert entries is not None                        name, entry = name                        orig_st = entry.stat(follow_symlinks=False)                dirfd = open(name, O_RDONLY, dir_fd=topfd)            except OSError as err:                if onerror is not None:                    onerror(err)                continue            try:                if follow_symlinks or path.samestat(orig_st, stat(dirfd)):                    dirpath = path.join(toppath, name)                    yield from _fwalk(dirfd, dirpath, isbytes,                                      topdown, onerror, follow_symlinks)            finally:                close(dirfd)        if not topdown:            yield toppath, dirs, nondirs, topfd    __all__.append(fwalk)# Make sure os.environ exists, at leasttry:    environexcept NameError:    environ = &#123;&#125;def execl(file, *args):    execl(file, *args)    Execute the executable file with argument list args, replacing the    current process.     execv(file, args)def execle(file, *args):    execle(file, *args, env)    Execute the executable file with argument list args and    environment env, replacing the current process.     env = args[-1]    execve(file, args[:-1], env)def execlp(file, *args):    execlp(file, *args)    Execute the executable file (which is searched for along $PATH)    with argument list args, replacing the current process.     execvp(file, args)def execlpe(file, *args):    execlpe(file, *args, env)    Execute the executable file (which is searched for along $PATH)    with argument list args and environment env, replacing the current    process.     env = args[-1]    execvpe(file, args[:-1], env)def execvp(file, args):    execvp(file, args)    Execute the executable file (which is searched for along $PATH)    with argument list args, replacing the current process.    args may be a list or tuple of strings.     _execvpe(file, args)def execvpe(file, args, env):    execvpe(file, args, env)    Execute the executable file (which is searched for along $PATH)    with argument list args and environment env , replacing the    current process.    args may be a list or tuple of strings.     _execvpe(file, args, env)__all__.extend([execl,execle,execlp,execlpe,execvp,execvpe])def _execvpe(file, args, env=None):    if env is not None:        exec_func = execve        argrest = (args, env)    else:        exec_func = execv        argrest = (args,)        env = environ    if path.dirname(file):        exec_func(file, *argrest)        return    saved_exc = None    path_list = get_exec_path(env)    if name != nt:        file = fsencode(file)        path_list = map(fsencode, path_list)    for dir in path_list:        fullname = path.join(dir, file)        try:            exec_func(fullname, *argrest)        except (FileNotFoundError, NotADirectoryError) as e:            last_exc = e        except OSError as e:            last_exc = e            if saved_exc is None:                saved_exc = e    if saved_exc is not None:        raise saved_exc    raise last_excdef get_exec_path(env=None):    Returns the sequence of directories that will be searched for the    named executable (similar to a shell) when launching a process.    *env* must be an environment variable dict or None.  If *env* is None,    os.environ will be used.        # Use a local import instead of a global import to limit the number of    # modules loaded at startup: the os module is always loaded at startup by    # Python. It may also avoid a bootstrap issue.    import warnings    if env is None:        env = environ    # &#123;bPATH: ...&#125;.get(PATH) and &#123;PATH: ...&#125;.get(bPATH) emit a    # BytesWarning when using python -b or python -bb: ignore the warning    with warnings.catch_warnings():        warnings.simplefilter(ignore, BytesWarning)        try:            path_list = env.get(PATH)        except TypeError:            path_list = None        if supports_bytes_environ:            try:                path_listb = env[bPATH]            except (KeyError, TypeError):                pass            else:                if path_list is not None:                    raise ValueError(                        env cannot contain PATH and bPATH keys)                path_list = path_listb            if path_list is not None and isinstance(path_list, bytes):                path_list = fsdecode(path_list)    if path_list is None:        path_list = defpath    return path_list.split(pathsep)# Change environ to automatically call putenv(), unsetenv if they exist.from _collections_abc import MutableMappingclass _Environ(MutableMapping):    def __init__(self, data, encodekey, decodekey, encodevalue, decodevalue, putenv, unsetenv):        self.encodekey = encodekey        self.decodekey = decodekey        self.encodevalue = encodevalue        self.decodevalue = decodevalue        self.putenv = putenv        self.unsetenv = unsetenv        self._data = data    def __getitem__(self, key):        try:            value = self._data[self.encodekey(key)]        except KeyError:            # raise KeyError with the original key value            raise KeyError(key) from None        return self.decodevalue(value)    def __setitem__(self, key, value):        key = self.encodekey(key)        value = self.encodevalue(value)        self.putenv(key, value)        self._data[key] = value    def __delitem__(self, key):        encodedkey = self.encodekey(key)        self.unsetenv(encodedkey)        try:            del self._data[encodedkey]        except KeyError:            # raise KeyError with the original key value            raise KeyError(key) from None    def __iter__(self):        # list() from dict object is an atomic operation        keys = list(self._data)        for key in keys:            yield self.decodekey(key)    def __len__(self):        return len(self._data)    def __repr__(self):        return environ(&#123;&#123;&#123;&#125;&#125;&#125;).format(, .join(            (&#123;!r&#125;: &#123;!r&#125;.format(self.decodekey(key), self.decodevalue(value))            for key, value in self._data.items())))    def copy(self):        return dict(self)    def setdefault(self, key, value):        if key not in self:            self[key] = value        return self[key]try:    _putenv = putenvexcept NameError:    _putenv = lambda key, value: Noneelse:    if putenv not in __all__:        __all__.append(putenv)try:    _unsetenv = unsetenvexcept NameError:    _unsetenv = lambda key: _putenv(key, )else:    if unsetenv not in __all__:        __all__.append(unsetenv)def _createenviron():    if name == nt:        # Where Env Var Names Must Be UPPERCASE        def check_str(value):            if not isinstance(value, str):                raise TypeError(str expected, not %s % type(value).__name__)            return value        encode = check_str        decode = str        def encodekey(key):            return encode(key).upper()        data = &#123;&#125;        for key, value in environ.items():            data[encodekey(key)] = value    else:        # Where Env Var Names Can Be Mixed Case        encoding = sys.getfilesystemencoding()        def encode(value):            if not isinstance(value, str):                raise TypeError(str expected, not %s % type(value).__name__)            return value.encode(encoding, surrogateescape)        def decode(value):            return value.decode(encoding, surrogateescape)        encodekey = encode        data = environ    return _Environ(data,        encodekey, decode,        encode, decode,        _putenv, _unsetenv)# unicode environenviron = _createenviron()del _createenvirondef getenv(key, default=None):    Get an environment variable, return None if it doesnt exist.    The optional second argument can specify an alternate default.    key, default and the result are str.    return environ.get(key, default)supports_bytes_environ = (name != nt)__all__.extend((getenv, supports_bytes_environ))if supports_bytes_environ:    def _check_bytes(value):        if not isinstance(value, bytes):            raise TypeError(bytes expected, not %s % type(value).__name__)        return value    # bytes environ    environb = _Environ(environ._data,        _check_bytes, bytes,        _check_bytes, bytes,        _putenv, _unsetenv)    del _check_bytes    def getenvb(key, default=None):        Get an environment variable, return None if it doesnt exist.        The optional second argument can specify an alternate default.        key, default and the result are bytes.        return environb.get(key, default)    __all__.extend((environb, getenvb))def _fscodec():    encoding = sys.getfilesystemencoding()    errors = sys.getfilesystemencodeerrors()    def fsencode(filename):        Encode filename (an os.PathLike, bytes, or str) to the filesystem        encoding with surrogateescape error handler, return bytes unchanged.        On Windows, use strict error handler if the file system encoding is        mbcs (which is the default encoding).                filename = fspath(filename)  # Does type-checking of `filename`.        if isinstance(filename, str):            return filename.encode(encoding, errors)        else:            return filename    def fsdecode(filename):        Decode filename (an os.PathLike, bytes, or str) from the filesystem        encoding with surrogateescape error handler, return str unchanged. On        Windows, use strict error handler if the file system encoding is        mbcs (which is the default encoding).                filename = fspath(filename)  # Does type-checking of `filename`.        if isinstance(filename, bytes):            return filename.decode(encoding, errors)        else:            return filename    return fsencode, fsdecodefsencode, fsdecode = _fscodec()del _fscodec# Supply spawn*() (probably only for Unix)if _exists(fork) and not _exists(spawnv) and _exists(execv):    P_WAIT = 0    P_NOWAIT = P_NOWAITO = 1    __all__.extend([P_WAIT, P_NOWAIT, P_NOWAITO])    # XXX Should we support P_DETACH?  I suppose it could fork()**2    # and close the std IO streams.  Also, P_OVERLAY is the same    # as execv*()?    def _spawnvef(mode, file, args, env, func):        # Internal helper; func is the exec*() function to use        if not isinstance(args, (tuple, list)):            raise TypeError(argv must be a tuple or a list)        if not args or not args[0]:            raise ValueError(argv first element cannot be empty)        pid = fork()        if not pid:            # Child            try:                if env is None:                    func(file, args)                else:                    func(file, args, env)            except:                _exit(127)        else:            # Parent            if mode == P_NOWAIT:                return pid # Caller is responsible for waiting!            while 1:                wpid, sts = waitpid(pid, 0)                if WIFSTOPPED(sts):                    continue                elif WIFSIGNALED(sts):                    return -WTERMSIG(sts)                elif WIFEXITED(sts):                    return WEXITSTATUS(sts)                else:                    raise OSError(Not stopped, signaled or exited???)    def spawnv(mode, file, args):        spawnv(mode, file, args) -&gt; integerExecute file with arguments from args in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return _spawnvef(mode, file, args, None, execv)    def spawnve(mode, file, args, env):        spawnve(mode, file, args, env) -&gt; integerExecute file with arguments from args in a subprocess with thespecified environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return _spawnvef(mode, file, args, env, execve)    # Note: spawnvp[e] isnt currently supported on Windows    def spawnvp(mode, file, args):        spawnvp(mode, file, args) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return _spawnvef(mode, file, args, None, execvp)    def spawnvpe(mode, file, args, env):        spawnvpe(mode, file, args, env) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return _spawnvef(mode, file, args, env, execvpe)    __all__.extend([spawnv, spawnve, spawnvp, spawnvpe])if _exists(spawnv):    # These arent supplied by the basic Windows code    # but can be easily implemented in Python    def spawnl(mode, file, *args):        spawnl(mode, file, *args) -&gt; integerExecute file with arguments from args in a subprocess.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return spawnv(mode, file, args)    def spawnle(mode, file, *args):        spawnle(mode, file, *args, env) -&gt; integerExecute file with arguments from args in a subprocess with thesupplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         env = args[-1]        return spawnve(mode, file, args[:-1], env)    __all__.extend([spawnl, spawnle])if _exists(spawnvp):    # At the moment, Windows doesnt implement spawnvp[e],    # so it wont have spawnlp[e] either.    def spawnlp(mode, file, *args):        spawnlp(mode, file, *args) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         return spawnvp(mode, file, args)    def spawnlpe(mode, file, *args):        spawnlpe(mode, file, *args, env) -&gt; integerExecute file (which is looked for along $PATH) with arguments fromargs in a subprocess with the supplied environment.If mode == P_NOWAIT return the pid of the process.If mode == P_WAIT return the processs exit code if it exits normally;otherwise return -SIG, where SIG is the signal that killed it.         env = args[-1]        return spawnvpe(mode, file, args[:-1], env)    __all__.extend([spawnlp, spawnlpe])# Supply os.popen()def popen(cmd, mode=r, buffering=-1):    if not isinstance(cmd, str):        raise TypeError(invalid cmd type (%s, expected string) % type(cmd))    if mode not in (r, w):        raise ValueError(invalid mode %r % mode)    if buffering == 0 or buffering is None:        raise ValueError(popen() does not support unbuffered streams)    import subprocess, io    if mode == r:        proc = subprocess.Popen(cmd,                                shell=True,                                stdout=subprocess.PIPE,                                bufsize=buffering)        return _wrap_close(io.TextIOWrapper(proc.stdout), proc)    else:        proc = subprocess.Popen(cmd,                                shell=True,                                stdin=subprocess.PIPE,                                bufsize=buffering)        return _wrap_close(io.TextIOWrapper(proc.stdin), proc)# Helper for popen() -- a proxy for a file whose close waits for the processclass _wrap_close:    def __init__(self, stream, proc):        self._stream = stream        self._proc = proc    def close(self):        self._stream.close()        returncode = self._proc.wait()        if returncode == 0:            return None        if name == nt:            return returncode        else:            return returncode &lt;&lt; 8  # Shift left to match old behavior    def __enter__(self):        return self    def __exit__(self, *args):        self.close()    def __getattr__(self, name):        return getattr(self._stream, name)    def __iter__(self):        return iter(self._stream)# Supply os.fdopen()def fdopen(fd, *args, **kwargs):    if not isinstance(fd, int):        raise TypeError(invalid fd type (%s, expected integer) % type(fd))    import io    return io.open(fd, *args, **kwargs)# For testing purposes, make sure the function is available when the C# implementation exists.def _fspath(path):    Return the path representation of a path-like object.    If str or bytes is passed in, it is returned unchanged. Otherwise the    os.PathLike interface is used to get the path representation. If the    path representation is not str or bytes, TypeError is raised. If the    provided path is not str, bytes, or os.PathLike, TypeError is raised.        if isinstance(path, (str, bytes)):        return path    # Work from the objects type to match method resolution of other magic    # methods.    path_type = type(path)    try:        path_repr = path_type.__fspath__(path)    except AttributeError:        if hasattr(path_type, __fspath__):            raise        else:            raise TypeError(expected str, bytes or os.PathLike object,                             not  + path_type.__name__)    if isinstance(path_repr, (str, bytes)):        return path_repr    else:        raise TypeError(expected &#123;&#125;.__fspath__() to return str or bytes,                         not &#123;&#125;.format(path_type.__name__,                                        type(path_repr).__name__))# If there is no C implementation, make the pure Python version the# implementation as transparently as possible.if not _exists(fspath):    fspath = _fspath    fspath.__name__ = fspathclass PathLike(abc.ABC):    Abstract base class for implementing the file system path protocol.    @abc.abstractmethod    def __fspath__(self):        Return the file system path representation of the object.        raise NotImplementedError    @classmethod    def __subclasshook__(cls, subclass):        return hasattr(subclass, __fspath__)\n\n","tags":["python"],"path":"2019/09/27/os-py/","external_link":""},{"title":"Desition Tree","date":"2019-09-27T06:52:07.000Z","content":"目录\n1. 什么是决策树\n1.1 决策树的基本思想\n1.2 “树”的成长过程\n1.3 “树”怎么长\n1.3.1 ID3算法\n1.3.2 C4.5\n1.3.3 CART算法\n1.3.4 三种不同的决策树\n\n\n2. 树形结构为什么不需要归一化?\n3. 分类决策树和回归决策树的区别\n4. 决策树如何剪枝\n5. 代码实现\n\n1. 什么是决策树1.1 决策树的基本思想其实用一下图片能更好的理解LR模型和决策树模型算法的根本区别，我们可以思考一下一个决策问题：是否去相亲，一个女孩的母亲要给这个女海介绍对象。\n\n大家都看得很明白了吧！LR模型是一股脑儿的把所有特征塞入学习，而决策树更像是编程语言中的if-else一样，去做条件判断，这就是根本性的区别。\n1.2 “树”的成长过程决策树基于“树”结构进行决策的，这时我们就要面临两个问题 ：\n\n“树”怎么长。\n这颗“树”长到什么时候停。\n\n弄懂了这两个问题，那么这个模型就已经建立起来了，决策树的总体流程是“分而治之”的思想，一是自根至叶的递归过程，一是在每个中间节点寻找一个“划分”属性，相当于就是一个特征属性了。接下来我们来逐个解决以上两个问题。\n这颗“树”长到什么时候停\n当前结点包含的样本全属于同一类别，无需划分；例如：样本当中都是决定去相亲的，属于同一类别，就是不管特征如何改变都不会影响结果，这种就不需要划分了。\n当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；例如：所有的样本特征都是一样的，就造成无法划分了，训练集太单一。\n当前结点包含的样本集合为空，不能划分。\n\n1.3 “树”怎么长在生活当中，我们都会碰到很多需要做出决策的地方，例如：吃饭地点、数码产品购买、旅游地区等，你会发现在这些选择当中都是依赖于大部分人做出的选择，也就是跟随大众的选择。其实在决策树当中也是一样的，当大部分的样本都是同一类的时候，那么就已经做出了决策。\n我们可以把大众的选择抽象化，这就引入了一个概念就是纯度，想想也是如此，大众选择就意味着纯度越高。好，在深入一点，就涉及到一句话：信息熵越低，纯度越高。我相信大家或多或少都听说过“熵”这个概念，信息熵通俗来说就是用来度量包含的“信息量”，如果样本的属性都是一样的，就会让人觉得这包含的信息很单一，没有差异化，相反样本的属性都不一样，那么包含的信息量就很多了。\n一到这里就头疼了，因为马上要引入信息熵的公式，其实也很简单：\n\nPk表示的是：当前样本集合D中第k类样本所占的比例为Pk。\n信息增益\n废话不多说直接上公式：\n\n看不懂的先不管，简单一句话就是：划分前的信息熵–划分后的信息熵。表示的是向纯度方向迈出的“步长”。\n好了，有了前面的知识，我们就可以开始“树”的生长了。\n1.3.1 ID3算法解释：在根节点处计算信息熵，然后根据属性依次划分并计算其节点的信息熵，用根节点信息熵–属性节点的信息熵=信息增益，根据信息增益进行降序排列，排在前面的就是第一个划分属性，其后依次类推，这就得到了决策树的形状，也就是怎么“长”了。\n如果不理解的，可以查看我分享的图片示例，结合我说的，包你看懂：\n\n第一张图.jpg\n第二张图.jpg\n第三张图.jpg\n第四张图.jpg\n\n不过，信息增益有一个问题：对可取值数目较多的属性有所偏好，例如：考虑将“编号”作为一个属性。为了解决这个问题，引出了另一个 算法C4.5。\n1.3.2 C4.5为了解决信息增益的问题，引入一个信息增益率：\n\n其中：\n\n属性a的可能取值数目越多(即V越大)，则IV(a)的值通常就越大。信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。不过有一个缺点：\n\n缺点：信息增益率偏向取值较少的特征。\n\n使用信息增益率：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。\n1.3.3 CART算法数学家真实聪明，想到了另外一个表示纯度的方法，叫做基尼指数(讨厌的公式)：\n\n表示在样本集合中一个随机选中的样本被分错的概率。举例来说，现在一个袋子里有3种颜色的球若干个，伸手进去掏出2个球，颜色不一样的概率，这下明白了吧。Gini(D)越小，数据集D的纯度越高。\n举个例子假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”，\n当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下：\n1.划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士}\n2.划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士}\n3.划分点： “硕士”，划分后的子集合 ： {博士}，{本科，硕士}}\n对于上述的每一种划分，都可以计算出基于 划分特征= 某个特征值 将样本集合D划分为两个子集的纯度：\n\n因而对于一个具有多个取值（超过2个）的特征，需要计算以每一个取值作为划分点，对样本D划分之后子集的纯度Gini(D,Ai)，(其中Ai 表示特征A的可能取值)\n然后从所有的可能划分的Gini(D,Ai)中找出Gini指数最小的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。到此就可以长成一棵“大树”了。\n1.3.4 三种不同的决策树\nID3：取值多的属性，更容易使数据更纯，其信息增益更大。\n训练得到的是一棵庞大且深度浅的树：不合理。\n\nC4.5：采用信息增益率替代信息增益。\n\nCART：以基尼系数替代熵，最小化不纯度，而不是最大化信息增益。\n\n\n2. 树形结构为什么不需要归一化?因为数值缩放不影响分裂点位置，对树模型的结构不造成影响。按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。而且，树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。\n既然树形结构（如决策树、RF）不需要归一化，那为何非树形结构比如Adaboost、SVM、LR、Knn、KMeans之类则需要归一化。\n对于线性模型，特征值差别很大时，运用梯度下降的时候，损失等高线是椭圆形，需要进行多次迭代才能到达最优点。但是如果进行了归一化，那么等高线就是圆形的，促使SGD往原点迭代，从而导致需要的迭代次数较少。\n3. 分类决策树和回归决策树的区别Classification And Regression Tree(CART)是决策树的一种，CART算法既可以用于创建分类树（Classification Tree），也可以用于创建回归树（Regression Tree），两者在建树的过程稍有差异。\n回归树：\nCART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第j个特征值进行分裂的，设该特征值小于s的样本划分为左子树，大于s的样本划分为右子树。 \n\n而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：\n\n因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数：\n\n所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。\n参考文章：经典算法详解–CART分类决策树、回归树和模型树\n4. 决策树如何剪枝决策树的剪枝基本策略有 预剪枝 (Pre-Pruning) 和 后剪枝 (Post-Pruning)。\n\n预剪枝：其中的核心思想就是，在每一次实际对结点进行进一步划分之前，先采用验证集的数据来验证如果划分是否能提高划分的准确性。如果不能，就把结点标记为叶结点并退出进一步划分；如果可以就继续递归生成节点。\n后剪枝：后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点。\n\n参考文章：决策树及决策树生成与剪枝\n5. 代码实现GitHub：https:github.comNLP-LOVEML-NLPblobmasterMachine%20Learning3.Desition%20TreeDecisionTree.ipynb\n\n\n作者：@mantchs\nGitHub：https:github.comNLP-LOVEML-NLP\n欢迎大家加入讨论！共同完善此项目！群号：【541954936】\n\n","tags":["机器学习","Tree"],"path":"2019/09/27/Desition-Tree/","external_link":""},{"title":"Recommendation System","date":"2019-09-27T06:56:13.000Z","content":"目录\n1. 什么是推荐系统\n2. 总体架构\n2.1 离线推荐\n2.2 在线训练\n\n\n3. 特征数据\n4. 协同过滤算法\n4.1 基于物品的协同过滤(ItemCF)\n4.2 基于用户的协同过滤(UserCF)\n4.3 矩阵分解\n\n\n5. 隐语义模型\n5.1 基本思想\n5.2 模型理解\n\n\n6. 排序算法\n7. 评估测试\n7.1 AB测试\n7.2 其它评估方法\n\n\n8. 推荐系统冷启动问题\n8.1 用户冷启动\n8.2 物品冷启动\n8.3 系统冷启动\n\n\n9. 参考文献\n\n1. 什么是推荐系统推荐系统是利用电子商务网站向客户提供商品信息和建议，帮助用户决定应该购买什么产品，模拟销售人员帮助客户完成购买过程。个性化推荐是根据用户的兴趣特点和购买行为，向用户推荐用户感兴趣的信息和商品。\n随着电子商务规模的不断扩大，商品个数和种类快速增长，顾客需要花费大量的时间才能找到自己想买的商品。这种浏览大量无关的信息和产品过程无疑会使淹没在信息过载问题中的消费者不断流失。\n为了解决这些问题，个性化推荐系统应运而生。个性化推荐系统是建立在海量数据挖掘基础上的一种高级商务智能平台，以帮助电子商务网站为其顾客购物提供完全个性化的决策支持和信息服务。\n常见的推荐栏位例如：淘宝的猜你喜欢、看了又看、推荐商品，美团的首页推荐、附近推荐等。\n推荐系统是比较偏向于工程类的系统，要做得更加的精确，需要的不仅仅是推荐算法，还有用户意图识别、文本分析、行为分析等，是一个综合性很强的系统。\n2. 总体架构本节介绍的几种推荐系统架构，并不是互相独立的关系，实际的推荐系统可能会用到其中一种或者几种的架构。在实际设计的过程中，读者可以把本文介绍的架构作为一个设计的起点，更多地结合自身业务特点进行独立思考，从而设计出适合自身业务的系统。\n根据响应用户行为的速度不同，推荐系统可以大致分为基于离线训练和在线训练的推荐系统。\n2.1 离线推荐于离线训练的推荐系统架构是最常见的一种推荐系统架构。这里的“离线”训练指的是使用历史一段时间（ 比如周或者几周 ）的数据进行训练，模型迭代的周期较长（一般 以小时为单位 ）。模型拟合的是用户的中长期兴趣。\n如下图所示， 一个典型的基于离线训练的推荐系统架构由数据上报、离线训练、在线存储、实时计算和 AB 测试这几个模块组成。其中，数据上报和离线训练组成了监督学习中的学习系统，而实时计算和 AB 测试组成了预测系统。另外，除了模型之外，还有一个在线存储模块，用于存储模型和模型需要的特征信息供实时计算模块调用。图中的各个模块组成了训练和预测两条数据流，训练的数据流搜集业务的数据最后生成模型存储于在线存储模块；预测的数据流接受业务的预测请求，通过 AB 测试模块访问实时计算模块获取预测结果。\n\n\n数据上报：据上报模块的作用是搜集业务数据组成训练样本。一般分为收集、验证、清洗和转换几个步骤。将收集的数据转化为训练所需要的样本格式，保存到离线存储模块。\n\n\n离线训练：线训练模块又细分为离线存储和离线计算。实际业务中使用的推荐系统一般都需要处理海量的用户行为数据，所以离线存储模块需要有一个分布式的文件系统或者存储平台来存储这些数据。离线计算常见的操作有：样本抽样、特征工程、模型训练、相似度计算等。\n\n在线存储：因为线上的服务对于时延都有严格的要求。比如，某个用户打开手机 APP ，他肯定希望APP 能够快速响应，如果耗时过长，就会影响用户的体验。一般来说，这就要求推荐系统在几十毫秒以内处理完用户请求返回推荐结果，所以，针对线上的服务，需要有一个专门的在线存储模块，负责存储用于线上的模型和特征数据 。\n\n实时推荐：实时推荐模块的功能是对来自业务的新请求进行预测。1.获取用户特征；2.调用推荐模型；3.结果排序。\n在实际应用中，因为业务的物品列表太大，如果实时计算对每 个物品使用复杂的模型进行打分，就有可能耗时过长而影响用户满意度。所以，一种常见的做法是将推荐列表生成分为召回和排序两步。召回的作用是从大量的候选物品中（例如上百万）筛选出一批用户较可能喜欢的候选集 （一般是几百）。排序的作用是对召回得到的相对较小的候选集使用排序模型进行打分。更进一步，在排序得到推荐列表后，为了多样性和运营的一些考虑，还会加上第三步重排过滤，用于对精排后的推荐列表进行处理。\n\n\nAB测试：对于互联网产品来说， AB 测试基本上是一个必备的模块，对于推荐系统来说也不例外，它可以帮助开发人员评估新算法对客户行为的影响。除了 离线的指标外，一个新的推荐算法上线之前 般都会经过 AB 测试来测试新算法的有效性。\n\n\n下图是与之对应的实际系统中各个组件的流转过程。需要注意的是生成推荐列表就已经做完了召回和排序的操作，业务层直接调用API就可以得到这个推荐列表。\n\n2.2 在线训练对于业务来说，我们希望用户对于上 个广告的反馈 （喜欢或者不 欢，有没有点击 ，可以很快地用于下一个广告的推荐中。这就要求我们用另 种方法来解决这个问题，这个方法就是在线训练。\n基于在线训练的推荐系统架构适合于广告和电商等高维度大数据量且对实时性要求很高的场景 相比较基于离线训练的推荐系统，基于在线训练的推荐系统不区分训练和测试阶段，每个回合都在学习，通过实时的反馈来调整策略。 方面，在线训练要求其样本、特征和模型的处理都是实时的，以便推荐的内容更快地反映用户实时的喜好；另一方面，因为在线训练井不需要将所有的训练数据都存储下来，所以不需要巨大的离线存储开销，使得系统具有很好的伸缩性，可以支持超大的数据量和模型。\n\n\n样本处理：和基于离线训练的推荐系统相比，在线训练在数据上报阶段的主要不同体现在样本处理上。，对于离线训练来说，上报后的数据先是被存储到一个分布式文件系统，然后等待离线计算任务来对样本进行处理；对于在线训练来说，对样本的去重、过滤和采样等计算都需要实时进行。\n实时特性：实时特征模块通过实时处理样本数据拼接训练需要的特征构造训练样本，输入流式训练模块用于更新模型。该模块的主要的功能是特征拼接和特征工程。\n流式训练：、流式训练模块的主要作用是使用实时训练样本来更新模型。推荐算法中增量更新部分的计算，通过流式计算的方式来进行更新。在线训练的优势之一，是可以支持模型的稀疏存储。训练方面，在线模型不一定都是从零开始训练，而是可以将离线训练得到的模型参数作为基础，在这个基础上进行增量训练。\n模型存储和加载：模型一般存储在参数服务器中。模型更新后，将模型文件推送到线上存储，并由线上服务模块动态加载。\n\n3. 特征数据要训练推荐模型，就需要先收集用户的行为数据生成特征向量以后才能进行训练，而一个特征向量由特征以及特征的权重组成，在利用用户行为计算特征向量时需要考虑以下因素。\n\n用户行为的种类：在一个网站中，用户可以对物品产生很多不同种类的行为。用户可以浏览物品、单击物品的链接、收藏物品、给物品打分、购买物品、评论物品、给物品打上不同的标签、和好友分享物品、搜索不同的关键词等。这些行为都会对物品特征的权重产生影响，但不同行为的影响不同，大多时候很难确定什么行为更加重要，一般的标准就是用户付出代价越大的行为权重越高。\n用户行为产生的时间：一般来说，用户近期的行为比较重要，而用户很久之前的行为相对比较次要。因此，如果用户最近购买过某一个物品，那么这个物品对应的特征将会具有比较高的权重。\n用户行为的次数：有时用户对一个物品会产生很多次行为。比如用户会听一首歌很多次，看一部电视剧的很多集等。因此用户对同一个物品的同一种行为发生的次数也反映了用户对物品的兴趣，行为次数多的物品对应的特征权重越高。\n物品的热门程度：如果用户对一个很热门的物品产生了行为，往往不能代表用户的个性，因为用户可能是在跟风，可能对该物品并没有太大兴趣，特别是在用户对一个热门物品产生了偶尔几次不重要的行为（比如浏览行为）时，就更说明用户对这个物品可能没有什么兴趣，可能只是因为这个物品的链接到处都是，很容易点到而已。反之，如果用户对一个不热门的物品产生了行为，就说明了用户的个性需求。因此，推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重。\n数据去燥：对样本做去噪。对于数据中混杂的刷单等类作弊行为的数据，要将其排除出训练数据,否则它会直接影响模型的效果；样本中的缺失值也要做处理。\n正负样本均衡：一般我们收集用户的行为数据都是属于正样本，造成了严重的不平衡。所以对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。\n特征组合：我们需要考虑特征与特征之间的关系。例如在美团酒店搜索排序中，酒店的销量、价格、用户的消费水平等是强相关的因素，用户的年龄、位置可能是弱相关的因素，用户的ID是完全无关的因素。在确定了哪些因素可能与预测目标相关后，我们需要将此信息表示为数值类型,即为特征抽取的过程。除此之外，用户在App上的浏览、交易等行为记录中包含了大量的信息，特征抽取则主要是从这些信息抽取出相关因素，用数值变量进行表示。常用的统计特征有计数特征,如浏览次数、下单次数等;比率特征，如点击率、转化率等;统计量特征，如价格均值、标准差、分位数、偏度、峰度等。\n\n4. 协同过滤算法协同过滤算法起源于 1992 年，被 Xerox 公司用于个性化定制邮件系统。Xerox 司的用户需要在数十种主题中选择三到五种主题，协同过滤算法根据不同的主题过滤邮件，最终达到个性化的目的。\n协同过滤算法分为基于物品的协同过滤和基于用户的协同过滤，输出结果为 TOPn 的推荐列表。\n4.1 基于物品的协同过滤(ItemCF)基于物品的协同过滤算法的核心思想：给用户推荐那些和他们之前喜欢的物品相似的物品。\n基于物品的协同过滤算法首先计算物品之间的相似度， 计算相似度的方法有以下几种：\n\n基于共同喜欢物品的用户列表计算\n\n在此，分母中 N(i) 是购买物品 i 的用户数，N(j) 是购买物品 j 的用户数，而分子 是同时购买物品i 和物品 j 的用户数。。可见上述的公式的核心是计算同时购买这件商品的人数比例 。当同时购买这两个物品人数越多，他们的相似度也就越高。另外值得注意的是，在分母中我们用了物品总购买人数做惩罚，也就是说某个物品可能很热门，导致它经常会被和其他物品一起购买，所以除以它的总购买人数，来降低它和其他物品的相似分数。\n\n基于余弦的相似度计算\n上面的方法计算物品相似度是直接使同时购买这两个物品的人数。但是也有可能存在用户购买了但不喜欢的情况 所以如果数据集包含了具体的评分数据 我们可以进一步把用户评分引入到相似度计算中 。\n\n其中 是用户 k 对物品 i 的评分，如果没有评分则为 0。\n\n热门物品的惩罚\n对于热门物品的问题，可以用如下公式解决：\n\n当 时，N(i) 越小，惩罚得越厉害，从而会使热 物品相关性分数下降。\n\n\n4.2 基于用户的协同过滤(UserCF)基于用户的协同过滤（User CF ）的原理其实是和基于物品的协同过滤类似的。所不同的是，基于物品的协同过滤的原理是用户 U 购买了 A 物品，推荐给用户 U 和 A 相似的物品 B、C、D。而基于用户的协同过滤，是先计算用户 U 与其他的用户的相似度，然后取和 U 最相似的几个用户，把他们购买过的物品推荐给用户U。\n为了计算用户相似度，我们首先要把用户购买过物品的索引数据转化成物品被用户购买过的索引数据，即物品的倒排索引：\n\n建立好物品的倒排索引后，就可以根据相似度公式计算用户之间的相似度：\n\n其中 N(a) 表示用户 a 购买物品的数量，N(b) 表示用户 b 购买物品的数量，N(a)∩N(b) 表示用户 a 和 b 购买相同物品的数量。有了用户的相似数据，针对用户 U 挑选 K 个最相似的用户，把他们购买过的物品中，U 未购买过的物品推荐给用户 U 即可。\n4.3 矩阵分解上述计算会得到一个相似度矩阵，而这个矩阵的大小和纬度都是很大的，需要进行降维处理，用到的是SVD的降维方法，具体可以参考我之前写的降维方法：2.5 降维方法\n基于稀疏自编码的矩阵分解\n矩阵分解技术在推荐领域的应用比较成熟，但是通过上一节的介绍，我们不难发现矩阵分解本质上只通过一次分解来对 原矩阵进行逼近，特征挖掘的层次不够深入。另外矩阵分解也没有运用到物品本身的内容特征，例如书本的类别分类、音乐的流派分类等。随着神经网络技术的兴起，笔者发现通过多层感知机，可以得到更加深度的特征表示，并且可以对内容分类特征加以应用。首先，我们介绍一下稀疏自编码神经网络的设计思路。\n\n基础的自编码结构\n最简单的自编码结构如下图，构造个三层的神经网络，我们让输出层等于输入层，且中间层的维度远低于输入层和输出层，这样就得到了第一层的特征压缩。\n\n简单来说自编码神经网络尝试学习中间层约等于输入层的函数。换句话说，它尝试逼近一个恒等函数。如果网络的输入数据是完全随机的，比如每一个输入都是一个跟其他特征完全无关的独立同分布高斯随机变 ，那么这一压缩表示将会非常难于学习。但是如果输入数据中隐含着 些特定的结构，比如某些输入特征是彼此相关的，那么这一算法就可以发现输入数据中的这些相关性。\n\n多层结构\n基于以上的单层隐藏层的网络结构，我们可以扩展至多层网络结构，学习到更高层次的抽象特征。\n\n\n\n5. 隐语义模型5.1 基本思想推荐系统中一个重要的分支，隐语义建模。隐语义模型LFM：Latent Factor Model，其核心思想就是通过隐含特征联系用户兴趣和物品。\n过程分为三个部分，将物品映射到隐含分类，确定用户对隐含分类的兴趣，然后选择用户感兴趣的分类中的物品推荐给用户。它是基于用户行为统计的自动聚类。\n隐语义模型在Top-N推荐中的应用十分广泛。常用的隐语义模型，LSA(Latent Semantic Analysis)，LDA(Latent Dirichlet Allocation)，主题模型(Topic Model)，矩阵分解(Matrix Factorization)等等。\n首先通过一个例子来理解一下这个模型，比如说有两个用户A和B，目前有用户的阅读列表，用户A的兴趣涉及侦探小说，科普图书以及一些计算机技术书，而用户B的兴趣比较集中在数学和机器学习方面。那么如何给A和B推荐图书呢？\n对于UserCF，首先需要找到和他们看了同样书的其他用户(兴趣相似的用户)，然后在给他们推荐那些用户喜欢的其他书。对于ItemCF,需要给他们推荐和他们已经看的书相似的书，比如用户B 看了很多数据挖掘方面的书，那么可以给他推荐机器学习或者模式识别方面的书。\n还有一种方法就是使用隐语义模型，可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。\n5.2 模型理解\n如何给物品进行分类？\n如何确定用户对哪些类的物品感兴趣，以及感兴趣的程度？\n对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何确定这些物品在一个类中的权重？\n\n为了解决上面的问题，研究人员提出：为什么我们不从数据出发，自动地找到那些类，然后进行个性化推荐，隐语义分析技术因为采取基于用户行为统计的自动聚类，较好地解决了上面的问题。隐语义分析技术从诞生到今天产生了很多著名的模型和方法，其中和推荐技术相关的有pLSA，LDA，隐含类别模型（latent class model）, 隐含主题模型（latent topic model）, 矩阵分解（matrix factorization）。\nLFM通过如下公式计算用户 u 对物品 i 的兴趣：\n\n这个公式中 和 是模型的参数，其中 度量了用户 u 的兴趣和第 k 个隐类的关系，而 度量了第 k 个隐类和物品 i 之间的关系。那么，下面的问题就是如何计算这两个参数。\n对最优化理论或者机器学习有所了解的读者，可能对如何计算这两个参数都比较清楚。这两个参数是从数据集中计算出来的。要计算这两个参数，需要一个训练集，对于每个用户u，训练集里都包含了用户u喜欢的物品和不感兴趣的物品，通过学习这个数据集，就可以获得上面的模型参数。\n6. 排序算法在工业应用中，推荐系统通常可分为两部分，召回和排序。协同过滤属于召回的算法，从召回中得到一个比较小的推荐列表，然后经过排序之后才会输出到最终的推荐列表里，是一个有序的推荐列表。\n这个过程会从几千万 item 中筛选出几百或者上千的候选集，然后在排序阶段选出30个给到每位用户。这个排序可理解为一个函数，F(user, item, context)，输入为用户、物品、环境，输出一个0到1之间的分数，取分数最高的几首。这一过程通常称为 CTR 预估。那么 F 函数常见的运作形式有：\n\nLogistic Regression\n最简单的是逻辑回归(Logistic Regression)，一个广义线性模型。拿某 user 的用户画像(一个向量)比如[3, 1]，拼接上某 item 的物品画像比如[4, 0]，再加上代表 context 的向量[0, 1, 1]后得到[3, 1, 4, 0, 0, 1, 1]，若该 user 曾与该 item 发生过联系则 label 为1，这些加起来是一个正样本，同时可以将用户“跳过”的 item 或热门的却没有与用户产生过联系的 item 作为负样本，label 为0。按照这样的输入和输出就可以训练出排序算法了。详细模型见：2. 逻辑回归\n\nGBDT\n使用梯度提升决策树(GBDT) 的方案也可以解决这个排序的问题，只是模型与 LR 不一样。GBDT作为集成模型，会使用多棵决策树，每棵树去拟合前一棵树的残差来得到很好的拟合效果。一个样本输入到一棵树中，会根据各节点的条件往下走到某个叶子节点，将此节点值置为1，其余置为0。详细模型算法见：3.2 GBDT\n\nGBDT+LR\nGBDT与LR的stacking模型相对于只用GBDT会有略微的提升，更大的好处是防止GBDT过拟合。升级为GBDT+LR后，线上效果提升了约5%，并且因为省去了对新特征进行人工转换的步骤，增加特征的迭代测试也更容易了。\n\nGBDT+FM\nGBDT是不支持高维稀疏特征的，如果将高维特征加到LR中，一方面需要人工组合高维特征，另一方面模型维度和计算复杂度会是O（N^2）级别的增长。所以设计了GBDT+FM的模型如图所示，采用Factorization Machines模型替换LR。\n\nFactorization Machines（FM）模型如下所示：\n\n具有以下几个优点①前两项为一个线性模型，相当于LR模型的作用②第三项为一个二次交叉项，能够自动对特征进行交叉组合③通过增加隐向量，模型训练和预测的计算复杂度降为了O(N)④支持稀疏特征。\n几个优点，使的GBDT+FM具有了良好的稀疏特征支持，FM使用GBDT的叶子结点和稀疏特征（内容特征）作为输入，模型结构示意图如下，GBDT+FM模型上线后相比GBDT+LR在各项指标的效果提升在4%~6%之间。\n\nDNN+GBDT+FM\nGBDT+FM模型，对embedding等具有结构信息的深度特征利用不充分，而深度学习（Deep Neural Network）能够对嵌入式（embedding）特征和普通稠密特征进行学习，抽取出深层信息，提高模型的准确性，并已经成功应用到众多机器学习领域。因此我们将DNN引入到排序模型中，提高排序整体质量。\nDNN+GBDT+FM的ensemble模型架构如图所示，FM层作为模型的最后一层，即融合层，其输入由三部分组成：DNN的最后一层隐藏层、GBDT的输出叶子节点、高维稀疏特征。DNN+GBDT+FM的ensemble模型架构介绍如下所示，该模型上线后相对于GBDT+FM有4%的效果提升。\n\n使用分布式的TensorFlow进行训练，使用基于TensorFlow Serving的微服务进行在线预测，DNN+GBDT+FM的ensemble模型使用的是Adam优化器。Adam结合了The Adaptive Gradient Algorithm（AdaGrad）和Root Mean Square Propagation（RMSProp）算法。具有更优的收敛速率，每个变量有独自的下降步长，整体下降步长会根据当前梯度进行调节，能够适应带噪音的数据。实验测试了多种优化器，Adam的效果是最优的。\n\n\n工业界DNN ranking现状\n\nYoutube于2016年推出DNN排序算法。\n上海交通大学和UCL于2016年推出Product-based Neural Network（PNN）网络进行用户点击预测。PNN相当于在DNN层做了特征交叉，我们的做法是把特征交叉交给FM去做，DNN专注于深层信息的提取。\nGoogle于2016年推出Wide And Deep Model，这个也是我们当前模型的基础，在此基础上使用FM替换了Cross Feature LR，简化了计算复杂度，提高交叉的泛化能力。\n阿里今年使用attention机制推出了Deep Interest Network（DIN）进行商品点击率预估，优化embedding向量的准确性，值得借鉴。\n\n7. 评估测试7.1 AB测试新的推荐模型上线后要进行AB测试，将它和旧的算法进行比较。\nAB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。对AB测试感兴趣的读者可以浏览一下网站http:www.abtests.com ，该网站给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。\n切分流量是AB测试中的关键，不同的层以及控制这些层的团队需要从一个统一的地方获得自己AB测试的流量，而不同层之间的流量应该是正交的。\n\n“正交性”是从几何中借来的术语。如果两条直线相交成直角，他们就是正交的。用向量术语来说，这两条直线互不依赖。\n\n下图是一个简单的AB测试系统。用户进入网站后，流量分配系统决定用户是否需要被进行AB测试，如果需要的话，流量分配系统会给用户打上在测试中属于什么分组的标签。然后用户浏览网页，而用户在浏览网页时的行为都会被通过日志系统发回后台的日志数据库。此时，如果用户有测试分组的标签，那么该标签也会被发回后台数据库。在后台，实验人员的工作首先是配置流量分配系统，决定满足什么条件的用户参加什么样的测试。其次，实验人员需要统计日志数据库中的数据，通过评测系统生成不同分组用户的实验报告，并比较和评测实验结果。\n\n当完成了AB测试后，根据指标结果，如果优于之前的推荐算法，那么旧的算法就可以替换成新的了。\n7.2 其它评估方法模型准备就绪后，一般会先通过离线指标来评估模型的好坏， 然后再决定能否上线测试。离线算法评估常见的指标包括准确率、覆盖度 、多样性、新颖性和 UC 等。在线测试一般通过 AB 测试进行，常见的指标有点击率、用户停留时间、 广告收入等，需要注意分析统计显著性。同时，需要注意短期的指标和长期的指标相结合， 一些短期指标的提升有时候反而会导致长期指标下降 比如 ，经常推荐美女或者搞笑类的内容会带来短期的点击率提高，但是可能会引起长期的用户粘性下降。设计者需要从自己的产品角度出发，根据产品的需要制定评估指标，这样才能更好地指导推荐系统的优化方向。常见的评价指标如下：\n\n8. 推荐系统冷启动问题冷启动（ cold start ）在推荐系统中表示该系统积累数据量过少，无法给新用户作个性化推荐的问题，这是产品推荐的一大难题。每个有推荐功能的产品都会遇到冷启动的问题。一方面，当新商品时上架 会遇到冷启动的问题，没有收集到任何一个用户对其浏览、点击或者购买的行为，也无从判断如何将商品进行推荐；另一方面，新用户到来的时候，如果没有他在应用上的行为数据，也无法预测其兴趣，如果给用户的推荐千篇律，没有亮点，会使用户在一开始就对产品失去兴趣，从而放弃使用。所以在冷启动的时候要同时考虑用户的冷启动和物品的冷启动。\n基本上，冷启动题可以分为以下三类。\n8.1 用户冷启动用户冷启动主要解决如何给新用户作个性化推荐的问题。当新用户到来时，我 没有他的行为数据，所以也无法根据他的历史行为预 其兴趣，从而无法借此给他做个性化推荐。解决方法参考以下：\n\n利用用户的账号信息。\n利用用户的手机 IMEI 号进行冷启动。\n制造选工页，让用户选择自己感兴趣的点后，即时生成粗粒度的推荐。\n\n8.2 物品冷启动物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。解决方法参考以下：\n\n利用物品的内容、分类信息。\n利用专家标注的数据。\n\n8.3 系统冷启动系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性推荐系统，从而在产品刚上线时就让用户体验到个性 推荐服务这一问题。\n9. 参考文献\n推荐系统实践–项亮\n推荐系统与深度学习\n美团机器学习实践\n\n\n\n作者:@mantchs\nGitHub:https:github.comNLP-LOVEML-NLP\n欢迎大家加入讨论！共同完善此项目！群号:【541954936】\n\n","tags":["推荐系统"],"path":"2019/09/27/Recommendation-System/","external_link":""},{"title":"python style rules","date":"2019-09-28T10:13:42.000Z","content":"Python风格规范分号.. tip::    不要在行尾加分号, 也不要用分号将两条命令放在同一行.   \n.. _line_length:    \n行长度.. tip::    每行不超过80个字符    \n例外:\n#. 长的导入模块语句\n#. 注释里的URL\n不要使用反斜杠连接行.\nPython会将 圆括号, 中括号和花括号中的行隐式的连接起来 &lt;http:docs.python.org2referencelexical_analysis.html#implicit-line-joining&gt;_ , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号. \n.. code-block:: python\nYes: foo_bar(self, width, height, color=&apos;black&apos;, design=None, x=&apos;foo&apos;,\n             emphasis=None, highlight=0)\n\n     if (width == 0 and height == 0 and\n         color == &apos;red&apos; and emphasis == &apos;strong&apos;):    如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:\n.. code-block:: python\nx = (&apos;This will build a very long long &apos;\n     &apos;long long long long long long string&apos;)在注释中，如果必要，将长的URL放在一行上。\n.. code-block:: python\nYes:  # See details at\n      # http:www.example.comusdeveloperdocumentationapicontentv2.0csv_file_name_extension_full_specification.html.. code-block:: python\nNo:  # See details at\n     # http:www.example.comusdeveloperdocumentationapicontent\n     # v2.0csv_file_name_extension_full_specification.html     注意上面例子中的元素缩进; 你可以在本文的 :ref:缩进 &lt;indentation&gt; 部分找到解释. \n括号.. tip::    宁缺毋滥的使用括号    \n除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的. \n.. code-block:: python    \nYes: if foo:\n         bar()\n     while x:\n         x = bar()\n     if x and y:\n         bar()\n     if not x:\n         bar()\n     return foo\n     for (x, y) in dict.items(): ...  .. code-block:: python\nNo:  if (x):\n         bar()\n     if not(x):\n         bar()\n     return (foo).. _indentation:  \n缩进.. tip::    用4个空格来缩进代码\n绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 :ref:行长度 &lt;line_length&gt; 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):\n.. code-block:: python\n   Yes:   # Aligned with opening delimiter          foo = long_function_name(var_one, var_two,                                   var_three, var_four)\n# Aligned with opening delimiter in a dictionary\nfoo = {\n    long_dictionary_key: value1 +\n                         value2,\n    ...\n}\n\n# 4-space hanging indent; nothing on first line\nfoo = long_function_name(\n    var_one, var_two, var_three,\n    var_four)\n\n# 4-space hanging indent in a dictionary\nfoo = {\n    long_dictionary_key:\n        long_dictionary_value,\n    ...\n}.. code-block:: python\nNo:    # Stuff on first line forbidden\n      foo = long_function_name(var_one, var_two,\n          var_three, var_four)\n\n      # 2-space hanging indent forbidden\n      foo = long_function_name(\n        var_one, var_two, var_three,\n        var_four)\n\n      # No hanging indent in a dictionary\n      foo = {\n          long_dictionary_key:\n              long_dictionary_value,\n              ...\n      }空行.. tip::    顶级定义之间空两行, 方法定义之间空一行\n顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.     \n空格.. tip::    按照标准的排版规范来使用标点两边的空格\n括号内不要有空格.\n.. code-block:: python\nYes: spam(ham[1], {eggs: 2}, []).. code-block:: python\nNo:  spam( ham[ 1 ], { eggs: 2 }, [ ] )不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).\n.. code-block:: python\nYes: if x == 4:\n         print x, y\n     x, y = y, x.. code-block:: python\nNo:  if x == 4 :\n         print x , y\n     x , y = y , x参数列表, 索引或切片的左括号前不应加空格.\n.. code-block:: python   \nYes: spam(1).. code-block:: python\nno: spam (1).. code-block:: python  \nYes: dict[&apos;key&apos;] = list[index].. code-block:: python  \nNo:  dict [&apos;key&apos;] = list [index]       在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not).  至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致. \n.. code-block:: python\nYes: x == 1.. code-block:: python\nNo:  x&lt;1当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格. \n.. code-block:: python\nYes: def complex(real, imag=0.0): return magic(r=real, i=imag).. code-block:: python\nNo:  def complex(real, imag = 0.0): return magic(r = real, i = imag)不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):\n.. code-block:: python\nYes:\n     foo = 1000  # comment\n     long_name = 2  # comment that should not be aligned\n\n     dictionary = {\n         &quot;foo&quot;: 1,\n         &quot;long_name&quot;: 2,\n         }.. code-block:: python\nNo:\n     foo       = 1000  # comment\n     long_name = 2     # comment that should not be aligned\n\n     dictionary = {\n         &quot;foo&quot;      : 1,\n         &quot;long_name&quot;: 2,\n         }Shebang.. tip::    大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 &lt;http:www.python.orgdevpepspep-0394&gt;_ , 程序的main文件应该以 #!usrbinpython2或者 #!usrbinpython3开始.\n(译者注: 在计算机科学中, Shebang &lt;http:en.wikipedia.orgwikiShebang_(Unix)&gt;_ (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!binsh开头的文件在执行时会实际调用binsh程序.)\n#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!.\n.. _comments:  \n注释.. tip::    确保对模块, 函数, 方法和行内注释使用正确的风格    \n文档字符串\nPython有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号&quot;&quot;&quot;( `PEP-257 &lt;http:www.python.orgdevpepspep-0257&gt;`_ ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块\n每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.函数和方法\n下文所指的函数,包括函数, 方法, 以及生成器.\n\n一个函数必须要有文档字符串, 除非它满足以下条件:\n\n#. 外部不可见\n#. 非常短小\n#. 简单明了\n\n文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&quot;怎么做&quot;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.\n\n关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格. \n\nArgs:\n    列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致).\n    描述应该包括所需的类型和含义.\n    如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar.\n\nReturns: (或者 Yields: 用于生成器)\n    描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.\n\nRaises:\n    列出与接口有关的所有异常.\n\n.. code-block:: python\n\n    def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):\n        &quot;&quot;&quot;Fetches rows from a Bigtable.\n\n        Retrieves rows pertaining to the given keys from the Table instance\n        represented by big_table.  Silly things may happen if\n        other_silly_variable is not None.\n\n        Args:\n            big_table: An open Bigtable Table instance.\n            keys: A sequence of strings representing the key of each table row\n                to fetch.\n            other_silly_variable: Another optional variable, that has a much\n                longer name than the other args, and which does nothing.\n\n        Returns:\n            A dict mapping keys to the corresponding table row data\n            fetched. Each row is represented as a tuple of strings. For\n            example:\n\n            {&apos;Serak&apos;: (&apos;Rigel VII&apos;, &apos;Preparer&apos;),\n             &apos;Zim&apos;: (&apos;Irk&apos;, &apos;Invader&apos;),\n             &apos;Lrrr&apos;: (&apos;Omicron Persei 8&apos;, &apos;Emperor&apos;)}\n\n            If a key from the keys argument is missing from the dictionary,\n            then that row was not found in the table.\n\n        Raises:\n            IOError: An error occurred accessing the bigtable.Table object.\n        &quot;&quot;&quot;\n        pass类\n类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.\n\n.. code-block:: python\n\n    class SampleClass(object):\n        &quot;&quot;&quot;Summary of class here.\n\n        Longer class information....\n        Longer class information....\n\n        Attributes:\n            likes_spam: A boolean indicating if we like SPAM or not.\n            eggs: An integer count of the eggs we have laid.\n        &quot;&quot;&quot;\n\n        def __init__(self, likes_spam=False):\n            &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;\n            self.likes_spam = likes_spam\n            self.eggs = 0\n\n        def public_method(self):\n            &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;块注释和行注释\n最需要写注释的是代码中那些技巧性的部分. 如果你在下次 `代码审查 &lt;http:en.wikipedia.orgwikiCode_review&gt;`_ 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. \n\n.. code-block:: python\n\n    # We use a weighted dictionary search to find out where i is in\n    # the array.  We extrapolate position based on the largest num\n    # in the array and the array size and then do binary search to\n    # get the exact number.\n\n    if i &amp; (i-1) == 0:        # True if i is 0 or a power of 2.\n\n为了提高可读性, 注释应该至少离开代码2个空格. \n\n另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. \n\n.. code-block:: python\n\n    # BAD COMMENT: Now go through the b array and make sure whenever i occurs\n    # the next element is i+1类.. tip::    如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.\n.. code-block:: python\nYes: class SampleClass(object):\n         pass\n\n\n     class OuterClass(object):\n\n         class InnerClass(object):\n             pass\n\n\n     class ChildClass(ParentClass):\n         &quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;.. code-block:: python\nNo: class SampleClass:\n        pass\n\n\n    class OuterClass:\n\n        class InnerClass:\n            pass继承自 object 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 PEP-3000 &lt;http:www.python.orgdevpepspep-3000&gt;_ 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ .\n字符串.. tip::    即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.\n.. code-block:: python\nYes: x = a + b\n     x = &apos;%s, %s!&apos; % (imperative, expletive)\n     x = &apos;{}, {}!&apos;.format(imperative, expletive)\n     x = &apos;name: %s; score: %d&apos; % (name, n)\n     x = &apos;name: {}; score: {}&apos;.format(name, n).. code-block:: python\nNo: x = &apos;%s%s&apos; % (a, b)  # use + in this case\n    x = &apos;{}{}&apos;.format(a, b)  # use + in this case\n    x = imperative + &apos;, &apos; + expletive + &apos;!&apos;\n    x = &apos;name: &apos; + name + &apos;; score: &apos; + str(n)避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.)\n.. code-block:: python\nYes: items = [&apos;&lt;table&gt;&apos;]\n     for last_name, first_name in employee_list:\n         items.append(&apos;&lt;tr&gt;&lt;td&gt;%s, %s&lt;td&gt;&lt;tr&gt;&apos; % (last_name, first_name))\n     items.append(&apos;&lt;table&gt;&apos;)\n     employee_table = &apos;&apos;.join(items).. code-block:: python\nNo: employee_table = &apos;&lt;table&gt;&apos;\n    for last_name, first_name in employee_list:\n        employee_table += &apos;&lt;tr&gt;&lt;td&gt;%s, %s&lt;td&gt;&lt;tr&gt;&apos; % (last_name, first_name)\n    employee_table += &apos;&lt;table&gt;&apos;在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. GPyLint已经加入了这一检查.\n(译者注:GPyLint疑为笔误, 应为PyLint.)  \n.. code-block:: python\n   Yes:        Python(‘Why are you hiding your eyes?’)        Gollum(“I’m scared of lint errors.”)        Narrator(‘“Good!” thought a happy Python reviewer.’)\n.. code-block:: python\n   No:        Python(“Why are you hiding your eyes?”)        Gollum(‘The lint. It burns. It burns us.’)        Gollum(“Always the great lint. Watching. Watching.”)\n为多行字符串使用三重双引号”””而非三重单引号’’’. 当且仅当项目中使用单引号’来引用字符串时, 才可能会使用三重’’’为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号”””. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致. \n.. code-block:: python\nYes:\n    print (&quot;This is much nicer.n&quot;\n           &quot;Do it this way.n&quot;).. code-block:: python\nNo:\n      print &quot;&quot;&quot;This is pretty ugly.\n  Don&apos;t do this.\n  &quot;&quot;&quot;文件和sockets.. tip::    在文件和sockets结束时, 显式的关闭它.\n除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:\n#. 它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.\n#. 持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.\n#. 仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来.\n而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因: \n#. 没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.\n#. 对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).\n推荐使用 &quot;with&quot;语句 &lt;http:docs.python.orgreferencecompound_stmts.html#the-with-statement&gt;_ 以管理文件:\n.. code-block:: python\nwith open(&quot;hello.txt&quot;) as hello_file:\n    for line in hello_file:\n        print line对于不支持使用”with”语句的类似文件的对象,使用 contextlib.closing():\n.. code-block:: python\nimport contextlib\n\nwith contextlib.closing(urllib.urlopen(&quot;http:www.python.org&quot;)) as front_page:\n    for line in front_page:\n        print lineLegacy AppEngine 中Python 2.5的代码如使用”with”语句, 需要添加 “from future import with_statement”.\nTODO注释.. tip::    为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.\nTODO注释应该在所有开头处包含”TODO”字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字. \n.. code-block:: python    \n# TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.\n# TODO(Zeke) Change this to use relations.如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”). \n导入格式.. tip::    每个导入应该独占一行\n.. code-block:: python  \nYes: import os\n     import sys.. code-block:: python  \nNo:  import os, sys导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前.  导入应该按照从最通用到最不通用的顺序分组:\n#. 标准库导入\n#. 第三方库导入\n#. 应用程序指定导入\n每种分组中,  应该根据每个模块的完整包路径按字典序排序, 忽略大小写.\n.. code-block:: python\nimport foo\nfrom foo import bar\nfrom foo.bar import baz\nfrom foo.bar import Quux\nfrom Foob import ar语句.. tip::    通常每个语句应该独占一行   \n不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行.  如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 tryexcept 这样做, 因为try和except不能放在同一行. \n.. code-block:: python\nYes:\n\n  if foo: bar(foo).. code-block:: python\nNo:\n\n  if foo: bar(foo)\n  else:   baz(foo)\n\n  try:               bar(foo)\n  except ValueError: baz(foo)\n\n  try:\n      bar(foo)\n  except ValueError: baz(foo)访问控制.. tip::    在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性. \n(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化. \n命名.. tip::    module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.   \n应该避免的名称\n#. 单字符名称, 除了计数器和迭代器.\n#. 包模块名中的连字符(-)\n#. 双下划线开头并结尾的名称(Python保留, 例如__init__)命名约定\n#. 所谓&quot;内部(Internal)&quot;表示仅模块内可用, 或者, 在类内是保护或私有的.\n#. 用单下划线(_)开头表示模块变量或函数是protected的(使用from module import *时不会包含).\n#. 用双下划线(__)开头的实例变量或方法表示类内私有.\n#. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.\n#. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Python之父Guido推荐的规范    \n===========================    ====================    ======================================================================Type                           Public                  Internal===========================    ====================    ======================================================================Modules                        lower_with_under        _lower_with_underPackages                       lower_with_underClasses                        CapWords                _CapWordsExceptions                     CapWordsFunctions                      lower_with_under()      _lower_with_under()GlobalClass Constants         CAPS_WITH_UNDER         _CAPS_WITH_UNDERGlobalClass Variables         lower_with_under        _lower_with_underInstance Variables             lower_with_under        _lower_with_under (protected) or __lower_with_under (private)Method Names                   lower_with_under()      _lower_with_under() (protected) or __lower_with_under() (private)FunctionMethod Parameters     lower_with_underLocal Variables                lower_with_under===========================    ====================    ======================================================================\n.. _main:  \nMain.. tip::    即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中. \n在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 if __name__ == &#39;__main__&#39; , 这样当模块被导入时主程序就不会被执行. \n.. code-block:: python\ndef main():\n      ...\n\nif __name__ == &apos;__main__&apos;:\n    main()所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.\n","tags":["python"],"path":"2019/09/28/python-style-rules/","external_link":""},{"title":"vue_route","date":"2019-09-29T15:37:49.000Z","content":"vue自动化路由目的解放双手，从此不用配置路由。当你看到项目中大批量的路由思考是拆分维护业务路由还是统一入口维护时，无需多虑，router-auto是你的最优选择，它帮你解决路由的维护成本，你只需要创建相应的文件夹，路由就能动态生成，路由拦截你可以在main.js中去拦截他，总之比你想象的开发还要简单。\n\nrouter-auto github地址有帮助的可以star一下\nrouter-auto npm地址欢迎提issue\n\n实现效果\n简要用法具体用法请实时查看github或者npm，下面做一些简要用法介绍\n引用12345678910const RouterAuto = require(router-auto)module.exports = &#123;    entry: ...,    output: &#123;&#125;,    module: &#123;&#125;,    plugin:[        new RouterAuto()    ]&#125;\n\n项目结构\npackage.json 等等文件与目录\nsrc 项目目录\npage 页面目录\nhelloworld\nIndex.vue 页面入口\nhello.vue 业务组件\nrouter.js 额外配置\n\n\ndemo\ntest\nIndex.vue 页面入口\ntest.vue 业务组件\n\n\nIndex.vue 页面入口\n\n\nhome\nIndex.vue 页面入口\n\n\n\n\n\n\n\n上面的目录结构生成的路由结构为\n123456789101112131415161718192021222324252627282930import Vue from vueimport Router from vue-routerimport helloworld from @pagehelloworldIndex.vueimport demo from @pagedemoIndex.vueimport demo_test from @pagedemotestIndex.vueimport home from @pagehomeIndex.vue  Vue.use(Router)  export default new Router(&#123;    mode:history,    base:auto,    routes:[&#123;      path: helloworldindex,      name: helloworld,      component: helloworld    &#125;,&#123;      path: demoindex,      name: demo,      component: demo    &#125;,&#123;      path: demotestindex,      name: demo_test,      component: demo_test    &#125;,&#123;      path: homeindex,      name: home,      component: home    &#125;]&#125;)\n\n\n作者：ngaiwe链接：https:juejin.impost5d90798151882576e44088e8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n","tags":["vue"],"path":"2019/09/29/vue-route/","external_link":""},{"title":"BPlusTree","date":"2019-09-30T09:41:21.000Z","content":"B+ Trees\nB+ Trees\n","tags":["B+树"],"path":"2019/09/30/BPlusTree/","external_link":""},{"title":"26 remove-duplicates-from-sorted-array","date":"2019-10-04T02:50:35.000Z","content":"26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例 1:\n12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2:\n12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n12345678 nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); 在函数里修改输入数组对于调用者是可见的。 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n\n双指针法\n12345678910111213class Solution &#123;    public int removeDuplicates(int[] nums) &#123;        if (nums.length == 0) return 0;        int i = 0;        for (int j = 1; j &lt; nums.length; j++) &#123;            if (nums[j] != nums[i]) &#123;                i++;                nums[i] = nums[j];            &#125;        &#125;        return i + 1;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n\n空间复杂度：O(1)。\n\n\n","tags":["leetcode"],"path":"2019/10/04/26-remove-duplicates-from-sorted-array/","external_link":""},{"title":"search_engine","date":"2019-10-05T02:22:55.000Z","content":"全球十大搜索引擎\n百度属于搜索引擎的其中之一，这个大家想必都知道。尤其对于做网络和媒体的人来说，你必须知道如何与搜索引擎打交道。但是你知道除了百度，世界上还有哪些好用的搜索引擎吗？\n\nNO.1 Google（谷歌） ：18亿www.google.com\n全球第一搜索引擎，不解释。\n\nNO.2 Bing（必应） ：5亿www.bing.com\nBing是微软旗下的搜索引擎，感觉它的搜索界面背景图非常美，是谷歌最好的替代品，备胎中的战斗机。\n\nNO.3 Yahoo!（雅虎） ：4.9亿www.search.yahoo.com\n在搜索方面，雅虎表现中规中矩，网页搜索表现不错，但死链率较高而且缺少一些应有的高级搜索功能。\n\nNO.4 Baidu（百度）：4.8亿www.baidu.com\n全球最大的中文搜索引擎，不解释。\n\nNO.5 Ask ：3亿www.ask.com\nAsk搜索引擎是国外比较出名的一款搜索引擎，其规模虽不大，但很有特色。Ask是DirectHit的母公司，于2001年收购Teoma搜索引擎，并全部采用Teoma搜索结果。是支持自然提问的搜索引擎，其数据库里储存了超过1000万个问题的答案，只要用户用英文直接输入一个问题，它就会给出问题答案，如果用户的问题答案不在其数据库中，那么它会列出一串跟用户的问题类似的问题和含有答案的链接，供用户选择。\n\nNO.6 Aol ：2亿www.search.aol.com\nAol Search是美国在线旗下搜索引擎网站。Aol Search为用户提供快速、方便地访问相关视频、图片、本地地图、新闻、股市行情和更全面的网页搜索结果。Aol Search的搜索技术服务是由谷歌提供的。\n\nNO.7 DuckDuckGo ：1.5亿www.duckduckgo.com\nDuckDuckGo是一个很特殊的网络搜索引擎，他和Google、Bing 这些不一样，他不会追踪、搜寻用户的信息，这对用户来说可以安个心了。\n\nNO.8 WolframAlpha ：0.35亿www.wolframalpha.com\n与其他搜索引擎不同，WolframAlpha其实是一个计算知识引擎，它真正的创新之处在于能够马上理解问题，并给出答案。它可以进行各种算术，还有数据分析，物理，艺术等等各个行业的查询。\n比如你查询一个城市，它会出来和这个城市相关数据，它在地图上显示位置，人口，机场，著名的公司，它就像一个只能的机器人，你想知道有关一个东西的所有信息，它都能告诉你。\n\nNO.9 Яндексwww.yandex.com\nYandex搜索引擎是俄罗斯第一大搜索引擎，创建于1997年，目前已经发展成为一个提供搜索、图片共享、社交网络、网络支付、免费网站托管、以及其它服务的门户网站。因为份额太小，我们就不放数字了。\n\nNO.10 webcrawlerwww.webcrawler.com\nWebCrawler是一个融合来自谷歌搜索和雅虎搜索等世界著名的搜索结果的元搜索引擎。WebCrawler为用户提供搜索图片、音频、视频、新闻、黄页和白页的选项卡。\n\n传送门\n","tags":["搜索引擎"],"path":"2019/10/05/search-engine/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/AI/" style="font-size: 0.8em; color: #488baf">AI</a> <a href="/tags/B-树/" style="font-size: 0.8em; color: #488baf">B+树</a> <a href="/tags/Docker/" style="font-size: 0.8em; color: #488baf">Docker</a> <a href="/tags/Flutter/" style="font-size: 0.8em; color: #488baf">Flutter</a> <a href="/tags/HashMap/" style="font-size: 0.8em; color: #488baf">HashMap</a> <a href="/tags/Http/" style="font-size: 0.8em; color: #488baf">Http</a> <a href="/tags/JVM/" style="font-size: 0.8em; color: #488baf">JVM</a> <a href="/tags/Java/" style="font-size: 2em; color: #d63e0a">Java</a> <a href="/tags/Nodejs/" style="font-size: 0.8em; color: #488baf">Nodejs</a> <a href="/tags/OCR/" style="font-size: 0.8em; color: #488baf">OCR</a> <a href="/tags/OpenCV/" style="font-size: 0.8em; color: #488baf">OpenCV</a> <a href="/tags/Spring/" style="font-size: 0.8em; color: #488baf">Spring</a> <a href="/tags/TensorFlow/" style="font-size: 1em; color: #607e94">TensorFlow</a> <a href="/tags/Tree/" style="font-size: 0.8em; color: #488baf">Tree</a> <a href="/tags/dio/" style="font-size: 0.8em; color: #488baf">dio</a> <a href="/tags/electron/" style="font-size: 0.8em; color: #488baf">electron</a> <a href="/tags/git/" style="font-size: 1.2em; color: #777178">git</a> <a href="/tags/github/" style="font-size: 0.8em; color: #488baf">github</a> <a href="/tags/jad/" style="font-size: 0.8em; color: #488baf">jad</a> <a href="/tags/javascript/" style="font-size: 0.8em; color: #488baf">javascript</a> <a href="/tags/leetcode/" style="font-size: 1.6em; color: #a75841">leetcode</a> <a href="/tags/linux/" style="font-size: 0.8em; color: #488baf">linux</a> <a href="/tags/nohup/" style="font-size: 0.8em; color: #488baf">nohup</a> <a href="/tags/python/" style="font-size: 1em; color: #607e94">python</a> <a href="/tags/vue/" style="font-size: 1em; color: #607e94">vue</a> <a href="/tags/webhooks/" style="font-size: 0.8em; color: #488baf">webhooks</a> <a href="/tags/二叉树/" style="font-size: 0.8em; color: #488baf">二叉树</a> <a href="/tags/反编译/" style="font-size: 0.8em; color: #488baf">反编译</a> <a href="/tags/备份/" style="font-size: 0.8em; color: #488baf">备份</a> <a href="/tags/天平/" style="font-size: 0.8em; color: #488baf">天平</a> <a href="/tags/推荐系统/" style="font-size: 0.8em; color: #488baf">推荐系统</a> <a href="/tags/搜索引擎/" style="font-size: 0.8em; color: #488baf">搜索引擎</a> <a href="/tags/数据库/" style="font-size: 1em; color: #607e94">数据库</a> <a href="/tags/文章/" style="font-size: 1em; color: #607e94">文章</a> <a href="/tags/暴力破解/" style="font-size: 0.8em; color: #488baf">暴力破解</a> <a href="/tags/机器学习/" style="font-size: 1.2em; color: #777178">机器学习</a> <a href="/tags/树/" style="font-size: 0.8em; color: #488baf">树</a> <a href="/tags/框架/" style="font-size: 0.8em; color: #488baf">框架</a> <a href="/tags/爱因斯坦/" style="font-size: 0.8em; color: #488baf">爱因斯坦</a> <a href="/tags/狂野飙车/" style="font-size: 0.8em; color: #488baf">狂野飙车</a> <a href="/tags/百科/" style="font-size: 0.8em; color: #488baf">百科</a> <a href="/tags/相对论/" style="font-size: 0.8em; color: #488baf">相对论</a> <a href="/tags/矩阵/" style="font-size: 0.8em; color: #488baf">矩阵</a> <a href="/tags/算法/" style="font-size: 1.8em; color: #be4b26">算法</a> <a href="/tags/素数/" style="font-size: 0.8em; color: #488baf">素数</a> <a href="/tags/红黑树/" style="font-size: 0.8em; color: #488baf">红黑树</a> <a href="/tags/编程/" style="font-size: 1.4em; color: #8f655d">编程</a> <a href="/tags/脚本/" style="font-size: 0.8em; color: #488baf">脚本</a> <a href="/tags/自动化部署/" style="font-size: 0.8em; color: #488baf">自动化部署</a> <a href="/tags/跑车/" style="font-size: 0.8em; color: #488baf">跑车</a> <a href="/tags/边缘检测/" style="font-size: 0.8em; color: #488baf">边缘检测</a> <a href="/tags/递归/" style="font-size: 1.2em; color: #777178">递归</a> <a href="/tags/链表/" style="font-size: 1em; color: #607e94">链表</a> <a href="/tags/面试/" style="font-size: 1.6em; color: #a75841">面试</a> <a href="/tags/魔方/" style="font-size: 0.8em; color: #488baf">魔方</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> 版权所有 <a href="">times </a> @ 2019</p>
            <p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    






  <script>
  var gitment = new Gitment({
    id: window.location.pathname, // optional
    owner: 'hsutimes',
    repo: 'gitment_blog',
    oauth: {
      client_id: 'd73d768ea9e3bd69ab54',
      client_secret: '4b958932671ae1a2ab37b2a112ee945824fd4abd',
    },
    // ...
    // For more available options, check out the documentation below
  })

  gitment.render('gitment')
  </script>







    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    
<script type='text/javascript'>
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
