<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.9.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Time</title>
  

  
  
  <meta name="description" content>
  <meta name="author" content="times">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-134224598-1', 'auto');
	ga('send', 'pageview');
</script>


  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/theme-icon.svg' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">Time</a>
			</h1>
			<subtitle>
				time
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
			<li><a href="/categories/文章/"><img src="/images/文章.svg" alt="文章" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='文章'></a></li>
		
			<li><a href="/categories/算法/"><img src="/images/算法.svg" alt="算法" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='算法'></a></li>
		
			<li><a href="/categories/人工智能/"><img src="/images/人工智能.svg" alt="人工智能" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='人工智能'></a></li>
		
			<li><a href="/categories/生活/"><img src="/images/生活.svg" alt="生活" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='生活'></a></li>
		
			<li><a href="/categories/笔试/"><img src="/images/笔试.svg" alt="笔试" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='笔试'></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"118. 杨辉三角","date":"2019-08-31T15:25:17.000Z","content":"杨辉三角题目给定一个非负整数 numRows，生成杨辉三角的前 numRows行。\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n123456789输入: 5输出:[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]\n\n题解\n动态规划\n\n思路\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n算法\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 0 的特殊情况，否则我们会返回 [1]。如果 numRows &gt; 0，那么我们用 [1] 作为第一行来初始化 triangle with [1]，并按如下方式继续填充：\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;List&lt;Integer&gt;&gt;();         First base case; if user requests zero rows, they get zero rows.        if (numRows == 0) &#123;            return triangle;        &#125;         Second base case; first row is always [1].        triangle.add(new ArrayList&lt;&gt;());        triangle.get(0).add(1);        for (int rowNum = 1; rowNum &lt; numRows; rowNum++) &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            List&lt;Integer&gt; prevRow = triangle.get(rowNum-1);             The first row element is always 1.            row.add(1);             Each triangle element (other than the first and last of each row)             is equal to the sum of the elements above-and-to-the-left and             above-and-to-the-right.            for (int j = 1; j &lt; rowNum; j++) &#123;                row.add(prevRow.get(j-1) + prevRow.get(j));            &#125;             The last row element is always 1.            row.add(1);            triangle.add(row);        &#125;        return triangle;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(numRows²)\n\n虽然更新 triangle 中的每个值都是在常量时间内发生的，但它会被执行 O(numRows²) 次。想要了解原因，就需要考虑总共有多少次循环迭代。很明显外层循环需要运行 numRows 次，但在外层循环的每次迭代中，内层循环要运行 rowNumrowNum 次。因此，triangle 发生的更新总数为1 + 2 + 3 + ... + *numRows*，根据高斯公式有\n\n\n空间复杂度：O(numRows²)\n\n因为我们需要存储我们在 triangle 中更新的每个数字，所以空间需求与时间复杂度相同。\n\nPython解法\n\n1234567891011121314151617class Solution:    def generate(self, num_rows):        triangle = []        for row_num in range(num_rows):            # The first and last row elements are always 1.            row = [None for _ in range(row_num+1)]            row[0], row[-1] = 1, 1            # Each triangle element is equal to the sum of the elements            # above-and-to-the-left and above-and-to-the-right.            for j in range(1, len(row)-1):                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]            triangle.append(row)        return triangle\n\n\n递归解法\n\n通过numRows-1，求numRows行，递归求解\n1234567891011121314151617181920212223242526class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; listw = new ArrayList&lt;List&lt;Integer&gt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;Integer&gt; listn = new ArrayList&lt;Integer&gt;();        if (numRows == 0)            return listw;        generate(numRows - 1);        for (int i = 0; i &lt; numRows; i++) &#123;            if (i == 0) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 1) &#123;                listn.add(1);                continue;            &#125; else if (i == numRows - 2) &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + 1);                continue;            &#125; else &#123;                listn.add(listw.get(numRows - 2).get(i - 1) + listw.get(numRows - 2).get(i));            &#125;        &#125;        listw.add(listn);        return listw;    &#125;&#125;\n\n","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/118-杨辉三角/","external_link":""},{"title":"24. 两两交换链表中的节点","date":"2019-08-31T14:57:20.000Z","content":"\n24. 两两交换链表中的节点题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.题解\n非递归\n\n123456789101112131415161718192021222324** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; *class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0);        pre.next = head;        ListNode temp = pre;        while(temp.next != null &amp;&amp; temp.next.next != null) &#123;            ListNode start = temp.next;            ListNode end = temp.next.next;            temp.next = end;            start.next = end.next;            end.next = start;            temp = start;        &#125;        return pre.next;    &#125;&#125;\n\n\n递归解法\n\n详细介绍一下递归的思路;\n递归和栈处理问题类似,先把问题从前往后收集起来,然后再从后往前处理每一个问题;\n两两交换链表结点,先处理最后两个或一个节点,然后再从后往前处理每一对节点;\n先创建一个next临时结点保存head的下一个结点,然后让head指向下下一个节点,最后让 next节点指向head结点;\n此题只有处理完后面的结点才可处理前面的结点,画图更容易理解;\n\n\n\n\n123456789101112class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null)            return head;         三个节点顺序:head, next, swapPairs(next.next)        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;        return next;    &#125;&#125;","tags":["算法","leetcode","递归","链表"],"path":"2019/08/31/24-两两交换链表中的节点/","external_link":""},{"title":"334. 反转字符串","date":"2019-08-31T14:49:17.000Z","content":"\n334. 反转字符串题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1：\n输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：\n输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]    题解\n递归解法\n\n123456789101112131415class Solution &#123;    public void reverseString(char[] s) &#123;        swap(0, s.length-1, s);    &#125;        public void swap(int start, int end, char[] s) &#123;        if(start &gt;= end)&#123;            return;        &#125;        char temp = s[start];        s[start] = s[end];        s[end] = temp;        swap(start+1, end-1, s);    &#125;&#125;\n\n\n循环解法\n\n1234567891011class Solution &#123;    public void reverseString(char[] s) &#123;        int j=s.length-1;        for(int i=0;i&lt;s.length2;i++)&#123;            char tmp = s[i];            s[i] = s[j];            s[j] = tmp;            j--;        &#125;    &#125;&#125;\n\n\nPython解法\n\n12def reverseString(self, s: List[str]) -&gt; None:    s[0::]=s[::-1]\n\n\nc++解法\n\n双指针，交换头尾两个指针所指的两个位置的值，指针向中间移动一个位置，重复以上操作，直到两个指针交错；\n12345678910111213class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int i = 0;        int j = s.size() - 1;        while(i&lt;j)        &#123;            swap(s[i],s[j]);            ++ i;            -- j;        &#125;    &#125;&#125;;","tags":["算法","leetcode","递归"],"path":"2019/08/31/334-反转字符串/","external_link":""},{"title":"54. 螺旋矩阵","date":"2019-09-07T03:08:58.000Z","content":"\n54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n示例 1:\n1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]\n\n示例 2:\n1234567输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n方法 1：模拟直觉\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n算法\n假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。\n当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n1234567891011121314151617181920212223242526class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0) return ans;        int R = matrix.length, C = matrix[0].length;        boolean[][] seen = new boolean[R][C];        int[] dr = &#123;0, 1, 0, -1&#125;;        int[] dc = &#123;1, 0, -1, 0&#125;;        int r = 0, c = 0, di = 0;        for (int i = 0; i &lt; R * C; i++) &#123;            ans.add(matrix[r][c]);            seen[r][c] = true;            int cr = r + dr[di];            int cc = c + dc[di];            if (0 &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;                r = cr;                c = cc;            &#125; else &#123;                di = (di + 1) % 4;                r += dr[di];                c += dc[di];            &#125;        &#125;        return ans;    &#125;&#125;\n\n12345678910111213141516171819class Solution(object):    def spiralOrder(self, matrix):        if not matrix: return []        R, C = len(matrix), len(matrix[0])        seen = [[False] * C for _ in matrix]        ans = []        dr = [0, 1, 0, -1]        dc = [1, 0, -1, 0]        r = c = di = 0        for _ in range(R * C):            ans.append(matrix[r][c])            seen[r][c] = True            cr, cc = r + dr[di], c + dc[di]            if 0 &lt;= cr &lt; R and 0 &lt;= cc &lt; C and not seen[cr][cc]:                r, c = cr, cc            else:                di = (di + 1) % 4                r, c = r + dr[di], c + dc[di]        return ans\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要两个矩阵 seen 和 ans 存储所需信息。\n\n方法 2：按层模拟\n直觉\n答案是最外层所有元素按照顺时针顺序输出，其次是次外层，以此类推。\n算法\n我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，然后是第 3 层的。\n12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]]\n\n\n12345678910111213141516171819202122class Solution &#123;    public List &lt; Integer &gt; spiralOrder(int[][] matrix) &#123;        List ans = new ArrayList();        if (matrix.length == 0)            return ans;        int r1 = 0, r2 = matrix.length - 1;        int c1 = 0, c2 = matrix[0].length - 1;        while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;            for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);            for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]);            if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;                for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]);                for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);            &#125;            r1++;            r2--;            c1++;            c2--;        &#125;        return ans;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。\n空间复杂度： O(N)，需要矩阵 ans 存储信息。\n\n方法 3：顺时针旋转\n这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小\n\n首先设定上下左右边界\n其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界\n判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案\n若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理\n不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        int[][] matrix = new int[][] &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;        List&lt;Integer&gt; list = spiralOrder(matrix);        System.out.println(list);    &#125;    static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        if (matrix.length == 0)            return list;        int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1;        while (true) &#123;             向右            for (int i = l; i &lt;= r; i++)                list.add(matrix[u][i]);            if (++u &gt; d)                break;             向下            for (int i = u; i &lt;= d; i++)                list.add(matrix[i][r]);            if (--r &lt; l)                break;             向左            for (int i = r; i &gt;= l; i--)                list.add(matrix[d][i]);            if (--d &lt; u)                break;             向上            for (int i = d; i &gt;= u; i--)                list.add(matrix[i][l]);            if (++l &gt; r)                break;        &#125;        return list;    &#125;&#125;\n\n1234567891011121314151617181920212223class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        vector &lt;int&gt; ans;        if(matrix.empty()) return ans; 若数组为空，直接返回答案        int u = 0; 赋值上下左右边界        int d = matrix.size() - 1;        int l = 0;        int r = matrix[0].size() - 1;        while(true)        &#123;            for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); 向右移动直到最右            if(++ u &gt; d) break; 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同            for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); 向下            if(-- r &lt; l) break; 重新设定有边界            for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); 向左            if(-- d &lt; u) break; 重新设定下边界            for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); 向上            if(++ l &gt; r) break; 重新设定左边界        &#125;        return ans;    &#125;&#125;;","author":null,"tags":["leetcode","编程","矩阵"],"path":"2019/09/07/54-螺旋矩阵/","external_link":""},{"title":"Flutter Http请求开源库-dio","date":"2019-09-09T00:39:17.000Z","content":"文档语言: English | 中文简体\ndio\ndio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传下载、超时等…\n添加依赖12dependencies:  dio: ^x.x.x   请使用pub上的最新版本\n\n一个极简的示例12345678910import package:diodio.dart;void getHttp() async &#123;  try &#123;    Response response;    response = await Dio().get(http:www.baidu.com);    return print(response);  &#125; catch (e) &#123;    return print(e);  &#125;&#125;\n\n内容列表\n示例\nDio APIs\n请求配置\n响应数据\n拦截器\n错误处理\n使用applicationx-www-form-urlencoded编码\nFormData\n转换器\n设置Http代理\nHttps证书校验\n请求取消\nCookie管理\nFeatures and bugs\n\n示例发起一个 GET 请求 :\n1234567  Response response;  Dio dio = new Dio();  response = await dio.get(test?id=12&amp;name=wendu)  print(response.data.toString()); 请求参数也可以通过对象传递，上面的代码等同于：  response = await dio.get(test, data: &#123;id: 12, name: wendu&#125;);  print(response.data.toString());\n\n发起一个 POST 请求:\n1response = await dio.post(test, data: &#123;id: 12, name: wendu&#125;);\n\n发起多个并发请求:\n1response = await Future.wait([dio.post(info), dio.get(token)]);\n\n下载文件:\n1response = await dio.download(https:www.google.com, .xx.html);\n\n发送 FormData:\n12345FormData formData = new FormData.from(&#123;    name: wendux,    age: 25,  &#125;);  response = await dio.post(info, data: formData);\n\n通过FormData上传多个文件:\n1234567891011121314FormData formData = new FormData.from(&#123;  name: wendux,  age: 25,  file1: new UploadFileInfo(new File(.upload.txt), upload1.txt),  支持直接上传字节数组 (List&lt;int&gt;) ，方便直接上传内存中的内容  file2: new UploadFileInfo.fromBytes(      utf8.encode(hello world), word.txt),   支持文件数组上传  files: [    new UploadFileInfo(new File(.exampleupload.txt), upload.txt),    new UploadFileInfo(new File(.exampleupload.txt), upload.txt)  ]&#125;);response = await dio.post(info, data: formData);\n\n监听发送(上传)数据进度:\n1234567response = await dio.post(  http:www.dtworkroom.comdoris12.0.0test,  data: &#123;aa: bb * 22&#125;,  onUploadProgress: (int sent, int total) &#123;    print($sent $total);  &#125;,);\n\n…你可以在这里获取所有示例代码.\nDio APIs创建一个Dio实例，并配置它你可以使用默认配置或传递一个可选 Options参数来创建一个Dio实例 :\n12345678910111213Dio dio = new Dio;  使用默认配置 配置dio实例  dio.options.baseUrl = https:www.xx.comapi;  dio.options.connectTimeout = 5000; 5s  dio.options.receiveTimeout = 3000; 或者通过传递一个 `options`来创建dio实例  Options options = new Options(      baseUrl: https:www.xx.comapi,      connectTimeout: 5000,      receiveTimeout: 3000);  Dio dio = new Dio(options);\n\nDio实例的核心API是 :\nFuture request(String path, {data, Options options,CancelToken cancelToken})\n12response = await request(    test, data: &#123;id: 12, name: xx&#125;, new Options(method: GET));\n\n请求方法别名为了方便使用，Dio提供了一些其它的Restful API, 这些API都是request的别名。\nFuture get(path, {data, Options options,CancelToken cancelToken})\nFuture post(path, {data, Options options,CancelToken cancelToken})\nFuture put(path, {data, Options options,CancelToken cancelToken})\nFuture delete(path, {data, Options options,CancelToken cancelToken})\nFuture head(path, {data, Options options,CancelToken cancelToken})\nFuture put(path, {data, Options options,CancelToken cancelToken})\nFuture path(path, {data, Options options,CancelToken cancelToken})\nFuture download(String urlPath, savePath,​    {OnDownloadProgress onProgress, data, bool flush: false, Options options,CancelToken cancelToken})\n请求配置下面是所有的请求配置选项。 如果请求method没有指定，则默认为GET :\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123;   Http method.  String method;   请求基地址,可以包含子路径，如: https:www.google.comapi.  String baseUrl;   Http请求头.  Map&lt;String, dynamic&gt; headers;   连接服务器超时时间，单位是毫秒.  int connectTimeout;    响应流上前后两次接受到数据的间隔，单位为毫秒。如果两次间隔超过[receiveTimeout]，    [Dio] 将会抛出一个[DioErrorType.RECEIVE_TIMEOUT]的异常.    注意: 这并不是接收数据的总时限.  int receiveTimeout;   请求数据,可以是任意类型.  var data;   请求路径，如果 `path` 以 http(s)开始, 则 `baseURL` 会被忽略； 否则,   将会和baseUrl拼接出完整的的url.  String path = ;   请求的Content-Type，默认值是[ContentType.JSON].   如果您想以applicationx-www-form-urlencoded格式编码请求数据,   可以设置此选项为 `ContentType.parse(applicationx-www-form-urlencoded)`,  这样[Dio]   就会自动编码请求体.  ContentType contentType;   [responseType] 表示期望以那种格式(方式)接受响应数据。   目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`.     默认值是 `JSON`, 当响应头中content-type为applicationjson时，dio 会自动将响应内容转化为json对象。   如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`.     如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`.  ResponseType responseType;   `validateStatus` 决定http响应状态码是否被dio视为请求成功， 返回`validateStatus`    返回`true` , 请求结果就会按成功处理，否则会按失败处理.  ValidateStatus validateStatus;   用户自定义字段，可以在 [Interceptor]、[Transformer] 和 [Response] 中取到.  Map&lt;String, dynamic&gt; extra;&#125;\n\n这里有一个完成的示例.\n响应数据当请求成功时会返回一个Response对象，它包含如下字段：\n123456789101112&#123;   响应数据，可能已经被转换了类型, 详情请参考Options中的[ResponseType].  var data;   响应头  HttpHeaders headers;   本次请求信息  Options request;   Http status code.  int statusCode;   响应对象的自定义字段（可以在拦截器中设置它），调用方可以在`then`中获取.  Map&lt;String, dynamic&gt; extra;&#125;\n\n示例如下:\n12345Response response = await dio.get(https:www.google.com);print(response.data);print(response.headers);print(response.request);print(response.statusCode);\n\n拦截器每一个 Dio 实例都有一个请求拦截器  RequestInterceptor 和一个响应拦截器 ResponseInterceptor, 通过拦截器你可以在请求之前或响应之后(但还没有被 then 或 catchError处理)做一些统一的预处理操作。\n1234567891011121314151617dio.interceptor.request.onSend = (Options options)&#123;     在请求被发送之前做一些事情    return options; continue     如果你想完成请求并返回一些自定义数据，可以返回一个`Response`对象或返回`dio.resolve(data)`。     这样请求将会被终止，上层then会被调用，then中返回的数据将是你的自定义数据data.         如果你想终止请求并触发一个错误,你可以返回一个`DioError`对象，或返回`dio.reject(errMsg)`，     这样请求将被中止并触发异常，上层catchError会被调用。&#125;dio.interceptor.response.onSuccess = (Response response) &#123;     在返回响应数据之前做一些预处理    return response;  continue&#125;;dio.interceptor.response.onError = (DioError e)&#123;     当请求失败时做一些预处理    return e;continue&#125;\n\n如果你想移除拦截器，你可以将它们置为null:\n123dio.interceptor.request.onSend = null;dio.interceptor.response.onSuccess = null;dio.interceptor.response.onError = null;\n\n完成和终止请求响应在所有拦截器中，你都可以改变请求执行流， 如果你想完成请求响应并返回自定义数据，你可以返回一个 Response 对象或返回 dio.resolve(data)的结果。 如果你想终止(触发一个错误，上层catchError会被调用)一个请求响应，那么可以返回一个DioError 对象或返回 dio.reject(errMsg) 的结果.\n12345dio.interceptor.request.onSend = (Options options) &#123;  return dio.resolve(fake data)&#125;Response response = await dio.get(test);print(response.data); fake data\n\n拦截器中支持异步任务拦截器中不仅支持同步任务，而且也支持异步任务, 下面是在请求拦截器中发起异步任务的一个实例:\n1234567 dio.interceptor.request.onSend = (Options options) async &#123;    ...If no token, request token firstly.    Response response = await dio.get(token);    Set the token to headers    options.headers[token] = response.data[data][token];    return options; continue&#125;\n\nLockunlock 拦截器你可以通过调用拦截器的 lock()unlock 方法来锁定解锁拦截器。一旦请求响应拦截器被锁定，接下来的请求响应将会在进入请求响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行(进入拦截器)。这在一些需要串行化请求响应的场景中非常实用，后面我们将给出一个示例。\n12345678910111213tokenDio = new Dio(); Create a new instance to request the token.tokenDio.options = dio;dio.interceptor.request.onSend = (Options options) async &#123;   If no token, request token firstly and lock this interceptor   to prevent other request enter this interceptor.  dio.interceptor.request.lock();   We use a new Dio(to avoid dead lock) instance to request token.  Response response = await tokenDio.get(token);  Set the token to headers  options.headers[token] = response.data[data][token];  dio.interceptor.request.unlock();  return options; continue&#125;\n\nClear()\n你也可以调用拦截器的clear()方法来清空等待队列。\n别名当请求拦截器被锁定时，接下来的请求将会暂停，这等价于锁住了dio实例，因此，Dio示例上提供了请求拦截器lockunlock的别名方法：\ndio.lock() ==  dio.interceptor.request.lock()\ndio.unlock() ==  dio.interceptor.request.unlock()\ndio.clear() ==  dio.interceptor.request.clear()\n示例假设这么一个场景：出于安全原因，我们需要给所有的请求头中添加一个csrfToken，如果csrfToken不存在，我们先去请求csrfToken，获取到csrfToken后，再发起后续请求。 由于请求csrfToken的过程是异步的，我们需要在请求过程中锁定后续请求（因为它们需要csrfToken), 直到csrfToken请求成功后，再解锁，代码如下：\n1234567891011121314151617dio.interceptor.request.onSend = (Options options) &#123;    print(send request：path:$&#123;options.path&#125;，baseURL:$&#123;options.baseUrl&#125;);    if (csrfToken == null) &#123;      print(no token，request token firstly...);      lock the dio.      dio.lock();      return tokenDio.get(token).then((d) &#123;        options.headers[csrfToken] = csrfToken = d.data[data][token];        print(request token succeed, value:  + d.data[data][token]);        print(continue to perform request：path:$&#123;options.path&#125;，baseURL:$&#123;options.path&#125;);        return options;      &#125;).whenComplete(() =&gt; dio.unlock());  unlock the dio    &#125; else &#123;      options.headers[csrfToken] = csrfToken;      return options;    &#125;  &#125;;\n\n完整的示例代码请点击 这里.\n错误处理当请求过程中发生错误时, Dio 会包装 ErrorException 为一个 DioError:\n12345678910111213141516try &#123;  404  await dio.get(https:wendux.github.ioxsddddd);&#125; on DioError catch (e) &#123;   The request was made and the server responded with a status code   that falls out of the range of 2xx and is also not 304.  if (e.response) &#123;    print(e.response.data);    print(e.response.headers);    print(e.response.request);  &#125; else &#123;     Something happened in setting up or sending the request that triggered an Error    print(e.request);    print(e.message);  &#125;&#125;\n\nDioError 字段12345678910111213 &#123;   响应信息, 如果错误发生在在服务器返回数据之前，它为 `null`  Response response;   错误描述.  String message;   错误类型，见下文  DioErrorType type;   错误栈信息，可能为null  StackTrace stackTrace;&#125;\n\nDioErrorType12345678910111213141516171819enum DioErrorType &#123;   Default error type, usually occurs before connecting the server.  DEFAULT,   When opening  url timeout, it occurs.  CONNECT_TIMEOUT,    Whenever more than [receiveTimeout] (in milliseconds) passes between two events from response stream,    [Dio] will throw the [DioError] with [DioErrorType.RECEIVE_TIMEOUT].      Note: This is not the receiving time limitation.  RECEIVE_TIMEOUT,   When the server response, but with a incorrect status, such as 404, 503...  RESPONSE,   When the request is cancelled, dio will throw a error with this type.  CANCEL&#125;\n\n使用applicationx-www-form-urlencoded编码默认情况下, Dio 会将请求数据(除过String类型)序列化为 JSON. 如果想要以 applicationx-www-form-urlencoded格式编码, 你可以显式设置contentType :\n1234Instance leveldio.options.contentType=ContentType.parse(applicationx-www-form-urlencoded);or works oncedio.post(info,data:&#123;id:5&#125;, options: new Options(contentType:ContentType.parse(applicationx-www-form-urlencoded)));\n\n这里有一个示例.\nFormDataDio支持发送 FormData, 请求数据将会以 multipartform-data方式编码, FormData中可以一个或多个包含文件 .\n123456FormData formData = new FormData.from(&#123;    name: wendux,    age: 25,    file: new UploadFileInfo(new File(.exampleupload.txt), upload.txt)&#125;);response = await dio.post(info, data: formData);\n\n\n注意: 只有 post 方法支持发送 FormData.\n\n这里有一个完整的示例.\n转换器转换器Transformer 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器DefaultTransformer作为默认的 Transformer. 如果你想对请求响应数据进行自定义编解码处理，可以提供自定义转换器，通过 dio.transformer设置。\n\n请求转换器  Transformer.transformRequest(...)   只会被用于 ‘PUT’、 ‘POST’、 ‘PATCH’方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 Transformer.transformResponse() 会被用于所有请求方法的返回数据。\n\n执行流虽然在拦截器中也可以对数据进行预处理，但是转换器主要职责是对请求响应数据进行编解码，之所以将转化器单独分离，一是为了和拦截器解耦，二是为了不修改原始请求数据(如果你在拦截器中修改请求数据(options.data)，会覆盖原始请求数据，而在某些时候您可能需要原始请求数据). Dio的请求流是：\n请求拦截器 &gt;&gt; 请求转换器 &gt;&gt; 发起请求  &gt;&gt; 响应转换器  &gt;&gt; 响应拦截器  &gt;&gt; 最终结果。\n这是一个自定义转换器的示例.\n设置Http代理Dio 是使用 HttpClient发起的http请求，所以你可以通过配置 httpClient来支持代理，示例如下：\n12345678dio.onHttpClientCreate = (HttpClient client) &#123;  client.findProxy = (uri) &#123;    proxy all request to localhost:8888    return PROXY localhost:8888;  &#125;;   你也可以自己创建一个新的HttpClient实例返回。   return new HttpClient(SecurityContext);&#125;;\n\n完整的示例请查看这里.\nHttps证书校验有两种方法可以校验https证书，假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下：\n123456789String PEM=XXXXX; 证书内容dio.onHttpClientCreate = (HttpClient client) &#123;  client.badCertificateCallback=(X509Certificate cert, String host, int port)&#123;    if(cert.pem==PEM)&#123;  证书一致，则放行      return true;     &#125;    return false;  &#125;;&#125;;\n\nX509Certificate是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。\n对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到badCertificateCallback回调中：\n1234567dio.onHttpClientCreate = (HttpClient client) &#123;  SecurityContext sc = new SecurityContext();  file为证书路径  sc.setTrustedCertificates(file);  HttpClient httpClient = new HttpClient(context: sc);  return httpClient;&#125;;\n\n注意，通过setTrustedCertificates()设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。\n请求取消你可以通过 cancel token 来取消发起的请求：\n1234567891011CancelToken token = new CancelToken();dio.get(url, cancelToken: token)    .catchError((DioError err)&#123;        if (CancelToken.isCancel(err)) &#123;            print(Request canceled! + err.message)        &#125;else&#123;             handle error.        &#125;    &#125;); cancel the requests with cancelled message.token.cancel(cancelled);\n\n\n注意: 同一个cancel token 可以用于多个请求，当一个cancel token取消时，所有使用该cancel token的请求都会被取消。\n\n完整的示例请参考取消示例.\nCookie管理你可以通过 cookieJar 来自动管理请求响应cookie.\n\n dio cookie 管理 API 是基于开源库 cookie_jar.\n\n你可以创建一个CookieJar 或 PersistCookieJar 来帮您自动管理cookie,  dio 默认使用  CookieJar , 它会将cookie保存在内存中。 如果您想对cookie进行持久化,  请使用 PersistCookieJar ,  示例代码如下:\n12var dio = new Dio();dio.cookieJar = new PersistCookieJar(.cookies);\n\nPersistCookieJar 实现了RFC中标准的cookie策略.  PersistCookieJar 会将cookie保存在文件中，所以 cookies 会一直存在除非显式调用 delete 删除.\n更多关于 cookie_jar  请参考 : https:github.comflutterchinacookie_jar .\nCopyright &amp; License此开源项目为Flutter中文网(https:flutterchina.club) 授权 ，license 是 MIT.   如果您喜欢，欢迎star.\nFlutter中文网开源项目计划\n开发一系列Flutter SDK之外常用(实用)的Package、插件，丰富Flutter第三方库，为Flutter生态贡献来自中国开发者的力量。所有项目将发布在 Github Flutter中文网 Organization ，所有源码贡献者将加入到我们的Organization，成为成员. 目前社区已有几个开源项目开始公测，欢迎您加入开发或测试，详情请查看: Flutter中文网开源项目。 如果您想加入到“开源项目计划”， 请发邮件到824783146@qq.com， 并附上自我介绍(个人基本信息+擅长关注技术)。\nFeatures and bugsPlease file feature requests and bugs at the issue tracker.\n","tags":["Flutter","Http","dio"],"path":"2019/09/09/Flutter-Http请求开源库-dio/","external_link":""},{"title":"Git Rebase 黄金法则问题","date":"2019-09-10T13:45:18.000Z","content":"Git Rebase 黄金法则问题git 整合来自不同分支的修改主要有两种方法：merge 操作和rebase操作，merge初学者可能很熟悉。我们今天来主要说一下 rebase 操作，文章结尾会简单说一下 merge 操作的 –no-ff 参数问题。\nrebase的简单定义：你可以把某一分支的所有修改都移至另外一个分支就像重新播放一样。有点儿像金庸武侠小说里面的乾坤大挪移。举个🌰假设我们本地库的代码，如下所示\n123      A---B---C  remotesoriginmaster     D---E---F---G  master\n\n如果此时我们执行 git pull 操作，就会变成下面的样子，因为 pull 默认执行的是 merge 操作，多出来H这次没必要的提交。如下所示\n123     A---B---C  remotesoriginmaster              D---E---F---G---H master\n\n如果我们执行 git pull –rebase 操作，将会变成下面的样子，这里我们用rebase代替了默认的merge操作\n12345            remotesorigin                |D---E---A---B---C---F---G                        |                        master\n\nrebase 作用就是变成线性了，这在多人协作的情况变得非常关键。因为多人合作是不允许随意制造分叉的。大家可以参考我这篇文章。\n这就引出了这篇博文要主要阐述的问题，rebase golden rule 问题。\n\nRebase golden rule“No one shall rebase a shared branch” — Everyone about rebase\n\n简单来说就是不要在你的公共分支上做任何rebase操作。再举一个🌰。\n图一是我们做rebase操作前的样子\n\n图二是我们正确rebase的结果，即在feature分支执行rebase develop命令\n\n图三是我们错误rebase的结果，即违反黄金法则的结果，我们在develop分支上执行了rebase feature操作\n\n当我们在图三这种情况下对develop分支进行提交的话，会发现和远程分支冲突，然后我们手动或自动解决冲突，继续提交上去之后发现，我们修改的功能代码已经提交上去了，但是当我们看我们提交历史的记录的时候会发现有一部分重复的提交log。这就是问题所在，你的项目组长是绝对不允许在他的项目里出现这种情况，因为会影响后续的代码追查，code review等问题。说完了这个问题，这篇博文的主要任务基本完成了，最后在简单说一下 merge 的 –no-ff 参数，这也是我们在分支合并的时候经常遇到的问题。–no-ff 的意思就是关闭 merge 的 fast-forwarded，merge 操作默认执行的是 fast-forwarded。fast-forwarded 的意思就是在合并分支的时候，如果不涉及三方合并，git 只会简单的移动指针。再再举一个🌰\n1234567        dev        |A---B---C                   D---E              |              feature\n\n此时我们执行 merge –no-ff 操作，将会得到如下图\n12345                dev                |A---B---C--------F                         D---E\n\n执行 merge 之后得到的结果如下\n123               dev                |A---B---C---D---E\n\n如上git 将指针从C移到了E。\n简单来说就是 –no-ff 的作用就是保持分支的非线性。方便我们看到分支的变化。\n\n本文作者： Frank本文链接： http:hellofrank.github.io20180427Git-Rebase-黄金法则问题版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！\n\n","tags":["git"],"path":"2019/09/10/Git-Rebase-黄金法则问题/","external_link":""},{"title":"Github的webhooks网站自动化部署","date":"2019-09-08T23:56:41.000Z","content":"Github的webhooks进行网站自动化部署\n相信很多码农都玩过了Git，如果对Git只是一知半解，可以移步LV写的 GIT常用操作总结，下面介绍到的一些关于 Git 的概念就不再赘述。\n为啥想写这篇文章？主要是因为部门服务器因为安全性原因不允许SCP上传文件进行应用部署，然后有一些应用是放在Github上的，然后部署应用的步骤就变成：\n1.git clone github项目 本地目录2.配置一下应用的pm2.json并reload3.Nginx配置一下反向代理并restart\n当然如果只是一次性部署上去就不再修改的话并没啥问题，但是要是项目持续性修改迭代的话，就比较麻烦了，我们就在不断的重复着上面的步骤。作为一个码农，怎么允许不断的重复同样的工作，于是Github webhooks闪亮登场。\n关于Github webhooks\n必须是Github上面的项目\n订阅了确定的事件（包括pushpull等命令）\n自动触发\n\n刚好符合了这几个条件，那接下来就看看如何进行网站自动化部署，主要会从下面几点来讲解：\n\n自动化shell脚本\n服务端实现\n配置github webhooks\n\n自动化脚本auto_build.sh\n1234567#! binbashSITE_PATH=rootnginxwwwcd $SITE_PATHgit reset --hard originmastergit clean -fgit pullgit checkout master\n\nNote: 在执行上面shell脚本之前我们必须第一次手动git clone项目进去\n服务端实现Github webhooks需要跟我们的服务器进行通信，确保是可以推送到我们的服务器，所以会发送一个带有X-Hub-Signature的POST请求，为了方便我们直接用第三方的库github-webhook-handler来接收参数并且做监听事件的处理等工作。\n1npm i github-webhook-handler -S\n\nindex.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(http);var spawn = require(child_process).spawn;var createHandler = require(github-webhook-handler); 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径var handler = createHandler(&#123; path: auto_build, secret:  &#125;);http.createServer(function (req, res) &#123;  handler(req, res, function (err) &#123;    res.statusCode = 404;    res.end(no such location);  &#125;)&#125;).listen(6666);handler.on(error, function (err) &#123;  console.error(Error:, err.message)&#125;); 监听到push事件的时候执行我们的自动化脚本handler.on(push, function (event) &#123;  console.log(Received a push event for %s to %s,    event.payload.repository.name,    event.payload.ref);  runCommand(sh, [auto_build.sh], function( txt )&#123;    console.log(txt);  &#125;);&#125;);function runCommand( cmd, args, callback )&#123;    var child = spawn( cmd, args );    var response = ;    child.stdout.on(data, function( buffer )&#123; resp += buffer.toString(); &#125;);    child.stdout.on(end, function()&#123; callback( resp ) &#125;);&#125; 由于我们不需要监听issues，所以下面代码注释掉  handler.on(issues, function (event) &#123;    console.log(Received an issue event for %s action=%s: #%d %s,      event.payload.repository.name,      event.payload.action,      event.payload.issue.number,      event.payload.issue.title)&#125;);\n\n配置github webhooks\n小结上面就是利用Github webhooks进行网站自动化部署的全部内容了，不难发现其实这项技术还是有局限性的，那就是依赖于github，一般我们选择的都是免费github账号，所有项目都对外，一些敏感项目是不适合放置上去的。\n","tags":["git","github","webhooks","自动化部署"],"path":"2019/09/09/Github的webhooks网站自动化部署/","external_link":""},{"title":"Electron-vue","date":"2019-09-08T03:09:19.000Z","content":"\nElectron-vue\n基于 vue (基本上是它听起来的样子) 来构造 electron 应用程序的样板代码。\n\n什么是electron?\n\nelectron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。\n它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：\n\nMain进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。\nRenderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在3. Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。Main进程和Renderer进程通过ipcMain和ipcRenderer来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。\n\n起步该样板代码被构建为 vue-cli 的一个模板，并且包含多个选项，可以自定义你最终的脚手架程序。本项目需要使用 node@^7 或更高版本。electron-vue 官方推荐 yarn 作为软件包管理器，因为它可以更好地处理依赖关系，并可以使用 yarn clean 帮助减少最后构建文件的大小。\n12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgregelectron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev\n\n项目结构12345678910111213141516171819202122232425262728293031323334353637my-project├─ .electron-vue│  └─ &lt;builddevelopment&gt;.js files├─ build│  └─ icons├─ dist│  ├─ electron│  └─ web├─ node_modules├─ src│  ├─ main│  │  ├─ index.dev.js│  │  └─ index.js│  ├─ renderer│  │  ├─ components│  │  ├─ router│  │  ├─ store│  │  ├─ App.vue│  │  └─ main.js│  └─ index.ejs├─ static├─ test│  ├─ e2e│  │  ├─ specs│  │  ├─ index.js│  │  └─ utils.js│  ├─ unit│  │  ├─ specs│  │  ├─ index.js│  │  └─ karma.config.js│  └─ .eslintrc├─ .babelrc├─ .eslintignore├─ .eslintrc.js├─ .gitignore├─ package.json└─ README.md\n\n产品构建123456789app.asar├─ dist│  └─ electron│     ├─ static│     ├─ index.html│     ├─ main.js│     └─ renderer.js├─ node_modules└─ package.json\n\n运行效果\n","tags":["electron","vue"],"path":"2019/09/08/Electron-vue/","external_link":""},{"title":"Java面试题（框架+JVM+多线程+算法+数据库）","date":"2019-08-24T08:20:38.000Z","content":"\n基础与框架\nString类能被继承吗，为什么\nString，Stringbuffer，StringBuilder的区别？\nArrayList和LinkedList有什么区别\n类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序\n用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等\nHashMap为什么get和set那么快，concurrentHashMap为什么能提高并发\n抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\n什么情况下会发生栈内存溢出\n什么是nio，原理\n反射中，Class.forName和ClassLoader区别\ntomcat结构，类加载器流程\n讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式\nSpring的beanFactory和factoryBean的区别\nSpring加载流程\nSpring如何管理事务的\n\n多线程\n线城池的最大线程数目根据什么确定\n多线程的几种实现方式，什么是线程安全，什么是重排序3.volatile的原理，作用，能代替锁么\nsleep和wait的区别，以及wait的实现原理\nLock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁\n用过哪些原子类，他们的参数以及原理是什么\n用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等\n有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。\nspring的controller是单例还是多例，怎么保证并发的安全\n用三个线程按顺序循环打印abc三个字母，比如abcabcabc\nThreadLocal用过么，原理是什么，用的时候要注意什么\n如果让你实现一个并发安全的链表，你会怎么做\n\nJVM相关\njvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等\n你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms\n当出现了内存溢出，你怎么排错\nJVM内存模型的相关知识了解多少\n简单说说你了解的类加载器\nJAVA的反射机制\n\n网络\nhttp1.0和http1.1有什么区别\nTCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么\nTIME_WAIT和CLOSE_WAIT的区别\n说说你知道的几种HTTP响应码\n当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤\nLinux下IO模型有几种，各自的含义是什么\nTCPIP如何保证可靠性，数据包有哪些数据组成\n架构设计与分布式：\ntomcat如何调优，各种参数的意义\n常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等\n如何防止缓存雪崩12.用java自己实现一个LRU\n分布式集群下如何做到唯一序列号\n设计一个秒杀系统，30分钟没付款就自动关闭交易\n如何做一个分布式锁\n用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗\nMQ系统的数据如何保证不丢失\n分布式事务的原理，如何使用分布式事务\n什么是一致性hash\n什么是restful，讲讲你理解的restful\n如何设计建立和保持100w的长连接？\n解释什么是MESI协议(缓存一致性)\n说说你知道的几种HASH算法，简单的也可以\n什么是paxos算法\nredis和memcached 的内存管理的区别\n一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新\n\n算法\n10亿个数字里里面找最小的10个2、有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优3、2亿个随机生成的无序整数,找出中间大小的值4、遍历二叉树六、数据库1.数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点\n高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义\nSQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？\n数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁\nMYsql的索引实现方式\n聚集索引和非聚集索引的区别\n数据库中 BTREE和B+tree区别\n\n作者：程序汪追风链接：https:juejin.impost5d5fd40bf265da03df5f1b3a来源：掘金\n","tags":["算法","面试","数据库","JVM","框架"],"path":"2019/08/24/Java面试题（框架-JVM-多线程-算法-数据库）/","external_link":""},{"title":"Spring框架面试总结","date":"2019-09-03T16:32:24.000Z","content":"\n介绍spring框架它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。\nSpring的优点？\n降低了组件之间的耦合性 ，实现了软件各层之间的解耦 \n可以使用容易提供的众多服务，如事务管理，消息服务等 \n容器提供单例模式支持 \n容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 \n容器提供了众多的辅助类，能加快应用的开发 \nspring对于主流的应用框架提供了集成支持，如hibernate，   JPA，Struts等 \nspring属于低侵入式设计，代码的污染极低 \n独立于各种应用服务器 \nspring的DI机制降低了业务对象替换的复杂性 \nSpring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring 的部分或全部 \n\nspring有两种代理方式：答: 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。\n  优点：因为有接口，所以使系统更加松耦合\n  缺点：为每一个目标类创建接口\n若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。\n  优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。\n  缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好\n如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。\nXML配置文件。\n基于注解的配置。\n基于java的配置。\n构造方法注入和设值注入有什么区别？请注意以下明显的区别：\n在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。\n对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。\n在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。\n设值注入不会重写构造方法的值。\n在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。\n请介绍一下Spring框架中Bean的生命周期一、Bean的定义 \nSpring通常通过配置文件定义Bean。如：  \n这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 \n二、Bean的初始化\n有两种方式初始化Bean。 \n1、在配置文档中通过指定init-method 属性来完成 \n2、实现 org.springframwork.beans.factory.InitializingBean接口  \n那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 \n三、Bean的调用 \n有三种方式可以得到Bean并进行调用： \n1、使用BeanWrapper\n2、使用BeanFactory\n3、使用ApplicationConttext\n四、Bean的销毁 \n1、使用配置文件中的 destory-method 属性\n2、实现 org.springframwork.bean.factory.DisposebleBean接口 \nSpring中AOP的应用场景、Aop原理、好处？答：AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:\nAuthentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务\n原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。\n优点：1.各个步骤之间的良好隔离性耦合性大大降低 \n2.源代码无关性，再扩展功能的同时不对源码进行修改操作 有几种不同类型的自动代理？BeanNameAutoProxyCreator\nDefaultAdvisorAutoProxyCreator\nMetadata autoproxying\nApplicationContext通常的实现是什么?FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\nClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\nWebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。\n有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\nSetter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。\n什么是IOC，什么又是DI，他们有什么区别？一、IOC介绍\nIOC是控制反转。\n创建对象实例的控制权从代码控制剥离到IOC容器控制(之前的写法，由程序代码直接操控使用new关键字)，实际就是你在xml文件控制，控制权的转移是所谓反转，侧重于原理。 \n二、DI介绍\nDI是依赖注入\n创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。\nspring事务定义事务的定义：事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么都成功。其必须遵循四个原则（ACID）。\n原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做；\n一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。\n隔离性（Isolation）：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；\n持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。\nSpring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。\n","tags":["面试","Spring"],"path":"2019/09/04/Spring框架面试总结/","external_link":""},{"title":"Java反编译工具jad","date":"2019-09-06T05:21:38.000Z","content":"\nJad(JAva Decompiler)Jad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。下载点击\n使用方法：\n[1] 反编译一个class文件：jad example.class，会生成example.jad，用文本编辑器打开就是java源代码\n[2] 指定生成源代码的后缀名：jad -sjava example.class，生成example.java\n[3] 改变生成的源代码的名称，可以先使用-p将反编译后的源代码输出到控制台窗口，然后使用重定向，输出到文件：jad -p example.class &gt; myexample.java\n[4] 把源代码文件输出到指定的目录：jad -dnewdir -sjava example.class，在newdir目录下生成example.java\n[5] 把packages目录下的class文件全部反编译：jad -sjava packages*.class\n[6] 把packages目录以及子目录下的文件全部反编译：jad -sjava packages*.class，不过你仍然会发现所有的源代码文件被放到了同一个文件中，没有按照class文件的包路径建立起路径\n[7] 把packages目录以及子目录下的文件全部反编译并建立和java包一致的文件夹路径，可以使用-r命令：jad -r -sjava packages*.class\n[8] 当重复使用命令反编译时，Jad会提示“whether you want to overwrite it or not”，使用-o可以强制覆盖旧文件\n[9] 还有其他的参数可以设置生成的源代码的格式，可以输入jad命令查看帮助，这里有个人做了简单的翻译：jad命令总结\n[10] 当然，你会发现有些源文件头部有些注释信息，不用找了，jad没有参数可以去掉它，用别的办法吧。\n测试Main.java\n123456789101112131415161718192021222324252627282930public class Main &#123;    static volatile int t = 0;    public static void main(String[] args) &#123;        int n = 100;        Thread[] threads = new Thread[n];        for (int i = 0; i &lt; n; i++) &#123;            threads[i] = new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i = 0; i &lt; 10000; i++) &#123;                        add();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        while (Thread.activeCount() &gt; 1)            Thread.yield();        System.out.println(t);    &#125;    static void add() &#123;        t++;    &#125;&#125;\n\nMain.class\n1234567891011121314151617cafe babe 0000 0034 0037 0a00 0d00 1d07001e 0700 1f0a 0003 001d 0a00 0200 200a0002 0021 0a00 0200 220a 0002 0023 09002400 2509 000c 0026 0a00 2700 2807 00290700 2a01 000c 496e 6e65 7243 6c61 73736573 0100 0174 0100 0149 0100 063c 696e6974 3e01 0003 2829 5601 0004 436f 64650100 0f4c 696e 654e 756d 6265 7254 61626c65 0100 046d 6169 6e01 0016 285b 4c6a6176 612f 6c61 6e67 2f53 7472 696e 673b2956 0100 0d53 7461 636b 4d61 7054 61626c65 0700 2b01 0003 6164 6401 0008 3c636c69 6e69 743e 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0011 0012 0100 106a 6176 612f 6c61 6e672f54 6872 6561 6401 0006 4d61 696e 2431...\n\n\n反编译后的结果\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. Jad home page: http:www.kpdus.comjad.html Decompiler options: packimports(3)  Source File Name:   Main.javaimport java.io.PrintStream;public class Main&#123;    public Main()    &#123;    &#125;    public static void main(String args[])    &#123;        byte byte0 = 100;        Thread athread[] = new Thread[byte0];        for(int i = 0; i &lt; byte0; i++)        &#123;            athread[i] = new Thread(new Runnable() &#123;                public void run()                &#123;                    for(int j = 0; j &lt; 10000; j++)                        Main.add();                &#125;            &#125;);            athread[i].start();        &#125;        for(; Thread.activeCount() &gt; 1; Thread.yield());        System.out.println(t);    &#125;    static void add()    &#123;        t++;    &#125;    static volatile int t = 0;&#125;\n\n","tags":["Java","反编译","jad"],"path":"2019/09/06/Java反编译工具jad/","external_link":""},{"title":"TensorFlow 2.0 中文手写字识别（汉字OCR）","date":"2019-09-06T07:08:56.000Z","content":"\nTensorFlow 2.0 中文手写字识别（汉字OCR）\n搜索空间空前巨大，我们使用的数据集1.0版本汉字就多大3755个，如果加上1.1版本一起，总共汉字可以分为多达7599+个类别！这比10个阿拉伯字母识别难度大很多！\n数据集处理挑战更大，相比于mnist和fasionmnist来说，汉字手写字体识别数据集非常少，而且仅有的数据集数据预处理难度非常大，非常不直观，但是，千万别吓到，相信你看完本教程一定会收货满满!\n汉字识别更考验选手的建模能力，还在分类花？分类猫和狗？随便搭建的几层在搜索空间巨大的汉字手写识别里根本不work！你现在是不是想用很深的网络跃跃欲试？更深的网络在这个任务上可能根本不可行！！看完本教程我们就可以一探究竟！总之一句话，模型太简单和太复杂都不好，甚至会发散！（想亲身体验模型训练发散抓狂的可以来尝试一下！）。\n\n数据准备在开始之前，先介绍一下本项目所采用的数据信息。我们的数据全部来自于CASIA的开源中文手写字数据集，该数据集分为两部分：\n\nCASIA-HWDB：离线的HWDB，我们仅仅使用1.0-1.2，这是单字的数据集，2.0-2.2是整张文本的数据集，我们暂时不用，单字里面包含了约7185个汉字以及171个英文字母、数字、标点符号等；\nCASIA-OLHWDB：在线的HWDB，格式一样，包含了约7185个汉字以及171个英文字母、数字、标点符号等，我们不用。\n\n其实你下载1.0的train和test差不多已经够了，可以直接运行 datasetget_hwdb_1.0_1.1.sh 下载。原始数据下载链接点击这里. 由于原始数据过于复杂，我们使用一个类来封装数据读取过程，这是我们展示的效果：\n看到这么密密麻麻的文字相信连人类都…. 开始头疼了，这些复杂的文字能够通过一个神经网络来识别出来？？答案是肯定的…. 不有得感叹一下神经网络的强大。。上面的部分文字识别出来的结果是这样的：\n\n关于数据的处理部分，从服务器下载到的原始数据是 trn_gnt.zip 解压之后是 gnt.alz， 需要再次解压得到一个包含 gnt文件的文件夹。里面每一个gnt文件都包含了若干个汉字及其标注。直接处理比较麻烦，也不方便抽取出图片再进行操作，虽然转为图片存入文件夹比较直观，但是不适合批量读取和训练, 后面我们统一转为tfrecord进行训练。\n更新: 实际上，由于单个汉字图片其实很小，差不多也就最大80x80的大小，这个大小不适合转成图片保存到本地，因此我们将hwdb原始的二进制保存为tfrecord。同时也方便后面训练，可以直接从tfrecord读取图片进行训练。\n\n训练过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def train():    all_characters = load_characters()    num_classes = len(all_characters)    logging.info(all characters: &#123;&#125;.format(num_classes))    train_dataset = load_ds()    train_dataset = train_dataset.shuffle(100).map(preprocess).batch(32).repeat()    val_ds = load_val_ds()    val_ds = val_ds.shuffle(100).map(preprocess).batch(32).repeat()    for data in train_dataset.take(2):        print(data)    # init model    model = build_net_003((64, 64, 1), num_classes)    model.summary()    logging.info(model loaded.)    start_epoch = 0    latest_ckpt = tf.train.latest_checkpoint(os.path.dirname(ckpt_path))    if latest_ckpt:        start_epoch = int(latest_ckpt.split(-)[1].split(.)[0])        model.load_weights(latest_ckpt)        logging.info(model resumed from: &#123;&#125;, start at epoch: &#123;&#125;.format(latest_ckpt, start_epoch))    else:        logging.info(passing resume since weights not there. training from scratch)    if use_keras_fit:        model.compile(            optimizer=tf.keras.optimizers.Adam(),            loss=tf.keras.losses.SparseCategoricalCrossentropy(),            metrics=[accuracy])        callbacks = [            tf.keras.callbacks.ModelCheckpoint(ckpt_path,                                               save_weights_only=True,                                               verbose=1,                                               period=500)        ]        try:            model.fit(                train_dataset,                validation_data=val_ds,                validation_steps=1000,                epochs=15000,                steps_per_epoch=1024,                callbacks=callbacks)        except KeyboardInterrupt:            model.save_weights(ckpt_path.format(epoch=0))            logging.info(keras model saved.)        model.save_weights(ckpt_path.format(epoch=0))        model.save(os.path.join(os.path.dirname(ckpt_path), cn_ocr.h5))\n\n大家在以后编写训练代码的时候其实可以保持这个好的习惯。\nOK，整个模型训练起来之后，可以在短时间内达到95%的准确率：\n\n\n总结通过本教程，我们完成了使用tensorflow 2.0全新的API搭建一个中文汉字手写识别系统。模型基本能够实现我们想要的功能。要知道，这个模型可是在搜索空间多大3755的类别当中准确的找到最相似的类别！！通过本实验，我们有几点心得：\n\n神经网络不仅仅是在学习，它具有一定的想象力！！比如它的一些看着很像的字：拜-佯， 扮-捞，笨-苯…. 这些字如果手写出来，连人都比较难以辨认！！但是大家要知道这些字在类别上并不是相领的！也就是说，模型具有一定的联想能力！\n不管问题多复杂，要敢于动手、善于动手。\n\n","tags":["AI","TensorFlow","OCR"],"path":"2019/09/06/TensorFlow-2-0-中文手写字识别（汉字OCR）/","external_link":""},{"title":"System类","date":"2019-09-06T06:20:34.000Z","content":"\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256* * Copyright (c) 1994, 2013, Oracle andor its affiliates. All rights reserved. * ORACLE PROPRIETARYCONFIDENTIAL. Use is subject to license terms. * * *package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;** * The &lt;code&gt;System&lt;code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author  unascribed * @since   JDK1.0 *public final class System &#123;    * register the natives via the static initializer.     *     * VM will invoke the initializeSystemClass method to complete     * the initialization for this class separated from clinit.     * Note that to use properties set by the VM, see the constraints     * described in the initializeSystemClass method.     *    private static native void registerNatives();    static &#123;        registerNatives();    &#125;    ** Dont let anyone instantiate this class *    private System() &#123;    &#125;    **     * The standard input stream. This stream is already     * open and ready to supply input data. Typically this stream     * corresponds to keyboard input or another input source specified by     * the host environment or user.     *    public final static InputStream in = null;    **     * The standard output stream. This stream is already     * open and ready to accept output data. Typically this stream     * corresponds to display output or another output destination     * specified by the host environment or user.     * &lt;p&gt;     * For simple stand-alone Java applications, a typical way to write     * a line of output data is:     * &lt;blockquote&gt;&lt;pre&gt;     *     System.out.println(data)     * &lt;pre&gt;&lt;blockquote&gt;     * &lt;p&gt;     * See the &lt;code&gt;println&lt;code&gt; methods in class &lt;code&gt;PrintStream&lt;code&gt;.     *     * @see     java.io.PrintStream#println()     * @see     java.io.PrintStream#println(boolean)     * @see     java.io.PrintStream#println(char)     * @see     java.io.PrintStream#println(char[])     * @see     java.io.PrintStream#println(double)     * @see     java.io.PrintStream#println(float)     * @see     java.io.PrintStream#println(int)     * @see     java.io.PrintStream#println(long)     * @see     java.io.PrintStream#println(java.lang.Object)     * @see     java.io.PrintStream#println(java.lang.String)     *    public final static PrintStream out = null;    **     * The standard error output stream. This stream is already     * open and ready to accept output data.     * &lt;p&gt;     * Typically this stream corresponds to display output or another     * output destination specified by the host environment or user. By     * convention, this output stream is used to display error messages     * or other information that should come to the immediate attention     * of a user even if the principal output stream, the value of the     * variable &lt;code&gt;out&lt;code&gt;, has been redirected to a file or other     * destination that is typically not continuously monitored.     *    public final static PrintStream err = null;    * The security manager for the system.     *    private static volatile SecurityManager security = null;    **     * Reassigns the standard input stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard input stream.     * &lt;p&gt;     *     * @param in the new standard input stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard input stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setIn(InputStream in) &#123;        checkIO();        setIn0(in);    &#125;    **     * Reassigns the standard output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard output stream.     *     * @param out the new standard output stream     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setOut(PrintStream out) &#123;        checkIO();        setOut0(out);    &#125;    **     * Reassigns the standard error output stream.     *     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;code&gt;     * method is called with a &lt;code&gt;RuntimePermission(setIO)&lt;code&gt; permission     *  to see if its ok to reassign the standard error output stream.     *     * @param err the new standard error output stream.     *     * @throws SecurityException     *        if a security manager exists and its     *        &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *        reassigning of the standard error output stream.     *     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *     * @since   JDK1.1     *    public static void setErr(PrintStream err) &#123;        checkIO();        setErr0(err);    &#125;    private static volatile Console cons = null;    **     * Returns the unique &#123;@link java.io.Console Console&#125; object associated     * with the current Java virtual machine, if any.     *     * @return  The system console, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @since   1.6     *     public static Console console() &#123;         if (cons == null) &#123;             synchronized (System.class) &#123;                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();             &#125;         &#125;         return cons;     &#125;    **     * Returns the channel inherited from the entity that created this     * Java virtual machine.     *     * &lt;p&gt; This method returns the channel obtained by invoking the     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125; method of the system-wide default     * &#123;@link java.nio.channels.spi.SelectorProvider&#125; object. &lt;p&gt;     *     * &lt;p&gt; In addition to the network-oriented channels described in     * &#123;@link java.nio.channels.spi.SelectorProvider#inheritedChannel     * inheritedChannel&#125;, this method may return other kinds of     * channels in the future.     *     * @return  The inherited channel, if any, otherwise &lt;tt&gt;null&lt;tt&gt;.     *     * @throws  IOException     *          If an IO error occurs     *     * @throws  SecurityException     *          If a security manager is present and it does not     *          permit access to the channel.     *     * @since 1.5     *    public static Channel inheritedChannel() throws IOException &#123;        return SelectorProvider.provider().inheritedChannel();    &#125;    private static void checkIO() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(setIO));        &#125;    &#125;    private static native void setIn0(InputStream in);    private static native void setOut0(PrintStream out);    private static native void setErr0(PrintStream err);    **     * Sets the System security.     *     * &lt;p&gt; If there is a security manager already installed, this method first     * calls the security managers &lt;code&gt;checkPermission&lt;code&gt; method     * with a &lt;code&gt;RuntimePermission(setSecurityManager)&lt;code&gt;     * permission to ensure its ok to replace the existing     * security manager.     * This may result in throwing a &lt;code&gt;SecurityException&lt;code&gt;.     *     * &lt;p&gt; Otherwise, the argument is established as the current     * security manager. If the argument is &lt;code&gt;null&lt;code&gt; and no     * security manager has been established, then no action is taken and     * the method simply returns.     *     * @param      s   the security manager.     * @exception  SecurityException  if the security manager has already     *             been set and its &lt;code&gt;checkPermission&lt;code&gt; method     *             doesnt allow it to be replaced.     * @see #getSecurityManager     * @see SecurityManager#checkPermission     * @see java.lang.RuntimePermission     *    public static    void setSecurityManager(final SecurityManager s) &#123;        try &#123;            s.checkPackageAccess(java.lang);        &#125; catch (Exception e) &#123;             no-op        &#125;        setSecurityManager0(s);    &#125;    private static synchronized    void setSecurityManager0(final SecurityManager s) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;             ask the currently installed security manager if we             can replace it.            sm.checkPermission(new RuntimePermission                                     (setSecurityManager));        &#125;        if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) &#123;             New security manager class is not on bootstrap classpath.             Cause policy to get initialized before we install the new             security manager, in order to prevent infinite loops when             trying to initialize the policy (which usually involves             accessing some security andor system properties, which in turn             calls the installed security managers checkPermission method             which will loop infinitely if there is a non-system class             (in this case: the new security manager class) on the stack).            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;                public Object run() &#123;                    s.getClass().getProtectionDomain().implies                        (SecurityConstants.ALL_PERMISSION);                    return null;                &#125;            &#125;);        &#125;        security = s;    &#125;    **     * Gets the system security interface.     *     * @return  if a security manager has already been established for the     *          current application, then that security manager is returned;     *          otherwise, &lt;code&gt;null&lt;code&gt; is returned.     * @see     #setSecurityManager     *    public static SecurityManager getSecurityManager() &#123;        return security;    &#125;    **     * Returns the current time in milliseconds.  Note that     * while the unit of time of the return value is a millisecond,     * the granularity of the value depends on the underlying     * operating system and may be larger.  For example, many     * operating systems measure time in units of tens of     * milliseconds.     *     * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;code&gt; for     * a discussion of slight discrepancies that may arise between     * computer time and coordinated universal time (UTC).     *     * @return  the difference, measured in milliseconds, between     *          the current time and midnight, January 1, 1970 UTC.     * @see     java.util.Date     *    public static native long currentTimeMillis();    **     * Returns the current value of the running Java Virtual Machines     * high-resolution time source, in nanoseconds.     *     * &lt;p&gt;This method can only be used to measure elapsed time and is     * not related to any other notion of system or wall-clock time.     * The value returned represents nanoseconds since some fixed but     * arbitrary &lt;i&gt;origin&lt;i&gt; time (perhaps in the future, so values     * may be negative).  The same origin is used by all invocations of     * this method in an instance of a Java virtual machine; other     * virtual machine instances are likely to use a different origin.     *     * &lt;p&gt;This method provides nanosecond precision, but not necessarily     * nanosecond resolution (that is, how frequently the value changes)     * - no guarantees are made except that the resolution is at least as     * good as that of &#123;@link #currentTimeMillis()&#125;.     *     * &lt;p&gt;Differences in successive calls that span greater than     * approximately 292 years (2&lt;sup&gt;63&lt;sup&gt; nanoseconds) will not     * correctly compute elapsed time due to numerical overflow.     *     * &lt;p&gt;The values returned by this method become meaningful only when     * the difference between two such values, obtained within the same     * instance of a Java virtual machine, is computed.     *     * &lt;p&gt; For example, to measure how long some code takes to execute:     *  &lt;pre&gt; &#123;@code     * long startTime = System.nanoTime();     *  ... the code being measured ...     * long estimatedTime = System.nanoTime() - startTime;&#125;&lt;pre&gt;     *     * &lt;p&gt;To compare two nanoTime values     *  &lt;pre&gt; &#123;@code     * long t0 = System.nanoTime();     * ...     * long t1 = System.nanoTime();&#125;&lt;pre&gt;     *     * one should use &#123;@code t1 - t0 &lt; 0&#125;, not &#123;@code t1 &lt; t0&#125;,     * because of the possibility of numerical overflow.     *     * @return the current value of the running Java Virtual Machines     *         high-resolution time source, in nanoseconds     * @since 1.5     *    public static native long nanoTime();    **     * Copies an array from the specified source array, beginning at the     * specified position, to the specified position of the destination array.     * A subsequence of array components are copied from the source     * array referenced by &lt;code&gt;src&lt;code&gt; to the destination array     * referenced by &lt;code&gt;dest&lt;code&gt;. The number of components copied is     * equal to the &lt;code&gt;length&lt;code&gt; argument. The components at     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; in the source array are copied into     * positions &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+length-1&lt;code&gt;, respectively, of the destination     * array.     * &lt;p&gt;     * If the &lt;code&gt;src&lt;code&gt; and &lt;code&gt;dest&lt;code&gt; arguments refer to the     * same array object, then the copying is performed as if the     * components at positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; were first copied to a temporary     * array with &lt;code&gt;length&lt;code&gt; components and then the contents of     * the temporary array were copied into positions     * &lt;code&gt;destPos&lt;code&gt; through &lt;code&gt;destPos+length-1&lt;code&gt; of the     * destination array.     * &lt;p&gt;     * If &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown.     * &lt;p&gt;     * If &lt;code&gt;src&lt;code&gt; is &lt;code&gt;null&lt;code&gt;, then a     * &lt;code&gt;NullPointerException&lt;code&gt; is thrown and the destination     * array is not modified.     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown and the destination is     * not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;dest&lt;code&gt; argument refers to an object that is not an     *     array.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument and &lt;code&gt;dest&lt;code&gt; argument refer     *     to arrays whose component types are different primitive types.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a primitive     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a reference component type.     * &lt;li&gt;The &lt;code&gt;src&lt;code&gt; argument refers to an array with a reference     *    component type and the &lt;code&gt;dest&lt;code&gt; argument refers to an array     *     with a primitive component type.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any of the following is true, an     * &lt;code&gt;IndexOutOfBoundsException&lt;code&gt; is     * thrown and the destination is not modified:     * &lt;ul&gt;     * &lt;li&gt;The &lt;code&gt;srcPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;destPos&lt;code&gt; argument is negative.     * &lt;li&gt;The &lt;code&gt;length&lt;code&gt; argument is negative.     * &lt;li&gt;&lt;code&gt;srcPos+length&lt;code&gt; is greater than     *     &lt;code&gt;src.length&lt;code&gt;, the length of the source array.     * &lt;li&gt;&lt;code&gt;destPos+length&lt;code&gt; is greater than     *     &lt;code&gt;dest.length&lt;code&gt;, the length of the destination array.     * &lt;ul&gt;     * &lt;p&gt;     * Otherwise, if any actual component of the source array from     * position &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+length-1&lt;code&gt; cannot be converted to the component     * type of the destination array by assignment conversion, an     * &lt;code&gt;ArrayStoreException&lt;code&gt; is thrown. In this case, let     * &lt;b&gt;&lt;i&gt;k&lt;i&gt;&lt;b&gt; be the smallest nonnegative integer less than     * length such that &lt;code&gt;src[srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;]&lt;code&gt;     * cannot be converted to the component type of the destination     * array; when the exception is thrown, source array components from     * positions &lt;code&gt;srcPos&lt;code&gt; through     * &lt;code&gt;srcPos+&lt;code&gt;&lt;i&gt;k&lt;i&gt;&lt;code&gt;-1&lt;code&gt;     * will already have been copied to destination array positions     * &lt;code&gt;destPos&lt;code&gt; through     * &lt;code&gt;destPos+&lt;code&gt;&lt;i&gt;k&lt;I&gt;&lt;code&gt;-1&lt;code&gt; and no other     * positions of the destination array will have been modified.     * (Because of the restrictions already itemized, this     * paragraph effectively applies only to the situation where both     * arrays have component types that are reference types.)     *     * @param      src      the source array.     * @param      srcPos   starting position in the source array.     * @param      dest     the destination array.     * @param      destPos  starting position in the destination data.     * @param      length   the number of array elements to be copied.     * @exception  IndexOutOfBoundsException  if copying would cause     *               access of data outside array bounds.     * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;code&gt;     *               array could not be stored into the &lt;code&gt;dest&lt;code&gt; array     *               because of a type mismatch.     * @exception  NullPointerException if either &lt;code&gt;src&lt;code&gt; or     *               &lt;code&gt;dest&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     *    public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);    **     * Returns the same hash code for the given object as     * would be returned by the default method hashCode(),     * whether or not the given objects class overrides     * hashCode().     * The hash code for the null reference is zero.     *     * @param x object for which the hashCode is to be calculated     * @return  the hashCode     * @since   JDK1.1     *    public static native int identityHashCode(Object x);    **     * System properties. The following properties are guaranteed to be defined:     * &lt;dl&gt;     * &lt;dt&gt;java.version         &lt;dd&gt;Java version number     * &lt;dt&gt;java.vendor          &lt;dd&gt;Java vendor specific string     * &lt;dt&gt;java.vendor.url      &lt;dd&gt;Java vendor URL     * &lt;dt&gt;java.home            &lt;dd&gt;Java installation directory     * &lt;dt&gt;java.class.version   &lt;dd&gt;Java class version number     * &lt;dt&gt;java.class.path      &lt;dd&gt;Java classpath     * &lt;dt&gt;os.name              &lt;dd&gt;Operating System Name     * &lt;dt&gt;os.arch              &lt;dd&gt;Operating System Architecture     * &lt;dt&gt;os.version           &lt;dd&gt;Operating System Version     * &lt;dt&gt;file.separator       &lt;dd&gt;File separator ( on Unix)     * &lt;dt&gt;path.separator       &lt;dd&gt;Path separator (: on Unix)     * &lt;dt&gt;line.separator       &lt;dd&gt;Line separator (n on Unix)     * &lt;dt&gt;user.name            &lt;dd&gt;User account name     * &lt;dt&gt;user.home            &lt;dd&gt;User home directory     * &lt;dt&gt;user.dir             &lt;dd&gt;Users current working directory     * &lt;dl&gt;     *    private static Properties props;    private static native Properties initProperties(Properties props);    **     * Determines the current system properties.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The current set of system properties for use by the     * &#123;@link #getProperty(String)&#125; method is returned as a     * &lt;code&gt;Properties&lt;code&gt; object. If there is no current set of     * system properties, a set of system properties is first created and     * initialized. This set of system properties always includes values     * for the following keys:     * &lt;table summary=Shows property keys and associated values&gt;     * &lt;tr&gt;&lt;th&gt;Key&lt;th&gt;     *     &lt;th&gt;Description of Associated Value&lt;th&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor.url&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java vendor URL&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java installation directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine specification name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Virtual Machine implementation name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.vendor&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  vendor&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java Runtime Environment specification  name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class format version number&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Java class path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.library.path&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;List of paths to search when loading libraries&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.io.tmpdir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Default temp file path&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.compiler&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Name of JIT compiler to use&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.ext.dirs&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path of extension directory or directories     *         &lt;b&gt;Deprecated.&lt;b&gt; &lt;i&gt;This property, and the mechanism     *            which implements it, may be removed in a future     *            release.&lt;i&gt; &lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.arch&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system architecture&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.version&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Operating system version&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;file.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;File separator ( on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;path.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Path separator (: on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;line.separator&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Line separator (n on UNIX)&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.name&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users account name&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.home&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users home directory&lt;td&gt;&lt;tr&gt;     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.dir&lt;code&gt;&lt;td&gt;     *     &lt;td&gt;Users current working directory&lt;td&gt;&lt;tr&gt;     * &lt;table&gt;     * &lt;p&gt;     * Multiple paths in a system property value are separated by the path     * separator character of the platform.     * &lt;p&gt;     * Note that even if the security manager does not permit the     * &lt;code&gt;getProperties&lt;code&gt; operation, it may choose to permit the     * &#123;@link #getProperty(String)&#125; operation.     *     * @return     the system properties     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #setProperties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @see        java.util.Properties     *    public static Properties getProperties() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        return props;    &#125;    **     * Returns the system-dependent line separator string.  It always     * returns the same value - the initial value of the &#123;@linkplain     * #getProperty(String) system property&#125; &#123;@code line.separator&#125;.     *     * &lt;p&gt;On UNIX systems, it returns &#123;@code n&#125;; on Microsoft     * Windows systems it returns &#123;@code rn&#125;.     *     * @return the system-dependent line separator string     * @since 1.7     *    public static String lineSeparator() &#123;        return lineSeparator;    &#125;    private static String lineSeparator;    **     * Sets the system properties to the &lt;code&gt;Properties&lt;code&gt;     * argument.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertiesAccess&lt;code&gt; method is called with no     * arguments. This may result in a security exception.     * &lt;p&gt;     * The argument becomes the current set of system properties for use     * by the &#123;@link #getProperty(String)&#125; method. If the argument is     * &lt;code&gt;null&lt;code&gt;, then the current set of system properties is     * forgotten.     *     * @param      props   the new system properties.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertiesAccess&lt;code&gt; method doesnt allow access     *              to the system properties.     * @see        #getProperties     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     *    public static void setProperties(Properties props) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertiesAccess();        &#125;        if (props == null) &#123;            props = new Properties();            initProperties(props);        &#125;        System.props = props;    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the key as     * its argument. This may result in a SecurityException.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @return     the string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key);    &#125;    **     * Gets the system property indicated by the specified key.     * &lt;p&gt;     * First, if there is a security manager, its     * &lt;code&gt;checkPropertyAccess&lt;code&gt; method is called with the     * &lt;code&gt;key&lt;code&gt; as its argument.     * &lt;p&gt;     * If there is no current set of system properties, a set of system     * properties is first created and initialized in the same manner as     * for the &lt;code&gt;getProperties&lt;code&gt; method.     *     * @param      key   the name of the system property.     * @param      def   a default value.     * @return     the string value of the system property,     *             or the default value if there is no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *             access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #setProperty     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)     * @see        java.lang.System#getProperties()     *    public static String getProperty(String key, String def) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPropertyAccess(key);        &#125;        return props.getProperty(key, def);    &#125;    **     * Sets the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is set to the given     * value.     * &lt;p&gt;     *     * @param      key   the name of the system property.     * @param      value the value of the system property.     * @return     the previous value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if it did not have one.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPermission&lt;code&gt; method doesnt allow     *             setting of the specified property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; or     *             &lt;code&gt;value&lt;code&gt; is &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        java.lang.System#getProperty(java.lang.String)     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)     * @see        java.util.PropertyPermission     * @see        SecurityManager#checkPermission     * @since      1.2     *    public static String setProperty(String key, String value) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key,                SecurityConstants.PROPERTY_WRITE_ACTION));        &#125;        return (String) props.setProperty(key, value);    &#125;    **     * Removes the system property indicated by the specified key.     * &lt;p&gt;     * First, if a security manager exists, its     * &lt;code&gt;SecurityManager.checkPermission&lt;code&gt; method     * is called with a &lt;code&gt;PropertyPermission(key, write)&lt;code&gt;     * permission. This may result in a SecurityException being thrown.     * If no exception is thrown, the specified property is removed.     * &lt;p&gt;     *     * @param      key   the name of the system property to be removed.     * @return     the previous string value of the system property,     *             or &lt;code&gt;null&lt;code&gt; if there was no property with that key.     *     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkPropertyAccess&lt;code&gt; method doesnt allow     *              access to the specified system property.     * @exception  NullPointerException if &lt;code&gt;key&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;.     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;code&gt; is empty.     * @see        #getProperty     * @see        #setProperty     * @see        java.util.Properties     * @see        java.lang.SecurityException     * @see        java.lang.SecurityManager#checkPropertiesAccess()     * @since 1.5     *    public static String clearProperty(String key) &#123;        checkKey(key);        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new PropertyPermission(key, write));        &#125;        return (String) props.remove(key);    &#125;    private static void checkKey(String key) &#123;        if (key == null) &#123;            throw new NullPointerException(key cant be null);        &#125;        if (key.equals()) &#123;            throw new IllegalArgumentException(key cant be empty);        &#125;    &#125;    **     * Gets the value of the specified environment variable. An     * environment variable is a system-dependent external named     * value.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.+name)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125;     * being thrown.  If no exception is thrown the value of the     * variable &lt;code&gt;name&lt;code&gt; is returned.     *     * &lt;p&gt;&lt;a name=EnvironmentVSSystemProperties&gt;&lt;i&gt;System     * properties&lt;i&gt; and &lt;i&gt;environment variables&lt;i&gt;&lt;a&gt; are both     * conceptually mappings between names and values.  Both     * mechanisms can be used to pass user-defined information to a     * Java process.  Environment variables have a more global effect,     * because they are visible to all descendants of the process     * which defines them, not just the immediate Java subprocess.     * They can have subtly different semantics, such as case     * insensitivity, on different operating systems.  For these     * reasons, environment variables are more likely to have     * unintended side effects.  It is best to use system properties     * where possible.  Environment variables should be used when a     * global effect is desired, or when an external system interface     * requires an environment variable (such as &lt;code&gt;PATH&lt;code&gt;).     *     * &lt;p&gt;On UNIX systems the alphabetic case of &lt;code&gt;name&lt;code&gt; is     * typically significant, while on Microsoft Windows systems it is     * typically not.  For example, the expression     * &lt;code&gt;System.getenv(FOO).equals(System.getenv(foo))&lt;code&gt;     * is likely to be true on Microsoft Windows.     *     * @param  name the name of the environment variable     * @return the string value of the variable, or &lt;code&gt;null&lt;code&gt;     *         if the variable is not defined in the system environment     * @throws NullPointerException if &lt;code&gt;name&lt;code&gt; is &lt;code&gt;null&lt;code&gt;     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the environment variable     *         &lt;code&gt;name&lt;code&gt;     * @see    #getenv()     * @see    ProcessBuilder#environment()     *    public static String getenv(String name) &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.+name));        &#125;        return ProcessEnvironment.getenv(name);    &#125;    **     * Returns an unmodifiable string map view of the current system environment.     * The environment is a system-dependent mapping from names to     * values which is passed from parent to child processes.     *     * &lt;p&gt;If the system does not support environment variables, an     * empty map is returned.     *     * &lt;p&gt;The returned map will never contain null keys or values.     * Attempting to query the presence of a null key or value will     * throw a &#123;@link NullPointerException&#125;.  Attempting to query     * the presence of a key or value which is not of type     * &#123;@link String&#125; will throw a &#123;@link ClassCastException&#125;.     *     * &lt;p&gt;The returned map and its collection views may not obey the     * general contract of the &#123;@link Object#equals&#125; and     * &#123;@link Object#hashCode&#125; methods.     *     * &lt;p&gt;The returned map is typically case-sensitive on all platforms.     *     * &lt;p&gt;If a security manager exists, its     * &#123;@link SecurityManager#checkPermission checkPermission&#125;     * method is called with a     * &lt;code&gt;&#123;@link RuntimePermission&#125;(getenv.*)&lt;code&gt;     * permission.  This may result in a &#123;@link SecurityException&#125; being     * thrown.     *     * &lt;p&gt;When passing information to a Java subprocess,     * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;a&gt;     * are generally preferred over environment variables.     *     * @return the environment as a map of variable names to values     * @throws SecurityException     *         if a security manager exists and its     *         &#123;@link SecurityManager#checkPermission checkPermission&#125;     *         method doesnt allow access to the process environment     * @see    #getenv(String)     * @see    ProcessBuilder#environment()     * @since  1.5     *    public static java.util.Map&lt;String,String&gt; getenv() &#123;        SecurityManager sm = getSecurityManager();        if (sm != null) &#123;            sm.checkPermission(new RuntimePermission(getenv.*));        &#125;        return ProcessEnvironment.getenv();    &#125;    **     * Terminates the currently running Java Virtual Machine. The     * argument serves as a status code; by convention, a nonzero status     * code indicates abnormal termination.     * &lt;p&gt;     * This method calls the &lt;code&gt;exit&lt;code&gt; method in class     * &lt;code&gt;Runtime&lt;code&gt;. This method never returns normally.     * &lt;p&gt;     * The call &lt;code&gt;System.exit(n)&lt;code&gt; is effectively equivalent to     * the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().exit(n)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      status   exit status.     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow exit with the specified status.     * @see        java.lang.Runtime#exit(int)     *    public static void exit(int status) &#123;        Runtime.getRuntime().exit(status);    &#125;    **     * Runs the garbage collector.     * &lt;p&gt;     * Calling the &lt;code&gt;gc&lt;code&gt; method suggests that the Java Virtual     * Machine expend effort toward recycling unused objects in order to     * make the memory they currently occupy available for quick reuse.     * When control returns from the method call, the Java Virtual     * Machine has made a best effort to reclaim space from all discarded     * objects.     * &lt;p&gt;     * The call &lt;code&gt;System.gc()&lt;code&gt; is effectively equivalent to the     * call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().gc()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#gc()     *    public static void gc() &#123;        Runtime.getRuntime().gc();    &#125;    **     * Runs the finalization methods of any objects pending finalization.     * &lt;p&gt;     * Calling this method suggests that the Java Virtual Machine expend     * effort toward running the &lt;code&gt;finalize&lt;code&gt; methods of objects     * that have been found to be discarded but whose &lt;code&gt;finalize&lt;code&gt;     * methods have not yet been run. When control returns from the     * method call, the Java Virtual Machine has made a best effort to     * complete all outstanding finalizations.     * &lt;p&gt;     * The call &lt;code&gt;System.runFinalization()&lt;code&gt; is effectively     * equivalent to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().runFinalization()     * &lt;pre&gt;&lt;blockquote&gt;     *     * @see     java.lang.Runtime#runFinalization()     *    public static void runFinalization() &#123;        Runtime.getRuntime().runFinalization();    &#125;    **     * Enable or disable finalization on exit; doing so specifies that the     * finalizers of all objects that have finalizers that have not yet been     * automatically invoked are to be run before the Java runtime exits.     * By default, finalization on exit is disabled.     *     * &lt;p&gt;If there is a security manager,     * its &lt;code&gt;checkExit&lt;code&gt; method is first called     * with 0 as its argument to ensure the exit is allowed.     * This could result in a SecurityException.     *     * @deprecated  This method is inherently unsafe.  It may result in     *      finalizers being called on live objects while other threads are     *      concurrently manipulating those objects, resulting in erratic     *      behavior or deadlock.     * @param value indicating enabling or disabling of finalization     * @throws  SecurityException     *        if a security manager exists and its &lt;code&gt;checkExit&lt;code&gt;     *        method doesnt allow the exit.     *     * @see     java.lang.Runtime#exit(int)     * @see     java.lang.Runtime#gc()     * @see     java.lang.SecurityManager#checkExit(int)     * @since   JDK1.1     *    @Deprecated    public static void runFinalizersOnExit(boolean value) &#123;        Runtime.runFinalizersOnExit(value);    &#125;    **     * Loads the native library specified by the filename argument.  The filename     * argument must be an absolute path name.     *     * If the filename argument, when stripped of any platform-specific library     * prefix, path, and file extension, indicates a library whose name is,     * for example, L, and a native library called L is statically linked     * with the VM, then the JNI_OnLoad_L function exported by the library     * is invoked rather than attempting to load a dynamic library.     * A filename matching the argument does not have to exist in the     * file system.     * See the JNI Specification for more details.     *     * Otherwise, the filename argument is mapped to a native library image in     * an implementation-dependent manner.     *     * &lt;p&gt;     * The call &lt;code&gt;System.load(name)&lt;code&gt; is effectively equivalent     * to the call:     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().load(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      filename   the file to load.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError  if either the filename is not an     *             absolute path name, the native library is not statically     *             linked with the VM, or the library cannot be mapped to     *             a native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;filename&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#load(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void load(String filename) &#123;        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);    &#125;    **     * Loads the native library specified by the &lt;code&gt;libname&lt;code&gt;     * argument.  The &lt;code&gt;libname&lt;code&gt; argument must not contain any platform     * specific prefix, file extension or path. If a native library     * called &lt;code&gt;libname&lt;code&gt; is statically linked with the VM, then the     * JNI_OnLoad_&lt;code&gt;libname&lt;code&gt; function exported by the library is invoked.     * See the JNI Specification for more details.     *     * Otherwise, the libname argument is loaded from a system library     * location and mapped to a native library image in an implementation-     * dependent manner.     * &lt;p&gt;     * The call &lt;code&gt;System.loadLibrary(name)&lt;code&gt; is effectively     * equivalent to the call     * &lt;blockquote&gt;&lt;pre&gt;     * Runtime.getRuntime().loadLibrary(name)     * &lt;pre&gt;&lt;blockquote&gt;     *     * @param      libname   the name of the library.     * @exception  SecurityException  if a security manager exists and its     *             &lt;code&gt;checkLink&lt;code&gt; method doesnt allow     *             loading of the specified dynamic library     * @exception  UnsatisfiedLinkError if either the libname argument     *             contains a file path, the native library is not statically     *             linked with the VM,  or the library cannot be mapped to a     *             native library image by the host system.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.Runtime#loadLibrary(java.lang.String)     * @see        java.lang.SecurityManager#checkLink(java.lang.String)     *    @CallerSensitive    public static void loadLibrary(String libname) &#123;        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);    &#125;    **     * Maps a library name into a platform-specific string representing     * a native library.     *     * @param      libname the name of the library.     * @return     a platform-dependent native library name.     * @exception  NullPointerException if &lt;code&gt;libname&lt;code&gt; is     *             &lt;code&gt;null&lt;code&gt;     * @see        java.lang.System#loadLibrary(java.lang.String)     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)     * @since      1.2     *    public static native String mapLibraryName(String libname);    **     * Create PrintStream for stdouterr based on encoding.     *    private static PrintStream newPrintStream(FileOutputStream fos, String enc) &#123;       if (enc != null) &#123;            try &#123;                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);            &#125; catch (UnsupportedEncodingException uee) &#123;&#125;        &#125;        return new PrintStream(new BufferedOutputStream(fos, 128), true);    &#125;    **     * Initialize the system class.  Called after thread initialization.     *    private static void initializeSystemClass() &#123;         VM might invoke JNU_NewStringPlatform() to set those encoding         sensitive properties (user.home, user.name, boot.class.path, etc.)         during props initialization, in which it may need access, via         System.getProperty(), to the related system encoding property that         have been initialized (put into props) at early stage of the         initialization. So make sure the props is available at the         very beginning of the initialization and all system properties to         be put into it directly.        props = new Properties();        initProperties(props);   initialized by the VM         There are certain system configurations that may be controlled by         VM options such as the maximum amount of direct memory and         Integer cache size used to support the object identity semantics         of autoboxing.  Typically, the library will obtain these values         from the properties set by the VM.  If the properties are for         internal implementation use only, these properties should be         removed from the system properties.                 See java.lang.Integer.IntegerCache and the         sun.misc.VM.saveAndRemoveProperties method for example.                 Save a private copy of the system properties object that         can only be accessed by the internal implementation.  Remove         certain system properties that are not intended for public access.        sun.misc.VM.saveAndRemoveProperties(props);        lineSeparator = props.getProperty(line.separator);        sun.misc.Version.init();        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);        setIn0(new BufferedInputStream(fdIn));        setOut0(newPrintStream(fdOut, props.getProperty(sun.stdout.encoding)));        setErr0(newPrintStream(fdErr, props.getProperty(sun.stderr.encoding)));         Load the zip library now in order to keep java.util.zip.ZipFile         from trying to use itself to load this library later.        loadLibrary(zip);         Setup Java signal handlers for HUP, TERM, and INT (where available).        Terminator.setup();         Initialize any miscellenous operating system settings that need to be         set for the class libraries. Currently this is no-op everywhere except         for Windows where the process-wide error mode is set before the java.io         classes are used.        sun.misc.VM.initializeOSEnvironment();         The main thread is not added to its thread group in the same         way as other threads; we must do it ourselves here.        Thread current = Thread.currentThread();        current.getThreadGroup().add(current);         register shared secrets        setJavaLangAccess();         Subsystems that are invoked during initialization can invoke         sun.misc.VM.isBooted() in order to avoid doing things that should         wait until the application class loader has been set up.         IMPORTANT: Ensure that this remains the last initialization action!        sun.misc.VM.booted();    &#125;    private static void setJavaLangAccess() &#123;         Allow privileged classes outside of java.lang        sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess()&#123;            public sun.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) &#123;                return klass.getConstantPool();            &#125;            public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) &#123;                return klass.casAnnotationType(oldType, newType);            &#125;            public AnnotationType getAnnotationType(Class&lt;?&gt; klass) &#123;                return klass.getAnnotationType();            &#125;            public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) &#123;                return klass.getDeclaredAnnotationMap();            &#125;            public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawAnnotations();            &#125;            public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) &#123;                return klass.getRawTypeAnnotations();            &#125;            public byte[] getRawExecutableTypeAnnotations(Executable executable) &#123;                return Class.getExecutableTypeAnnotationBytes(executable);            &#125;            public &lt;E extends Enum&lt;E&gt;&gt;                    E[] getEnumConstantsShared(Class&lt;E&gt; klass) &#123;                return klass.getEnumConstantsShared();            &#125;            public void blockedOn(Thread t, Interruptible b) &#123;                t.blockedOn(b);            &#125;            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) &#123;                Shutdown.add(slot, registerShutdownInProgress, hook);            &#125;            public int getStackTraceDepth(Throwable t) &#123;                return t.getStackTraceDepth();            &#125;            public StackTraceElement getStackTraceElement(Throwable t, int i) &#123;                return t.getStackTraceElement(i);            &#125;            public String newStringUnsafe(char[] chars) &#123;                return new String(chars, true);            &#125;            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) &#123;                return new Thread(target, acc);            &#125;            public void invokeFinalize(Object o) throws Throwable &#123;                o.finalize();            &#125;        &#125;);    &#125;&#125;\n\n","tags":["编程","Java"],"path":"2019/09/06/System类/","external_link":""},{"title":"三阶魔方解法","date":"2019-09-12T10:09:12.000Z","content":"三阶魔方解法预备篇：三阶魔方相关知识在本教程中，统一使用官方配色（上黄、下白、左橙、右红、前蓝、后绿），并在还原的过程中，白色作为底色。\n下图中，A、B、C分别表示顶层、中层、底层；D为中心块，在还原的过程中以此作为参照色（即该面所最终还原的颜色）；E为棱块，每块有两个颜色；F为角块，每块有三个颜色。\n在本教程中，分别用Front、Back、Left、Right、Up、Down的首字母表示前面、后面、左面、右面、上面、下面的顺时针90度旋转，带撇号的为逆时针90度逆转，带数字2的为180度旋转。\n\n\n第一步：完成底层四棱子步骤一：拼成黄心白瓣小花如下图①所示，我们只要在黄色中心块的四周的棱块都挨着白色即可。\n对于在中层的白色棱，如②所示，只需转一个90度即可将白色朝上；对于在顶层、底层朝外的白色棱，如③所示，先在白色所在面转动90度后变成②的情况再处理；而在底层朝下的白色棱，如④所示，则通过180度旋转即可将白色朝上。\n值得留意的是⑤之类的情况，如果直接转90度将中层白色块朝上，那么会破坏掉上方原先已有的白色块。此时要先转动顶层（此例为U’），将空位转到对应位置，方可使该白色块转上去。\n\n子步骤二：找到相应颜色并掉落花瓣先随意选定一个白色棱（下图以白红棱为例），转动顶层（或扭转中底层），直到该棱侧面的颜色与中心块吻合时，以该中心块为轴转动180度，使其落到白色中心旁边。用同样的方法处理其他三个棱之后，在底层会形成白色的十字，棱的侧面也与中心块相连。\n\n第二步：完成底层四角这一步我们不仅要让白色的四角全都聚集在下面，还要留意其角块侧面的颜色也要吻合。\n如下图的上半部分所示，我们先在顶层寻找含白色的角块，同时观察该角块另外两种颜色，转动顶层（或扭转中底层），使之处在相应颜色的两个中心块之间。\n当角块转到相应位置后，观察白色的朝向，做相应的公式：\n①为白色朝右，做U’ F’ U F；②为白色朝前，做U R U’ R’；③为白色朝上，做三遍的公式①。当顶层无任何白色角块时，此时再观察底层有无错误朝向或位置的白色角块：\n④在底层，白色朝右，做两遍的公式①；⑤在底层，白色朝前，做两遍的公式②；⑥在底层，错误位置角块，先做公式①将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个角之后，底面为全白色，侧面会形成倒T字。\n\n第三步：完成中层四棱如下图的上半部分所示，我们先在顶层寻找不含黄色的棱块，同时观察该棱块另外两种颜色，转动顶层（或扭转中底层），使之朝外的颜色与中心块相吻合。\n当棱块转到相应位置后，观察最终所归的空位，并将空位置于右前方，做相应的公式（前面的公式①与②，在这里称为甲与乙）：\n①情况做U’ F’ U F U R U’ R’（先甲后乙）；②情况做U R U’ R’ U’ F’ U F（先乙后甲）；当顶层全为有黄色的棱块时，此时再观察中层有无错误朝向或位置的棱块：\n③与④情况，先做甲+乙将其赶回顶层，然后找到相应正确位置还原。用同样的方法处理其他三个棱之后，第二层即完成。\n\n第四步：完成顶面十字现在观察顶面的棱与中心块所构成的图形（忽视角块黄色是否朝上与否）分为“点、线、拐、十字”四种情况。找到相应的情况并按图示朝向摆放后，按照下流程图每次做R’ U’ F’ U F R（R’+甲+R）直到变成十字为止。其中“线”的情况还有一条捷径，即F R U R’ U’ F’。\nCube solve 7a.png\n第五步：调整顶棱顺序先转动顶层（或扭转中底层），直到至少有两个棱侧面的颜色与中心块吻合。\n现在观察另外两个错误的棱处于相邻还是相对位置，如果没有，则此步跳过；如果是相邻的，则将两个错误的置一前一右，做丙公式U’ F’ U’ F U’ F’ U2 F；如果是相对的，则将两个错误的置一左一后，先做丙公式，然后转下顶层变为相邻的，再置一前一右做丙公式完成。\nCube solve 8.png\n第六步：调整顶角顺序观察顶角，找到在正确位置的一个角（朝向是否正确暂时不考虑）。如果四角都在正确位置，则此步跳过；如果只有一个，则将正确的角置于左前方，做丁公式U’ L’ U R U’ L U R’（做一遍仍未成功则再做第二遍）；如果没有一个角在正确位置，则先做丁公式然后变成有一个角在正确位置再相应处理。\nCube solve 9.png\n第七步：调整顶角朝向此时我们统一将蓝色中心块保持前面放置，需要注意的是在操作的过程中魔方的底层会被暂时性打乱，不过不要紧，只要正确操作完后魔方会正常还原。\n观察顶层前右方的角块的黄色朝向，做戊公式F’ R F R’二或四遍使黄色朝上。完成一个角块的朝向处理之后，要转动顶层（U、U’、U2），并保持蓝色中心块在前面不动，再处理其他角块朝向。(在每一角落都要扭)\nCube solve 10.png\n维基百科\n","tags":["魔方"],"path":"2019/09/12/三阶魔方解法/","external_link":""},{"title":"git教程","date":"2019-08-16T07:47:37.000Z","content":"名称git - 愚蠢的内容跟踪器\n概要git [--version] [ -  help] [-C &lt;path&gt;] [-c &lt;name&gt; = &lt;value&gt;]\n    [--exec-path [= &lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n    [-p | --paginate | -P | --no-pager] [ -  no-replace-objects] [--bare]\n    [--git-dir = &lt;path&gt;] [ -  work-tree = &lt;path&gt;] [--namespace = &lt;name&gt;]\n    [--super前缀= &lt;路径&gt;]\n    &lt;command&gt; [&lt;args&gt;]描述Git是一个快速，可扩展的分布式版本控制系统，具有异常丰富的命令集，可提供高级操作和对内部的完全访问。\n请参阅gittutorial [7]以开始使用，然后查看 giteveryday [7]以获取有用的最小命令集。在Git的用户手册有一个更深入的介绍。\n掌握了基本概念后，您可以回到此页面了解Git提供的命令。您可以使用“git help command”了解有关各个Git命令的更多信息。 gitcli [7] 手册页概述了命令行命令语法。\n可以在以下位置查看最新Git文档的格式化和超链接副本https:git.github.iohtmldocsgit.html。\nOPTIONS\n版打印git程序来自的Git套件版本。\n\n救命打印概要和最常用命令的列表。如果选择–all或-a已给出，则打印所有可用命令。如果命名了Git命令，则此选项将显示该命令的手册页。\n\n\n其他选项可用于控制手册页的显示方式。有关更多信息，请参阅git-help [1]，因为git –help …内部转换为git help …。\n-C &lt;路径&gt;运行就好像git是在而不是当前工作目录中启动的。当-C给出多个选项时，-C 相对于前面的每个后续非绝对值被解释-C 。如果存在但是为空，例如-C “”，则保持当前工作目录不变。\n此选项会影响预期的路径名的选项一样–git-dir，并 –work-tree在他们的路径名的解释，将相对于所造成的工作目录进行-C选择。例如，以下调用是等效的：\ngit --git-dir = a.git --work-tree = b -C c status\ngit --git-dir = c  a.git --work-tree = c  b status-c  = 将配置参数传递给命令。给定的值将覆盖配置文件中的值。的格式与git config列出的格式相同 （以点分隔的子键）。\n请注意，允许省略=in git -c foo.bar …并设置 foo.bar为布尔值true（就像[foo]bar在配置文件中一样）。包括equals但空值（如git -c foo.bar= …）设置foo.bar为git config –type=bool将转换为的空字符串false。\n–exec路径[= &lt;路径&gt;]安装核心Git程序的路径。这也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径，git将打印当前设置然后退出。\n–html路径打印路径，不带斜杠，安装Git的HTML文档并退出。\n–man路径打印manpath（请参阅参考资料man(1)）获取此版本Git的手册页并退出。\n–info路径打印安装记录此版本Git的Info文件的路径并退出。\n-p–paginate如果标准输出是终端，则将所有输出传输到较少（或如果设置为$ PAGER）。这将覆盖pager. 配置选项（请参阅下面的“配置机制”部分）。\n-P–no寻呼机不要将Git输出传输到寻呼机。\n–git-DIR = &lt;路径&gt;设置存储库的路径。这也可以通过设置GIT_DIR环境变量来控制。它可以是当前工作目录的绝对路径或相对路径。\n\n共同努力树= &lt;路径&gt;设置工作树的路径。它可以是绝对路径或相对于当前工作目录的路径。这也可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制（有关更详细的讨论，请参阅git-config [1]中的core.worktree ）。\n\n–namespace = &lt;路径&gt;设置Git名称空间。有关更多详细信息，请参阅gitnamespaces [7]。相当于设置GIT_NAMESPACE环境变量。\n–super前缀= &lt;路径&gt;目前仅供内部使用。设置一个前缀，该前缀提供从存储库上方到其根目录的路径。一个用途是给出调用它的超级项目的子模块上下文。\n\n裸将存储库视为裸存储库。如果未设置GIT_DIR环境，则将其设置为当前工作目录。\n\n–no替换对象不要使用替换引用来替换Git对象。有关更多信息，请参阅 git-replace [1]。\n–literal按本义，pathspecs按字面意思处理pathspecs（即没有globbing，没有pathspec魔法）。这相当于将GIT_LITERAL_PATHSPECS环境变量设置为1。\n–glob-pathspecs为所有pathspec添加“glob”魔法。这相当于将GIT_GLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( literal）”在各个pathspec上禁用通配符\n–noglob-pathspecs为所有pathspec添加“literal”魔法。这相当于将GIT_NOGLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( glob）”在各个pathspec上启用globbing\n–icase-pathspecs为所有pathspec添加“icase”魔法。这相当于将GIT_ICASE_PATHSPECS环境变量设置为1。\n–no-可选锁不要执行需要锁定的可选操作。这相当于设置GIT_OPTIONAL_LOCKS为0。\n–list-CMDS =基团[，组…]按组列出命令。这是一个内部实验选项，可能会在将来更改或删除。支持的组包括：builtins，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（所有其他命令$PATH都有git-前缀），list- （请参阅命令中的类别 - list.txt），nohelpers（排除帮助程序命令），别名和配置（从配置变量completion.commands检索命令列表）\n","tags":["文章","git"],"path":"2019/08/16/git教程/","external_link":""},{"title":"你也能懂相对论","date":"2019-09-08T11:25:53.000Z","content":"\n相对论\n光线在通过强引力场附近时会发生弯曲，这是广义相对论的重要预言之一\n\n\n如果我说，相对论与日常生用息息相关，你会信吗？或许就算我是一位知名的物理学教授，说服力相信也不会大得多少。以下我将要用比较浅白简单的文字和少许初等代数，说明并说服大家，相对论并不难懂，而且它在日常经验中是如此的明显、如此的必要！\n1905 年被称为爱因斯坦的「奇迹年」，爱因斯坦向世界提出了一套非常明显、非常合理，但却一直不为人所理解的理论狭义相对论(special relativity)。被称为「狭义」是因为这个理论只在惯性座标系中适用；换句话说，即是在所有没有加速度的系统中都适用。狭义相对论建基于两大假设：\n\n在所有的惯性系统中，所有有物理定律保持不变。\n对于所有系统中的所有观测者，光速永远不变，而且不是无限快的。\n\n假设(一)「所有自然定律不变」一般被称为相对性原理(principle of relativity)，明显比较合理，也比较容易理解。而乍看之下，光速相对于所有人都不变，而不论那人正在高速奔跑或者静止不动都没有关系，就显得较为奇怪了。要理解这一点，我们需要由速度的意义说起。速度，就是在说「每单位时间内走了多远」。说得再浅白一点，可以想像为「每秒走了多少米(ms)」。但这只是惯用单位的问题，你当然可以想成「每小时走了多少公里(kmh)」，这正是司机们惯用的单位。在科学中，单位是至关重要的，因为不同单位的东西就是不同性质的东西，不可以混为一谈的比较，好像一个苹果永远不会等于一个橙。\n假设(二)「光速相对所有人都不变」，就是说相对于所有人，光在每单位时间内走的距离都一样。就是说，当你向着一道光奔跑，「直觉上」你会认为你所看到的光速比起你在静止不动时快，因为在你向光跑去的「同时」，光亦向着你冲去。换成数学上的表达，就是说如果你用速度  v 向着光冲去，而我们用  c 代表你在静止时看到的光速，那你看到的光速就会变成了c + v。这就是所谓的伽俐略变换，亦被一般人叫做「常识」。当然了啊，两个物件互相冲去，当然会比其中一个不动、或两者互相远离快啊。但是，爱因斯坦却说不论你用什么速度，向着光或离开光移动，你到的光速都仍然为  c，不多也不少！\n你会说：「这怎可能！这是违反常识的！」我的回答是，一般人的常识存在非常明显的漏洞，可是在爱因斯坦之前却一直没有人留意到这个严重的错误！这个错误就是「同时」这一概念的演绎。什么是「同时」？就是说大家的时钟显示的时间都一样啊！对，这也是爱因斯坦对「同时」的理解。但现在要再问一道问题，如何知道两个时钟的时间一样？\n问题到肉了，可是你会觉得很无聊：「说什么废话！只要我看到两个钟的指针拍着的时间就是了！」好，停一停，想一想：我们能「看」到东西，是因为光进入到我们的眼球穿过水晶体折射后投影在视网膜上。总言之，我们能看到东西，是因为有光。光以一定的速度前进，而且因为光速有限，因此在不同距离发出的光相对于同一个观测者而言，会在不同时间到达。试想像，两个人相距非常远，而两个人都带着一个时钟，那么当然，任何一方都会觉得对方那个时钟所发出的光，会比自己手上的时钟所发出的光要用更多时间才能进入你的眼睛吧！好了，我希望大家想想，究竟事先要如何调整两个时钟，才能使你和对方都看到两个时钟是同步的呢？当然，这是办不到的！因为两个时钟相距两个人的距离都不同。若然你看到它们是同步的，对方就会看到他手上的走得较快，反之亦然。\n如果你不太理解的话，请从头思考一次，先不要跳过读下去，因为刚才所说的就是相对论的精髓所在。重点是，要知道世界上并没有「对所有人都同时」这个概念存在，因此也可以说，「同时」这个概念对每个人都不同；说「对大家来说都是同时」就是错误的，没有可能发生。这是非常明显的，但却一直被我们所忽略。这完全是因为对于人类的感觉来说，光速(每秒三十万公里，能够环绕地球七个半圈) 实在是太快、太快了。\n好了，接下来我要介绍相对论导致的两个非常重要的结果，这些结果令人类对时间及空间的概念有了根本上的改变：时间及空间其实是互相纠缠、难分难离的。在这部分我会以数学论证，狭义相对论所涉及的数学都只是基本数学运算以及向量微积分，相信对有会考物理根基的朋友来说不会太难。\n\n在我们生活的三维空间中，每一件事件都可以用座标系的四个变量决定，就是(长，阔，高，时间)，数学表达为( x , y , z , t )。假设在座标系  S 中有一原点  O，在  S 内观测的人都会对每一件事件测得一组座标( x , y , z , t )；而现在有另一座标系S’正在相对S以速度  v 向右移动，它的原点  O’ 在时间  t = 0的时候刚好与  O重叠，而在S’内观测的人都会对每一件事件测得一组座标( x’ , y’ , z’ ,       t’ )。那么，在我们的「常识」中， ( x , y , z , t )与 ( x’ , y’ , z’ , t’ )的关系就是由伽俐略变换来决定：\n\n这就是我们认为的「常识」的数学表达方法。留意当中t’ = t，因为在传统的观念里，「同时」这概念仍然存在。明显地，在伽俐略变换当中，时间是独立地流逝的，与空间( x , y , z )无关。可是，在上文中我们知道「同时」是不存在的。\n\n想像小明站在一节正在行进的列车车厢正中间，在车头及车尾都摆放了感应器。他向左右同时照射出两道光束。对小明来说，车厢并没有移动，所以他会看到两道光束同时到达感应器。可是，对于一位站在月台上的人来说，因为列车正在向右移动，右边的感应器不断远离光束，而左边的就不断靠边光束。所以他会看到左边那道光束首先到达感应器。因此，时间会因为观测者的运动状态不同而有所分别，而且这是非常明显的！请注意，上述两种情况都是正确的，没有谁对谁错，完全因为观点与角度而已。回到  S 和  S’ 座标系的讨论，因为两个座标系的运动状态不同，所以伽俐略变换就不是正确的描述了，我们必须改用另外一种座标变换方法，名为洛伦兹变换( Lorentz Transformation)：\n\n有关这组公式的推导过程，有兴趣的朋友可以参考任何相对论课本。在这里我们有兴趣的是：如果时间及空间确实根据以上方程组变换的话，会有什么有趣的事情发生？\n\n首先，考虑一个「光钟」，这是一个纯粹由两块互相平行的平面镜组成的计时器，有一束光在两块镜之间来回反弹。然后我们定义这束光来回反弹一次的时间Δ t = 2 h  c 为一个时间单位，故此我们就有了这样一种有趣的计时器。\n\n现在，我们让这个光钟在S座标系中以水平方向向右以均速  v 移动。所以我们就知道，如果我们称光钟为S’ 座标系，就有Δ t’ = 2 h  c。在S 座标系当中，光就是以斜线行进的，根据毕氐定理，我们得到  \n  \n使用简单代数运算求得Δ t：\n\n因为v &lt; c，所以分母必定小于1 ，故此Δ t’ &lt; Δ t。换句话说，移动中的座标系的时间流逝得比较慢。这就是著名的时间迟滞(Time Dilation) 。 \n除了移动中的人的时间在其他人眼中会变慢之外，移动中的物体看起来也会变短。这叫做长度收缩(Length Contraction)。如果L 0 是物体静止时的长度，L是物体相对于观测者以速度  v移动时的长度，那么我们就会得到   \n\n公式(3) 的推导过程与公式(2) 差不多，只要把光钟转个直角再考虑水平移动就可以了，有兴趣的朋友可以自己当做练习试试推导。\n以上两个「违反直觉」的现象都已经被实验观测所证实了。其中一个重要的证明是关于宇宙射线的问题。每分每秒都有大量的宇宙射线攻击着地球，这些射线多是带电粒子诸如质子及电子等等，能量很高。幸好地球有磁场以及大气层的保护，不然地球上就不可能有生命存在了。\n一些粒子与大气粒子碰撞后，会产生许多不同种类的粒子，向各个方向散射。这些粒子的寿命一般都非常短暂，就算在产生的一刻开始已经用接近光速前进，在它再衰变成其他粒子之前，前进的距离最多也只得几百米。但是，虽然地球的大气层厚度约为100公里，设置在地面上的仪器却可以探测到它们！这完全是因为这些粒子以接近光速行进，相对论的效应就会变得很大。如果在静止时这些粒子的寿命是  T，那么根据时间迟滞现象，地面上的人就会测得它们的寿命为\n\n其中  v 是粒子的速度。明显地，当  v 非常接近  c 的时候，T’ 就会变得非常大，所以它们有足够的时间可以穿过厚厚的大气层落到地面。\n我最后想介绍的是著名的爱因斯坦速度相加法则。在早前的讨论中，我们已经明白到，在光速不是无限快的条件下，时间必须是「相对」的。亦即是说，对于不同运动状态的观测者，时间的流逝速率各有不同。同样地对于空间来说也是如此。因此，我们就不能说两个互相靠近的人的相对速度  v’，会简单地为  v’ = v 1 + v 2，其中  v 1 和  v 2 分别为两个人的速度。那么  v’ 应该如何表达才对呢？其实简单得很，只要把洛伦兹公式对时间微分就可以了。详细的做法可以参考教科书，其结果为\n\n因此可以看到在相对论下，相对速度  v’ 比较小。如果代入文章开头的例子，你和光束互相冲向对方，就有\n\n所以你会惊讶地发现，c + v 仍然是  c！这是当然的，因为相对论本身必须符合它的假设：光速不变。\n其实狭义相对论还有许多有趣的题目可以讨论的，例如著名的质能公式E = mc^2、双生子悖论、能量-动量四维向量、以及相对论性电磁场理论等等，或许在以后我会和大家深入讨论。而爱因斯坦在1916 年提出的广义相对论(general relativity)，则是一套把重力与加速度都包含在内的时空理论，能够非常准确地描述我们身处的宇宙。广义相对论所涉及的数学非常深奥，需要使用到十分抽象的黎曼几何以及张量的概念，确实并非每个学生也能明白。在以后我会试试为大家说明广义相对论的重要性。总而言之，在这篇文章中，我希望大家明白的事，是相对论其实并非一般人想像的那么深奥难懂。至少，就狭义相对论而言，只需要中学程度的物理及数学知识就可以了。\n原文链接\n","tags":["相对论","爱因斯坦"],"path":"2019/09/08/你也能懂相对论/","external_link":""},{"title":"天平砝码摆放问题","date":"2019-09-02T04:41:41.000Z","content":"题目一个天平上有6个位置，左右各三个位置，有6个砝码，分别是1、2、3、4、5、6克重。要使天平平衡，有多少种方法？（对称摆放算作一种方法） \n\n题解暴力求解\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    int t = 6;    int count = 0;    vector&lt;string&gt; v;    for (int i = 1; i &lt;= t; ++i) &#123;        for (int j = 1; j &lt;= t; ++j) &#123;            for (int k = 1; k &lt;= t; ++k) &#123;                for (int l = 1; l &lt;= t; ++l) &#123;                    for (int m = 1; m &lt;= t; ++m) &#123;                        for (int n = 1; n &lt;= t; ++n) &#123;                            if (i == j ||                                i == k || j == k ||                                i == l || j == l || k == l ||                                i == m || j == m || k == m || l == m ||                                i == n || j == n || k == n || l == n || m == n)                                continue;                            if ((3 * i + 2 * j + k) == (l + 2 * m + 3 * n)) &#123;                                string s = to_string(i) + to_string(j) + to_string(k) + to_string(l) + to_string(m) +                                           to_string(n);                                int te = 0;                                if (v.size() &gt; 0) &#123;                                    string tem = s;                                    reverse(tem.begin(), tem.end());                                    vector&lt;string&gt;::iterator it;                                    for (it = v.begin(); it != v.end(); it++) &#123;                                        if (*it == tem) &#123;                                            cout&lt;&lt;tem&lt;&lt;endl;                                            te = 1;                                            break;                                        &#125;                                    &#125;                                &#125;                                if (te == 0) &#123;                                    v.push_back(s);                                    count++;                                    printf( %d %d %d | %d %d %dn, i, j, k, l, m, n);                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;    return 0;&#125;\n\n1234567891011121314151617181 4 6 | 5 3 21 5 6 | 2 4 31 5 6 | 3 2 41 6 4 | 3 5 21 6 5 | 2 3 42 4 6 | 1 5 32 4 6 | 3 1 52 6 3 | 4 1 52 6 4 | 1 3 53 2 6 | 5 1 43 4 5 | 2 1 63 5 4 | 1 2 63 6 2 | 1 5 44 2 6 | 1 3 54 3 5 | 1 2 65 2 4 | 3 1 65 4 2 | 1 3 617","tags":["算法","天平","暴力破解"],"path":"2019/09/02/天平砝码摆放问题/","external_link":""},{"title":"判断素数","date":"2019-09-05T18:53:05.000Z","content":"\n素数\n质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。\n0和1既不是质数也不是合数，最小的质数是2\n\n\n最直观，但效率最低的写法\n\n这里特殊处理了一下小于等于3的数，因为小于等于3的自然数只有2和3是质数。\n然后，我们只需要从2开始，一直到小于其自身，依次判断能否被n整除即可，能够整除则不是质数，否则是质数。\n1234567891011public static boolean isPrime(int n)&#123;    if (n &lt;= 3) &#123;        return n &gt; 1;    &#125;    for(int i = 2; i &lt; n; i++)&#123;        if (n % i == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n优化\n\n我们继续分析，其实质数还有一个特点，就是它总是等于 6x-1 或者 6x+1，其中 x 是大于等于1的自然数。\n如何论证这个结论呢，其实不难。首先 6x 肯定不是质数，因为它能被 6 整除；其次 6x+2 肯定也不是质数，因为它还能被2整除；依次类推，6x+3 肯定能被 3 整除；6x+4 肯定能被 2 整除。那么，就只有 6x+1 和 6x+5 (即等同于6x-1) 可能是质数了。所以循环的步长可以设为 6，然后每次只判断 6 两侧的数即可。\n12345678910111213141516public static boolean isPrime(int num) &#123;    if (num &lt;= 3) &#123;        return num &gt; 1;    &#125;     不在6的倍数两侧的一定不是质数    if (num % 6 != 1 &amp;&amp; num % 6 != 5) &#123;        return false;    &#125;    int sqrt = (int) Math.sqrt(num);    for (int i = 5; i &lt;= sqrt; i += 6) &#123;        if (num % i == 0 || num % (i + 2) == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n\n性能对比\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;         Scanner in = new Scanner(System.in);         int n = in.nextInt();         in.close();        Stack&lt;Integer&gt; a = new Stack&lt;&gt;(), b = new Stack&lt;&gt;();        int n = 100000;        long s = System.currentTimeMillis(), e;        for (int i = 1; i &lt; n; i++) &#123;            if (f(i))                a.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        s = System.currentTimeMillis();        for (int i = 1; i &lt; n; i++) &#123;            if (func(i))                b.push(i);        &#125;        e = System.currentTimeMillis();        System.out.println(e - s +  ms);        System.gc();    &#125;    static boolean f(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        for (int i = 2; i &lt; n; i++) &#123;            if (n % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;    static boolean func(int n) &#123;        if (n &lt;= 3)            return n &gt; 1;        if (n % 6 != 1 &amp;&amp; n % 6 != 5) &#123;            return false;        &#125;        int tem = (int) Math.sqrt(n);        for (int i = 5; i &lt;= tem; i += 6) &#123;            if (n % i == 0 || n % (i + 2) == 0)                return false;        &#125;        return true;    &#125;&#125;\n\n121392 ms5 ms","author":"times","tags":["编程","Java","素数"],"path":"2019/09/06/判断素数/","external_link":""},{"title":"技术栈","date":"2019-08-18T15:30:34.000Z","content":"\nHTML  CSS\n【HTML】HTML，即超文本标记语言（Hyper Text Markup Language）\n【HTML5】HTML5 是下一代 HTML 标准\n【CSS】层叠样式表（Cascading StyleSheet）\n【CSS3】CSS3是CSS技术的升级版本\n【Bootstrap3】Bootstrap，来自 Twitter，是目前最受欢迎的前端框架\n【Bootstrap4】Bootstrap4 目前是 Bootstrap 的最新版本\n【Font Awesome】Font Awesome 是一套绝佳的图标字体库和CSS框架。\n【Foundation】Foundation 用于开发响应式的 HTML, CSS and JavaScript 框架JavaScript\n【JavaScript】JavaScript 是 Web 的编程语言\n【HTML DOM】HTML DOM 定义了访问和操作 HTML 文档的标准方法\n【jQuery】jQuery 是一个 JavaScript 库\n【AngularJS】AngularJS 通过新的属性和表达式扩展了 HTML\n【AngularJS2】AngularJS2 是一款开源JavaScript库，由Google维护。\n【Vue.js】Vue.js 是一套构建用户界面的渐进式框架。\n【React】React 是一个用于构建用户界面的 JAVASCRIPT 库\n【TypeScript】TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准\n【jQuery UI】jQuery UI 是建立在 jQuery上的一组用户界面交互、特效、小部件及主题\n【jQuery EasyUI 】jQuery EasyUI 是一个基于 jQuery 的框架，集成了各种用户界面插件\n【Node.js】Node.js 是运行在服务端的 JavaScript\n【AJAX】AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n【JSON】JSON 是存储和交换文本信息的语法\n【Highcharts】Highcharts 是一个用纯JavaScript编写的一个图表库\n【Google 地图】Google 地图接口使用说明\n\n服务端\n【PHP】PHP 是一种通用开源脚本语言\n【Python】Python 是一种面向对象、解释型计算机程序设计语言\n【Python3】Python 升级版，变化较大\n【Django】Django是一个开放源代码的Web应用框架，由Python写成\n【Linux】Linux是一套免费使用和自由传播的类Unix操作系统\n【Docker】Docker 是一个开源的应用容器引擎，基于 Go 语言\n【Ruby】一种为简单快捷的面向对象编程（面向对象程序设计）而创的脚本语言\n【Java】一种可以撰写跨平台应用软件的面向对象的程序设计语言\n【C】一门通用计算机编程语言\n【C++】C++是在C语言的基础上开发的一种通用编程语言\n【Perl】Perl 是高级、通用、直译式、动态的程序语言\n【Servlet 】运行在 Web 服务器或应用服务器上的程序\n【JSP】JSP与PHP、ASP、ASP.NET等语言类似，运行在服务端的语言\n【Lua】Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放\n【Scala】Scala 是一门多范式（multi-paradigm）的编程语言。\n【Go】Go语言是谷歌推出的一种全新的编程语言\n【设计模式】设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用\n【正则表达式】正则表达式是对字符串操作的一种逻辑公式\n【Maven】Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n【NumPy】NumPy 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算。\n【ASP】ASP（Active Server Pages 动态服务器页面）是一种生成动态交互性网页的强有力工具\n【AppML】AppML 是一个为web应用程序设计的HTML扩展框\n【VBScript】一种微软环境下的轻量级的解释型语言\n\n数据库\n【SQL】结构化查询语言(Structured Query Language)\n【Mysql】MySQL是一个关系型数据库管理系统\n【PostgreSQL】PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)\n【SQLite】一款轻型的数据库\n【MongoDB】Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql)\n【Redis】一个高性能的key-value数据库\n【Memcached】Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。\n\n移动端\n【Android】Android 是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备\n【Swift】Swift 是一种支持多编程范式和编译式的编程语言,用于开发 iOS，OS X 和 watchOS应用程序。\n【jQuery Mobile】jQuery Mobile是jQuery 在手机上和平板设备上的版本\n【ionic】ionic 是一个强大的 HTML5 应用程序开发框架(HTML5 Hybrid Mobile App Framework )\n【Kotlin】在 Java 虚拟机上运行的静态类型编程语言，Android 官方开发语言\n\nXML 教程\n【XML】XML 被设计用来传输和存储数据\n【DTD】DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块\n【XML DOM】XML DOM 定义访问和操作XML文档的标准方法\n【XSLT】XSL 是一个 XML 文档的样式表语言，XSLT 指 XSL 转换\n【XPath】XPath 是一门在 XML 文档中查找信息的语言\n【XQuery】XQuery 被设计用来查询 XML 数据\n【XLink】XLink 定义在 XML 文档中创建超级链接的标准方法\n【XPointer】XPointer是在可扩展标志语言（XML）文件中定位数据的一种语言\n【XML Schema】XML Schema 描述了 XML文档的结构\n【XSL-FO】XSL-FO 指可扩展样式表语言格式化对象\n【SVG】SVG 使用 XML 格式定义图像\n\nASP.NET\n【ASP.NET】ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架\n【C#】C# 是一个简单的、现代的、通用的、面向对象的编程语言\n【Web Pages】Web Pages 是三种网页编程模型中的一种，用于创建网站和web 应用程序\n【Razor】Razor 是一种标记语法，可以让您将基于服务器的代码（Visual Basic 和 C#）嵌入到网页中\n【MVC】MVC（Model View Controller 模型-视图-控制器）\n【Web Forms】Web Forms 是三种创建 ASP.NET 网站和 Web 应用程序的编程模式中的一种\n\nWeb Service\n【Web Service】Web Service 脚本平台需支持 XML + HTTP\n【WSDL】WSDL是一门基于 XML 的语言，用于描述 Web Service 以及如何对它们进行访问\n【SOAP】SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息\n【RSS】RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议\n【RDF】DF(资源描述框架)是描述网络资源的 W3C 标准\n\n开发工具\n【Eclipse】Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台\n【Git】Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目\n【Svn】SVN 是一个开放源代码的版本控制系统\n【Markdown】Markdown 是一种轻量级标记语\n\n网站建设\n【HTTP】HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议\n【网站建设指南】网站建设指导课程\n【浏览器信息】对于网站开发人员来说，浏览器信息和统计数据都是非常重要的\n【网站主机教程】如果您希望向全世界发布自己的网站，那么您的网站就需要被放置于一个 WEB 服务器\n【TCPIP】TCPIP 是因特网的通信协议\n【W3C】W3C 让每个人都能在互联网上分享资源\n【网站品质】何创建高质量的web网站\n\n菜鸟教程\n","tags":["文章","编程"],"path":"2019/08/18/技术栈/","external_link":""},{"title":"深入理解Node.js 中的进程与线程","date":"2019-09-05T13:26:58.000Z","content":"\n前言进程与线程是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解进程与线程，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用。\n面试会问\nNode.js是单线程吗？\n\n\nNode.js 做耗时的计算时候，如何避免阻塞？\n\n\nNode.js如何实现多进程的开启和关闭？\n\n\nNode.js可以创建线程吗？\n\n\n你们开发过程中如何实现进程守护的？\n\n\n除了使用第三方模块，你们自己是否封装过一个多进程架构?\n\n进程进程Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。\n1234567const http = require(http);const server = http.createServer();server.listen(3000,()=&gt;&#123;    process.title=程序员成长指北测试进程;    console.log(进程id,process.pid)&#125;)\n\n运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663\n线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。\n单线程单线程就是一个进程只开一个线程\nJavascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。\n123456789101112131415161718192021222324const http = require(http);const longComputation = () =&gt; &#123;  let sum = 0;  for (let i = 0; i &lt; 1e10; i++) &#123;    sum += i;  &#125;;  return sum;&#125;;const server = http.createServer();server.on(request, (req, res) =&gt; &#123;  if (req.url === compute) &#123;    console.info(计算开始,new Date());    const sum = longComputation();    console.info(计算结束,new Date());    return res.end(`Sum is $&#123;sum&#125;`);  &#125; else &#123;    res.end(Ok)  &#125;&#125;);server.listen(3000);打印结果计算开始 2019-07-28T07:08:49.849Z计算结束 2019-07-28T07:09:04.522Z\n\n查看打印结果，当我们调用127.0.0.1:3000compute的时候，如果想要调用其他的路由地址比如127.0.0.1大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。\n单线程的一些说明\n\nNode.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。\n当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。\nNode.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。\n单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。\n\n","tags":["Nodejs"],"path":"2019/09/05/深入理解Node-js-中的进程与线程/","external_link":""},{"title":"树的高度（小米2017秋招真题）","date":"2019-09-05T08:08:46.000Z","content":"\n树的高度（小米2017秋招真题）题目题目描述\n现在有一棵合法的二叉树，树的节点都是用数字表示，现在给定这棵树上所有的父子关系，求这棵树的高度\n时间限制CC++语言：1000MS 其它语言：3000MS\n内存限制CC++语言：65536KB 其它语言：589824KB\n输入\n输入的第一行表示节点的个数n（1&lt;=n&lt;=1000，节点的编号为0到n-1）组成，下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号\n输出\n输出树的高度，为一个整数\n样例输入\n1234550 10 21 31 4\n\n样例输出\n13\n\n题解java\n1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] parent = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            parent[i] = -1;        &#125;        for (int i = 0; i &lt; n - 1; i++) &#123;            int a = sc.nextInt();            int b = sc.nextInt();            parent[b] = a;        &#125;        int h = 0;        for (int i = 0; i &lt; n; i++) &#123;            int max = 1;            int j = i;            while (parent[j] != -1) &#123;                j = parent[j];                max++;            &#125;            h = max &gt; h ? max : h;        &#125;        System.out.println(h);    &#125;&#125;\n\npython\n1234567891011121314import sysdef get(x):    try:        return 1 + get(dic_s[x])    except KeyError:        return 1n = int(sys.stdin.readline().strip())dic_s = &#123;&#125;for i in range(int(n)-1):    j_1,j_2 = sys.stdin.readline().strip().split()    dic_s[j_2] = j_1print max([get(i) for i in set(dic_s.keys()) - set(dic_s.values())]) if n&gt;1 else 1\n\njavascript\n12345678910111213141516var n=readInt(),rec=&#123;&#125;,dps=&#123;&#125;,rs=1while(n--&gt;1) &#123;  var a=readInt(),b=readInt()  rec[a]=rec[a]||[]  rec[a].push(b)&#125;for(var k in rec) rs=Math.max(rs,maxDps(k))print(rs)function maxDps(n)&#123;  if(!rec[n]) return 1  if(dps[n]) return dps[n]  var r=1  for(var x of rec[n]) r=Math.max(r,maxDps(x)+1)  dps[n]=r  return dps[n]&#125;\n\n","tags":["算法","树","二叉树"],"path":"2019/09/05/树的高度（小米2017秋招真题）/","external_link":""},{"title":"灭霸脚本","date":"2019-09-08T23:20:36.000Z","content":"Thanos.shThis command could delete list half your files randomly.\ndon’t use it at home and other places. this is a real gun, use it wisely… \nfeel free to post your story on waiting.12345678910111213141516# 灭霸脚本这个命令会随机“删掉”您一半的文件。。请不要在家里或其他地方使用。这是真家伙，要小心…你可以在```Story.md```文件里发布你的故事，期待中…  ## 特别说明 &gt; 1. 支持mac系统，但是需要使用到```gshuf```命令，需要通过```brew```安装,安装命令如下：```shell    #安装brew    usrbinruby -e &quot;$(curl -fsSL https:raw.githubusercontent.comHomebrewinstallmasterinstall)&quot;    #安装gshuf    brew install coreutils`\n\n\n此脚本只会列出当前目录一半的文件。并且。。。总之小心点。。。  \n\n\nInvoke-Thanos.ps1Invokes Thanos to remove each object with probability 12. It works with files, registry, environment variables, functions, variables, aliases and certificates.\nFor help, use Get-Help .Invoke-Thanos.ps1. Be sure to not actually invoke it!\n123456789101112131415#!binshlet i=`find . -type f | wc -l`2;if [[ uname==Darwin ]]; then    find . -not -name Thanos.sh -type f -print0 | gshuf -z -n $i | xargs -0  -- cat;else    find . -not -name Thanos.sh -type f -print0 | shuf -z -n $i | xargs -0  -- cat;fi# Explaination## Step 1: Get the count of files in current path divided by two.## Step 2: Get all the files in current path and print in one line.## Step 3: Turn half of the second step output into standard input randomly.## Step 4: Show half of the files in terminal.# Key Point## If you want to make delete, what you need to do is turn cat into rm.\n\n本人在线上服务器上运行了一次，…\n\n\n","tags":["脚本"],"path":"2019/09/09/灭霸脚本/","external_link":""},{"title":"数据库备份恢复容器化项目实践经验总结","date":"2019-09-08T13:35:18.000Z","content":"数据库备份恢复容器化项目实践经验总结\n本文分享了唯品会数据库Docker的异地容灾项目实践经验，项目中针对用户数据库的异地恢复场景的需求进行开发和测试，整合了网络，存储、调度、监控，镜像等多个模块。在实施完成后，从技术上总结关于选型、开发、踩坑、测试等方面的经验。\n\n项目背景数据库Docker的异地备份恢复容灾项目，针对用户数据库的异地备份恢复场景的需求进行开发和测试，整合了容器网络、存储、调度、监控、镜像等多个模块。同时针对数据库的日常运维工作开发了监控、资源调度、日志、Puppet自动推送等工具。\n通过Docker天生隔离性和快速部署等特点，实现在单台物理机上运行多个数据库备份恢复实例，大大提高服务器使用率，节省大量成本。通过对Docker本身和相关组件的研究和改造，从普通开源产品落地到公司内部生产环境，积累宝贵的开发经验。通过对Docker已经在其上层运行的数据库日常运维和监控，也积累宝贵的Docker运维经验，为更大规模推广容器提供基础。\n\n关于容器技术通过实践，证明容器技术在易用性，可管理性，快速部署具备天然的优势。在资源利用率方面，容器部署在上百个物理节点上，提供约500多个数据库灾备实例，提升了硬件资源的利用率，节约了约400台物理机的采购成本。这些是容器技术带来的实实在在收益。在资源分配与隔离方面，又不输于虚拟机。CPU、内存、磁盘IO、网络IO限流等技术的应用，保证了资源的合理使用，从机制上阻止了单一实例的资源过分消耗的问题。\n稳定性是使用容器技术非常关注的一个点，也是基石。MySQL备份恢复属于CPU密集 + 磁盘IO密集 + 网络IO密集型业务，对于Docker daemon是个较大的考验。就目前来看，限制每台宿主机的容器数量（5个左右）的情况下，集群跑了三个多月没有出现因为容器负载过大导致的crash现象，还是值得信赖的。遇到的唯一相关问题是Docker daemon挂死，具体现象是docker info、docker ps没有响应，docker volume、docker images 正常，下面的容器运行正常。这是偶发事件，无法重现，以后需要继续观察。\n由于容器以进程方式存在，体现出几乎与物理机上相当的性能，Overheads极低（低于10%）。从数据抽取任务的结果来看，与物理机相比，使用容器对成功率没有影响，效率也差不多。这也很符合最初预想，不管跑容器还是外部服务从物理机角度来说它们之间是没有什么区别的，都是一个进程，唯一不同是父进程不一样而已。\n以上是容器“RUN”带来的好处，通过统一开发流程，应用微服务化，CICD等方面的改进，能够进一步利用容器“BUILD”、“SHIP” 优势，容器技术还来的潜力是巨大的。要说容器技术的缺点，还真的不明显。硬要提的话一个是需要一定的学习成本，改变开发流程与方式，一个是开发人员对容器技术的接受程度。这个项目仅用了不到二百人天，对于一个采用新技术的项目来说，真的是很低的了。一开始我们也担心因为采用新技术导致开发推广有困难，后来实际能通过技术上解决问题，打消了大部分用户对使用Docker的疑虑，反而有助于该技术的普遍应用。\n关于Docker daemon版本的选择，我们之前是有过一些讨论的。现在Docker社区非常活跃，当时我们用1.10.3， 到现在已经出了两个新版本了。在功能满足的前提下，稳定性是第一考量。Docker自1.9.0引入CNM网络模型，1.10算是比较成熟。CNM是我们希望在这个项目尝试的一部分。网络与Volume插件功能与稳定性的提升，开始支持磁盘IO读写限速，Device Mapper的支持，等等，都是选择了这个版本的原因。另外，Docker插件的引入，很好地解耦了Docker与底层模块的关系，使我们可以专注于底层（网络、存储）实现而不需要修改Docker daemon本身，同时避免产生升级依赖。\n关于容器存储容器外部卷使用Convoy，以插件的形式支持容器持久化数据。容器本身与外部卷均使用Device Mapper作为底层。没有选择分布式存储原因，主要是为了简化实现，更稳定。通过限制每个容器的BlkioDeviceReadBps、BlkioDeviceWriteBps、BlkioDeviceReadIOps、BlkioDeviceWriteIOps，使磁盘IO稳定地达到相当于95%物理机性能。\n\n对于Device Mapper，因为是红帽推荐的，而OS又是用的CentOS7.2, 所以就用了它。测试过程中发现Device Mapper健壮性不是很好，仅仅在低并发下，也会出现容器删除失败的情况，容器并发启停偶尔出现找不到设备的情况。这种使用映射关系的设备，功能是丰富，实现上过于复杂，每次对设备的修改都需要额外去更新Metadata，并发场景出错的机会就大了。让我再选的话我会考虑Overlay这种更简单的driver。\n对于Convoy，是来自Rancher的产品，Go语言，仍然处于未成熟阶段，版本号0.5, 并没有完全实现Volume Plugin接口。相比其它模块它的问题也是最多的，例如Volume创建失败，无法删除，UNIX Socket泄漏，重名冲突，异常自动退出等。属于能用，但未完善的状态，你自己得有一定开发调试能力去解决发现的问题。其它几个存储插件情况也差不多，Flocker、Blockbridge、Horcrux等等，有的连第一个正式发布版都还没有，Convoy反而相对好点，有点烂柿子堆里挑的感觉。\n关于容器监控容器监控在这个项目里还可以有很大的空间可以改进。项目里用的是cAdvisor，容器内top、free、iostat命令劫持，基于已有的Zabbix体系作数据收集与展示。结论是Zabbix完全不合适做容器监控，数据收集密度，展示质量，灵活度都没能满足需求。\n后来在测试中尝试使用Telegraf + InfluxDB + Grafana。 只需要Grafana简单的配置，能够帮忙我们清晰地展示容器及服务进程CPU、内存、网络、磁盘等情况。Grafana上SQL查询语句的调试与开发，确实需要不少的时间，但这个工作量是一次性的。因为是Go写的，Telegraf CPU占用属于比较低的水平（0.4 – 5%）。功能上比较丰富，同时支持外部进程与容器的数据收集，多达55种数据源插件，有它就不需要布cAdvisor了，个人比较推荐。需要告警的同学，可以考虑把influxDB改成Prometheus。它包含Alertmanager实现Email、PagerDuty等消息通知。数据Backend可以选择自带的DB，也可以外接influxDB、Graphite、OpenTSDB等流行方案。\n\n监控领域业界已经有很多开源方案可以参考，以下是要衡量的标准：易扩展、开销低、入侵小、大集中、易部署、实时性、展现清晰灵活。这方面希望与各位有更多的交流。\n","tags":["数据库","备份","Docker"],"path":"2019/09/08/数据库备份恢复容器化项目实践经验总结/","external_link":""},{"title":"狂野飙车9","date":"2019-09-04T18:19:56.000Z","content":"兰博基尼\n法拉利\n布加迪\n迈凯伦\n兰博基尼\n风神\n","tags":["狂野飙车","跑车"],"path":"2019/09/05/狂野飙车9/","external_link":""},{"title":"面试红黑树","date":"2019-09-08T02:43:14.000Z","content":"什么是红黑树红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。\n它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。\n由于 TreeMap 就是由红黑树实现的，因此本文将使用 TreeMap 的相关操作的代码进行分析、论证。\n黑色高度从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。\n红黑树的 5 个特性\n红黑树在原有的二叉查找树基础上增加了如下几个要求：\n\nEvery node is either red or black.\nThe root is black.\nEvery leaf (NIL) is black.\nIf a node is red, then both its children are black.\nFor each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\n中文意思是：\n\n每个节点要么是红色，要么是黑色；\n根节点永远是黑色的；\n所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；\n每个红色节点的两个子节点一定都是黑色；\n从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；\n\n注意：性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。\n性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。\n性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。\n红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。\n红黑树的左旋右旋\n红黑树的左右旋是比较重要的操作，左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。\n比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。\n我们以 Java 集合框架中的 TreeMap 中的代码来看下左右旋的具体操作方法：\n指定节点 x 的左旋 (右图转成左图)：\n123456789101112131415161718 这里 p 代表 xprivate void rotateLeft(Entry p) &#123;    if (p != null) &#123;        Entry r = p.right;  p 是上图中的 x，r 就是 y        p.right = r.left;        左旋后，x 的右子树变成了 y 的左子树 β         if (r.left != null)                     r.left.parent = p;  β 确认父亲为 x        r.parent = p.parent;        y 取代 x 的第一步：认 x 的父亲为爹        if (p.parent == null)       要是 x 没有父亲，那 y 就是最老的根节点            root = r;        else if (p.parent.left == p) 如果 x 有父亲并且是它父亲的左孩子，x 的父亲现在认 y 为左孩子，不要 x 了            p.parent.left = r;        else                            如果 x 是父亲的右孩子，父亲就认 y 为右孩子，抛弃 x            p.parent.right = r;        r.left = p;     y 逆袭成功，以前的爸爸 x 现在成了它的左孩子        p.parent = r;    &#125;&#125;\n\n可以看到，x 节点的左旋就是把 x 变成 右孩子 y 的左孩子，同时把 y 的左孩子送给 x 当右子树。\n简单点记就是：左旋把右子树里的一个节点（上图 β）移动到了左子树。\n指定节点 y 的右旋（左图转成右图）：\n123456789101112131415private void rotateRight(Entry p) &#123;    if (p != null) &#123;        Entry l = p.left;        p.left = l.right;        if (l.right != null) l.right.parent = p;        l.parent = p.parent;        if (p.parent == null)            root = l;        else if (p.parent.right == p)            p.parent.right = l;        else p.parent.left = l;        l.right = p;        p.parent = l;    &#125;&#125;\n\n同理，y 节点的右旋就是把 y 变成 左孩子 x 的右孩子，同时把 x 的右孩子送给 x 当左子树。\n简单点记就是：右旋把左子树里的一个节点（上图 β）移动到了右子树。\n了解左旋、右旋的方法及意义后，就可以了解红黑树的主要操作：插入、删除。\n总结红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。\n红黑树的插入、删除调整逻辑比较复杂，但最终目的是满足红黑树的 5 个特性，尤其是 4 和 5。\n在插入调整时为了简化操作我们直接把插入的节点涂成红色，这样只要保证插入节点的父节点不是红色就可以了。\n而在删除后的调整中，针对删除黑色节点，所在子树缺少一个节点，需要进行弥补或者对别人造成一个黑色节点的伤害。具体调整方法取决于兄弟节点所在子树的情况。\n红黑树的插入、删除在树形数据结构中算比较复杂的，理解起来比较难，但只要记住，红黑树有其特殊的平衡规则，而我们为了维持平衡，根据邻树的状况进行旋转或者涂色。\n红黑树这么难理解，必定有其过人之处。它的有序、快速特性在很多场景下都有用到，比如 Java 集合框架的 TreeMap, TreeSet 等。\n","tags":["算法","面试","红黑树"],"path":"2019/09/08/面试红黑树/","external_link":""},{"title":"Airbnb JavaScript 代码规范() {","date":"2019-09-08T02:51:27.000Z","content":"Airbnb JavaScript 代码规范() {一种写JavaScript更合理的代码风格。\n\nNote: 本指南假设你使用了 Babel, 并且要求你使用 babel-preset-airbnb 或者其他同等资源。 并且假设你在你的应用中安装了 shimspolyfills ，使用airbnb-browser-shims 或者相同功能。\n\n\n\n\n其他代码风格指南\n\nES5 (Deprecated)\nReact\nCSS-in-JavaScript\nCSS &amp; Sass\nRuby\n\n目录\n类型\n引用\n对象\n数组\n解构\n字符\n方法\n箭头函数\n类和构造器\n模块\n迭代器和发生器\n属性\n变量\n提升\n比较运算符和等号\n块\n控制语句\n注释\n空白\n逗号\n分号\n类型转换和强制类型转换\n命名规范\n存取器\n事件\njQuery\nECMAScript 5 兼容性\nECMAScript 6+ (ES 2015+) 风格\n标准库\n测试\n性能\n资源\nJavaScript风格指南的指南\n许可证\n修正案\n\n类型  \n\n1.1 原始值: 当你访问一个原始类型的时候，你可以直接使用它的值。\n\nstring\nnumber\nboolean\nnull\nundefined\nsymbol\n\n123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar);  =&gt; 1, 9\n\n\nSymbols cannot be faithfully polyfilled, so they should not be used when targeting browsersenvironments that don’t support them natively.\n\n\n\n1.2  复杂类型: 当你访问一个复杂类型的时候，你需要一个值得引用。\n\nobject\narray\nfunction\n\n123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]);  =&gt; 9, 9\n\n\n\n⬆ 返回目录\n引用  \n\n2.1 使用 const 定义你的所有引用；避免使用 var。 eslint: prefer-const, no-const-assign\n\n为什么? 这样能够确保你不能从新分配你的引用，否则可能导致错误或者产生难以理解的代码。.\n\n1234567 badvar a = 1;var b = 2; goodconst a = 1;const b = 2;\n\n\n\n2.2 如果你必须重新分配你的引用， 使用 let 代替 var。 eslint: no-var\n\n为什么? let 是块级作用域，而不像 var 是函数作用域.\n\n1234567891011 badvar count = 1;if (true) &#123;  count += 1;&#125; good, use the let.let count = 1;if (true) &#123;  count += 1;&#125;\n\n\n\n2.3 注意，let 和 const 都是块级范围的。\n1234567 const 和 let 只存在于他们定义的块中。&#123;  let a = 1;  const b = 1;&#125;console.log(a);  ReferenceErrorconsole.log(b);  ReferenceError\n\n\n\n⬆ 返回目录\n对象  \n\n3.1 使用字面语法来创建对象。 eslint: no-new-object\n12345 badconst item = new Object(); goodconst item = &#123;&#125;;\n\n\n\n3.2 在创建具有动态属性名称的对象时使用计算属性名。\n\n为什么? 它允许你在一个地方定义对象的所有属性。\n\n123456789101112131415161718function getKey(k) &#123;  return `a key named $&#123;k&#125;`;&#125; badconst obj = &#123;  id: 5,  name: San Francisco,&#125;;obj[getKey(enabled)] = true; goodconst obj = &#123;  id: 5,  name: San Francisco,  [getKey(enabled)]: true,&#125;;\n\n\n\n3.3 使用对象方法的缩写。 eslint: object-shorthand\n1234567891011121314151617 badconst atom = &#123;  value: 1,  addValue: function (value) &#123;    return atom.value + value;  &#125;,&#125;; goodconst atom = &#123;  value: 1,  addValue(value) &#123;    return atom.value + value;  &#125;,&#125;;\n\n\n\n3.4 使用属性值的缩写。 eslint: object-shorthand\n\n为什么? 它的写法和描述较短。\n\n1234567891011const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  lukeSkywalker: lukeSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,&#125;;\n\n\n\n3.5 在对象声明的时候将简写的属性进行分组。\n\n为什么? 这样更容易的判断哪些属性使用的简写。\n\n12345678910111213141516171819202122const anakinSkywalker = Anakin Skywalker;const lukeSkywalker = Luke Skywalker; badconst obj = &#123;  episodeOne: 1,  twoJediWalkIntoACantina: 2,  lukeSkywalker,  episodeThree: 3,  mayTheFourth: 4,  anakinSkywalker,&#125;; goodconst obj = &#123;  lukeSkywalker,  anakinSkywalker,  episodeOne: 1,  twoJediWalkIntoACantina: 2,  episodeThree: 3,  mayTheFourth: 4,&#125;;\n\n\n\n3.6 只使用引号标注无效标识符的属性。 eslint: quote-props\n\n为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。\n\n12345678910111213 badconst bad = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;; goodconst good = &#123;  foo: 3,  bar: 4,  data-blah: 5,&#125;;\n\n\n\n3.7 不能直接调用 Object.prototype 的方法，如： hasOwnProperty 、 propertyIsEnumerable 和 isPrototypeOf。\n\n为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 { hasOwnProperty: false } - 或者，对象是一个空对象 (Object.create(null))。\n\n123456789101112 badconsole.log(object.hasOwnProperty(key)); goodconsole.log(Object.prototype.hasOwnProperty.call(object, key)); bestconst has = Object.prototype.hasOwnProperty;  在模块范围内的缓存中查找一次* or *import has from has;  https:www.npmjs.compackagehas ...console.log(has.call(object, key));\n\n\n\n3.8 更喜欢对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n1234567891011121314 very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;);  变异的 `original` ಠ_ಠdelete copy.a;  这.... badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;);  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125; goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;;  copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy;  noA =&gt; &#123; b: 2, c: 3 &#125;\n\n\n\n⬆ 返回目录\n数组  \n\n4.1 使用字面语法创建数组。 eslint: no-array-constructor\n12345 badconst items = new Array(); goodconst items = [];\n\n\n\n4.2 使用 Array#push 取代直接赋值来给数组添加项。\n1234567const someStack = []; badsomeStack[someStack.length] = abracadabra; goodsomeStack.push(abracadabra);\n\n\n\n4.3 使用数组展开方法 ... 来拷贝数组。\n1234567891011 badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) &#123;  itemsCopy[i] = items[i];&#125; goodconst itemsCopy = [...items];\n\n\n\n4.4 将一个类数组对象转换成一个数组， 使用展开方法 ... 代替 Array.from。\n1234567const foo = document.querySelectorAll(.foo); goodconst nodes = Array.from(foo); bestconst nodes = [...foo];\n\n\n\n4.5 对于对迭代器的映射，使用 Array.from 替代展开方法 ... ， 因为它避免了创建中间数组。\n12345 badconst baz = [...foo].map(bar); goodconst baz = Array.from(foo, bar);\n\n\n\n4.6 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 8.2。 eslint: array-callback-return\n1234567891011121314151617181920212223242526272829303132333435363738394041 good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map(x =&gt; x + 1); bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;&#125;); good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123;  const flatten = acc.concat(item);  acc[index] = flatten;  return flatten;&#125;); badinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125; else &#123;    return false;  &#125;&#125;); goodinbox.filter((msg) =&gt; &#123;  const &#123; subject, author &#125; = msg;  if (subject === Mockingbird) &#123;    return author === Harper Lee;  &#125;  return false;&#125;);\n\n\n\n4.7 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n12345678910111213141516171819202122232425262728293031 badconst arr = [  [0, 1], [2, 3], [4, 5],];const objectInArray = [&#123;  id: 1,&#125;, &#123;  id: 2,&#125;];const numberInArray = [  1, 2,]; goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [  &#123;    id: 1,  &#125;,  &#123;    id: 2,  &#125;,];const numberInArray = [  1,  2,];\n\n\n\n⬆ 返回目录\n解构  \n\n5.1 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: prefer-destructuring\n\n为什么? 解构可以避免为这些属性创建临时引用。\n\n123456789101112131415161718 badfunction getFullName(user) &#123;  const firstName = user.firstName;  const lastName = user.lastName;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; goodfunction getFullName(user) &#123;  const &#123; firstName, lastName &#125; = user;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;  return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;\n\n\n\n5.2 使用数组解构。 eslint: prefer-destructuring\n12345678const arr = [1, 2, 3, 4]; badconst first = arr[0];const second = arr[1]; goodconst [first, second] = arr;\n\n\n\n5.3 对于多个返回值使用对象解构，而不是数组解构。\n\n为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。\n\n1234567891011121314151617 badfunction processInput(input) &#123;   处理代码...  return [left, right, top, bottom];&#125; 调用者需要考虑返回数据的顺序。const [left, __, top] = processInput(input); goodfunction processInput(input) &#123;   处理代码...  return &#123; left, right, top, bottom &#125;;&#125; 调用者只选择他们需要的数据。const &#123; left, top &#125; = processInput(input);\n\n\n\n⬆ 返回目录\n字符  \n\n6.1 使用单引号 &#39;&#39; 定义字符串。 eslint: quotes\n12345678 badconst name = Capt. Janeway; bad - 模板文字应该包含插值或换行。const name = `Capt. Janeway`; goodconst name = Capt. Janeway;\n\n\n\n6.2 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n\n为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。\n\n12345678910111213 badconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.; badconst errorMessage = This is a super long error that was thrown because  +  of Batman. When you stop to think about how Batman had anything to do  +  with this, you would get nowhere fast.; goodconst errorMessage = This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.;\n\n\n\n6.3 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: prefer-template template-curly-spacing\n\n为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。\n\n12345678910111213141516171819 badfunction sayHi(name) &#123;  return How are you,  + name + ?;&#125; badfunction sayHi(name) &#123;  return [How are you, , name, ?].join();&#125; badfunction sayHi(name) &#123;  return `How are you, $&#123; name &#125;?`;&#125; goodfunction sayHi(name) &#123;  return `How are you, $&#123;name&#125;?`;&#125;\n\n\n\n6.4 不要在字符串上使用 eval() ，它打开了太多漏洞。 eslint: no-eval\n\n\n6.5 不要转义字符串中不必要的字符。 eslint: no-useless-escape\n\n为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。\n\n123456 badconst foo = this is quoted; goodconst foo = this is quoted;const foo = `my name is $&#123;name&#125;`;\n\n\n\n⬆ 返回目录\n方法  \n\n7.1 使用命名的函数表达式代替函数声明。 eslint: func-style\n\n为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (Discussion)\n\n123456789101112131415 badfunction foo() &#123;   ...&#125; badconst foo = function () &#123;   ...&#125;; good 从变量引用调用中区分的词汇名称const short = function longUniqueMoreDescriptiveLexicalFoo() &#123;   ...&#125;;\n\n\n\n7.2 Wrap立即调用函数表达式。 eslint: wrap-iife\n\n为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。\n\n1234 immediately-invoked function expression (IIFE) 立即调用的函数表达式(function () &#123;  console.log(Welcome to the Internet. Please follow me.);&#125;());\n\n\n\n7.3 切记不要在非功能块中声明函数 (if, while, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: no-loop-func\n\n\n7.4 注意: ECMA-262 将 block 定义为语句列表。 函数声明不是语句。\n1234567891011121314 badif (currentUser) &#123;  function test() &#123;    console.log(Nope.);  &#125;&#125; goodlet test;if (currentUser) &#123;  test = () =&gt; &#123;    console.log(Yup.);  &#125;;&#125;\n\n\n\n7.5 永远不要定义一个参数为 arguments。 这将会优先于每个函数给定范围的 arguments 对象。\n123456789 badfunction foo(name, options, arguments) &#123;   ...&#125; goodfunction foo(name, options, args) &#123;   ...&#125;\n\n\n\n7.6 不要使用 arguments, 选择使用 rest 语法 ... 代替。 eslint: prefer-rest-params\n\n为什么? ... 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 arguments 。\n\n12345678910 badfunction concatenateAll() &#123;  const args = Array.prototype.slice.call(arguments);  return args.join();&#125; goodfunction concatenateAll(...args) &#123;  return args.join();&#125;\n\n\n\n7.7 使用默认的参数语法，而不是改变函数参数。\n123456789101112131415161718192021 really badfunction handleThings(opts) &#123;   No! We shouldn’t mutate function arguments.   Double bad: if opts is falsy itll be set to an object which may   be what you want but it can introduce subtle bugs.  opts = opts || &#123;&#125;;   ...&#125; still badfunction handleThings(opts) &#123;  if (opts === void 0) &#123;    opts = &#123;&#125;;  &#125;   ...&#125; goodfunction handleThings(opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.8 避免使用默认参数的副作用。\n\n为什么? 他们很容易混淆。\n\n123456789var b = 1; badfunction count(a = b++) &#123;  console.log(a);&#125;count();   1count();   2count(3);  3count();   3\n\n\n\n7.9 总是把默认参数放在最后。\n123456789 badfunction handleThings(opts = &#123;&#125;, name) &#123;   ...&#125; goodfunction handleThings(name, opts = &#123;&#125;) &#123;   ...&#125;\n\n\n\n7.10 永远不要使用函数构造器来创建一个新函数。 eslint: no-new-func\n\n为什么? 以这种方式创建一个函数将对一个类似于 eval() 的字符串进行计算，这将打开漏洞。\n\n12345 badvar add = new Function(a, b, return a + b); still badvar subtract = Function(a, b, return a - b);\n\n\n\n7.11 函数签名中的间距。 eslint: space-before-function-paren space-before-blocks\n\n为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。\n\n12345678 badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;; goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;;\n\n\n\n7.12 没用变异参数。 eslint: no-param-reassign\n\n为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。\n\n123456789 badfunction f1(obj) &#123;  obj.key = 1;&#125; goodfunction f2(obj) &#123;  const key = Object.prototype.hasOwnProperty.call(obj, key) ? obj.key : 1;&#125;\n\n\n\n7.13 不要再分配参数。 eslint: no-param-reassign\n\n为什么? 重新分配参数会导致意外的行为，尤其是在访问 arguments 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。\n\n1234567891011121314151617181920 badfunction f1(a) &#123;  a = 1;   ...&#125;function f2(a) &#123;  if (!a) &#123; a = 1; &#125;   ...&#125; goodfunction f3(a) &#123;  const b = a || 1;   ...&#125;function f4(a = 1) &#123;   ...&#125;\n\n\n\n7.14 优先使用扩展运算符 ... 来调用可变参数函数。 eslint: prefer-spread\n\n为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 apply 来 new 。\n\n12345678910111213 badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x); goodconst x = [1, 2, 3, 4, 5];console.log(...x); badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5])); goodnew Date(...[2016, 8, 5]);\n\n\n\n7.15 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: function-paren-newline\n123456789101112131415161718192021222324252627 badfunction foo(bar,             baz,             quux) &#123;   ...&#125; goodfunction foo(  bar,  baz,  quux,) &#123;   ...&#125; badconsole.log(foo,  bar,  baz); goodconsole.log(  foo,  bar,  baz,);\n\n\n\n⬆ 返回目录\n箭头函数  \n\n8.1 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: prefer-arrow-callback, arrow-spacing\n\n为什么? 它创建了一个在 this 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。\n\n\n为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。\n\n1234567891011 bad[1, 2, 3].map(function (x) &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.2 如果函数体包含一个单独的语句，返回一个没有副作用的 expression ， 省略括号并使用隐式返回。否则，保留括号并使用 return 语句。 eslint: arrow-parens, arrow-body-style\n\n为什么? 语法糖。 多个函数被链接在一起时，提高可读性。\n\n12345678910111213141516171819202122232425262728293031323334353637 bad[1, 2, 3].map(number =&gt; &#123;  const nextNumber = number + 1;  `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`); good[1, 2, 3].map((number) =&gt; &#123;  const nextNumber = number + 1;  return `A string containing the $&#123;nextNumber&#125;.`;&#125;); good[1, 2, 3].map((number, index) =&gt; (&#123;  [index]: number,&#125;)); 没有副作用的隐式返回function foo(callback) &#123;  const val = callback();  if (val === true) &#123;     如果回调返回 true 执行  &#125;&#125;let bool = false; badfoo(() =&gt; bool = true); goodfoo(() =&gt; &#123;  bool = true;&#125;);\n\n\n\n8.3 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n\n为什么? 它清楚地显示了函数的起点和终点。\n\n1234567891011121314 bad[get, post, put].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )); good[get, post, put].map(httpMethod =&gt; (  Object.prototype.hasOwnProperty.call(    httpMagicObjectWithAVeryLongName,    httpMethod,  )));\n\n\n\n8.4 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 “always” option 来配置 eslint. eslint: arrow-parens\n\n为什么? 减少视觉上的混乱。\n\n12345678910111213141516171819202122 bad[1, 2, 3].map((x) =&gt; x * x); good[1, 2, 3].map(x =&gt; x * x); good[1, 2, 3].map(number =&gt; (  `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`)); bad[1, 2, 3].map(x =&gt; &#123;  const y = x + 1;  return x * y;&#125;); good[1, 2, 3].map((x) =&gt; &#123;  const y = x + 1;  return x * y;&#125;);\n\n\n\n8.5 避免箭头函数符号 (=&gt;) 和比较运算符 (&lt;=, &gt;=) 的混淆。 eslint: no-confusing-arrow\n1234567891011121314 badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize; goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize); goodconst itemHeight = (item) =&gt; &#123;  const &#123; height, largeSize, smallSize &#125; = item;  return height &gt; 256 ? largeSize : smallSize;&#125;;\n\n\n\n8.6 注意带有隐式返回的箭头函数函数体的位置。 eslint: implicit-arrow-linebreak\n12345678910111213 bad(foo) =&gt;  bar;(foo) =&gt;  (bar); good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; (   bar)\n\n\n\n⬆ 返回目录\n类和构造器  \n\n9.1 尽量使用 class. 避免直接操作 prototype .\n\n为什么? class 语法更简洁，更容易推理。\n\n123456789101112131415161718192021 badfunction Queue(contents = []) &#123;  this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123;  const value = this.queue[0];  this.queue.splice(0, 1);  return value;&#125;; goodclass Queue &#123;  constructor(contents = []) &#123;    this.queue = [...contents];  &#125;  pop() &#123;    const value = this.queue[0];    this.queue.splice(0, 1);    return value;  &#125;&#125;\n\n\n\n9.2 使用 extends 来扩展继承。\n\n为什么? 它是一个内置的方法，可以在不破坏 instanceof 的情况下继承原型功能。\n\n12345678910111213141516 badconst inherits = require(inherits);function PeekableQueue(contents) &#123;  Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123;  return this.queue[0];&#125;; goodclass PeekableQueue extends Queue &#123;  peek() &#123;    return this.queue[0];  &#125;&#125;\n\n\n\n9.3 方法返回了 this 来供其内部方法调用。\n12345678910111213141516171819202122232425262728293031 badJedi.prototype.jump = function () &#123;  this.jumping = true;  return true;&#125;;Jedi.prototype.setHeight = function (height) &#123;  this.height = height;&#125;;const luke = new Jedi();luke.jump();  =&gt; trueluke.setHeight(20);  =&gt; undefined goodclass Jedi &#123;  jump() &#123;    this.jumping = true;    return this;  &#125;  setHeight(height) &#123;    this.height = height;    return this;  &#125;&#125;const luke = new Jedi();luke.jump()  .setHeight(20);\n\n\n\n9.4 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 toString() 方法也是可以的。\n12345678910111213class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    this.name = options.name || no name;  &#125;  getName() &#123;    return this.name;  &#125;  toString() &#123;    return `Jedi - $&#123;this.getName()&#125;`;  &#125;&#125;\n\n\n\n9.5 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: no-useless-constructor\n1234567891011121314151617181920212223 badclass Jedi &#123;  constructor() &#123;&#125;  getName() &#123;    return this.name;  &#125;&#125; badclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125; goodclass Rey extends Jedi &#123;  constructor(...args) &#123;    super(...args);    this.name = Rey;  &#125;&#125;\n\n\n\n9.6 避免定义重复的类成员。 eslint: no-dupe-class-members\n\n为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。\n\n123456789101112131415 badclass Foo &#123;  bar() &#123; return 1; &#125;  bar() &#123; return 2; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 1; &#125;&#125; goodclass Foo &#123;  bar() &#123; return 2; &#125;&#125;\n\n\n\n⬆ 返回目录\n模块  \n\n10.1 你可能经常使用模块 (importexport) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n\n为什么? 模块是未来的趋势，让我们拥抱未来。\n\n1234567891011 badconst AirbnbStyleGuide = require(.AirbnbStyleGuide);module.exports = AirbnbStyleGuide.es6; okimport AirbnbStyleGuide from .AirbnbStyleGuide;export default AirbnbStyleGuide.es6; bestimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.2 不要使用通配符导入。\n\n为什么? 这确定你有一个单独的默认导出。\n\n12345 badimport * as AirbnbStyleGuide from .AirbnbStyleGuide; goodimport AirbnbStyleGuide from .AirbnbStyleGuide;\n\n\n\n10.3 不要直接从导入导出。\n\n为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。\n\n12345678 bad filename es6.jsexport &#123; es6 as default &#125; from .AirbnbStyleGuide; good filename es6.jsimport &#123; es6 &#125; from .AirbnbStyleGuide;export default es6;\n\n\n\n10.4 只从一个路径导入所有需要的东西。eslint: no-duplicate-imports\n\n为什么? 从同一个路径导入多个行，使代码更难以维护。\n\n12345678910111213 badimport foo from foo; … 其他导入 … import &#123; named1, named2 &#125; from foo; goodimport foo, &#123; named1, named2 &#125; from foo; goodimport foo, &#123;  named1,  named2,&#125; from foo;\n\n\n\n10.5 不要导出可变的引用。eslint: importno-mutable-exports\n\n为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。\n\n1234567 badlet foo = 3;export &#123; foo &#125;; goodconst foo = 3;export &#123; foo &#125;;\n\n\n\n10.6 在单个导出的模块中，选择默认模块而不是指定的导出。eslint: importprefer-default-export\n\n为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。\n\n12345 badexport function foo() &#123;&#125; goodexport default function foo() &#123;&#125;\n\n\n\n10.7 将所有的 imports 语句放在所有非导入语句的上边。eslint: importfirst\n\n为什么? 由于所有的 imports 都被提前，保持他们在顶部是为了防止意外发生。\n\n1234567891011 badimport foo from foo;foo.init();import bar from bar; goodimport foo from foo;import bar from bar;foo.init();\n\n\n\n10.8 多行导入应该像多行数组和对象一样缩进。\n\n为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。\n\n1234567891011 badimport &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from path; goodimport &#123;  longNameA,  longNameB,  longNameC,  longNameD,  longNameE,&#125; from path;\n\n\n\n10.9 在模块导入语句中禁止使用 Webpack 加载器语法。eslint: importno-webpack-loader-syntax\n\n为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 webpack.config.js 中使用加载器语法。\n\n1234567 badimport fooSass from css!sass!foo.scss;import barCss from style!css!bar.css; goodimport fooSass from foo.scss;import barCss from bar.css;\n\n\n\n⬆ 返回目录\n迭代器和发生器  \n\n11.1 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of。 eslint: no-iterator no-restricted-syntax\n\n为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。\n\n\n使用 map()  every()  filter()  find()  findIndex()  reduce()  some()  … 遍历数组， 和使用 Object.keys()  Object.values()  Object.entries() 迭代你的对象生成数组。\n\n12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5]; badlet sum = 0;for (let num of numbers) &#123;  sum += num;&#125;sum === 15; goodlet sum = 0;numbers.forEach((num) =&gt; &#123;  sum += num;&#125;);sum === 15; best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) &#123;  increasedByOne.push(numbers[i] + 1);&#125; goodconst increasedByOne = [];numbers.forEach((num) =&gt; &#123;  increasedByOne.push(num + 1);&#125;); best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1);\n\n\n\n11.2 不要使用发生器。\n\n为什么? They don’t transpile well to ES5.\n\n\n\n11.3 如果你必须使用发生器或者无视 我们的建议，请确保他们的函数签名是正常的间隔。 eslint: generator-star-spacing\n\n为什么? function 和 * 是同一个概念关键字的一部分 - * 不是 function 的修饰符， function* 是一个不同于 function 的构造器。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 badfunction * foo() &#123;   ...&#125; badconst bar = function * () &#123;   ...&#125;; badconst baz = function *() &#123;   ...&#125;; badconst quux = function*() &#123;   ...&#125;; badfunction*foo() &#123;   ...&#125; badfunction *foo() &#123;   ...&#125; very badfunction*foo() &#123;   ...&#125; very badconst wat = function*() &#123;   ...&#125;; goodfunction* foo() &#123;   ...&#125; goodconst foo = function* () &#123;   ...&#125;;\n\n\n\n⬆ 返回目录\n属性  \n\n12.1 访问属性时使用点符号。 eslint: dot-notation\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;; badconst isJedi = luke[jedi]; goodconst isJedi = luke.jedi;\n\n\n\n12.2 使用变量访问属性时，使用 []表示法。\n12345678910const luke = &#123;  jedi: true,  age: 28,&#125;;function getProp(prop) &#123;  return luke[prop];&#125;const isJedi = getProp(jedi);\n\n\n\n12.3 计算指数时，可以使用 ** 运算符。 eslint: no-restricted-properties.\n12345 badconst binary = Math.pow(2, 10); goodconst binary = 2 ** 10;\n\n\n\n⬆ 返回目录\n变量  \n\n13.1 使用 const 或者 let 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: no-undef prefer-const\n12345 badsuperPower = new SuperPower(); goodconst superPower = new SuperPower();\n\n\n\n13.2 使用 const 或者 let 声明每一个变量。 eslint: one-var\n\n为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 ; 还是使用 , 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。\n\n123456789101112131415 badconst items = getItems(),    goSportsTeam = true,    dragonball = z; bad (compare to above, and try to spot the mistake)const items = getItems(),    goSportsTeam = true;    dragonball = z; goodconst items = getItems();const goSportsTeam = true;const dragonball = z;\n\n\n\n13.3 把 const 声明的放在一起，把 let 声明的放在一起。.\n\n为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。\n\n123456789101112131415161718 badlet i, len, dragonball,    items = getItems(),    goSportsTeam = true; badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len; goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length;\n\n\n\n13.4 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n\n为什么? let 和 const 是块级作用域而不是函数作用域。\n\n12345678910111213141516171819202122232425262728293031 bad - 不必要的函数调用function checkName(hasName) &#123;  const name = getName();  if (hasName === test) &#123;    return false;  &#125;  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125; goodfunction checkName(hasName) &#123;  if (hasName === test) &#123;    return false;  &#125;  const name = getName();  if (name === test) &#123;    this.setName();    return false;  &#125;  return name;&#125;\n\n\n\n13.5 不要链式变量赋值。 eslint: no-multi-assign\n\n为什么? 链式变量赋值会创建隐式全局变量。\n\n123456789101112131415161718192021222324 bad(function example() &#123;   JavaScript 把它解释为   let a = ( b = ( c = 1 ) );   let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。  let a = b = c = 1;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  1console.log(c);  1 good(function example() &#123;  let a = 1;  let b = a;  let c = a;&#125;());console.log(a);  throws ReferenceErrorconsole.log(b);  throws ReferenceErrorconsole.log(c);  throws ReferenceError 对于 `const` 也一样\n\n\n\n13.6 避免使用不必要的递增和递减 (++, --)。 eslint no-plusplus\n\n为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 num += 1 这样的语句来改变您的值，而不是使用 num++ 或 num ++ 。不允许不必要的增量和减量语句也会使您无法预先递增预递减值，这也会导致程序中的意外行为。\n\n1234567891011121314151617181920212223242526 badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) &#123;  let value = array[i];  sum += value;  if (value) &#123;    truthyCount++;  &#125;&#125; goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length;\n\n\n\n\n\n13.7 避免在赋值语句 = 前后换行。如果你的代码违反了 max-len， 使用括号包裹。 eslint operator-linebreak.\n\n为什么? 在 = 前后换行，可能混淆分配的值。\n\n123456789101112131415 badconst foo =  superLongLongLongLongLongLongLongLongFunctionName(); badconst foo  = superLongLongLongLongLongLongLongLongString; goodconst foo = (  superLongLongLongLongLongLongLongLongFunctionName()); goodconst foo = superLongLongLongLongLongLongLongLongString;\n\n\n\n⬆ 返回目录\n提升  \n\n14.1 var 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。const 和 let 声明的变量受到一个称之为 Temporal Dead Zones (TDZ) 的新概念保护。 知道为什么 typeof 不在安全 是很重要的。\n1234567891011121314151617181920212223242526 我们知道这个行不通 (假设没有未定义的全局变量)function example() &#123;  console.log(notDefined);  =&gt; throws a ReferenceError&#125; 在引用变量后创建变量声明将会因变量提升而起作用。 注意: 真正的值 `true` 不会被提升。function example() &#123;  console.log(declaredButNotAssigned);  =&gt; undefined  var declaredButNotAssigned = true;&#125; 解释器将变量提升到函数的顶部 这意味着我们可以将上边的例子重写为：function example() &#123;  let declaredButNotAssigned;  console.log(declaredButNotAssigned);  =&gt; undefined  declaredButNotAssigned = true;&#125; 使用 const 和 letfunction example() &#123;  console.log(declaredButNotAssigned);  =&gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned);  =&gt; throws a ReferenceError  const declaredButNotAssigned = true;&#125;\n\n\n\n14.2 匿名函数表达式提升变量名，而不是函数赋值。\n123456789function example() &#123;  console.log(anonymous);  =&gt; undefined  anonymous();  =&gt; TypeError anonymous is not a function  var anonymous = function () &#123;    console.log(anonymous function expression);  &#125;;&#125;\n\n\n\n14.3 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n12345678910111213141516171819202122function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  superPower();  =&gt; ReferenceError superPower is not defined  var named = function superPower() &#123;    console.log(Flying);  &#125;;&#125; 当函数名和变量名相同时也是如此。function example() &#123;  console.log(named);  =&gt; undefined  named();  =&gt; TypeError named is not a function  var named = function named() &#123;    console.log(named);  &#125;;&#125;\n\n\n\n14.4 函数声明提升其名称和函数体。\n1234567function example() &#123;  superPower();  =&gt; Flying  function superPower() &#123;    console.log(Flying);  &#125;&#125;\n\n更多信息请参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。\n\n\n⬆ 返回目录\n比较运算符和等号  \n\n15.1 使用 === 和 !== 而不是 == 和 !=。 eslint: eqeqeq\n\n\n15.2 条件语句，例如 if 语句使用 ToBoolean 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：\n\nObjects 的取值为： true\nUndefined 的取值为： false\nNull 的取值为： false\nBooleans 的取值为： 布尔值的取值\nNumbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true\nStrings 的取值为: 如果是一个空字符串 &#39;&#39; 值为 false 否则为 true\n\n1234if ([0] &amp;&amp; []) &#123;   true   一个数组（既是是空的）是一个对象，对象的取值为 true&#125;\n\n\n\n15.3 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n1234567891011121314151617181920212223242526272829 badif (isValid === true) &#123;   ...&#125; goodif (isValid) &#123;   ...&#125; badif (name) &#123;   ...&#125; goodif (name !== ) &#123;   ...&#125; badif (collection.length) &#123;   ...&#125; goodif (collection.length &gt; 0) &#123;   ...&#125;\n\n\n\n15.4 获取更多信息请查看 Angus Croll 的 Truth Equality and JavaScript 。\n\n\n15.5 在 case 和 default 的子句中，如果存在声明 (例如. let, const, function, 和 class)，使用大括号来创建块 。 eslint: no-case-declarations\n\n为什么? 语法声明在整个 switch 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 case 条件达到才会发生。 当多个 case 语句定义相同的东西是，这会导致问题问题。\n\n12345678910111213141516171819202122232425262728293031323334353637383940 badswitch (foo) &#123;  case 1:    let x = 1;    break;  case 2:    const y = 2;    break;  case 3:    function f() &#123;       ...    &#125;    break;  default:    class C &#123;&#125;&#125; goodswitch (foo) &#123;  case 1: &#123;    let x = 1;    break;  &#125;  case 2: &#123;    const y = 2;    break;  &#125;  case 3: &#123;    function f() &#123;       ...    &#125;    break;  &#125;  case 4:    bar();    break;  default: &#123;    class C &#123;&#125;  &#125;&#125;\n\n\n\n15.6 三目表达式不应该嵌套，通常是单行表达式。 eslint: no-nested-ternary\n123456789101112131415 badconst foo = maybe1 &gt; maybe2  ? bar  : value1 &gt; value2 ? baz : null; 分离为两个三目表达式const maybeNull = value1 &gt; value2 ? baz : null; betterconst foo = maybe1 &gt; maybe2  ? bar  : maybeNull; bestconst foo = maybe1 &gt; maybe2 ? bar : maybeNull;\n\n\n\n15.7 避免不必要的三目表达式。 eslint: no-unneeded-ternary\n123456789 badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true; goodconst foo = a || b;const bar = !!c;const baz = !c;\n\n\n\n15.8 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (+, -, *, &amp; ) 因为他们的优先级被广泛理解。 eslint: no-mixed-operators\n\n为什么? 这能提高可读性并且表明开发人员的意图。\n\n12345678910111213141516171819202122232425 badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0; badconst bar = a ** b - 5 % d; bad 可能陷入一种 (a || b) &amp;&amp; c 的思考if (a || b &amp;&amp; c) &#123;  return d;&#125; goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0); goodconst bar = (a ** b) - (5 % d); goodif (a || (b &amp;&amp; c)) &#123;  return d;&#125; goodconst bar = a + b  c * d;\n\n\n\n⬆ 返回目录\n块  \n\n16.1 当有多行代码块的时候，使用大括号包裹。 eslint: nonblock-statement-body-position\n12345678910111213141516171819 badif (test)  return false; goodif (test) return false; goodif (test) &#123;  return false;&#125; badfunction foo() &#123; return false; &#125; goodfunction bar() &#123;  return false;&#125;\n\n\n\n16.2 如果你使用的是 if 和 else 的多行代码块，则将 else 语句放在 if 块闭括号同一行的位置。 eslint: brace-style\n12345678910111213141516 badif (test) &#123;  thing1();  thing2();&#125;else &#123;  thing3();&#125; goodif (test) &#123;  thing1();  thing2();&#125; else &#123;  thing3();&#125;\n\n\n\n16.3 如果一个 if 块总是执行一个 return 语句，那么接下来的 else 块就没有必要了。 如果一个包含 return 语句的 else if 块，在一个包含了 return 语句的 if 块之后，那么可以拆成多个 if 块。 eslint: no-else-return\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 badfunction foo() &#123;  if (x) &#123;    return x;  &#125; else &#123;    return y;  &#125;&#125; badfunction cats() &#123;  if (x) &#123;    return x;  &#125; else if (y) &#123;    return y;  &#125;&#125; badfunction dogs() &#123;  if (x) &#123;    return x;  &#125; else &#123;    if (y) &#123;      return y;    &#125;  &#125;&#125; goodfunction foo() &#123;  if (x) &#123;    return x;  &#125;  return y;&#125; goodfunction cats() &#123;  if (x) &#123;    return x;  &#125;  if (y) &#123;    return y;  &#125;&#125; goodfunction dogs(x) &#123;  if (x) &#123;    if (z) &#123;      return y;    &#125;  &#125; else &#123;    return z;  &#125;&#125;\n\n\n\n⬆ 返回目录\n控制语句  \n\n17.1 如果你的控制语句 (if, while 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n\n为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546 badif ((foo === 123 || bar === abc) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; badif (foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; badif (foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; badif (  foo === 123 &amp;&amp;  bar === abc) &#123;  thing1();&#125; goodif (  foo === 123  &amp;&amp; bar === abc) &#123;  thing1();&#125; goodif (  (foo === 123 || bar === abc)  &amp;&amp; doesItLookGoodWhenItBecomesThatLong()  &amp;&amp; isThisReallyHappening()) &#123;  thing1();&#125; goodif (foo === 123 &amp;&amp; bar === abc) &#123;  thing1();&#125;\n\n\n\n17.2 不要使用选择操作符代替控制语句。\n1234567 bad!isRunning &amp;&amp; startRunning(); goodif (!isRunning) &#123;  startRunning();&#125;\n\n\n\n⬆ 返回目录\n注释  \n\n18.1 使用 ** ... * 来进行多行注释。\n123456789101112131415161718192021222324 bad make() returns a new element based on the passed in tag name @param &#123;String&#125; tag @return &#123;Element&#125; elementfunction make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.2 使用  进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n123456789101112131415161718192021222324252627282930313233 badconst active = true;   is current tab good is current tabconst active = true; badfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; goodfunction getType() &#123;  console.log(fetching type...);   set the default type to no type  const type = this.type || no type;  return type;&#125; also goodfunction getType() &#123;   set the default type to no type  const type = this.type || no type;  return type;&#125;\n\n\n\n18.3 用一个空格开始所有的注释，使它更容易阅读。 eslint: spaced-comment\n12345678910111213141516171819202122232425262728293031 badis current tabconst active = true; good is current tabconst active = true; bad** *make() returns a new element *based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125; good** * make() returns a new element * based on the passed-in tag name *function make(tag) &#123;   ...  return element;&#125;\n\n\n\n18.4 使用 FIXME 或者 TODO 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 FIXME: -- 需要解决这个问题 或者 TODO: -- 需要被实现。\n\n\n18.5 使用  FIXME: 注释一个问题。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     FIXME: 这里不应该使用全局变量    total = 0;  &#125;&#125;\n\n\n\n18.6 使用  TODO: 注释解决问题的方法。\n12345678class Calculator extends Abacus &#123;  constructor() &#123;    super();     TODO: total 应该由一个 param 的选项配置    this.total = 0;  &#125;&#125;\n\n\n\n⬆ 返回目录\n空白  \n\n19.1 使用 tabs (空格字符) 设置为 2 个空格。 eslint: indent\n1234567891011121314 badfunction foo() &#123;∙∙∙∙let name;&#125; badfunction bar() &#123;∙let name;&#125; goodfunction baz() &#123;∙∙let name;&#125;\n\n\n\n19.2 在主体前放置一个空格。 eslint: space-before-blocks\n123456789101112131415161718192021 badfunction test()&#123;  console.log(test);&#125; goodfunction test() &#123;  console.log(test);&#125; baddog.set(attr,&#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;); gooddog.set(attr, &#123;  age: 1 year,  breed: Bernese Mountain Dog,&#125;);\n\n\n\n19.3 在控制语句（if, while 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: keyword-spacing\n12345678910111213141516171819 badif(isJedi) &#123;  fight ();&#125; goodif (isJedi) &#123;  fight();&#125; badfunction fight () &#123;  console.log (Swooosh!);&#125; goodfunction fight() &#123;  console.log(Swooosh!);&#125;\n\n\n\n19.4 用空格分离操作符。 eslint: space-infix-ops\n12345 badconst x=y+5; goodconst x = y + 5;\n\n\n\n19.5 使用单个换行符结束文件。 eslint: eol-last\n1234 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;\n\n12345 badimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵↵\n\n1234 goodimport &#123; es6 &#125; from .AirbnbStyleGuide;   ...export default es6;↵\n\n\n\n19.6 在使用长方法连滴啊用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: newline-per-chained-call no-whitespace-before-property\n12345678910111213141516171819202122232425262728293031323334353637 bad$(#items).find(.selected).highlight().end().find(.open).updateCount(); bad$(#items).  find(.selected).    highlight().    end().  find(.open).    updateCount(); good$(#items)  .find(.selected)    .highlight()    .end()  .find(.open)    .updateCount(); badconst leds = stage.selectAll(.led).data(data).enter().append(svg:svg).classed(led, true)    .attr(width, (radius + margin) * 2).append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led)    .data(data)  .enter().append(svg:svg)    .classed(led, true)    .attr(width, (radius + margin) * 2)  .append(svg:g)    .attr(transform, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)    .call(tron.led); goodconst leds = stage.selectAll(.led).data(data);\n\n\n\n19.7 在块和下一个语句之前留下一空白行。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 badif (foo) &#123;  return bar;&#125;return baz; goodif (foo) &#123;  return bar;&#125;return baz; badconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; goodconst obj = &#123;  foo() &#123;  &#125;,  bar() &#123;  &#125;,&#125;;return obj; badconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr; goodconst arr = [  function foo() &#123;  &#125;,  function bar() &#123;  &#125;,];return arr;\n\n\n\n19.8 不要在块的开头使用空白行。 eslint: padded-blocks\n1234567891011121314151617181920212223242526272829303132333435 badfunction bar() &#123;  console.log(foo);&#125; badif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125; badclass Foo &#123;  constructor(bar) &#123;    this.bar = bar;  &#125;&#125; goodfunction bar() &#123;  console.log(foo);&#125; goodif (baz) &#123;  console.log(qux);&#125; else &#123;  console.log(foo);&#125;\n\n\n\n19.9 不要在括号内添加空格。 eslint: space-in-parens\n12345678910111213141516171819 badfunction bar( foo ) &#123;  return foo;&#125; goodfunction bar(foo) &#123;  return foo;&#125; badif ( foo ) &#123;  console.log(foo);&#125; goodif (foo) &#123;  console.log(foo);&#125;\n\n\n\n19.10 不要在中括号中添加空格。 eslint: array-bracket-spacing\n1234567 badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]); goodconst foo = [1, 2, 3];console.log(foo[0]);\n\n\n\n19.11 在花括号内添加空格。 eslint: object-curly-spacing\n12345 badconst foo = &#123;clark: kent&#125;; goodconst foo = &#123; clark: kent &#125;;\n\n\n\n19.12 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 约束，长字符串可免除此规定，不应分解。 eslint: max-len\n\n为什么? 这样能够确保可读性和可维护性。\n\n12345678910111213141516171819202122 badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; bad$.ajax(&#123; method: POST, url: https:airbnb.com, data: &#123; name: John &#125; &#125;).done(() =&gt; console.log(Congratulations!)).fail(() =&gt; console.log(You have failed this city.)); goodconst foo = jsonData  &amp;&amp; jsonData.foo  &amp;&amp; jsonData.foo.bar  &amp;&amp; jsonData.foo.bar.baz  &amp;&amp; jsonData.foo.bar.baz.quux  &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; good$.ajax(&#123;  method: POST,  url: https:airbnb.com,  data: &#123; name: John &#125;,&#125;)  .done(() =&gt; console.log(Congratulations!))  .fail(() =&gt; console.log(You have failed this city.));\n\n\n\n19.13 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: block-spacing\n1234567 badfunction foo() &#123;return true;&#125;if (foo) &#123; bar = 0;&#125; goodfunction foo() &#123; return true; &#125;if (foo) &#123; bar = 0; &#125;\n\n\n\n19.14 逗号之前避免使用空格，逗号之后需要使用空格。eslint: comma-spacing\n1234567 badvar foo = 1,bar = 2;var arr = [1 , 2]; goodvar foo = 1, bar = 2;var arr = [1, 2];\n\n\n\n19.15 在计算属性之间强化间距。eslint: computed-property-spacing\n1234567891011 badobj[foo ]obj[ foo]var x = &#123;[ b ]: a&#125;obj[foo[ bar ]] goodobj[foo]obj[foo]var x = &#123; [b]: a &#125;obj[foo[bar]]\n\n\n\n19.16 在函数和它的调用之间强化间距。 eslint: func-call-spacing\n12345678 badfunc ();func(); goodfunc();\n\n\n\n19.17 在对象的属性和值之间强化间距。 eslint: key-spacing\n123456 badvar obj = &#123; foo : 42 &#125;;var obj2 = &#123; foo:42 &#125;; goodvar obj = &#123; foo: 42 &#125;;\n\n\n\n19.18 在行的末尾避免使用空格。 eslint: no-trailing-spaces\n\n\n19.19 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: no-multiple-empty-lines\n\n1234567891011 badvar x = 1;var y = 2; goodvar x = 1;var y = 2;\n\n\n\n\n\n⬆ 返回目录\n逗号  \n\n20.1 逗号前置： 不行 eslint: comma-style\n1234567891011121314151617181920212223242526272829 badconst story = [    once  , upon  , aTime]; goodconst story = [  once,  upon,  aTime,]; badconst hero = &#123;    firstName: Ada  , lastName: Lovelace  , birthYear: 1815  , superPower: computers&#125;; goodconst hero = &#123;  firstName: Ada,  lastName: Lovelace,  birthYear: 1815,  superPower: computers,&#125;;\n\n\n\n20.2 添加尾随逗号： 可以 eslint: comma-dangle\n\n为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 尾随逗号问题 。\n\n1234567891011121314 bad - 没有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,-    lastName: Nightingale+    lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing]&#125;; good - 有尾随逗号的 git 差异const hero = &#123;     firstName: Florence,     lastName: Nightingale,+    inventorOf: [coxcomb chart, modern nursing],&#125;;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 badconst hero = &#123;  firstName: Dana,  lastName: Scully&#125;;const heroes = [  Batman,  Superman]; goodconst hero = &#123;  firstName: Dana,  lastName: Scully,&#125;;const heroes = [  Batman,  Superman,]; badfunction createHero(  firstName,  lastName,  inventorOf) &#123;   does nothing&#125; goodfunction createHero(  firstName,  lastName,  inventorOf,) &#123;   does nothing&#125; good (注意逗号不能出现在 rest 元素后边)function createHero(  firstName,  lastName,  inventorOf,  ...heroArgs) &#123;   does nothing&#125; badcreateHero(  firstName,  lastName,  inventorOf); goodcreateHero(  firstName,  lastName,  inventorOf,); good (注意逗号不能出现在 rest 元素后边)createHero(  firstName,  lastName,  inventorOf,  ...heroArgs);\n\n\n\n⬆ 返回目录\n分号  \n\n21.1 对 eslint: semi\n\n为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 Automatic Semicolon Insertion 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。\n\n123456789101112131415161718192021222324252627282930313233343536 bad - 可能异常const luke = &#123;&#125;const leia = &#123;&#125;[luke, leia].forEach(jedi =&gt; jedi.father = vader) bad - 可能异常const reaction = No! Thats impossible!(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()) bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生function foo() &#123;  return    search your feelings, you know it to be foo&#125; goodconst luke = &#123;&#125;;const leia = &#123;&#125;;[luke, leia].forEach((jedi) =&gt; &#123;  jedi.father = vader;&#125;); goodconst reaction = No! Thats impossible!;(async function meanwhileOnTheFalcon() &#123;   handle `leia`, `lando`, `chewie`, `r2`, `c3p0`   ...&#125;()); goodfunction foo() &#123;  return search your feelings, you know it to be foo;&#125;\n\n更多信息.\n\n\n⬆ 返回目录\n类型转换和强制类型转换  \n\n22.1 在语句开始前进行类型转换。\n\n\n22.2  字符类型： eslint: no-new-wrappers\n12345678910111213 =&gt; this.reviewScore = 9; badconst totalScore = new String(this.reviewScore);  typeof totalScore is object not string badconst totalScore = this.reviewScore + ;  invokes this.reviewScore.valueOf() badconst totalScore = this.reviewScore.toString();  isn’t guaranteed to return a string goodconst totalScore = String(this.reviewScore);\n\n\n\n22.3 数字类型：使用 Number 进行类型铸造和 parseInt 总是通过一个基数来解析一个字符串。 eslint: radix no-new-wrappers\n12345678910111213141516171819const inputValue = 4; badconst val = new Number(inputValue); badconst val = +inputValue; badconst val = inputValue &gt;&gt; 0; badconst val = parseInt(inputValue); goodconst val = Number(inputValue); goodconst val = parseInt(inputValue, 10);\n\n\n\n22.4 如果出于某种原因，你正在做一些疯狂的事情，而 parseInt 是你的瓶颈，并且出于 性能问题 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n123456 good** * parseInt 使我的代码变慢。 * 位运算将一个字符串转换成数字更快。 *const val = inputValue &gt;&gt; 0;\n\n\n\n22.5 注意： 当你使用位运算的时候要小心。 数字总是被以 64-bit 值 的形式表示，但是位运算总是返回一个 32-bit 的整数 (来源)。 对于大于 32 位的整数值，位运算可能会导致意外行为。讨论。 最大的 32 位整数是： 2,147,483,647。\n1232147483647 &gt;&gt; 0;  =&gt; 21474836472147483648 &gt;&gt; 0;  =&gt; -21474836482147483649 &gt;&gt; 0;  =&gt; -2147483647\n\n\n\n22.6 布尔类型： eslint: no-new-wrappers\n12345678910const age = 0; badconst hasAge = new Boolean(age); goodconst hasAge = Boolean(age); bestconst hasAge = !!age;\n\n\n\n⬆ 返回目录\n命名规范  \n\n23.1 避免单字母的名字。用你的命名来描述功能。 eslint: id-length\n123456789 badfunction q() &#123;   ...&#125; goodfunction query() &#123;   ...&#125;\n\n\n\n23.2 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: camelcase\n12345678 badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125; goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;\n\n\n\n23.3 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: new-cap\n12345678910111213141516171819 badfunction user(options) &#123;  this.name = options.name;&#125;const bad = new user(&#123;  name: nope,&#125;); goodclass User &#123;  constructor(options) &#123;    this.name = options.name;  &#125;&#125;const good = new User(&#123;  name: yup,&#125;);\n\n\n\n23.4 不要使用前置或者后置下划线。 eslint: no-underscore-dangle\n\n为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。\n\n123456789101112 badthis.__firstName__ = Panda;this.firstName_ = Panda;this._firstName = Panda; goodthis.firstName = Panda; 好，在 WeakMapx 可用的环境中 see https:kangax.github.iocompat-tablees6#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, Panda);\n\n\n\n23.5 不要保存 this 的引用。 使用箭头函数或者 函数#bind。\n12345678910111213141516171819202122 badfunction foo() &#123;  const self = this;  return function () &#123;    console.log(self);  &#125;;&#125; badfunction foo() &#123;  const that = this;  return function () &#123;    console.log(that);  &#125;;&#125; goodfunction foo() &#123;  return () =&gt; &#123;    console.log(this);  &#125;;&#125;\n\n\n\n23.6 文件名应该和默认导出的名称完全匹配。\n123456789101112131415161718192021222324252627282930 file 1 contentsclass CheckBox &#123;   ...&#125;export default CheckBox; file 2 contentsexport default function fortyTwo() &#123; return 42; &#125; file 3 contentsexport default function insideDirectory() &#123;&#125; in some other file badimport CheckBox from .checkBox;  PascalCase importexport, camelCase filenameimport FortyTwo from .FortyTwo;  PascalCase importfilename, camelCase exportimport InsideDirectory from .InsideDirectory;  PascalCase importfilename, camelCase export badimport CheckBox from .check_box;  PascalCase importexport, snake_case filenameimport forty_two from .forty_two;  snake_case importfilename, camelCase exportimport inside_directory from .inside_directory;  snake_case import, camelCase exportimport index from .inside_directoryindex;  requiring the index file explicitlyimport insideDirectory from .insideDirectoryindex;  requiring the index file explicitly goodimport CheckBox from .CheckBox;  PascalCase exportimportfilenameimport fortyTwo from .fortyTwo;  camelCase exportimportfilenameimport insideDirectory from .insideDirectory;  camelCase exportimportdirectory nameimplicit index ^ supports both insideDirectory.js and insideDirectoryindex.js\n\n\n\n23.7 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n12345function makeStyleGuide() &#123;   ...&#125;export default makeStyleGuide;\n\n\n\n23.8 当你导出一个构造器  类  单例  函数库  暴露的对象时应该使用帕斯卡命名法。\n123456const AirbnbStyleGuide = &#123;  es6: &#123;  &#125;,&#125;;export default AirbnbStyleGuide;\n\n\n\n23.9 缩略词和缩写都必须是全部大写或者全部小写。\n\n为什么? 名字是为了可读性，不是为了满足计算机算法。\n\n12345678910111213141516171819202122232425262728 badimport SmsContainer from .containersSmsContainer; badconst HttpRequests = [   ...]; goodimport SMSContainer from .containersSMSContainer; goodconst HTTPRequests = [   ...]; also goodconst httpRequests = [   ...]; bestimport TextMessageContainer from .containersTextMessageContainer; bestconst requests = [   ...];\n\n\n\n23.10 你可以大写一个常亮，如果它：（1）被导出，（2）使用 const 定义（不能被重新分配），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n\n为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。\n\n是否是对所有的 const 定义的变量？ - 这个是没哟必要的，不应该在文件中使用大学。但是，它应该用于导出常量。\n导出对象呢？ - 在顶级导出属性 (e.g. EXPORTED_OBJECT.key) 并且保持所有嵌套属性不变。\n\n\n12345678910111213141516171819202122232425262728 badconst PRIVATE_VARIABLE = should not be unnecessarily uppercased within a file; badexport const THING_TO_BE_CHANGED = should obviously not be uppercased; badexport let REASSIGNABLE_VARIABLE = do not use let with uppercase variables; --- 允许，但是不提供语义值export const apiKey = SOMEKEY; 多数情况下，很好export const API_KEY = SOMEKEY; --- bad - 不必要大写 key 没有增加语义值export const MAPPING = &#123;  KEY: value&#125;; goodexport const MAPPING = &#123;  key: value&#125;;\n\n\n\n⬆ 返回目录\n存取器  \n\n24.1 对于属性的的存取函数不是必须的。\n\n\n24.2 不要使用 JavaScript 的 getterssetters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 getVal() 和 setVal(&#39;hello&#39;)。\n123456789101112131415161718192021 badclass Dragon &#123;  get age() &#123;     ...  &#125;  set age(value) &#123;     ...  &#125;&#125; goodclass Dragon &#123;  getAge() &#123;     ...  &#125;  setAge(value) &#123;     ...  &#125;&#125;\n\n\n\n24.3 如果属性方法是一个 boolean 值，使用 isVal() 或者 hasVal()。\n123456789 badif (!dragon.age()) &#123;  return false;&#125; goodif (!dragon.hasAge()) &#123;  return false;&#125;\n\n\n\n24.4 可以创建 get() 和 set() 方法，但是要保证一致性。\n1234567891011121314class Jedi &#123;  constructor(options = &#123;&#125;) &#123;    const lightsaber = options.lightsaber || blue;    this.set(lightsaber, lightsaber);  &#125;  set(key, val) &#123;    this[key] = val;  &#125;  get(key) &#123;    return this[key];  &#125;&#125;\n\n\n\n⬆ 返回目录\n事件  \n\n25.1 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n12345678 bad$(this).trigger(listingUpdated, listing.id); ...$(this).on(listingUpdated, (e, listingID) =&gt; &#123;   do something with listingID&#125;);\n\n更好的写法：\n12345678 good$(this).trigger(listingUpdated, &#123; listingID: listing.id &#125;); ...$(this).on(listingUpdated, (e, data) =&gt; &#123;   do something with data.listingID&#125;);\n\n\n  ⬆ 返回目录\njQuery  \n\n26.1 对于 jQuery 对象的变量使用 $ 作为前缀。\n12345678 badconst sidebar = $(.sidebar); goodconst $sidebar = $(.sidebar); goodconst $sidebarBtn = $(.sidebar-btn);\n\n\n\n26.2 缓存 jQuery 查询。\n12345678910111213141516171819202122 badfunction setSidebar() &#123;  $(.sidebar).hide();   ...  $(.sidebar).css(&#123;    background-color: pink,  &#125;);&#125; goodfunction setSidebar() &#123;  const $sidebar = $(.sidebar);  $sidebar.hide();   ...  $sidebar.css(&#123;    background-color: pink,  &#125;);&#125;\n\n\n\n26.3 对于 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;) 的格式。 jsPerf\n\n\n26.4 对于有作用域的 jQuery 对象查询使用 find 。\n1234567891011121314 bad$(ul, .sidebar).hide(); bad$(.sidebar).find(ul).hide(); good$(.sidebar ul).hide(); good$(.sidebar &gt; ul).hide(); good$sidebar.find(ul).hide();\n\n\n\n⬆ 返回目录\nECMAScript 5 兼容性  \n\n27.1 参考 Kangax的 ES5 兼容性表格。\n\n⬆ 返回目录\n\nECMAScript 6+ (ES 2015+) Styles  \n\n28.1 这是一个链接到各种 ES6+ 特性的集合。\n\n\n箭头函数\n\n类\n\n对象简写\n\n对象简洁\n\n对象计算属性\n\n字符串模板\n\n解构\n\n默认参数\n\nRest\n\n数组展开\n\nLet 和 Const\n\n求幂运算符\n\n迭代器和发生器\n\n模块\n\n\n28.2 不要使用尚未达到第3阶段的 TC39 建议。\n\n为什么? 它们没有最终确定， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。\n\n\n\n\n\n⬆ 返回目录\n标准库  标准库  包含功能已损坏的实用工具，但因为遗留原因而保留。\n  \n\n29.1 使用 Number.isNaN 代替全局的 isNaN.eslint: no-restricted-globals\n\n为什么? 全局的 isNaN 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n1234567 badisNaN(1.2);  falseisNaN(1.2.3);  true goodNumber.isNaN(1.2.3);  falseNumber.isNaN(Number(1.2.3));  true\n\n\n\n29.2 使用 Number.isFinite 代替全局的 isFinite.eslint: no-restricted-globals\n\n为什么? 全局的 isFinite 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。\n\n\n如果需要这种行为，请明确说明。\n\n123456 badisFinite(2e3);  true goodNumber.isFinite(2e3);  falseNumber.isFinite(parseInt(2e3, 10));  true\n\n\n\n⬆ 返回目录\nTesting  \n\n30.1 是的.\n123function foo() &#123;  return true;&#125;\n\n\n\n30.2 没有，但是认真:\n\n无论你使用那种测试框架，都应该编写测试！\n努力写出许多小的纯函数，并尽量减少发生错误的地方。\n对于静态方法和 mock 要小心—-它们会使你的测试更加脆弱。\n我们主要在 Airbnb 上使用 mocha 和 jest 。 tape 也会用在一些小的独立模块上。\n100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。\n无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。\n\n\n\n⬆ 返回目录\n性能\nOn Layout &amp; Web Performance\nString vs Array Concat\nTryCatch Cost In a Loop\nBang Function\njQuery Find vs Context, Selector\ninnerHTML vs textContent for script text\nLong String Concatenation\nAre Javascript functions like map(), reduce(), and filter() optimized for traversing arrays?\nLoading…\n\n⬆ 返回目录\n资源学习 ES6+\n\nLatest ECMA spec\nExploringJS\nES6 Compatibility Table\nComprehensive Overview of ES6 Features\n\n读这个\n\nStandard ECMA-262\n\n工具\n\nCode Style Linters\nESlint - Airbnb Style .eslintrc\nJSHint - Airbnb Style .jshintrc\n\n\nNeutrino preset - neutrino-preset-airbnb-base\n\n其他编码规范\n\nGoogle JavaScript Style Guide\njQuery Core Style Guidelines\nPrinciples of Writing Consistent, Idiomatic JavaScript\nStandardJS\n\n其他风格\n\nNaming this in nested functions - Christian Johansen\nConditional Callbacks - Ross Allen\nPopular JavaScript Coding Conventions on GitHub - JeongHoon Byun\nMultiple var statements in JavaScript, not superfluous - Ben Alman\n\n进一步阅读\n\nUnderstanding JavaScript Closures - Angus Croll\nBasic JavaScript for the impatient programmer - Dr. Axel Rauschmayer\nYou Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz\nES6 Features - Luke Hoban\nFrontend Guidelines - Benjamin De Cock\n\n书籍\n\nJavaScript: The Good Parts - Douglas Crockford\nJavaScript Patterns - Stoyan Stefanov\nPro JavaScript Design Patterns  - Ross Harmes and Dustin Diaz\nHigh Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders\nMaintainable JavaScript - Nicholas C. Zakas\nJavaScript Web Applications - Alex MacCaw\nPro JavaScript Techniques - John Resig\nSmashing Node.js: JavaScript Everywhere - Guillermo Rauch\nSecrets of the JavaScript Ninja - John Resig and Bear Bibeault\nHuman JavaScript - Henrik Joreteg\nSuperhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy\nJSBooks - Julien Bouquillon\nThird Party JavaScript - Ben Vinegar and Anton Kovalyov\nEffective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman\nEloquent JavaScript - Marijn Haverbeke\nYou Don’t Know JS: ES6 &amp; Beyond - Kyle Simpson\n\n博客\n\nJavaScript Weekly\nJavaScript, JavaScript…\nBocoup Weblog\nAdequately Good\nNCZOnline\nPerfection Kills\nBen Alman\nDmitry Baranovskiy\nnettuts\n\n播客\n\nJavaScript Air\nJavaScript Jabber\n\n⬆ 返回目录\nJavaScript风格指南的指南\nReference\n\n许可证(The MIT License)\nCopyright (c) 2012 康兵奎\nPermission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, andor sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:\nThe above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n⬆ 返回目录\n修正案我们鼓励您使用此指南并更改规则以适应您的团队的风格指南。下面，你可以列出一些对风格指南的修正。这允许您定期更新您的样式指南，而不必处理合并冲突。\n};","tags":["javascript"],"path":"2019/09/08/Airbnb-JavaScript-代码规范/","external_link":""},{"title":"骨传导","date":"2019-09-12T11:49:16.000Z","content":"骨传导\n骨传导是一种声音传导方式，即通过将声音转化为不同频率的机械振动，通过人的颅骨、骨迷路、内耳淋巴液传递、螺旋器、听神经、听觉中枢来传递声波。相对于通过振膜产生声波的经典声音传导方式，骨传导省去了许多声波传递的步骤，能在嘈杂的环境中实现清晰的声音还原，而且声波也不会因为在空气中扩散而影响到他人。\n骨传导技术分为骨传导扬声器技术和骨传导麦克风技术：\n\n骨传导扬声器技术 用于受话，受话即听取声音。气导扬声器是把电信号转化为的声波（振动信号传至听神经。而骨传导扬声器则是电信号转化的声波（振动信号）直接通过骨头传至听神经。声波（振动信号）的传递介质不同。\n骨传导麦克风技术 用于送话，送话即收集声音。气导送话是声波通过空气传至麦克风，而骨传导送话则直接通过骨头传递。\n\n利用这些骨传导技术制造的耳机，称之为骨传导耳机，也被称作骨导耳机、骨感耳机、骨传耳机和骨传感耳机。\n原文链接\n","tags":["百科"],"path":"2019/09/12/骨传导/","external_link":""},{"title":"nohup:在linux后台运行程序","date":"2019-09-12T13:15:04.000Z","content":"\nnohup:在linux后台运行程序今天在工作中，lz要在Linux系统上运行一个java程序，这个程序要在系统中持续运行。随后lz无意将ssh窗口关掉了，发现java程序停止了。原来，当使用ssh连接到系统运行程序的时候，该程序已经和你的ssh连接绑定了。如果你关闭连接，该程序就会停止。还有一个情景：如果要在后台运行多个java程序的时候，就需要启动多个ssh窗口，这样很麻烦。有没有方法来解决这个问题呢？答案是肯定的。\n1.使用nohup来执行命令，它会把命令自动调到linux后台运行，不锁定当前ssh窗口，也不会被ctrl + c，alt + F4之类打断程序的动行。\n1nohup java -jar test.jar &amp;\n\n执行完该命令后，终端会显示如下信息：\n12[1] 27945nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;\n\n[1]：该后台任务的jobid27945：是该进程的pidnohup.out：是该任务的输出位置\n2.要指定重定向的文件，如下：\n1nohup java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp;\n\n3.如果一个任务已经在前台执行，那就使用以下方法来将任务调整到后台：\n（1）首先，在正在执行任务的终端使用ctrl+z\n1[1]+  已停止               java -jar test.jar\n\n（2）使用bg命令将该任务调整至后台（fg与之相反，将后台任务调整至前台）\n1bg %1(1是jobid)\n\n如果不知道jobid，也可以使用jobs命令来查询。\n但是任务的输出还是会打印到终端上的（具体怎么将输出重定向到别的地方，lz也不造）。而且，这时该任务还是与当前终端相关联的，关闭终端还是会断掉该任务的。使用下面命令来解决：\n1disown -h %1\n\n这样再也不用担心关掉终端会停止掉任务喽！！！\nPS：再来说说nohup吧。nohup的意思是no hang up，就是说关掉终端是不会挂掉程序的。如果开始执行命令时只使用&amp;：\n1java -jar test.jar &amp;\n\n那么该任务也会在后台执行，但是一旦关掉终端该任务还是会挂掉，所以这就是nohup的用处了。\n原文链接\n","tags":["linux","nohup"],"path":"2019/09/12/nohup-在linux后台运行程序/","external_link":""},{"title":"TensorFlow 2.0 RC is available","date":"2019-09-12T13:41:44.000Z","content":"\nTensorFlow 2.0 RC工具探索可支持和加速 TensorFlow 工作流程的工具。\n\nCoLabColaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您只需点击一下鼠标，即可在浏览器中执行 TensorFlow 代码。\nTensorBoard一套可视化工具，用于理解、调试和优化TensorFlow程序。\nWhat-If工具一种无代码的方式探究机器学习模型的工具，对模型的理解、调试和公平性很有用。可在TensorFlow和Jupyter或CoLab笔记本中使用。\nML Perf全面的机器学习基准测试套件，用于衡量机器学习软件框架、机器学习硬件加速器和机器学习云端平台的性能。\nXLAXLA(加速线性代数)是一种特定领域的线性代数编译器，能够优化TensorFlow计算，它可以提高服务器和移动平台的运行速度改进内存使用情况和可移植性。\nTensorFlow Playground在浏览器中设计神经网络。别担心，不会使浏览器崩溃。\nTensorFlow Research Cloud加入TensorFlow Research Cloud（TFRC）计划后，研究人员可于申请访问Cloud TPU来加快实现下一波研究突破；我们免费提供1000个Cloud TPU.\n","tags":["TensorFlow","机器学习"],"path":"2019/09/12/TensorFlow-2-0-RC-is-available/","external_link":""},{"title":"Java面试题","date":"2019-09-13T07:57:44.000Z","content":"基础与框架String类能被继承吗，为什么?\n不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。\n\n1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence\n\n根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。　　final类不能被继承，没有子类，final类中的方法默认是final的。　　final方法不能被子类的方法覆盖，但可以被继承。　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。　　final不能用于修饰构造方法。　　注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。\n如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。　　使用final方法的原因有二：　　第一、把方法锁定，防止任何继承类修改它的意义和实现。　　第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑）\n\n下面这段话摘自《Java编程思想》第四版第143页：“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。”\n\n关于String类，要了解常量池的概念\n1String s = new String(“xyz”);  创建了几个对象\n\n答案： 1个或2个， 如果”xyz”已经存在于常量池中，则只在堆中创建”xyz”对象的一个拷贝，否则还要在常量池中在创建一份\n1String s = a+b+c+d; 创建了几个对象\n\n答案： 这个和JVM实现有关， 如果常量池为空，可能是1个也可能是7个等\nString，Stringbuffer，StringBuilder的区别？1、用来处理字符串常用的类有3种：String、StringBuffer和StringBuilder2、三者之间的区别：都是final类，都不允许被继承；String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；StringBuffer类是线程安全的，StringBuilder不是线程安全的；\nString 和 StringBuffer：1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；\n2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；\n3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如：\n12String s1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);\n\n生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：\n12345Java Compiler直接把上述第一条语句编译为：String s2 = “This is only a”;String s3 = “ simple”;String s4 = “ test”;String s1 = s2 + s3 + s4;\n\n传送门\nArrayList和LinkedList有什么区别ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。\n数据的更新和查找ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻\n数据的增加和删除对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。\n传送门\n类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序\n此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量（父类实例成员变量）、父类构造函数、子类非静态变量（子类实例成员变量）、子类构造函数。 \n\n传送门\n用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等\nHashtable,HashMap,ConcurrentHashMap\n\n线程不安全的HashMap因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。\nHashMapHashMap内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。其中每个结点存储的是一个键值对整体（Entry），HashMap采用拉链法解决哈希冲突\n传送门\n效率低下的HashTable容器     HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。\nConcurrentHashMap的锁分段技术     HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n传送门\n\nhashcode() 方法，在object类中定义如下：\n\n1public native int hashCode();\n\nnative说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double。。。。等等这些类都是覆盖了hashcode()方法的例如String类中:就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。(为什么取31?主要是因为31是一个奇质数，所以31i=32i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多).\n123456789101112public int hashCode() &#123;    int h = hash;    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;        char val[] = value;        for (int i = 0; i &lt; value.length; i++) &#123;            h = 31 * h + val[i];        &#125;        hash = h;    &#125;    return h;&#125;\n\nHashMap为什么get和set那么快，concurrentHashMap为什么能提高并发\nHashMap 底层是基于 数组 + 链表 组成的\n\n传送门\n抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\n实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。抽象类和接口的区别\n\n\n由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。\n\n\n接口可以继承多个接口。java类是单继承的。classB Extends classAjava接口可以多继承。Interface3 Extends Interface0, Interface1, interface……不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。\n\n什么情况下会发生栈内存溢出方法递归调用产生这种结果\n\n栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）\n\n所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。栈溢出(StackOverflowError)\n什么是nio，原理\nNIO是为了弥补传统IO工作模式的不足而研发的，NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型IO能力。\n\nNIO的工作原理是什么？\n　　在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞IO的通信方式，不要求阻塞等待IO操作完成即可返回，从而减少了管理IO连接导致的系统开销，大幅度提高了系统性能。\n　　当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络IO中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络IO无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。\n　　并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络IO设计的并发型服务器程序与以往基于阻塞IO的实现程序有很大不同，在使用非阻塞网络IO的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。\n　　使用非阻塞型IO进行并发型服务器程序设计分三个部分：1. 向Selector对象注册感兴趣的事件；2.从Selector中获取所感兴趣的事件；3. 根据不同的事件进行相应的处理。\n　　在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展。\n传送门\n反射中，Class.forName和ClassLoader区别Java中Class.forName和classloader都可以用来对类进行加载。\n\nClass.forName(“className”);\n其实这种方法调运的是：Class.forName(className, true, ClassLoader.getCallerClassLoader())方法\n参数一：className，需要加载的类的名称。\n参数二：true，是否对class进行初始化（需要initialize）\n参数三：classLoader，对应的类加载器\nClassLoader.laodClass(“className”);\n其实这种方法调运的是：ClassLoader.loadClass(name, false)方法\n参数一：name,需要加载的类的名称\n参数二：false，这个类加载以后是否需要去连接（不需要linking）\n\n可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。\n而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。\n传送门\ntomcat结构，类加载器流程\nTomcat 的总体结构\n\n\n从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。\n什么是类加载器？虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。\n传送门\n讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式Spring的beanFactory和factoryBean的区别Spring加载流程Spring如何管理事务的多线程线城池的最大线程数目根据什么确定多线程的几种实现方式，什么是线程安全，什么是重排序volatile的原理，作用，能代替锁么sleep和wait的区别，以及wait的实现原理Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁用过哪些原子类，他们的参数以及原理是什么用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。spring的controller是单例还是多例，怎么保证并发的安全用三个线程按顺序循环打印abc三个字母，比如abcabcabcThreadLocal用过么，原理是什么，用的时候要注意什么如果让你实现一个并发安全的链表，你会怎么做JVM相关jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms当出现了内存溢出，你怎么排错JVM内存模型的相关知识了解多少简单说说你了解的类加载器JAVA的反射机制网络http1.0和http1.1有什么区别TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么TIME_WAIT和CLOSE_WAIT的区别说说你知道的几种HTTP响应码当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤Linux下IO模型有几种，各自的含义是什么TCPIP如何保证可靠性，数据包有哪些数据组成架构设计与分布式：tomcat如何调优，各种参数的意义常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等如何防止缓存雪崩12.用java自己实现一个LRU分布式集群下如何做到唯一序列号设计一个秒杀系统，30分钟没付款就自动关闭交易如何做一个分布式锁用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗MQ系统的数据如何保证不丢失分布式事务的原理，如何使用分布式事务什么是一致性hash什么是restful，讲讲你理解的restful如何设计建立和保持100w的长连接？解释什么是MESI协议(缓存一致性)说说你知道的几种HASH算法，简单的也可以什么是paxos算法redis和memcached 的内存管理的区别一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新算法10亿个数字里里面找最小的10个有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优2亿个随机生成的无序整数,找出中间大小的值遍历二叉树数据库数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁MYsql的索引实现方式聚集索引和非聚集索引的区别数据库中 BTREE和B+tree区别","tags":["面试","Java"],"path":"2019/09/13/Java面试题/","external_link":""},{"title":"OpenCV边缘检测","date":"2019-09-14T06:04:05.000Z","content":"OpenCV边缘检测\n12345678910111213import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(1024.jpg,0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap=gray)plt.title(original),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap=gray)plt.title(edge),plt.xticks([]),plt.yticks([])plt.show()\n\n","tags":["OpenCV","边缘检测"],"path":"2019/09/14/OpenCV边缘检测/","external_link":""},{"title":"2019年度机器学习49个顶级工程汇总","date":"2019-09-16T01:56:47.000Z","content":"2019年度机器学习49个顶级工程汇总\n过去一年中，我们比较了近22000个机器学习开源工程，并筛选了49个顶级项目（筛选率0.22%）。\n\n其中包括以下6个分类\n\n计算机视觉（1~5）\n强化学习（6~13）\nNLP（14~20）\nGAN（21~26）\nNeural Network（27~35）\nToolkit（36~49）\n\n\n我们花了很大的精力筛选这个list，并小心的选择出2018年1月到12月间最好的工程。为了保证名单质量，Mybridge AI协同考虑了流行度、参与度、发布时间等多重因素。\n\n计算机视觉1、Detectron：facebook发布的目标检测工具【18913 star on Github】项目地址：https:github.comfacebookresearchDetectron?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n2、Openpost：多人实时特征点检测工具【11052 stars on GitHub】项目地址：https:github.comCMU-Perceptual-Computing-Labopenpose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n3、DensePost：2维人体图片转3维的实时映射方法。【4165 stars on Github】项目地址：https:github.comfacebookresearchDensepose?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n4、Maskrcnn-benchmark：（Pytorch）语义分割与目标检测工具包。【3888 stars on Github】项目地址：https:github.comfacebookresearchmaskrcnn-benchmark?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n5、SNIPER：多尺度目标检测算法。【1963 stars on Github】项目地址：https:github.commahyarnajibiSNIPER?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n强化学习6、Psychlab：Psychlab实验范例。【5595 stars on Github】项目地址：https:github.comdeepmindlabtreemastergame_scriptslevelscontributedpsychlab?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n\n7、ELF：一个灵活、轻量、可扩展的游戏研究平台。【2406 stars on Github】项目地址：https:github.compytorchelf?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n8、TRFL：（TensorFlow）强化学习agent工具包。【2312 stars on Github】项目地址：https:github.comdeepmindtrfl?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n9、Horizon：首个用于大规模需求的开源强化学习平台。【1703 stars on Github】项目地址：https:github.comfacebookresearchHorizon?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n10、Chess-alpha-zero：国际象棋强化学习项目（基于AlphaGo Zero方法）。【1307 stars on Github】项目地址：https:github.comZeta36chess-alpha-zero?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n11、Dm_control：DeepMind工具包。【1231 stars on Github】项目地址：https:github.comdeepminddm_control?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n12、MAMEToolkit：基于强化学习的电子游戏python库。【437 stars on Github】项目地址：https:github.comM-J-MurrayMAMEToolkit?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n13、Reaver：模块化的深度强化学习框架（星际争霸2）。【355 stars on Github】项目地址：https:github.cominoryyreaver?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\nNLP14、Bert：BERT的TensorFlow代码，以及预训练模型。【11703 stars on Github】项目地址：https:github.comgoogle-researchbert?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n15、Pytext：基于Pytorch的神经语言模型框架。【4466 stars on Github】项目地址：https:github.comfacebookresearchpytext?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n16、Bert-as-service：BERT模型的网络服务版本项目地址：https:github.comhanxiaobert-as-service?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n17、UnsupervisedMT：基于Phrase的无监督机器翻译方法。【1068 stars on Github】项目地址：https:github.comfacebookresearchUnsupervisedMT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n18、DecaNLP：NLP十项全能工具，多任务模型。【1648 stars on Github】项目地址：https:github.comsalesforcedecaNLP?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n19、NLP-architect：来自英特尔AI实验室的python工具包，包含了当前NLP领域的多种最佳模型。【1751 stars on Github】项目地址：https:github.comNervanaSystemsnlp-architect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n20、Gluon-nlp：NLP工具包。【1263 stars on Github】项目地址：https:github.comdmlcgluon-nlp?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\nGAN21、DeOldify：一个基于深度学习的图像补全工具包。【5060 stars on Github】项目地址：https:github.comjanticDeOldify?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n22、Progressive_growing_of_gans：GAN的变种实现，提高生产质量、稳定性以及多样性。项目地址：https:github.comtkarrasprogressive_growing_of_gans?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n23、MUNIT：多模态无监督图像翻译。【1339 stars on Github】项目地址：https:github.comNVlabsMUNIT?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n24、Transparent_latent_gan：使用监督学习来解释GAN的隐空间信息。【1337 stars on Github】项目地址：https:github.comSummitKwantransparent_latent_gan?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n25、Gandissect：基于Pytorch的可视化以及理解GAN的神经元信息。【1065 stars on Github】项目地址：https:github.comCSAILVisiongandissect?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n26、GANimation：单张图片的表情变换。【869 stars on Github】项目地址：https:github.comalbertpumarolaGANimation?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more神经网络27、Fastai：加速神经网络训练过程，并提高准确率。【11597 stars on Github】项目地址：https:github.comfastaifastai?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n28、DeepCreamPy：图像修复。【7046 stars on Github】项目地址：https:github.comdeeppomfDeepCreamPy?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n29、Augmentor v0.2、图像增强工具包。【2805 stars on Github】项目地址：https:github.commdbloiceAugmentor?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n30、Graph_nets：Tensorflow的图网络构建工具。【2723 stars on Github】项目地址：https:github.comdeepmindgraph_nets?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n31、Textgenrnn：使用预训练字符级RNN生成文本。【1900 stars on Github】项目地址：https:github.comminimaxirtextgenrnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n32、Person-blocker：图像中自动删除人像。【1806 stars on Github】项目地址：https:github.comminimaxirperson-blocker?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n33、Deepvariant：DNA序列数据的分析工具项目地址：https:github.comgoogledeepvariant?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n34、Video-nolocal-net：non-local神经网络的视频分类方法。【1049 stars on Github】项目地址：https:github.comfacebookresearchvideo-nonlocal-net?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n35、Ann-visualizer：神经网络可视化工具。【922 stars on Github】项目地址：https:github.comProdicodeann-visualizer?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n工具包36、Tfjs：一个基于JS的ML模型训练部署工具包。【10268 stars on Github】项目地址：https:github.comtensorflowtfjs?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n37：Dopamine：快速的强化学习研究框架。【7142 stars on Github】项目地址：https:github.comgoogledopamine?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n38、Lime：分类器解释工具包。【5173 stars on Github】项目地址：https:github.commarcotcrlime?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n39、Autokeras：自动机器学习的开源软件库。【4520 stars on Github】项目地址：https:github.comjhfjhfj1autokeras?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n40、Shap：神经网络解释工具。【3496 stars on Github】项目地址：https:github.comslundbergshap?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n41、MMdnn：模型适配器。【3021 stars on Github】项目地址：https:github.comMicrosoftMMdnn?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n42、Mlflow：机器学习生命周期管理。【3013 stars on Github】项目地址：https:github.commlflowmlflow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n43、Mace：面向移动计算平台的深度学习推断框架。【2979 stars on Github】项目地址：https:github.comXiaoMimace?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n44、PySyft：关注安全性的深度学习库。【2595 stars on Github】项目地址：https:github.comOpenMinedPySyft?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n45、Adanet：AutoML计算库。【2293 stars on Github】项目地址：https:github.comtensorflowadanet?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n46、Tencent-ml-images：最大的多标签图像数据库。【2094 stars on Github】项目地址：https:github.comTencenttencent-ml-images?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n47、Donkeycar、开源的软硬件自动驾驶平台。【1207 stars on Github】\n项目地址：https:github.comautoropedonkeycar?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n48、PocketFlow：自动模型压缩框架。【1677 stars on Github】项目地址：https:github.comTencentPocketFlow?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n49、DALI：深度学习应用的优化工具包以及数据处理扩展引擎。【1013 stars on Github】项目地址：https:github.comNVIDIAdali?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more\n传送门\n","tags":["机器学习"],"path":"2019/09/16/2019年度机器学习49个顶级工程汇总/","external_link":""},{"title":"Java12的新特性","date":"2019-09-16T14:20:54.000Z","content":"Java12的新特性\nJava5的新特性Java6的新特性Java7的新特性Java8的新特性Java9的新特性Java10的新特性Java11的新特性Java12的新特性Java13的新特性\n\n\n版本号1234java -versionopenjdk version &quot;12&quot; 2019-03-19OpenJDK Runtime Environment (build 12+33)OpenJDK 64-Bit Server VM (build 12+33, mixed mode)\n\n\n从version信息可以看出是build 12+33\n\n特性列表\n189:    Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)\n\n\nShenandoah GC是一个面向low-pause-time的垃圾收集器，它最初由Red Hat实现，支持aarch64及amd64 architecture；ZGC也是面向low-pause-time的垃圾收集器，不过ZGC是基于colored pointers来实现，而Shenandoah GC是基于brooks pointers来实现；如果要使用Shenandoah GC需要编译时–with-jvm-features选项带有shenandoahgc，然后启动时使用-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC\n\n\n230:    Microbenchmark Suite\n\n\n在jdk源码里头新增了一套基础的microbenchmarks suite\n\n\n325:    Switch Expressions (Preview)\n\n\n对switch进行了增强，除了使用statement还可以使用expression，比如原来的写法如下：\n\n1234567891011121314151617switch (day) &#123;    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;&#125;\n\n现在可以改为如下写法：\n123456switch (day) &#123;    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);&#125;\n\n以及在表达式返回值\n123456int numLetters = switch (day) &#123;    case MONDAY, FRIDAY, SUNDAY -&gt; 6;    case TUESDAY                -&gt; 7;    case THURSDAY, SATURDAY     -&gt; 8;    case WEDNESDAY              -&gt; 9;&#125;;\n\n对于需要返回值的switch expression要么正常返回值要么抛出异常，以下这两种写法都是错误的\n1234567891011121314int i = switch (day) &#123;    case MONDAY -&gt; &#123;        System.out.println(Monday);          ERROR! Block doesnt contain a break with value    &#125;    default -&gt; 1;&#125;;i = switch (day) &#123;    case MONDAY, TUESDAY, WEDNESDAY:         break 0;    default:         System.out.println(Second half of the week);         ERROR! Group doesnt contain a break with value&#125;;\n\n\n334:    JVM Constants API\n\n\n新增了JVM Constants API，具体来说就是java.base模块新增了java.lang.constant包，引入了ConstantDesc接口(ClassDesc、MethodTypeDesc、MethodHandleDesc这几个接口直接继承了ConstantDesc接口)以及Constable接口；ConstantDesc接口定义了resolveConstantDesc方法，Constable接口定义了describeConstable方法；String、Integer、Long、Float、Double均实现了这两个接口，而EnumDesc实现了ConstantDesc接口\n\n\n340:    One AArch64 Port, Not Two\n\n\n64-bit Arm platform (arm64)，也可以称之为aarch64；之前JDK有两个关于aarch64的实现，分别是srchotspotcpuarm以及opensrchotspotcpuaarch64，它们的实现重复了，为了集中精力更好地实现aarch64，该特性在源码中删除了opensrchotspotcpuarm中关于64-bit的实现，保留其中32-bit的实现，于是opensrchotspotcpuaarch64部分就成了64-bit ARM architecture的默认实现\n\n\n341:    Default CDS Archives\n\n\njava10的新特性JEP 310: Application Class-Data Sharing扩展了JDK5引入的Class-Data Sharing，支持application的Class-Data Sharing；Class-Data Sharing可以用于多个JVM共享class，提升启动速度，最早只支持system classes及serial GC，JDK9对其进行扩展以支持application classes及其他GC算法，并在JDK10中开源出来(以前是commercial feature)；JDK11将-Xshare:off改为默认-Xshare:auto，以更加方便使用CDS特性；JDK12的这个特性即在64-bit平台上编译jdk的时候就默认在${JAVA_HOME}libserver目录下生成一份名为classes.jsa的默认archive文件(大概有18M)方便大家使用\n\n\n344:    Abortable Mixed Collections for G1\n\n\nG1在garbage collection的时候，一旦确定了collection set(CSet)开始垃圾收集这个过程是without stopping的，当collection set过大的时候，此时的STW时间会过长超出目标pause time，这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，允许将其分为mandatory及optional两部分(当完成mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标\n\n\n346:    Promptly Return Unused Committed Memory from G1\n\n\nG1目前只有在full GC或者concurrent cycle的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时会还committed Java heap memory给操作系统。JDK12的这个特性新增了两个参数分别是G1PeriodicGCInterval及G1PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。当上一次garbage collection pause过去G1PeriodicGCInterval(milliseconds)时间之后，如果getloadavg()(one-minute)低于G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(如果开启G1PeriodicGCInvokesConcurrent)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统\n\n细项解读上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见JDK 12 Release Notes，这里举几个例子。添加项\n\n支持unicode 11\n支持Compact Number Formatting\n\n\n使用实例如下\n\n12345678910@Testpublic void testCompactNumberFormat()&#123;    var cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);    System.out.println(cnf.format(1_0000));    System.out.println(cnf.format(1_9200));    System.out.println(cnf.format(1_000_000));    System.out.println(cnf.format(1L &lt;&lt; 30));    System.out.println(cnf.format(1L &lt;&lt; 40));    System.out.println(cnf.format(1L &lt;&lt; 50));&#125;\n\n输出\n1234561万2万100万11亿1兆1126兆\n\n\nString支持transform、indent操作\n\n1234567891011121314@Testpublic void testStringTransform()&#123;    System.out.println(hello.transform(new Function&lt;String, Integer&gt;() &#123;        @Override        public Integer apply(String s) &#123;            return s.hashCode();        &#125;    &#125;));&#125;@Testpublic void testStringIndent()&#123;    System.out.println(hello.indent(3));&#125;\n\nFiles新增mismatch方法\n12345678910111213141516@Testpublic void testFilesMismatch() throws IOException &#123;    FileWriter fileWriter = new FileWriter(tmpa.txt);    fileWriter.write(a);    fileWriter.write(b);    fileWriter.write(c);    fileWriter.close();    FileWriter fileWriterB = new FileWriter(tmpb.txt);    fileWriterB.write(a);    fileWriterB.write(1);    fileWriterB.write(c);    fileWriterB.close();    System.out.println(Files.mismatch(Path.of(tmpa.txt),Path.of(tmpb.txt)));&#125;\n\n\nCollectors新增teeing方法用于聚合两个downstream的结果\n\n1234567891011@Testpublic void testCollectorTeeing()&#123;    var result = Stream.of(Devoxx,Voxxed Days,Code One,Basel One)            .collect(Collectors.teeing(Collectors.filtering(n -&gt; n.contains(xx),Collectors.toList()),                                        Collectors.filtering(n -&gt; n.endsWith(One),Collectors.toList()),                    (List&lt;String&gt; list1, List&lt;String&gt; list2) -&gt; List.of(list1,list2)                                        ));    System.out.println(result.get(0));    System.out.println(result.get(1));&#125;\n\n\nCompletionStage新增exceptionallyAsync、exceptionallyCompose、exceptionallyComposeAsync方法\n\n1234567891011121314@Testpublic void testExceptionallyAsync() throws ExecutionException, InterruptedException &#123;    LOGGER.info(begin);    int result = CompletableFuture.supplyAsync(() -&gt; &#123;        LOGGER.info(calculate);        int i = 10;        return 100;    &#125;).exceptionallyAsync((t) -&gt; &#123;        LOGGER.info(error error:&#123;&#125;,t.getMessage());        return 0;    &#125;).get();    LOGGER.info(result:&#123;&#125;,result);&#125;\n\n\nJDK12之前CompletionStage只有一个exceptionally，该方法体在主线程执行，JDK12新增了exceptionallyAsync、exceptionallyComposeAsync方法允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage\n\nAllocation of Old Generation of Java Heap on Alternate Memory Devices\n\n\n\nG1及Parallel GC引入experimental特性，允许将old generation分配在诸如NV-DIMM memory的alternative memory device\n\n\nZGC: Concurrent Class Unloading\n\n\nZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用\n\n\n新增-XX:+ExtensiveErrorReports\n\n\n-XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数\n\n\n新增安全相关的改进\n\n\n支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationExceptionkeytool新增-groupname选项允许在生成key pair的时候指定一个named group新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成Java Flight Recorder新增了security-related的event支持ChaCha20 and Poly1305 TLS Cipher Suites\n\n\njdeps Reports Transitive Dependences\n\n\njdeps的–print-module-deps, –list-deps, 以及–list-reduce-deps选项得到增强，新增–no-recursive用于non-transitive的依赖分析，–ignore-missing-deps用于suppress missing dependence errors\n\n移除项\n移除com.sun.awt.SecurityWarnin\n移除FileInputStream、FileOutputStream、Java.util.ZipFileInflatorDeflator的finalize方法\n移除GTE CyberTrust Global Root\n移除javac的-source, -target对6及1.6的支持，同时移除–release选项\n\n废弃项\n废弃的API列表见deprecated-list\n废弃-XX:+-MonitorInUseLists选项\n废弃Default Keytool的-keyalg值\n\n已知问题\nSwing不支持GTK+ 3.20及以后的版本\n在使用JVMCI Compiler(比如Graal)的时候，JVMTI的can_pop_frame及can_force_early_return的capabilities是被禁用的\n\n其他事项\n如果用户没有指定user.timezone且从操作系统获取的为空，那么user.timezone属性的初始值为空变为null\njava.net.URLPermission的行为发生轻微变化，以前它会忽略url中的query及fragment部分，这次改动新增query及fragment部分，即scheme :  authority [  path ]变动为scheme :  authority [  path ] [ ignored-query-or-fragment ]\njavax.net.ssl.SSLContext API及Java Security Standard Algorithm Names规范移除了必须实现TLSv1及TLSv1.1的规定\n\n小结\njava12不是LTS(Long-Term Support)版本(oracle版本才有LTS)，oracle对该版本的support周期为6个月。这个版本主要有几个更新点，一个是语法层更新，一个是API层面的更新，另外主要是GC方面的更新。\n语法层面引入了preview版本的Switch Expressions；API层面引入了JVM Constants API，引入CompactNumberFormat，让NumberFormat支持COMPACTSTYLE，对String、Files、Collectors、CompletionStage等新增方法；GC方面引入了experimental版本的Shenandoah GC，不过oracle build的openjdk没有enable Shenandoah GC support；另外主要对ZGC及G1 GC进行了改进\n其中JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用；对于G1 GC则新增支持Abortable Mixed Collections以及Promptly Return Unused Committed Memory特性\n\n\n作者：go4it链接：https:juejin.impost5c91fcc9e51d45563b62382c来源：掘金\n\n","tags":["Java"],"path":"2019/09/16/Java12的新特性/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/AI/" style="font-size: 0.8em; color: #488baf">AI</a> <a href="/tags/Docker/" style="font-size: 0.8em; color: #488baf">Docker</a> <a href="/tags/Flutter/" style="font-size: 0.8em; color: #488baf">Flutter</a> <a href="/tags/Http/" style="font-size: 0.8em; color: #488baf">Http</a> <a href="/tags/JVM/" style="font-size: 0.8em; color: #488baf">JVM</a> <a href="/tags/Java/" style="font-size: 1.76em; color: #ba4d2b">Java</a> <a href="/tags/Nodejs/" style="font-size: 0.8em; color: #488baf">Nodejs</a> <a href="/tags/OCR/" style="font-size: 0.8em; color: #488baf">OCR</a> <a href="/tags/OpenCV/" style="font-size: 0.8em; color: #488baf">OpenCV</a> <a href="/tags/Spring/" style="font-size: 0.8em; color: #488baf">Spring</a> <a href="/tags/TensorFlow/" style="font-size: 1.04em; color: #647c8e">TensorFlow</a> <a href="/tags/dio/" style="font-size: 0.8em; color: #488baf">dio</a> <a href="/tags/electron/" style="font-size: 0.8em; color: #488baf">electron</a> <a href="/tags/git/" style="font-size: 1.28em; color: #816c6d">git</a> <a href="/tags/github/" style="font-size: 0.8em; color: #488baf">github</a> <a href="/tags/jad/" style="font-size: 0.8em; color: #488baf">jad</a> <a href="/tags/javascript/" style="font-size: 0.8em; color: #488baf">javascript</a> <a href="/tags/leetcode/" style="font-size: 1.52em; color: #9d5d4c">leetcode</a> <a href="/tags/linux/" style="font-size: 0.8em; color: #488baf">linux</a> <a href="/tags/nohup/" style="font-size: 0.8em; color: #488baf">nohup</a> <a href="/tags/vue/" style="font-size: 0.8em; color: #488baf">vue</a> <a href="/tags/webhooks/" style="font-size: 0.8em; color: #488baf">webhooks</a> <a href="/tags/二叉树/" style="font-size: 0.8em; color: #488baf">二叉树</a> <a href="/tags/反编译/" style="font-size: 0.8em; color: #488baf">反编译</a> <a href="/tags/备份/" style="font-size: 0.8em; color: #488baf">备份</a> <a href="/tags/天平/" style="font-size: 0.8em; color: #488baf">天平</a> <a href="/tags/数据库/" style="font-size: 1.04em; color: #647c8e">数据库</a> <a href="/tags/文章/" style="font-size: 1.04em; color: #647c8e">文章</a> <a href="/tags/暴力破解/" style="font-size: 0.8em; color: #488baf">暴力破解</a> <a href="/tags/机器学习/" style="font-size: 1.04em; color: #647c8e">机器学习</a> <a href="/tags/树/" style="font-size: 0.8em; color: #488baf">树</a> <a href="/tags/框架/" style="font-size: 0.8em; color: #488baf">框架</a> <a href="/tags/爱因斯坦/" style="font-size: 0.8em; color: #488baf">爱因斯坦</a> <a href="/tags/狂野飙车/" style="font-size: 0.8em; color: #488baf">狂野飙车</a> <a href="/tags/百科/" style="font-size: 0.8em; color: #488baf">百科</a> <a href="/tags/相对论/" style="font-size: 0.8em; color: #488baf">相对论</a> <a href="/tags/矩阵/" style="font-size: 0.8em; color: #488baf">矩阵</a> <a href="/tags/算法/" style="font-size: 2em; color: #d63e0a">算法</a> <a href="/tags/素数/" style="font-size: 0.8em; color: #488baf">素数</a> <a href="/tags/红黑树/" style="font-size: 0.8em; color: #488baf">红黑树</a> <a href="/tags/编程/" style="font-size: 1.52em; color: #9d5d4c">编程</a> <a href="/tags/脚本/" style="font-size: 0.8em; color: #488baf">脚本</a> <a href="/tags/自动化部署/" style="font-size: 0.8em; color: #488baf">自动化部署</a> <a href="/tags/跑车/" style="font-size: 0.8em; color: #488baf">跑车</a> <a href="/tags/边缘检测/" style="font-size: 0.8em; color: #488baf">边缘检测</a> <a href="/tags/递归/" style="font-size: 1.28em; color: #816c6d">递归</a> <a href="/tags/链表/" style="font-size: 1.04em; color: #647c8e">链表</a> <a href="/tags/面试/" style="font-size: 1.52em; color: #9d5d4c">面试</a> <a href="/tags/魔方/" style="font-size: 0.8em; color: #488baf">魔方</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> 版权所有 <a href="">times </a> @ 2019</p>
            <p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/文章/">
						<span>文章</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/算法/">
						<span>算法</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/人工智能/">
						<span>人工智能</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/笔试/">
						<span>笔试</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        pageSize: 10,
        comment_count: true,
        appId: 'x8sFMx0q5JkG3Y3x6Q3wiVoe-gzGzoHsz',
        appKey: 'Dt5xQxK8HtOYoNAmGQoWVMa6',
        placeholder: 'just go go',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'z'
    });
</script>








    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    
<script type='text/javascript'>
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
