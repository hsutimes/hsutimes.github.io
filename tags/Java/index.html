<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>标签: Java - Time</title>


    <meta name="description" content="blog">
<meta name="keywords" content="hsutimes">
<meta property="og:type" content="website">
<meta property="og:title" content="Time">
<meta property="og:url" content="https://blog.hsutimes.com/tags/Java/index.html">
<meta property="og:site_name" content="Time">
<meta property="og:description" content="blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://blog.hsutimes.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Time">
<meta name="twitter:description" content="blog">
<meta name="twitter:image" content="https://blog.hsutimes.com/images/og_image.png">
<meta name="twitter:site" content="https://twitter.com/times26740863">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134224598-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134224598-1');
</script>

    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Time" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/hsutimes/hsutimes.github.io">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">标签</a></li>
            <li class="is-active"><a href="#" aria-current="page">Java</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-11-08T15:45:34.000Z">2019-11-08</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 477 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/11/08/javamelody/">javamelody</a>
            
        </h1>
        <div class="content">
            <h1 id="JavaMelody-monitoring-of-JavaEE-applications"><a href="#JavaMelody-monitoring-of-JavaEE-applications" class="headerlink" title="JavaMelody : monitoring of JavaEE applications"></a>JavaMelody : monitoring of JavaEE applications</h1><p><img src="/images/2019/11/08/bd4c8d00-023e-11ea-97a2-eb10e3960fff.png" alt="image.png"></p>
<p>The goal of JavaMelody is to monitor Java or Java EE applications in QA and production environments. It is not a tool to simulate requests from users, it is a tool to measure and calculate statistics on real operation of an application depending on the usage of the application by users.</p>
<p>JavaMelody is opensource (ASL) and production ready: in production in an application of 25 person years. JavaMelody is easy to integrate in most applications and is lightweight (no profiling and no database).</p>
<p>JavaMelody is mainly based on statistics of requests and on evolution charts.</p>
<p>It allows to improve applications in QA and production and helps to:</p>
<ul>
<li>give facts about the average response times and number of executions</li>
<li>make decisions when trends are bad, before problems become too serious</li>
<li>optimize based on the more limiting response times</li>
<li>find the root causes of response times</li>
<li>verify the real improvement after optimizations</li>
</ul>
<p>It includes summary charts showing the evolution over time of the following indicators:</p>
<ul>
<li>Number of executions, mean execution times and percentage of errors of http requests, sql requests, jsf actions, struts actions, jsp pages or methods of business façades (if EJB3, Spring or Guice)</li>
<li>Java memory</li>
<li>Java CPU</li>
<li>Number of user sessions</li>
<li>Number of jdbc connections</li>
</ul>
<p>These charts can be viewed on the current day, week, month, year or custom period.</p>
<p>JavaMelody includes statistics of predefined counters (currently http requests, sql requests, jsf actions, struts actions, jsp pages and methods of business façades if EJB3, Spring or Guice) with, for each counter :</p>
<ul>
<li>A summary indicating the overall number of executions, the average execution time, the cpu time and the percentage of errors.</li>
<li>And the percentage of time spent in the requests for which the average time exceeds a configurable threshold.</li>
<li>And the complete list of requests, aggregated without dynamic parameters with, for each, the number of executions, the mean execution time, the mean cpu time, the percentage of errors and an evolution chart of execution time over time.</li>
<li>Furthermore, each http request indicates the size of the flow response, the mean number of sql executions and the mean sql time.<br>It also includes statistics on http errors, on warnings and errors in logs, on data caches if ehcache and on batch jobs if quartz.</li>
</ul>
<p>An optional and independent collect server may be used if necessary to unload the application of storage management, and of report generation and to centralize the data of clustered applications or of several applications.</p>
<p>See the online demo.</p>
<p>Read the User’s guide to install JavaMelody.</p>
<p>JavaMelody users’ group is at <a href="http://groups.google.com/group/javamelody" target="_blank" rel="noopener">http://groups.google.com/group/javamelody</a> (email: <a href="mailto:javamelody@googlegroups.com" target="_blank" rel="noopener">javamelody@googlegroups.com</a>).</p>
<p>There are a Jenkins plugin and a JIRA/Confluence/Bamboo/Bitbucket plugin and other plugins.</p>
<p>Roots conference slides and video by David Karlsen</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-10-22T13:17:32.000Z">2019-10-22</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 688 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/22/weilibipei/">weilibipei</a>
            
        </h1>
        <div class="content">
            <h1 id="违例匹配"><a href="#违例匹配" class="headerlink" title="违例匹配"></a>违例匹配</h1><p>“掷”出一个违例后，违例控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为违例已得到控制，不再进行更多的搜索工作。</p>
<p>在违例和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个控制器相配，如下例所示：</p>
<pre><code>//: Human.java
// Catching Exception Hierarchies

class Annoyance extends Exception {}
class Sneeze extends Annoyance {}

public class Human {
  public static void main(String[] args) {
    try {
      throw new Sneeze();
    } catch(Sneeze s) {
      System.out.println(&quot;Caught Sneeze&quot;);
    } catch(Annoyance a) {
      System.out.println(&quot;Caught Annoyance&quot;);
    }
  }
} ///:~</code></pre><p>Sneeze违例会被相符的第一个catch从句捕获。当然，这只是第一个。然而，假如我们删除第一个catch从句：</p>
<pre><code>    try {
      throw new Sneeze();
    } catch(Annoyance a) {
      System.out.println(&quot;Caught Annoyance&quot;);
    }</code></pre><p>那么剩下的catch从句依然能够工作，因为它捕获的是Sneeze的基础类。换言之，catch(Annoyance e)能捕获一个Annoyance以及从它衍生的任何类。这一点非常重要，因为一旦我们决定为一个方法添加更多的违例，而且它们都是从相同的基础类继承的，那么客户程序员的代码就不需要更改。至少能够假定它们捕获的是基础类。</p>
<p>若将基础类捕获从句置于第一位，试图“屏蔽”衍生类违例，就象下面这样：</p>
<pre><code>    try {
      throw new Sneeze();
    } catch(Annoyance a) {
      System.out.println(&quot;Caught Annoyance&quot;);
    } catch(Sneeze s) {
      System.out.println(&quot;Caught Sneeze&quot;);
    }</code></pre><p>则编译器会产生一条出错消息，因为它发现永远不可能抵达Sneeze捕获从句。</p>
<p>9.8.1 违例准则</p>
<p>用违例做下面这些事情：</p>
<p>(1) 解决问题并再次调用造成违例的方法。</p>
<p>(2) 平息事态的发展，并在不重新尝试方法的前提下继续。</p>
<p>(3) 计算另一些结果，而不是希望方法产生的结果。</p>
<p>(4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。</p>
<p>(5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。</p>
<p>(6) 中止程序执行。</p>
<p>(7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。</p>
<p>(8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-10-15T06:58:25.000Z">2019-10-15</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分钟 读完 (大约 2239 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/15/Computer-network-books/">Computer-network-books</a>
            
        </h1>
        <div class="content">
            <h1 id="网络安全从业者书单推荐"><a href="#网络安全从业者书单推荐" class="headerlink" title="网络安全从业者书单推荐"></a>网络安全从业者书单推荐</h1><h2 id="一、计算机及系统原理"><a href="#一、计算机及系统原理" class="headerlink" title="一、计算机及系统原理"></a>一、计算机及系统原理</h2><p>《编码：隐匿在计算机软硬件背后的语言》</p>
<p>作者：（美国）Charles Petzold  </p>
<p>《深入理解计算机系统》</p>
<p>作者：（美国）Randal E. Bryant</p>
<p>《深入解析windows操作系统》</p>
<p>作者：（美国）Mark E .Russinovich ，David A.Solomon</p>
<p>《Linux内核设计与实现》</p>
<p>作者：（美国）Robert Love</p>
<p>《深入理解android内核设计思想》</p>
<p>作者：林学森</p>
<p>《Android系统源代码情景分析》</p>
<p>作者：罗升阳</p>
<p>《深入解析Mac OS X &amp; iOS操作系统》</p>
<p>作者：（美国）Jonathan Levin</p>
<p>《深入理解LINUX内核》</p>
<p>作者：（美国）Daniel P.Bovet</p>
<p>《代码揭秘：从C/C++的角度探秘计算机系统》</p>
<p>作者：左飞</p>
<p>《Android Dalvik虚拟机结构及机制剖析》（共2卷）</p>
<p>作者：吴艳霞，张国印</p>
<p>《最强Android书：架构大剖析》</p>
<p>作者：（美国）Jonathan Levin</p>
<h2 id="二、编程开发"><a href="#二、编程开发" class="headerlink" title="二、编程开发"></a>二、编程开发</h2><p>1、系统平台</p>
<p>（1）Windows</p>
<p>《Windows程序设计》</p>
<p>作者：（美国）Charles Petzold </p>
<p>《Windows核心编程》</p>
<p>作者：（美国）Jeffrey Richter</p>
<p>《Windows环境下32位汇编语言程序设计》</p>
<p>作者：罗云彬</p>
<p>《Windows驱动开发技术详解》</p>
<p>作者：张帆，史彩成</p>
<p>（2）Linux / Unix</p>
<p>《UNIX环境高级编程》</p>
<p>作者：（美国）W.Richard Stevens</p>
<p>《Linux程序设计》</p>
<p>作者：（美国）Nell Matthew，Richard Stones</p>
<p>《鸟哥的Linux私房菜》</p>
<p>作者：鸟哥（蔡德明）</p>
<p>《Linux设备驱动程序》</p>
<p>作者：（美国）Jonahan Corbet</p>
<p>（3）Mac OS X / iOS</p>
<p>《iOS编程》</p>
<p>作者：（美国）Joe Conway，Aaron Hillegass</p>
<p>《OS X与iOS内核编程》</p>
<p>作者：（澳大利亚）Ole Henry Halvorsen，Douglas Clarke</p>
<p>（4）Android</p>
<p>《第一行代码 Android》</p>
<p>作者：郭霖</p>
<p>《Android编程权威指南》</p>
<p>作者：（美国）Bill Phillips，Brian Hardy</p>
<p>2、编程语言</p>
<p>（1）C</p>
<p>《C程序设计语言》</p>
<p>作者：（美国）Brian W. Kernighan，Dennis M. Ritchie </p>
<p>《C Primer Plus》</p>
<p>作者：（美国）Stephen Prata</p>
<p>《C和指针》</p>
<p>作者：（美国）Kenneth A．Reek</p>
<p>《C陷阱与缺陷》</p>
<p>作者：（美国）Andrew Koenig</p>
<p>《C专家编程》</p>
<p>作者：（美国）Perter VanDer Linden</p>
<p>（2）C++</p>
<p>《C++ Primer Plus》</p>
<p>作者：（美国）Stephen Prata</p>
<p>《C++ Primer》</p>
<p>作者：（美国）Stanley B. Lippman，Josée LaJoie，Barbara E. Moo</p>
<p>（3）ASM</p>
<p>《Intel 汇编语言程序设计》</p>
<p>作者：（美国）Kip R.Irvine</p>
<p>《Intel 开发手册》</p>
<p>（4）JAVA</p>
<p>《JAVA核心技术》</p>
<p>作者：（美国）Cay S. Horstmann</p>
<p>《Java编程思想》</p>
<p>作者：（美国）Bruce Eckel</p>
<p>（5）JavaScript</p>
<p>《JavaScript DOM编程艺术》</p>
<p>作者：（英国）Jeremy Keith，（加拿大）Jeffrey Sambells</p>
<p>《JavaScript高级程序设计》</p>
<p>作者：（美国）Nicholas C.Zakas</p>
<p>（6）Python</p>
<p>《Python核心编程》</p>
<p>作者：（美国）Wesley Chun</p>
<p>（7）Shell</p>
<p>《Linux Shell脚本攻略》</p>
<p>作者：（印度）Sarath Lakshman</p>
<p>3、调试技术</p>
<p>《软件调试》</p>
<p>作者：张银奎</p>
<p>《Debug Hacks》</p>
<p>作者：（日本）吉冈弘隆，大和一洋，大岩尚宏，安部东洋，吉田俊辅</p>
<p>《格蠹汇编：软件调试案例集锦》</p>
<p>作者：张银奎</p>
<p>4、数据结构与算法</p>
<p>《数据结构与算法分析：C语言描述》</p>
<p>作者：（美国）Mark Allen Weiss</p>
<p>《算法导论》</p>
<p>作者：（美国）Thomas H.Cormen，Charles E.Leiserson，Ronald L.Rivest</p>
<p>5、编译原理</p>
<p>《编译系统透视：图解编译原理》</p>
<p>作者：新设计团队</p>
<p>《编译原理》</p>
<p>作者：（美国）Alfred V.Aho，Monica S.Lam，Ravi Sethi，Jeffrey D.Ullman</p>
<p>6、其他</p>
<p>《编程高手箴言》</p>
<p>作者：梁肇新</p>
<p>《代码整洁之道》</p>
<p>作者：（美国）Robert C.Martin</p>
<p>《代码大全》</p>
<p>作者：（美国）Steve McConnell</p>
<h2 id="三、网络技术"><a href="#三、网络技术" class="headerlink" title="三、网络技术"></a>三、网络技术</h2><p>《TCP/IP详解 卷1：协议》</p>
<p>作者：（美国）Kevin R. Fall，W.Richard Stevens</p>
<p>《Wireshark数据包分析实战》</p>
<p>作者：（美国）Chris Sanders</p>
<h2 id="四、安全技术"><a href="#四、安全技术" class="headerlink" title="四、安全技术"></a>四、安全技术</h2><p>1、安全开发</p>
<p>《天书夜读：从汇编语言到Windows内核编程》</p>
<p>作者：谭文，邵坚磊</p>
<p>《Rootkit：系统灰色地带的潜伏者》</p>
<p>作者：（美国）Bill Blunden</p>
<p>《Rootkits——Windows内核的安全防护》</p>
<p>作者：（美国）Greg Hoglund，James Butler</p>
<p>《BSD ROOTKIT 设计–内核黑客指引书》</p>
<p>作者：（美国）Joseph Kong</p>
<p>《寒江独钓：Windows内核安全编程》</p>
<p>作者：谭文，杨潇，邵坚磊</p>
<p>2、逆向工程</p>
<p>《加密与解密》</p>
<p>作者：段钢</p>
<p>《恶意软件分析诀窍与工具箱——对抗“流氓”软件的技术与利器》</p>
<p>作者：（美国）Michael.Hale.Ligh，Steven Adair</p>
<p>《C++反汇编与逆向分析技术揭秘》</p>
<p>作者：钱林松，赵海旭</p>
<p>《IDA Pro权威指南》</p>
<p>作者：（美国）Chris Eagle</p>
<p>《逆向工程权威指南》</p>
<p>作者：（乌克兰）Dennis Yurichev</p>
<p>《Android软件安全与逆向分析》</p>
<p>作者：丰生强</p>
<p>《macOS软件安全与逆向分析》</p>
<p>作者：丰生强、 邢俊杰</p>
<p>《iOS应用逆向工程（第2版）》</p>
<p>作者：沙梓社，吴航</p>
<p>3、Web安全</p>
<p>《黑客攻防技术宝典：Web实战篇》</p>
<p>作者：（美国）Dafydd Stuttard，Marcus Pinto</p>
<p>《白帽子讲Web安全》</p>
<p>作者：吴翰清</p>
<p>《Web安全测试》</p>
<p>作者：（美国）Paco Hope，Ben Waltller</p>
<p>《Web前端黑客技术揭秘》</p>
<p>作者：钟晨鸣，徐少培</p>
<p>《精通脚本黑客》</p>
<p>作者：曾云好</p>
<p>4、软件 / 系统安全</p>
<p>《0day安全：软件漏洞分析技术》</p>
<p>作者：王清</p>
<p>《漏洞战争：软件漏洞分析精要》</p>
<p>作者：林桠泉</p>
<p>《捉虫日记》</p>
<p>作者：（德国）Tobias Klein</p>
<p>《内核漏洞的利用与防范》</p>
<p>作者：（美国）Enrico Perla，Massimiliano Oldani</p>
<p>《Fuzzing for Software Security Testing and Quality Assurance（第二版）》</p>
<p>作者：（美国）Charlie Miller</p>
<p>《iOS Hacker’s Handbook》</p>
<p>作者：（美国）Charlie Miller</p>
<p>《The Mac Hacker’S Handbook》</p>
<p>作者：（美国）Charlie Miller</p>
<p>《Android安全攻防权威指南》</p>
<p>作者：（美国）Joshua J.Drake，（西班牙）Pau Oliva Fora，（美国）Collin Mulliner</p>
<p>《The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities》</p>
<p>作者：（美国）Mark Dowd</p>
<p>《Android安全攻防实战》</p>
<p>作者：（美国）Keith Makan，Scott Alexander-Bown</p>
<p>《模糊测试：强制性安全漏洞发掘》</p>
<p>作者：（美国）Michael Sutton</p>
<p>《Exploit 编写系列教程》</p>
<p>作者：（美国）Corelan Team</p>
<p>《MacOS and iOS Internals, Volume III: Security &amp; Insecurity》</p>
<p>作者：（美国）Jonathan Levin</p>
<p>《灰帽黑客（第4版）：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》</p>
<p>作者：（美国）Allen Harper，Shon Harris</p>
<p>《威胁建模：设计和交付更安全的软件》</p>
<p>作者：（美国）Adam Shostack</p>
<p>5、无线电安全</p>
<p>《无线电安全攻防大揭秘》</p>
<p>作者：杨卿，黄琳</p>
<p>6、硬件安全</p>
<p>《硬件安全攻防大揭秘》</p>
<p>作者：简云定，杨卿</p>
<p>7、汽车安全</p>
<p>《智能汽车安全攻防大揭秘》</p>
<p>作者：李均，杨卿，曾颖涛，郑玉伟</p>
<p>《汽车黑客大曝光》</p>
<p>作者：（美国）Craig Smith</p>
<h2 id="五、软技能"><a href="#五、软技能" class="headerlink" title="五、软技能"></a>五、软技能</h2><p>《软技能：代码之外的生存指南》</p>
<p>作者：（美国）John Sonmez</p>
<p>《程序员健康指南》</p>
<p>作者：（美国）Joe Kutner</p>
<p>《影响力》</p>
<p>作者：（美国）Robert B.Cialdini</p>
<p>《思考，快与慢》</p>
<p>作者：（美国）Daniel Kahneman</p>
<p>《写给大家看的设计书》</p>
<p>作者：（美国）Robin Williams</p>
<p>《听故事，学PPT设计》</p>
<p>作者：杨雪</p>
<p>《横向领导力》</p>
<p>作者：（美国）Roger Fisher，Alan Sharp</p>
<p>《职业情商》</p>
<p>作者：张新越</p>
<p>《程序员的成长课》</p>
<p>作者：安晓辉，周鹏</p>
<p>《高效演讲：斯坦福最受欢迎的沟通课》</p>
<p>作者：（美国）Peter Meyers，Shann Nix</p>
<p>《程序员的英语》</p>
<p>作者：（韩国）朴栽浒，李海永</p>
<p>《少有人走的路》</p>
<p>作者：（美国）斯科特·派克</p>
<p>《异类：不一样的成功启示录》</p>
<p>作者：（加拿大）马尔科姆·格拉德威尔</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-10-13T05:06:51.000Z">2019-10-13</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1846 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/13/jna/">jna</a>
            
        </h1>
        <div class="content">
            <p><img src="https://github.com/java-native-access/jna/raw/master/www/images/jnalogo.jpg" alt="Java Native Access - JNA" title="Java Native Access - JNA"></p>
<p><a href="https://travis-ci.org/java-native-access/jna" target="_blank" rel="noopener"><img src="https://travis-ci.org/java-native-access/jna.svg?branch=master" alt="Build Status"></a><br><a href="https://ci.appveyor.com/project/dblock/jna-gsxuq/branch/master" target="_blank" rel="noopener"><img src="https://ci.appveyor.com/api/projects/status/j6vmpjrw5iktb8iu/branch/master?svg=true" alt="Build status"></a></p>
<h1 id="Java-Native-Access-JNA"><a href="#Java-Native-Access-JNA" class="headerlink" title="Java Native Access (JNA)"></a>Java Native Access (JNA)</h1><p>The definitive JNA reference (including an overview and usage details) is in the <a href="http://java-native-access.github.io/jna/5.4.0/javadoc/" target="_blank" rel="noopener">JavaDoc</a>.  Please read the <a href="http://java-native-access.github.io/jna/5.4.0/javadoc/overview-summary.html#overview_description" target="_blank" rel="noopener">overview</a>.  Questions, comments, or exploratory conversations should begin on the <a href="http://groups.google.com/group/jna-users" target="_blank" rel="noopener">mailing list</a>, although you may find it easier to find answers to already-solved problems on <a href="http://stackoverflow.com/questions/tagged/jna" target="_blank" rel="noopener">StackOverflow</a>.</p>
<p>JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required. This functionality is comparable to Windows’ Platform/Invoke and Python’s ctypes.</p>
<p>JNA allows you to call directly into native functions using natural Java method invocation. The Java call looks just like the call does in native code. Most calls require no special handling or configuration; no boilerplate or generated code is required.</p>
<p>JNA uses a small JNI library stub to dynamically invoke native code. The developer uses a Java interface to describe functions and structures in the target native library. This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms.  Read this <a href="https://github.com/java-native-access/jna/blob/master/www/FunctionalDescription.md" target="_blank" rel="noopener">more in-depth description</a>.</p>
<p>While significant attention has been paid to performance, correctness and ease of use take priority.</p>
<p>In addition, JNA includes a platform library with many native functions already mapped as well as a set of utility interfaces that simplify native access.</p>
<h1 id="Projects-Using-JNA"><a href="#Projects-Using-JNA" class="headerlink" title="Projects Using JNA"></a>Projects Using JNA</h1><p>JNA is a mature library with dozens of contributors and hundreds of commercial and non-commercial projects that use it.  If you’re using JNA, feel free to <a href="http://groups.google.com/group/jna-users" target="_blank" rel="noopener">tell us about it</a>.  Include some details about your company, project name, purpose and size and tell us how you use the library.</p>
<ul>
<li><a href="http://cassandra.apache.org" target="_blank" rel="noopener">Apache Cassandra</a>: Large-scale NoSQL data store.</li>
<li><a href="https://github.com/iterate-ch/rococoa" target="_blank" rel="noopener">Rococoa</a>: Java bindings to the Mac OS X Cocoa framework, by Duncan McGregor.</li>
<li><a href="http://kenai.com/projects/jna-posix" target="_blank" rel="noopener">jna-posix</a>: Common POSIX Functions for Java.</li>
<li><a href="https://github.com/nativelibs4java/JNAerator" target="_blank" rel="noopener">JNAerator</a>: Pronounced “generator”, auto-generates JNA mappings from C headers, by Olivier Chafik.</li>
<li><a href="http://fmj.sf.net" target="_blank" rel="noopener">Freedom for Media in Java</a> by Ken Larson/Dieter Krachtus.</li>
<li><a href="http://code.google.com/p/gstreamer-java" target="_blank" rel="noopener">gstreamer for Java</a> by Wayne Meissner.</li>
<li><a href="http://trac.videolan.org/jvlc/" target="_blank" rel="noopener">Videolan</a>: JVLC Java Multimedia Library.</li>
<li><a href="http://svnkit.com" target="_blank" rel="noopener">SVNKit</a>: Pure Java Subversion client library.</li>
<li><a href="http://omegat.sf.net" target="_blank" rel="noopener">OmegaT Computer-Aided Translation</a>.</li>
<li><a href="http://jetbrains.com" target="_blank" rel="noopener">IntelliJ IDEA</a> by JetBrains.</li>
<li><a href="http://netbeans.org" target="_blank" rel="noopener">NetBeans IDE</a>.</li>
<li><a href="http://www.athenabackup.com" target="_blank" rel="noopener">Athena Backup</a> by Doug Patriarche.</li>
<li><a href="http://www.filebot.net" target="_blank" rel="noopener">FileBot Media Renamer</a> by Reinhard Pointner.</li>
<li><a href="https://launchpad.net/libusb4j" target="_blank" rel="noopener">USB for Java</a> by Mario Boikov.</li>
<li><a href="https://github.com/dblock/waffle" target="_blank" rel="noopener">Waffle</a>: Enables SSO on Windows in Java applications, by Daniel Doubrovkine.</li>
<li><a href="https://github.com/protonail/leveldb-jna" target="_blank" rel="noopener">leveldb-jna</a>: Cross-platform JNA based adapter for <a href="https://github.com/google/leveldb" target="_blank" rel="noopener">LevelDB</a> (used in <a href="http://protonail.com" target="_blank" rel="noopener">Keylord</a>).</li>
<li><a href="https://github.com/protonail/bolt-jna" target="_blank" rel="noopener">bolt-jna</a>: Cross-platform JNA based adapter for <a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">Bolt</a> (used in <a href="http://protonail.com" target="_blank" rel="noopener">Keylord</a>). It is show how to use JNA for binding to Go library.</li>
<li><a href="https://github.com/kotlin-graphics/openvr" target="_blank" rel="noopener">JVM OpenVR Bindings</a>.</li>
<li><a href="https://ignite.apache.org/" target="_blank" rel="noopener">Apache Ignite</a>: Direct IO plugin</li>
<li><a href="https://github.com/klehmann/domino-jna" target="_blank" rel="noopener">Domino JNA</a>: Cross-platform access to HCL Notes/Domino C API methods from Java</li>
</ul>
<p><em>Interesting Investigations/Experiments</em></p>
<ul>
<li><a href="http://epirsch.blogspot.com/2008/02/jna-love-nxt.html" target="_blank" rel="noopener">Drive Lego Mindstorm NXT</a> by Emmanuel Pirsch.</li>
<li><a href="http://ochafik.free.fr/blog/?p=98" target="_blank" rel="noopener">Detect User Inactivity</a> by Olivier Chafik.</li>
<li><a href="http://callino.cc/jiaxcapplet/" target="_blank" rel="noopener">IAXClient Applet</a> provides VOIP for Java, by Wolfgang Pichler.</li>
</ul>
<p>There are also a number of examples and projects within the <code>contrib</code> directory of the JNA project itself.</p>
<h1 id="Supported-Platforms"><a href="#Supported-Platforms" class="headerlink" title="Supported Platforms"></a>Supported Platforms</h1><p>JNA will build on most linux-like platforms with a reasonable set of GNU tools and a JDK.  See the native <a href="https://raw.githubusercontent.com/java-native-access/jna/master/native/Makefile" target="_blank" rel="noopener">Makefile</a> for native configurations that have been built and tested.  If your platform is supported by <a href="http://en.wikipedia.org/wiki/Libffi" target="_blank" rel="noopener">libffi</a>, then chances are you can build JNA for it.</p>
<p>Pre-built platform support may be found <a href="https://github.com/java-native-access/jna/tree/master/lib/native" target="_blank" rel="noopener">here</a>.</p>
<h1 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h1><p>Version 5.4.0</p>
<h2 id="JNA"><a href="#JNA" class="headerlink" title="JNA"></a>JNA</h2><p><a href="https://search.maven.org/artifact/net.java.dev.jna/jna/5.4.0/jar" target="_blank" rel="noopener"><img src="https://img.shields.io/maven-central/v/net.java.dev.jna/jna.svg?label=Maven%20Central" alt="Maven Central"></a>&nbsp;<a href="http://repo1.maven.org/maven2/net/java/dev/jna/jna/5.4.0/jna-5.4.0.jar" target="_blank" rel="noopener">jna-5.4.0.jar</a></p>
<p>This is the core artifact of JNA and contains only the binding library and the<br>core helper classes.</p>
<h2 id="JNA-Platform"><a href="#JNA-Platform" class="headerlink" title="JNA Platform"></a>JNA Platform</h2><p><a href="https://search.maven.org/artifact/net.java.dev.jna/jna-platform/5.4.0/jar" target="_blank" rel="noopener"><img src="https://img.shields.io/maven-central/v/net.java.dev.jna/jna-platform.svg?label=Maven%20Central" alt="Maven Central"></a>&nbsp;<a href="http://repo1.maven.org/maven2/net/java/dev/jna/jna-platform/5.4.0/jna-platform-5.4.0.jar" target="_blank" rel="noopener">jna-platform-5.4.0.jar</a></p>
<p>This artifact holds cross-platform mappings and mappings for a number of commonly used platform<br>functions, including a large number of Win32 mappings as well as a set of utility classes<br>that simplify native access. The code is tested and the utility interfaces ensure that<br>native memory management is taken care of correctly.</p>
<p>See <a href="https://github.com/java-native-access/jna/blob/master/www/PlatformLibrary.md" target="_blank" rel="noopener">PlatformLibrary.md</a> for details.</p>
<h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><ul>
<li>Automatic mapping from Java to native functions, with simple mappings for all primitive data types</li>
<li>Runs on most platforms which support Java</li>
<li>Automatic conversion between C and Java strings, with customizable encoding/decoding</li>
<li>Structure and Union arguments/return values, by reference and by value</li>
<li>Function Pointers, (callbacks from native code to Java) as arguments and/or members of a struct</li>
<li>Auto-generated Java proxies for native function pointers</li>
<li>By-reference (pointer-to-type) arguments</li>
<li>Java array and NIO Buffer arguments (primitive types and pointers) as pointer-to-buffer</li>
<li>Nested structures and arrays</li>
<li>Wide (wchar_t-based) strings</li>
<li>Native long support (32- or 64-bit as appropriate)</li>
<li><a href="https://github.com/java-native-access/jna/tree/master/contrib" target="_blank" rel="noopener">Demo applications/examples</a></li>
<li>Supported on 1.4 or later JVMs, including JavaME (earlier VMs may work with stubbed NIO support)</li>
<li>Customizable marshalling/unmarshalling (argument and return value conversions)</li>
<li>Customizable mapping from Java method to native function name, and customizable invocation to simulate C preprocessor function macros</li>
<li>Support for automatic Windows ASCII/UNICODE function mappings</li>
<li>Varargs support</li>
<li>Type-safety for native pointers</li>
<li>VM crash protection (optional)</li>
<li>Optimized direct mapping for high-performance applications.</li>
<li>COM support for early and late binding.</li>
<li>COM/Typelib java code generator.</li>
</ul>
<h1 id="Community-and-Support"><a href="#Community-and-Support" class="headerlink" title="Community and Support"></a>Community and Support</h1><p>All questions should be posted to the <a href="http://groups.google.com/group/jna-users" target="_blank" rel="noopener">jna-users Google group</a>. Issues can be submitted <a href="https://github.com/java-native-access/jna/issues" target="_blank" rel="noopener">here on Github</a>.</p>
<p>When posting to the mailing list, please include the following:</p>
<ul>
<li>What OS/CPU/architecture you’re using (e.g. Windows 7 64-bit)</li>
<li>Reference to your native interface definitions (i.e. C headers), if available</li>
<li>The JNA mapping you’re trying to use</li>
<li>VM crash logs, if any</li>
<li>Example native usage, and your attempted Java usage</li>
</ul>
<p>It’s nearly impossible to indicate proper Java usage when there’s no native<br>reference to work from.</p>
<p>For commercial support, please contact twalljava [at] java [dot] net.</p>
<h1 id="Using-the-Library"><a href="#Using-the-Library" class="headerlink" title="Using the Library"></a>Using the Library</h1><ul>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md" target="_blank" rel="noopener">Getting Started</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/FunctionalDescription.md" target="_blank" rel="noopener">Functional Description</a>.</li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/Mappings.md" target="_blank" rel="noopener">Mapping between Java and Native</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/PointersAndArrays.md" target="_blank" rel="noopener">Using Pointers and Arrays</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/StructuresAndUnions.md" target="_blank" rel="noopener">Using Structures and Unions</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/ByRefArguments.md" target="_blank" rel="noopener">Using By-Reference Arguments</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/CustomMappings.md" target="_blank" rel="noopener">Customization of Type Mapping</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/CallbacksAndClosures.md" target="_blank" rel="noopener">Callbacks/Function Pointers/Closures</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/DynamicallyTypedLanguages.md" target="_blank" rel="noopener">Dynamically Typed Languages (JRuby/Jython)</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/PlatformLibrary.md" target="_blank" rel="noopener">Platform Library</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/DirectMapping.md" target="_blank" rel="noopener">Direct Method Mapping</a> (Optimization)</li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/FrequentlyAskedQuestions.md" target="_blank" rel="noopener">Frequently Asked Questions (FAQ)</a></li>
<li><a href="http://java-native-access.github.io/jna/5.4.0/javadoc/overview-summary.html#crash-protection" target="_blank" rel="noopener">Avoiding Crashes</a></li>
</ul>
<h1 id="Primary-Documentation-JavaDoc"><a href="#Primary-Documentation-JavaDoc" class="headerlink" title="Primary Documentation (JavaDoc)"></a>Primary Documentation (JavaDoc)</h1><p>The definitive JNA reference is in the <a href="http://java-native-access.github.io/jna/5.4.0/javadoc/" target="_blank" rel="noopener">JavaDoc</a>.</p>
<h1 id="Developers"><a href="#Developers" class="headerlink" title="Developers"></a>Developers</h1><ul>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/Contributing.md" target="_blank" rel="noopener">Contributing to JNA</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/WindowsDevelopmentEnvironment.md" target="_blank" rel="noopener">Setting up a Windows Development Environment</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/AndroidDevelopmentEnvironment.md" target="_blank" rel="noopener">Setting up an Android Development Environment</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/RaspberryPiDevelopmentEnvironment.md" target="_blank" rel="noopener">Setting up a RaspberryPi Development Environment</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/MacDevelopmentEnvironment.md" target="_blank" rel="noopener">Setting up a Mac Development Environment</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/ReleasingJNA.md" target="_blank" rel="noopener">Releasing JNA</a></li>
<li><a href="https://github.com/java-native-access/jna/blob/master/www/PublishingToMavenCentral.md" target="_blank" rel="noopener">Publishing to Maven Central</a></li>
</ul>
<h1 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h1><p>You’re encouraged to contribute to JNA. Fork the code from <a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">https://github.com/java-native-access/jna</a> and submit pull requests.</p>
<p>For more information on setting up a development environment see <a href="https://github.com/java-native-access/jna/blob/master/www/Contributing.md" target="_blank" rel="noopener">Contributing to JNA</a>.</p>
<p>If you are interested in paid support, feel free to say so on the <a href="http://groups.google.com/group/jna-users" target="_blank" rel="noopener">jna-users mailing list</a>. Most simple questions will be answered on the list, but more complicated work, new features or target platforms can be negotiated with any of the JNA developers (this is how several of JNA’s features came into being). You may even encounter other users with the same need and be able to cost share the new development.</p>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p>This library is licensed under the LGPL, version 2.1 or later, and (from version 4.0 onward) the Apache Software License, version 2.0. Commercial license arrangements are negotiable.</p>
<p><em>NOTE: Oracle is not sponsoring this project, even though the package name (com.sun.jna) might imply otherwise.</em></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-25T10:28:49.000Z">2019-09-25</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    30 分钟 读完 (大约 4448 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/25/LinkedList类/">LinkedList类</a>
            
        </h1>
        <div class="content">
            <h1 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h1><p><img src="/images/2019/09/25/2fb65570-df7f-11e9-b8a3-2dd4c9c0980e.png" alt="image.png"></p>
<pre><code class="java">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package java.util;

import java.util.function.Consumer;

/**
 * Doubly-linked list implementation of the {@code List} and {@code Deque}
 * interfaces.  Implements all optional list operations, and permits all
 * elements (including {@code null}).
 *
 * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked
 * list.  Operations that index into the list will traverse the list from
 * the beginning or the end, whichever is closer to the specified index.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a linked list concurrently, and at least
 * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more elements; merely setting the value of
 * an element is not a structural modification.)  This is typically
 * accomplished by synchronizing on some object that naturally
 * encapsulates the list.
 *
 * If no such object exists, the list should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedList Collections.synchronizedList}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the list:&lt;pre&gt;
 *   List list = Collections.synchronizedList(new LinkedList(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by this class&#39;s {@code iterator} and
 * {@code listIterator} methods are &lt;i&gt;fail-fast&lt;/i&gt;: if the list is
 * structurally modified at any time after the iterator is created, in
 * any way except through the Iterator&#39;s own {@code remove} or
 * {@code add} methods, the iterator will throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than
 * risking arbitrary, non-deterministic behavior at an undetermined
 * time in the future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw {@code ConcurrentModificationException} on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @author  Josh Bloch
 * @see     List
 * @see     ArrayList
 * @since 1.2
 * @param &lt;E&gt; the type of elements held in this collection
 */

public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
{
    transient int size = 0;

    /**
     * Pointer to first node.
     * Invariant: (first == null &amp;&amp; last == null) ||
     *            (first.prev == null &amp;&amp; first.item != null)
     */
    transient Node&lt;E&gt; first;

    /**
     * Pointer to last node.
     * Invariant: (first == null &amp;&amp; last == null) ||
     *            (last.next == null &amp;&amp; last.item != null)
     */
    transient Node&lt;E&gt; last;

    /**
     * Constructs an empty list.
     */
    public LinkedList() {
    }

    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection&#39;s
     * iterator.
     *
     * @param  c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public LinkedList(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
    }

    /**
     * Links e as first element.
     */
    private void linkFirst(E e) {
        final Node&lt;E&gt; f = first;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    }

    /**
     * Links e as last element.
     */
    void linkLast(E e) {
        final Node&lt;E&gt; l = last;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }

    /**
     * Inserts element e before non-null Node succ.
     */
    void linkBefore(E e, Node&lt;E&gt; succ) {
        // assert succ != null;
        final Node&lt;E&gt; pred = succ.prev;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }

    /**
     * Unlinks non-null first node f.
     */
    private E unlinkFirst(Node&lt;E&gt; f) {
        // assert f == first &amp;&amp; f != null;
        final E element = f.item;
        final Node&lt;E&gt; next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }

    /**
     * Unlinks non-null last node l.
     */
    private E unlinkLast(Node&lt;E&gt; l) {
        // assert l == last &amp;&amp; l != null;
        final E element = l.item;
        final Node&lt;E&gt; prev = l.prev;
        l.item = null;
        l.prev = null; // help GC
        last = prev;
        if (prev == null)
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    }

    /**
     * Unlinks non-null node x.
     */
    E unlink(Node&lt;E&gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }

    /**
     * Returns the first element in this list.
     *
     * @return the first element in this list
     * @throws NoSuchElementException if this list is empty
     */
    public E getFirst() {
        final Node&lt;E&gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }

    /**
     * Returns the last element in this list.
     *
     * @return the last element in this list
     * @throws NoSuchElementException if this list is empty
     */
    public E getLast() {
        final Node&lt;E&gt; l = last;
        if (l == null)
            throw new NoSuchElementException();
        return l.item;
    }

    /**
     * Removes and returns the first element from this list.
     *
     * @return the first element from this list
     * @throws NoSuchElementException if this list is empty
     */
    public E removeFirst() {
        final Node&lt;E&gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }

    /**
     * Removes and returns the last element from this list.
     *
     * @return the last element from this list
     * @throws NoSuchElementException if this list is empty
     */
    public E removeLast() {
        final Node&lt;E&gt; l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }

    /**
     * Inserts the specified element at the beginning of this list.
     *
     * @param e the element to add
     */
    public void addFirst(E e) {
        linkFirst(e);
    }

    /**
     * Appends the specified element to the end of this list.
     *
     * &lt;p&gt;This method is equivalent to {@link #add}.
     *
     * @param e the element to add
     */
    public void addLast(E e) {
        linkLast(e);
    }

    /**
     * Returns {@code true} if this list contains the specified element.
     * More formally, returns {@code true} if and only if this list contains
     * at least one element {@code e} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.
     *
     * @param o element whose presence in this list is to be tested
     * @return {@code true} if this list contains the specified element
     */
    public boolean contains(Object o) {
        return indexOf(o) != -1;
    }

    /**
     * Returns the number of elements in this list.
     *
     * @return the number of elements in this list
     */
    public int size() {
        return size;
    }

    /**
     * Appends the specified element to the end of this list.
     *
     * &lt;p&gt;This method is equivalent to {@link #addLast}.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        linkLast(e);
        return true;
    }

    /**
     * Removes the first occurrence of the specified element from this list,
     * if it is present.  If this list does not contain the element, it is
     * unchanged.  More formally, removes the element with the lowest index
     * {@code i} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;
     * (if such an element exists).  Returns {@code true} if this list
     * contained the specified element (or equivalently, if this list
     * changed as a result of the call).
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if this list contained the specified element
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (Node&lt;E&gt; x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node&lt;E&gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Appends all of the elements in the specified collection to the end of
     * this list, in the order that they are returned by the specified
     * collection&#39;s iterator.  The behavior of this operation is undefined if
     * the specified collection is modified while the operation is in
     * progress.  (Note that this will occur if the specified collection is
     * this list, and it&#39;s nonempty.)
     *
     * @param c collection containing elements to be added to this list
     * @return {@code true} if this list changed as a result of the call
     * @throws NullPointerException if the specified collection is null
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(size, c);
    }

    /**
     * Inserts all of the elements in the specified collection into this
     * list, starting at the specified position.  Shifts the element
     * currently at that position (if any) and any subsequent elements to
     * the right (increases their indices).  The new elements will appear
     * in the list in the order that they are returned by the
     * specified collection&#39;s iterator.
     *
     * @param index index at which to insert the first element
     *              from the specified collection
     * @param c collection containing elements to be added to this list
     * @return {@code true} if this list changed as a result of the call
     * @throws IndexOutOfBoundsException {@inheritDoc}
     * @throws NullPointerException if the specified collection is null
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        checkPositionIndex(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        Node&lt;E&gt; pred, succ;
        if (index == size) {
            succ = null;
            pred = last;
        } else {
            succ = node(index);
            pred = succ.prev;
        }

        for (Object o : a) {
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        }

        if (succ == null) {
            last = pred;
        } else {
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }

    /**
     * Removes all of the elements from this list.
     * The list will be empty after this call returns.
     */
    public void clear() {
        // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:
        // - helps a generational GC if the discarded nodes inhabit
        //   more than one generation
        // - is sure to free memory even if there is a reachable Iterator
        for (Node&lt;E&gt; x = first; x != null; ) {
            Node&lt;E&gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        first = last = null;
        size = 0;
        modCount++;
    }


    // Positional Access Operations

    /**
     * Returns the element at the specified position in this list.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     *
     * @param index index of the element to replace
     * @param element element to be stored at the specified position
     * @return the element previously at the specified position
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E set(int index, E element) {
        checkElementIndex(index);
        Node&lt;E&gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * Shifts the element currently at that position (if any) and any
     * subsequent elements to the right (adds one to their indices).
     *
     * @param index index at which the specified element is to be inserted
     * @param element element to be inserted
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    }

    /**
     * Removes the element at the specified position in this list.  Shifts any
     * subsequent elements to the left (subtracts one from their indices).
     * Returns the element that was removed from the list.
     *
     * @param index the index of the element to be removed
     * @return the element previously at the specified position
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));
    }

    /**
     * Tells if the argument is the index of an existing element.
     */
    private boolean isElementIndex(int index) {
        return index &gt;= 0 &amp;&amp; index &lt; size;
    }

    /**
     * Tells if the argument is the index of a valid position for an
     * iterator or an add operation.
     */
    private boolean isPositionIndex(int index) {
        return index &gt;= 0 &amp;&amp; index &lt;= size;
    }

    /**
     * Constructs an IndexOutOfBoundsException detail message.
     * Of the many possible refactorings of the error handling code,
     * this &quot;outlining&quot; performs best with both server and client VMs.
     */
    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
    }

    private void checkElementIndex(int index) {
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private void checkPositionIndex(int index) {
        if (!isPositionIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * Returns the (non-null) Node at the specified element index.
     */
    Node&lt;E&gt; node(int index) {
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }

    // Search Operations

    /**
     * Returns the index of the first occurrence of the specified element
     * in this list, or -1 if this list does not contain the element.
     * More formally, returns the lowest index {@code i} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,
     * or -1 if there is no such index.
     *
     * @param o element to search for
     * @return the index of the first occurrence of the specified element in
     *         this list, or -1 if this list does not contain the element
     */
    public int indexOf(Object o) {
        int index = 0;
        if (o == null) {
            for (Node&lt;E&gt; x = first; x != null; x = x.next) {
                if (x.item == null)
                    return index;
                index++;
            }
        } else {
            for (Node&lt;E&gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }

    /**
     * Returns the index of the last occurrence of the specified element
     * in this list, or -1 if this list does not contain the element.
     * More formally, returns the highest index {@code i} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,
     * or -1 if there is no such index.
     *
     * @param o element to search for
     * @return the index of the last occurrence of the specified element in
     *         this list, or -1 if this list does not contain the element
     */
    public int lastIndexOf(Object o) {
        int index = size;
        if (o == null) {
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
                index--;
                if (x.item == null)
                    return index;
            }
        } else {
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
                index--;
                if (o.equals(x.item))
                    return index;
            }
        }
        return -1;
    }

    // Queue operations.

    /**
     * Retrieves, but does not remove, the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     */
    public E peek() {
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : f.item;
    }

    /**
     * Retrieves, but does not remove, the head (first element) of this list.
     *
     * @return the head of this list
     * @throws NoSuchElementException if this list is empty
     * @since 1.5
     */
    public E element() {
        return getFirst();
    }

    /**
     * Retrieves and removes the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     */
    public E poll() {
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
    }

    /**
     * Retrieves and removes the head (first element) of this list.
     *
     * @return the head of this list
     * @throws NoSuchElementException if this list is empty
     * @since 1.5
     */
    public E remove() {
        return removeFirst();
    }

    /**
     * Adds the specified element as the tail (last element) of this list.
     *
     * @param e the element to add
     * @return {@code true} (as specified by {@link Queue#offer})
     * @since 1.5
     */
    public boolean offer(E e) {
        return add(e);
    }

    // Deque operations
    /**
     * Inserts the specified element at the front of this list.
     *
     * @param e the element to insert
     * @return {@code true} (as specified by {@link Deque#offerFirst})
     * @since 1.6
     */
    public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }

    /**
     * Inserts the specified element at the end of this list.
     *
     * @param e the element to insert
     * @return {@code true} (as specified by {@link Deque#offerLast})
     * @since 1.6
     */
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }

    /**
     * Retrieves, but does not remove, the first element of this list,
     * or returns {@code null} if this list is empty.
     *
     * @return the first element of this list, or {@code null}
     *         if this list is empty
     * @since 1.6
     */
    public E peekFirst() {
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : f.item;
     }

    /**
     * Retrieves, but does not remove, the last element of this list,
     * or returns {@code null} if this list is empty.
     *
     * @return the last element of this list, or {@code null}
     *         if this list is empty
     * @since 1.6
     */
    public E peekLast() {
        final Node&lt;E&gt; l = last;
        return (l == null) ? null : l.item;
    }

    /**
     * Retrieves and removes the first element of this list,
     * or returns {@code null} if this list is empty.
     *
     * @return the first element of this list, or {@code null} if
     *     this list is empty
     * @since 1.6
     */
    public E pollFirst() {
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
    }

    /**
     * Retrieves and removes the last element of this list,
     * or returns {@code null} if this list is empty.
     *
     * @return the last element of this list, or {@code null} if
     *     this list is empty
     * @since 1.6
     */
    public E pollLast() {
        final Node&lt;E&gt; l = last;
        return (l == null) ? null : unlinkLast(l);
    }

    /**
     * Pushes an element onto the stack represented by this list.  In other
     * words, inserts the element at the front of this list.
     *
     * &lt;p&gt;This method is equivalent to {@link #addFirst}.
     *
     * @param e the element to push
     * @since 1.6
     */
    public void push(E e) {
        addFirst(e);
    }

    /**
     * Pops an element from the stack represented by this list.  In other
     * words, removes and returns the first element of this list.
     *
     * &lt;p&gt;This method is equivalent to {@link #removeFirst()}.
     *
     * @return the element at the front of this list (which is the top
     *         of the stack represented by this list)
     * @throws NoSuchElementException if this list is empty
     * @since 1.6
     */
    public E pop() {
        return removeFirst();
    }

    /**
     * Removes the first occurrence of the specified element in this
     * list (when traversing the list from head to tail).  If the list
     * does not contain the element, it is unchanged.
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if the list contained the specified element
     * @since 1.6
     */
    public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }

    /**
     * Removes the last occurrence of the specified element in this
     * list (when traversing the list from head to tail).  If the list
     * does not contain the element, it is unchanged.
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if the list contained the specified element
     * @since 1.6
     */
    public boolean removeLastOccurrence(Object o) {
        if (o == null) {
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a list-iterator of the elements in this list (in proper
     * sequence), starting at the specified position in the list.
     * Obeys the general contract of {@code List.listIterator(int)}.&lt;p&gt;
     *
     * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally
     * modified at any time after the Iterator is created, in any way except
     * through the list-iterator&#39;s own {@code remove} or {@code add}
     * methods, the list-iterator will throw a
     * {@code ConcurrentModificationException}.  Thus, in the face of
     * concurrent modification, the iterator fails quickly and cleanly, rather
     * than risking arbitrary, non-deterministic behavior at an undetermined
     * time in the future.
     *
     * @param index index of the first element to be returned from the
     *              list-iterator (by a call to {@code next})
     * @return a ListIterator of the elements in this list (in proper
     *         sequence), starting at the specified position in the list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     * @see List#listIterator(int)
     */
    public ListIterator&lt;E&gt; listIterator(int index) {
        checkPositionIndex(index);
        return new ListItr(index);
    }

    private class ListItr implements ListIterator&lt;E&gt; {
        private Node&lt;E&gt; lastReturned;
        private Node&lt;E&gt; next;
        private int nextIndex;
        private int expectedModCount = modCount;

        ListItr(int index) {
            // assert isPositionIndex(index);
            next = (index == size) ? null : node(index);
            nextIndex = index;
        }

        public boolean hasNext() {
            return nextIndex &lt; size;
        }

        public E next() {
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();

            lastReturned = next;
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        }

        public boolean hasPrevious() {
            return nextIndex &gt; 0;
        }

        public E previous() {
            checkForComodification();
            if (!hasPrevious())
                throw new NoSuchElementException();

            lastReturned = next = (next == null) ? last : next.prev;
            nextIndex--;
            return lastReturned.item;
        }

        public int nextIndex() {
            return nextIndex;
        }

        public int previousIndex() {
            return nextIndex - 1;
        }

        public void remove() {
            checkForComodification();
            if (lastReturned == null)
                throw new IllegalStateException();

            Node&lt;E&gt; lastNext = lastReturned.next;
            unlink(lastReturned);
            if (next == lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = null;
            expectedModCount++;
        }

        public void set(E e) {
            if (lastReturned == null)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.item = e;
        }

        public void add(E e) {
            checkForComodification();
            lastReturned = null;
            if (next == null)
                linkLast(e);
            else
                linkBefore(e, next);
            nextIndex++;
            expectedModCount++;
        }

        public void forEachRemaining(Consumer&lt;? super E&gt; action) {
            Objects.requireNonNull(action);
            while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) {
                action.accept(next.item);
                lastReturned = next;
                next = next.next;
                nextIndex++;
            }
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    private static class Node&lt;E&gt; {
        E item;
        Node&lt;E&gt; next;
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }

    /**
     * @since 1.6
     */
    public Iterator&lt;E&gt; descendingIterator() {
        return new DescendingIterator();
    }

    /**
     * Adapter to provide descending iterators via ListItr.previous
     */
    private class DescendingIterator implements Iterator&lt;E&gt; {
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        public E next() {
            return itr.previous();
        }
        public void remove() {
            itr.remove();
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private LinkedList&lt;E&gt; superClone() {
        try {
            return (LinkedList&lt;E&gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }

    /**
     * Returns a shallow copy of this {@code LinkedList}. (The elements
     * themselves are not cloned.)
     *
     * @return a shallow copy of this {@code LinkedList} instance
     */
    public Object clone() {
        LinkedList&lt;E&gt; clone = superClone();

        // Put clone into &quot;virgin&quot; state
        clone.first = clone.last = null;
        clone.size = 0;
        clone.modCount = 0;

        // Initialize clone with our elements
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            clone.add(x.item);

        return clone;
    }

    /**
     * Returns an array containing all of the elements in this list
     * in proper sequence (from first to last element).
     *
     * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
     * maintained by this list.  (In other words, this method must allocate
     * a new array).  The caller is thus free to modify the returned array.
     *
     * &lt;p&gt;This method acts as bridge between array-based and collection-based
     * APIs.
     *
     * @return an array containing all of the elements in this list
     *         in proper sequence
     */
    public Object[] toArray() {
        Object[] result = new Object[size];
        int i = 0;
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            result[i++] = x.item;
        return result;
    }

    /**
     * Returns an array containing all of the elements in this list in
     * proper sequence (from first to last element); the runtime type of
     * the returned array is that of the specified array.  If the list fits
     * in the specified array, it is returned therein.  Otherwise, a new
     * array is allocated with the runtime type of the specified array and
     * the size of this list.
     *
     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,
     * the array has more elements than the list), the element in the array
     * immediately following the end of the list is set to {@code null}.
     * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if
     * the caller knows that the list does not contain any null elements.)
     *
     * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * &lt;p&gt;Suppose {@code x} is a list known to contain only strings.
     * The following code can be used to dump the list into a newly
     * allocated array of {@code String}:
     *
     * &lt;pre&gt;
     *     String[] y = x.toArray(new String[0]);&lt;/pre&gt;
     *
     * Note that {@code toArray(new Object[0])} is identical in function to
     * {@code toArray()}.
     *
     * @param a the array into which the elements of the list are to
     *          be stored, if it is big enough; otherwise, a new array of the
     *          same runtime type is allocated for this purpose.
     * @return an array containing the elements of the list
     * @throws ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in
     *         this list
     * @throws NullPointerException if the specified array is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T[] toArray(T[] a) {
        if (a.length &lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        int i = 0;
        Object[] result = a;
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            result[i++] = x.item;

        if (a.length &gt; size)
            a[size] = null;

        return a;
    }

    private static final long serialVersionUID = 876323262645176354L;

    /**
     * Saves the state of this {@code LinkedList} instance to a stream
     * (that is, serializes it).
     *
     * @serialData The size of the list (the number of elements it
     *             contains) is emitted (int), followed by all of its
     *             elements (each an Object) in the proper order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out size
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            s.writeObject(x.item);
    }

    /**
     * Reconstitutes this {@code LinkedList} instance from a stream
     * (that is, deserializes it).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i = 0; i &lt; size; i++)
            linkLast((E)s.readObject());
    }

    /**
     * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
     * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
     * list.
     *
     * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
     * {@link Spliterator#ORDERED}.  Overriding implementations should document
     * the reporting of additional characteristic values.
     *
     * @implNote
     * The {@code Spliterator} additionally reports {@link Spliterator#SUBSIZED}
     * and implements {@code trySplit} to permit limited parallelism..
     *
     * @return a {@code Spliterator} over the elements in this list
     * @since 1.8
     */
    @Override
    public Spliterator&lt;E&gt; spliterator() {
        return new LLSpliterator&lt;E&gt;(this, -1, 0);
    }

    /** A customized variant of Spliterators.IteratorSpliterator */
    static final class LLSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; {
        static final int BATCH_UNIT = 1 &lt;&lt; 10;  // batch array size increment
        static final int MAX_BATCH = 1 &lt;&lt; 25;  // max batch array size;
        final LinkedList&lt;E&gt; list; // null OK unless traversed
        Node&lt;E&gt; current;      // current node; null until initialized
        int est;              // size estimate; -1 until first needed
        int expectedModCount; // initialized when est set
        int batch;            // batch size for splits

        LLSpliterator(LinkedList&lt;E&gt; list, int est, int expectedModCount) {
            this.list = list;
            this.est = est;
            this.expectedModCount = expectedModCount;
        }

        final int getEst() {
            int s; // force initialization
            final LinkedList&lt;E&gt; lst;
            if ((s = est) &lt; 0) {
                if ((lst = list) == null)
                    s = est = 0;
                else {
                    expectedModCount = lst.modCount;
                    current = lst.first;
                    s = est = lst.size;
                }
            }
            return s;
        }

        public long estimateSize() { return (long) getEst(); }

        public Spliterator&lt;E&gt; trySplit() {
            Node&lt;E&gt; p;
            int s = getEst();
            if (s &gt; 1 &amp;&amp; (p = current) != null) {
                int n = batch + BATCH_UNIT;
                if (n &gt; s)
                    n = s;
                if (n &gt; MAX_BATCH)
                    n = MAX_BATCH;
                Object[] a = new Object[n];
                int j = 0;
                do { a[j++] = p.item; } while ((p = p.next) != null &amp;&amp; j &lt; n);
                current = p;
                batch = j;
                est = s - j;
                return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED);
            }
            return null;
        }

        public void forEachRemaining(Consumer&lt;? super E&gt; action) {
            Node&lt;E&gt; p; int n;
            if (action == null) throw new NullPointerException();
            if ((n = getEst()) &gt; 0 &amp;&amp; (p = current) != null) {
                current = null;
                est = 0;
                do {
                    E e = p.item;
                    p = p.next;
                    action.accept(e);
                } while (p != null &amp;&amp; --n &gt; 0);
            }
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

        public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
            Node&lt;E&gt; p;
            if (action == null) throw new NullPointerException();
            if (getEst() &gt; 0 &amp;&amp; (p = current) != null) {
                --est;
                E e = p.item;
                current = p.next;
                action.accept(e);
                if (list.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            }
            return false;
        }

        public int characteristics() {
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        }
    }

}</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-23T03:50:26.000Z">2019-09-23</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 9054 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/23/HashMap类/">HashMap类</a>
            
        </h1>
        <div class="content">
            <h1 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h1><p><img src="/images/2019/09/23/2728b8b0-ddb5-11e9-82dd-cd65309cd62c.png" alt="image.png"></p>
<pre><code class="java">/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.util;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import sun.misc.SharedSecrets;

/**
 * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This
 * implementation provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;
 * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
 *
 * &lt;p&gt;This implementation provides constant-time performance for the basic
 * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function
 * disperses the elements properly among the buckets.  Iteration over
 * collection views requires time proportional to the &quot;capacity&quot; of the
 * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number
 * of key-value mappings).  Thus, it&#39;s very important not to set the initial
 * capacity too high (or the load factor too low) if iteration performance is
 * important.
 *
 * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its
 * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
 * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
 * capacity is simply the capacity at the time the hash table is created.  The
 * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
 * get before its capacity is automatically increased.  When the number of
 * entries in the hash table exceeds the product of the load factor and the
 * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
 * structures are rebuilt) so that the hash table has approximately twice the
 * number of buckets.
 *
 * &lt;p&gt;As a general rule, the default load factor (.75) offers a good
 * tradeoff between time and space costs.  Higher values decrease the
 * space overhead but increase the lookup cost (reflected in most of
 * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including
 * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in
 * the map and its load factor should be taken into account when
 * setting its initial capacity, so as to minimize the number of
 * rehash operations.  If the initial capacity is greater than the
 * maximum number of entries divided by the load factor, no rehash
 * operations will ever occur.
 *
 * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;
 * instance, creating it with a sufficiently large capacity will allow
 * the mappings to be stored more efficiently than letting it perform
 * automatic rehashing as needed to grow the table.  Note that using
 * many keys with the same {@code hashCode()} is a sure way to slow
 * down performance of any hash table. To ameliorate impact, when keys
 * are {@link Comparable}, this class may use comparison order among
 * keys to help break ties.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a hash map concurrently, and at least one of
 * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map:&lt;pre&gt;
 *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by all of this class&#39;s &quot;collection view methods&quot;
 * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator&#39;s own
 * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 *
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {

    private static final long serialVersionUID = 362498820763181265L;

    /*
     * Implementation notes.
     *
     * This map usually acts as a binned (bucketed) hash table, but
     * when bins get too large, they are transformed into bins of
     * TreeNodes, each structured similarly to those in
     * java.util.TreeMap. Most methods try to use normal bins, but
     * relay to TreeNode methods when applicable (simply by checking
     * instanceof a node).  Bins of TreeNodes may be traversed and
     * used like any others, but additionally support faster lookup
     * when overpopulated. However, since the vast majority of bins in
     * normal use are not overpopulated, checking for existence of
     * tree bins may be delayed in the course of table methods.
     *
     * Tree bins (i.e., bins whose elements are all TreeNodes) are
     * ordered primarily by hashCode, but in the case of ties, if two
     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
     * type then their compareTo method is used for ordering. (We
     * conservatively check generic types via reflection to validate
     * this -- see method comparableClassFor).  The added complexity
     * of tree bins is worthwhile in providing worst-case O(log n)
     * operations when keys either have distinct hashes or are
     * orderable, Thus, performance degrades gracefully under
     * accidental or malicious usages in which hashCode() methods
     * return values that are poorly distributed, as well as those in
     * which many keys share a hashCode, so long as they are also
     * Comparable. (If neither of these apply, we may waste about a
     * factor of two in time and space compared to taking no
     * precautions. But the only known cases stem from poor user
     * programming practices that are already so slow that this makes
     * little difference.)
     *
     * Because TreeNodes are about twice the size of regular nodes, we
     * use them only when bins contain enough nodes to warrant use
     * (see TREEIFY_THRESHOLD). And when they become too small (due to
     * removal or resizing) they are converted back to plain bins.  In
     * usages with well-distributed user hashCodes, tree bins are
     * rarely used.  Ideally, under random hashCodes, the frequency of
     * nodes in bins follows a Poisson distribution
     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
     * parameter of about 0.5 on average for the default resizing
     * threshold of 0.75, although with a large variance because of
     * resizing granularity. Ignoring variance, the expected
     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
     * factorial(k)). The first values are:
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: less than 1 in ten million
     *
     * The root of a tree bin is normally its first node.  However,
     * sometimes (currently only upon Iterator.remove), the root might
     * be elsewhere, but can be recovered following parent links
     * (method TreeNode.root()).
     *
     * All applicable internal methods accept a hash code as an
     * argument (as normally supplied from a public method), allowing
     * them to call each other without recomputing user hashCodes.
     * Most internal methods also accept a &quot;tab&quot; argument, that is
     * normally the current table, but may be a new or old one when
     * resizing or converting.
     *
     * When bin lists are treeified, split, or untreeified, we keep
     * them in the same relative access/traversal order (i.e., field
     * Node.next) to better preserve locality, and to slightly
     * simplify handling of splits and traversals that invoke
     * iterator.remove. When using comparators on insertion, to keep a
     * total ordering (or as close as is required here) across
     * rebalancings, we compare classes and identityHashCodes as
     * tie-breakers.
     *
     * The use and transitions among plain vs tree modes is
     * complicated by the existence of subclass LinkedHashMap. See
     * below for hook methods defined to be invoked upon insertion,
     * removal and access that allow LinkedHashMap internals to
     * otherwise remain independent of these mechanics. (This also
     * requires that a map instance be passed to some utility methods
     * that may create new nodes.)
     *
     * The concurrent-programming-like SSA-based coding style helps
     * avoid aliasing errors amid all of the twisty pointer operations.
     */

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * The smallest table capacity for which bins may be treeified.
     * (Otherwise the table is resized if too many nodes in a bin.)
     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
     * between resizing and treeification thresholds.
     */
    static final int MIN_TREEIFY_CAPACITY = 64;

    /**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }

    /* ---------------- Static utilities -------------- */

    /**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don&#39;t benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }

    /**
     * Returns x&#39;s Class if it is of the form &quot;class C implements
     * Comparable&lt;C&gt;&quot;, else null.
     */
    static Class&lt;?&gt; comparableClassFor(Object x) {
        if (x instanceof Comparable) {
            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;
            if ((c = x.getClass()) == String.class) // bypass checks
                return c;
            if ((ts = c.getGenericInterfaces()) != null) {
                for (int i = 0; i &lt; ts.length; ++i) {
                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;
                        ((p = (ParameterizedType)t).getRawType() ==
                         Comparable.class) &amp;&amp;
                        (as = p.getActualTypeArguments()) != null &amp;&amp;
                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c
                        return c;
                }
            }
        }
        return null;
    }

    /**
     * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable
     * class), else 0.
     */
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable
    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {
        return (x == null || x.getClass() != kc ? 0 :
                ((Comparable)k).compareTo(x));
    }

    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

    /* ---------------- Fields -------------- */

    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     */
    transient Node&lt;K,V&gt;[] table;

    /**
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     */
    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

    /**
     * The number of key-value mappings contained in this map.
     */
    transient int size;

    /**
     * The number of times this HashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the HashMap or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the HashMap fail-fast.  (See ConcurrentModificationException).
     */
    transient int modCount;

    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    // (The javadoc description is true upon serialization.
    // Additionally, if the table array has not been allocated, this
    // field holds the initial array capacity, or zero signifying
    // DEFAULT_INITIAL_CAPACITY.)
    int threshold;

    /**
     * The load factor for the hash table.
     *
     * @serial
     */
    final float loadFactor;

    /* ---------------- Public operations -------------- */

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    /**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }

    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
        int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
        return size;
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise
     * it returns {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it&#39;s also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the
     * specified key.
     *
     * @param   key   The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     */
    public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;
    }

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don&#39;t change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
    final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

    /**
     * Replaces all linked nodes in bin at index for given hash unless
     * table is too small, in which case resizes instead.
     */
    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
        int n, index; Node&lt;K,V&gt; e;
        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
            TreeNode&lt;K,V&gt; hd = null, tl = null;
            do {
                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     * @throws NullPointerException if the specified map is null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        putMapEntries(m, true);
    }

    /**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param  key key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }

    /**
     * Implements Map.remove and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to match if matchValue, else ignored
     * @param matchValue if true only remove if value is equal
     * @param movable if false do not move other nodes while removing
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
            Node&lt;K,V&gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                if (p instanceof TreeNode)
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                else {
                    do {
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */
    public void clear() {
        Node&lt;K,V&gt;[] tab;
        modCount++;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            size = 0;
            for (int i = 0; i &lt; tab.length; ++i)
                tab[i] = null;
        }
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     * specified value.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     *         specified value
     */
    public boolean containsValue(Object value) {
        Node&lt;K,V&gt;[] tab; V v;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    if ((v = e.value) == value ||
                        (value != null &amp;&amp; value.equals(v)))
                        return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
     * the iteration are undefined.  The set supports element removal,
     * which removes the corresponding mapping from the map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
     * operations.
     *
     * @return a set view of the keys contained in this map
     */
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        if (ks == null) {
            ks = new KeySet();
            keySet = ks;
        }
        return ks;
    }

    final class KeySet extends AbstractSet&lt;K&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
        public final boolean contains(Object o) { return containsKey(o); }
        public final boolean remove(Object key) {
            return removeNode(hash(key), key, null, false, true) != null;
        }
        public final Spliterator&lt;K&gt; spliterator() {
            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super K&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e.key);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress
     * (except through the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation),
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a view of the values contained in this map
     */
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        if (vs == null) {
            vs = new Values();
            values = vs;
        }
        return vs;
    }

    final class Values extends AbstractCollection&lt;V&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
        public final boolean contains(Object o) { return containsValue(o); }
        public final Spliterator&lt;V&gt; spliterator() {
            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super V&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e.value);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a set view of the mappings contained in this map
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
    }

    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new EntryIterator();
        }
        public final boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
            Object key = e.getKey();
            Node&lt;K,V&gt; candidate = getNode(hash(key), key);
            return candidate != null &amp;&amp; candidate.equals(e);
        }
        public final boolean remove(Object o) {
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
                Object key = e.getKey();
                Object value = e.getValue();
                return removeNode(hash(key), key, value, true, true) != null;
            }
            return false;
        }
        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    // Overrides of JDK8 Map extension methods

    @Override
    public V getOrDefault(Object key, V defaultValue) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;
    }

    @Override
    public V putIfAbsent(K key, V value) {
        return putVal(hash(key), key, value, true, true);
    }

    @Override
    public boolean remove(Object key, Object value) {
        return removeNode(hash(key), key, value, true, true) != null;
    }

    @Override
    public boolean replace(K key, V oldValue, V newValue) {
        Node&lt;K,V&gt; e; V v;
        if ((e = getNode(hash(key), key)) != null &amp;&amp;
            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {
            e.value = newValue;
            afterNodeAccess(e);
            return true;
        }
        return false;
    }

    @Override
    public V replace(K key, V value) {
        Node&lt;K,V&gt; e;
        if ((e = getNode(hash(key), key)) != null) {
            V oldValue = e.value;
            e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
        return null;
    }

    @Override
    public V computeIfAbsent(K key,
                             Function&lt;? super K, ? extends V&gt; mappingFunction) {
        if (mappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
            V oldValue;
            if (old != null &amp;&amp; (oldValue = old.value) != null) {
                afterNodeAccess(old);
                return oldValue;
            }
        }
        V v = mappingFunction.apply(key);
        if (v == null) {
            return null;
        } else if (old != null) {
            old.value = v;
            afterNodeAccess(old);
            return v;
        }
        else if (t != null)
            t.putTreeVal(this, tab, hash, key, v);
        else {
            tab[i] = newNode(hash, key, v, first);
            if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                treeifyBin(tab, hash);
        }
        ++modCount;
        ++size;
        afterNodeInsertion(true);
        return v;
    }

    public V computeIfPresent(K key,
                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
        if (remappingFunction == null)
            throw new NullPointerException();
        Node&lt;K,V&gt; e; V oldValue;
        int hash = hash(key);
        if ((e = getNode(hash, key)) != null &amp;&amp;
            (oldValue = e.value) != null) {
            V v = remappingFunction.apply(key, oldValue);
            if (v != null) {
                e.value = v;
                afterNodeAccess(e);
                return v;
            }
            else
                removeNode(hash, key, null, false, true);
        }
        return null;
    }

    @Override
    public V compute(K key,
                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
        if (remappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
        }
        V oldValue = (old == null) ? null : old.value;
        V v = remappingFunction.apply(key, oldValue);
        if (old != null) {
            if (v != null) {
                old.value = v;
                afterNodeAccess(old);
            }
            else
                removeNode(hash, key, null, false, true);
        }
        else if (v != null) {
            if (t != null)
                t.putTreeVal(this, tab, hash, key, v);
            else {
                tab[i] = newNode(hash, key, v, first);
                if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                    treeifyBin(tab, hash);
            }
            ++modCount;
            ++size;
            afterNodeInsertion(true);
        }
        return v;
    }

    @Override
    public V merge(K key, V value,
                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
        if (value == null)
            throw new NullPointerException();
        if (remappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
        }
        if (old != null) {
            V v;
            if (old.value != null)
                v = remappingFunction.apply(old.value, value);
            else
                v = value;
            if (v != null) {
                old.value = v;
                afterNodeAccess(old);
            }
            else
                removeNode(hash, key, null, false, true);
            return v;
        }
        if (value != null) {
            if (t != null)
                t.putTreeVal(this, tab, hash, key, value);
            else {
                tab[i] = newNode(hash, key, value, first);
                if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                    treeifyBin(tab, hash);
            }
            ++modCount;
            ++size;
            afterNodeInsertion(true);
        }
        return value;
    }

    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Node&lt;K,V&gt;[] tab;
        if (action == null)
            throw new NullPointerException();
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            int mc = modCount;
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                    action.accept(e.key, e.value);
            }
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }

    @Override
    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
        Node&lt;K,V&gt;[] tab;
        if (function == null)
            throw new NullPointerException();
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            int mc = modCount;
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    e.value = function.apply(e.key, e.value);
                }
            }
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }

    /* ------------------------------------------------------------ */
    // Cloning and serialization

    /**
     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and
     * values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Object clone() {
        HashMap&lt;K,V&gt; result;
        try {
            result = (HashMap&lt;K,V&gt;)super.clone();
        } catch (CloneNotSupportedException e) {
            // this shouldn&#39;t happen, since we are Cloneable
            throw new InternalError(e);
        }
        result.reinitialize();
        result.putMapEntries(this, false);
        return result;
    }

    // These methods are also used when serializing HashSets
    final float loadFactor() { return loadFactor; }
    final int capacity() {
        return (table != null) ? table.length :
            (threshold &gt; 0) ? threshold :
            DEFAULT_INITIAL_CAPACITY;
    }

    /**
     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
     *             bucket array) is emitted (int), followed by the
     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
     *             mappings), followed by the key (Object) and value (Object)
     *             for each key-value mapping.  The key-value mappings are
     *             emitted in no particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
        int buckets = capacity();
        // Write out the threshold, loadfactor, and any hidden stuff
        s.defaultWriteObject();
        s.writeInt(buckets);
        s.writeInt(size);
        internalWriteEntries(s);
    }

    /**
     * Reconstitute the {@code HashMap} instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        // Read in the threshold (ignored), loadfactor, and any hidden stuff
        s.defaultReadObject();
        reinitialize();
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                             loadFactor);
        s.readInt();                // Read and ignore number of buckets
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings &lt; 0)
            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                             mappings);
        else if (mappings &gt; 0) { // (if zero, use defaults)
            // Size the table using given load factor only if within
            // range of 0.25...4.0
            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
            float fc = (float)mappings / lf + 1.0f;
            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
                       DEFAULT_INITIAL_CAPACITY :
                       (fc &gt;= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
                       tableSizeFor((int)fc));
            float ft = (float)cap * lf;
            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
                         (int)ft : Integer.MAX_VALUE);

            // Check Map.Entry[].class since it&#39;s the nearest public type to
            // what we&#39;re actually creating.
            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);
            @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
            table = tab;

            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i &lt; mappings; i++) {
                @SuppressWarnings(&quot;unchecked&quot;)
                    K key = (K) s.readObject();
                @SuppressWarnings(&quot;unchecked&quot;)
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
        }
    }

    /* ------------------------------------------------------------ */
    // iterators

    abstract class HashIterator {
        Node&lt;K,V&gt; next;        // next entry to return
        Node&lt;K,V&gt; current;     // current entry
        int expectedModCount;  // for fast-fail
        int index;             // current slot

        HashIterator() {
            expectedModCount = modCount;
            Node&lt;K,V&gt;[] t = table;
            current = next = null;
            index = 0;
            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry
                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
            }
        }

        public final boolean hasNext() {
            return next != null;
        }

        final Node&lt;K,V&gt; nextNode() {
            Node&lt;K,V&gt;[] t;
            Node&lt;K,V&gt; e = next;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (e == null)
                throw new NoSuchElementException();
            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {
                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
            }
            return e;
        }

        public final void remove() {
            Node&lt;K,V&gt; p = current;
            if (p == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            current = null;
            K key = p.key;
            removeNode(hash(key), key, null, false, false);
            expectedModCount = modCount;
        }
    }

    final class KeyIterator extends HashIterator
        implements Iterator&lt;K&gt; {
        public final K next() { return nextNode().key; }
    }

    final class ValueIterator extends HashIterator
        implements Iterator&lt;V&gt; {
        public final V next() { return nextNode().value; }
    }

    final class EntryIterator extends HashIterator
        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }
    }

    /* ------------------------------------------------------------ */
    // spliterators

    static class HashMapSpliterator&lt;K,V&gt; {
        final HashMap&lt;K,V&gt; map;
        Node&lt;K,V&gt; current;          // current node
        int index;                  // current index, modified on advance/split
        int fence;                  // one past last index
        int est;                    // size estimate
        int expectedModCount;       // for comodification checks

        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,
                           int fence, int est,
                           int expectedModCount) {
            this.map = m;
            this.index = origin;
            this.fence = fence;
            this.est = est;
            this.expectedModCount = expectedModCount;
        }

        final int getFence() { // initialize fence and size on first use
            int hi;
            if ((hi = fence) &lt; 0) {
                HashMap&lt;K,V&gt; m = map;
                est = m.size;
                expectedModCount = m.modCount;
                Node&lt;K,V&gt;[] tab = m.table;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            return hi;
        }

        public final long estimateSize() {
            getFence(); // force init
            return (long) est;
        }
    }

    static final class KeySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                       int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public KeySpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                        expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p.key);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        K k = current.key;
                        current = current.next;
                        action.accept(k);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
                Spliterator.DISTINCT;
        }
    }

    static final class ValueSpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;V&gt; {
        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public ValueSpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p.value);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        V v = current.value;
                        current = current.next;
                        action.accept(v);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);
        }
    }

    static final class EntrySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public EntrySpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        Node&lt;K,V&gt; e = current;
                        current = current.next;
                        action.accept(e);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
                Spliterator.DISTINCT;
        }
    }

    /* ------------------------------------------------------------ */
    // LinkedHashMap support


    /*
     * The following package-protected methods are designed to be
     * overridden by LinkedHashMap, but not by any other subclass.
     * Nearly all other internal methods are also package-protected
     * but are declared final, so can be used by LinkedHashMap, view
     * classes, and HashSet.
     */

    // Create a regular (non-tree) node
    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
        return new Node&lt;&gt;(hash, key, value, next);
    }

    // For conversion from TreeNodes to plain nodes
    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
        return new Node&lt;&gt;(p.hash, p.key, p.value, next);
    }

    // Create a tree bin node
    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
        return new TreeNode&lt;&gt;(hash, key, value, next);
    }

    // For treeifyBin
    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);
    }

    /**
     * Reset to initial default state.  Called by clone and readObject.
     */
    void reinitialize() {
        table = null;
        entrySet = null;
        keySet = null;
        values = null;
        modCount = 0;
        threshold = 0;
        size = 0;
    }

    // Callbacks to allow LinkedHashMap post-actions
    void afterNodeAccess(Node&lt;K,V&gt; p) { }
    void afterNodeInsertion(boolean evict) { }
    void afterNodeRemoval(Node&lt;K,V&gt; p) { }

    // Called only from writeObject, to ensure compatible ordering.
    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {
        Node&lt;K,V&gt;[] tab;
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    s.writeObject(e.key);
                    s.writeObject(e.value);
                }
            }
        }
    }

    /* ------------------------------------------------------------ */
    // Tree bins

    /**
     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn
     * extends Node) so can be used as extension of either regular or
     * linked node.
     */
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
            super(hash, key, val, next);
        }

        /**
         * Returns root of tree containing this node.
         */
        final TreeNode&lt;K,V&gt; root() {
            for (TreeNode&lt;K,V&gt; r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
            }
        }

        /**
         * Ensures that the given root is the first node of its bin.
         */
        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
            int n;
            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {
                int index = (n - 1) &amp; root.hash;
                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];
                if (root != first) {
                    Node&lt;K,V&gt; rn;
                    tab[index] = root;
                    TreeNode&lt;K,V&gt; rp = root.prev;
                    if ((rn = root.next) != null)
                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;
                    if (rp != null)
                        rp.next = rn;
                    if (first != null)
                        first.prev = root;
                    root.next = first;
                    root.prev = null;
                }
                assert checkInvariants(root);
            }
        }

        /**
         * Finds the node starting at root p with the given hash and key.
         * The kc argument caches comparableClassFor(key) upon first use
         * comparing keys.
         */
        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
            TreeNode&lt;K,V&gt; p = this;
            do {
                int ph, dir; K pk;
                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;
                if ((ph = p.hash) &gt; h)
                    p = pl;
                else if (ph &lt; h)
                    p = pr;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;
                else if (pl == null)
                    p = pr;
                else if (pr == null)
                    p = pl;
                else if ((kc != null ||
                          (kc = comparableClassFor(k)) != null) &amp;&amp;
                         (dir = compareComparables(kc, k, pk)) != 0)
                    p = (dir &lt; 0) ? pl : pr;
                else if ((q = pr.find(h, k, kc)) != null)
                    return q;
                else
                    p = pl;
            } while (p != null);
            return null;
        }

        /**
         * Calls find for root node.
         */
        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
            return ((parent != null) ? root() : this).find(h, k, null);
        }

        /**
         * Tie-breaking utility for ordering insertions when equal
         * hashCodes and non-comparable. We don&#39;t require a total
         * order, just a consistent insertion rule to maintain
         * equivalence across rebalancings. Tie-breaking further than
         * necessary simplifies testing a bit.
         */
        static int tieBreakOrder(Object a, Object b) {
            int d;
            if (a == null || b == null ||
                (d = a.getClass().getName().
                 compareTo(b.getClass().getName())) == 0)
                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?
                     -1 : 1);
            return d;
        }

        /**
         * Forms tree of the nodes linked from this node.
         * @return root of tree
         */
        final void treeify(Node&lt;K,V&gt;[] tab) {
            TreeNode&lt;K,V&gt; root = null;
            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {
                next = (TreeNode&lt;K,V&gt;)x.next;
                x.left = x.right = null;
                if (root == null) {
                    x.parent = null;
                    x.red = false;
                    root = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&lt;?&gt; kc = null;
                    for (TreeNode&lt;K,V&gt; p = root;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &gt; h)
                            dir = -1;
                        else if (ph &lt; h)
                            dir = 1;
                        else if ((kc == null &amp;&amp;
                                  (kc = comparableClassFor(k)) == null) ||
                                 (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);

                        TreeNode&lt;K,V&gt; xp = p;
                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir &lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            root = balanceInsertion(root, x);
                            break;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);
        }

        /**
         * Returns a list of non-TreeNodes replacing those linked from
         * this node.
         */
        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
            Node&lt;K,V&gt; hd = null, tl = null;
            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {
                Node&lt;K,V&gt; p = map.replacementNode(q, null);
                if (tl == null)
                    hd = p;
                else
                    tl.next = p;
                tl = p;
            }
            return hd;
        }

        /**
         * Tree version of putVal.
         */
        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                       int h, K k, V v) {
            Class&lt;?&gt; kc = null;
            boolean searched = false;
            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;
            for (TreeNode&lt;K,V&gt; p = root;;) {
                int dir, ph; K pk;
                if ((ph = p.hash) &gt; h)
                    dir = -1;
                else if (ph &lt; h)
                    dir = 1;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;
                else if ((kc == null &amp;&amp;
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = true;
                        if (((ch = p.left) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null) ||
                            ((ch = p.right) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null))
                            return q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    if (dir &lt;= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    if (xpn != null)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    return null;
                }
            }
        }

        /**
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by &quot;next&quot; pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         */
        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                  boolean movable) {
            int n;
            if (tab == null || (n = tab.length) == 0)
                return;
            int index = (n - 1) &amp; hash;
            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;
            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;
            if (pred == null)
                tab[index] = first = succ;
            else
                pred.next = succ;
            if (succ != null)
                succ.prev = pred;
            if (first == null)
                return;
            if (root.parent != null)
                root = root.root();
            if (root == null || root.right == null ||
                (rl = root.left) == null || rl.left == null) {
                tab[index] = first.untreeify(map);  // too small
                return;
            }
            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;
            if (pl != null &amp;&amp; pr != null) {
                TreeNode&lt;K,V&gt; s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode&lt;K,V&gt; sr = s.right;
                TreeNode&lt;K,V&gt; pp = p.parent;
                if (s == pr) { // p was s&#39;s direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode&lt;K,V&gt; sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                if (sr != null)
                    replacement = sr;
                else
                    replacement = p;
            }
            else if (pl != null)
                replacement = pl;
            else if (pr != null)
                replacement = pr;
            else
                replacement = p;
            if (replacement != p) {
                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }

            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);

            if (replacement == p) {  // detach
                TreeNode&lt;K,V&gt; pp = p.parent;
                p.parent = null;
                if (pp != null) {
                    if (p == pp.left)
                        pp.left = null;
                    else if (p == pp.right)
                        pp.right = null;
                }
            }
            if (movable)
                moveRootToFront(tab, r);
        }

        /**
         * Splits nodes in a tree bin into lower and upper tree bins,
         * or untreeifies if now too small. Called only from resize;
         * see above discussion about split bits and indices.
         *
         * @param map the map
         * @param tab the table for recording bin heads
         * @param index the index of the table being split
         * @param bit the bit of hash to split on
         */
        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
            TreeNode&lt;K,V&gt; b = this;
            // Relink into lo and hi lists, preserving order
            TreeNode&lt;K,V&gt; loHead = null, loTail = null;
            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;
            int lc = 0, hc = 0;
            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {
                next = (TreeNode&lt;K,V&gt;)e.next;
                e.next = null;
                if ((e.hash &amp; bit) == 0) {
                    if ((e.prev = loTail) == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                    ++lc;
                }
                else {
                    if ((e.prev = hiTail) == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                    ++hc;
                }
            }

            if (loHead != null) {
                if (lc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index] = loHead.untreeify(map);
                else {
                    tab[index] = loHead;
                    if (hiHead != null) // (else is already treeified)
                        loHead.treeify(tab);
                }
            }
            if (hiHead != null) {
                if (hc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
            }
        }

        /* ------------------------------------------------------------ */
        // Red-black tree methods, all adapted from CLR

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
                                              TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; r, pp, rl;
            if (p != null &amp;&amp; (r = p.right) != null) {
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                if ((pp = r.parent = p.parent) == null)
                    (root = r).red = false;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
            return root;
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
                                               TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; l, pp, lr;
            if (p != null &amp;&amp; (l = p.left) != null) {
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent) == null)
                    (root = l).red = false;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                                    TreeNode&lt;K,V&gt; x) {
            x.red = true;
            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
                if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null)
                    return root;
                if (xp == (xppl = xpp.left)) {
                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {
                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null &amp;&amp; xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,
                                                   TreeNode&lt;K,V&gt; x) {
            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  {
                if (x == null || x == root)
                    return root;
                else if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (x.red) {
                    x.red = false;
                    return root;
                }
                else if ((xpl = xp.left) == x) {
                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) {
                        xpr.red = false;
                        xp.red = true;
                        root = rotateLeft(root, xp);
                        xpr = (xp = x.parent) == null ? null : xp.right;
                    }
                    if (xpr == null)
                        x = xp;
                    else {
                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;
                        if ((sr == null || !sr.red) &amp;&amp;
                            (sl == null || !sl.red)) {
                            xpr.red = true;
                            x = xp;
                        }
                        else {
                            if (sr == null || !sr.red) {
                                if (sl != null)
                                    sl.red = false;
                                xpr.red = true;
                                root = rotateRight(root, xpr);
                                xpr = (xp = x.parent) == null ?
                                    null : xp.right;
                            }
                            if (xpr != null) {
                                xpr.red = (xp == null) ? false : xp.red;
                                if ((sr = xpr.right) != null)
                                    sr.red = false;
                            }
                            if (xp != null) {
                                xp.red = false;
                                root = rotateLeft(root, xp);
                            }
                            x = root;
                        }
                    }
                }
                else { // symmetric
                    if (xpl != null &amp;&amp; xpl.red) {
                        xpl.red = false;
                        xp.red = true;
                        root = rotateRight(root, xp);
                        xpl = (xp = x.parent) == null ? null : xp.left;
                    }
                    if (xpl == null)
                        x = xp;
                    else {
                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;
                        if ((sl == null || !sl.red) &amp;&amp;
                            (sr == null || !sr.red)) {
                            xpl.red = true;
                            x = xp;
                        }
                        else {
                            if (sl == null || !sl.red) {
                                if (sr != null)
                                    sr.red = false;
                                xpl.red = true;
                                root = rotateLeft(root, xpl);
                                xpl = (xp = x.parent) == null ?
                                    null : xp.left;
                            }
                            if (xpl != null) {
                                xpl.red = (xp == null) ? false : xp.red;
                                if ((sl = xpl.left) != null)
                                    sl.red = false;
                            }
                            if (xp != null) {
                                xp.red = false;
                                root = rotateRight(root, xp);
                            }
                            x = root;
                        }
                    }
                }
            }
        }

        /**
         * Recursive invariant check
         */
        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {
            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,
                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
            if (tb != null &amp;&amp; tb.next != t)
                return false;
            if (tn != null &amp;&amp; tn.prev != t)
                return false;
            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
                return false;
            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
                return false;
            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
                return false;
            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
                return false;
            if (tl != null &amp;&amp; !checkInvariants(tl))
                return false;
            if (tr != null &amp;&amp; !checkInvariants(tr))
                return false;
            return true;
        }
    }

}
</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-21T11:00:03.000Z">2019-09-21</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8837 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/21/BigInteger类/">BigInteger类</a>
            
        </h1>
        <div class="content">
            <h1 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h1><p><img src="/images/2019/09/21/f1ae7690-dc5e-11e9-8024-c70d44c51336.png" alt="image.png"></p>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package java.math;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.io.StreamCorruptedException;
import java.io.ObjectInputStream.GetField;
import java.io.ObjectOutputStream.PutField;
import java.util.Arrays;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import jdk.internal.HotSpotIntrinsicCandidate;
import jdk.internal.misc.Unsafe;

public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; {
    final int signum;
    final int[] mag;
    private int bitCountPlusOne;
    private int bitLengthPlusOne;
    private int lowestSetBitPlusTwo;
    private int firstNonzeroIntNumPlusTwo;
    static final long LONG_MASK = 4294967295L;
    private static final int MAX_MAG_LENGTH = 67108864;
    private static final int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;
    private static final int KARATSUBA_THRESHOLD = 80;
    private static final int TOOM_COOK_THRESHOLD = 240;
    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;
    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;
    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;
    static final int BURNIKEL_ZIEGLER_OFFSET = 40;
    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;
    private static final int MULTIPLY_SQUARE_THRESHOLD = 20;
    private static final int MONTGOMERY_INTRINSIC_THRESHOLD = 512;
    private static long[] bitsPerDigit = new long[]{0L, 0L, 1024L, 1624L, 2048L, 2378L, 2648L, 2875L, 3072L, 3247L, 3402L, 3543L, 3672L, 3790L, 3899L, 4001L, 4096L, 4186L, 4271L, 4350L, 4426L, 4498L, 4567L, 4633L, 4696L, 4756L, 4814L, 4870L, 4923L, 4975L, 5025L, 5074L, 5120L, 5166L, 5210L, 5253L, 5295L};
    private static final int SMALL_PRIME_THRESHOLD = 95;
    private static final int DEFAULT_PRIME_CERTAINTY = 100;
    private static final BigInteger SMALL_PRIME_PRODUCT = valueOf(152125131763605L);
    private static final int MAX_CONSTANT = 16;
    private static BigInteger[] posConst = new BigInteger[17];
    private static BigInteger[] negConst = new BigInteger[17];
    private static volatile BigInteger[][] powerCache;
    private static final double[] logCache;
    private static final double LOG_TWO = Math.log(2.0D);
    public static final BigInteger ZERO;
    public static final BigInteger ONE;
    public static final BigInteger TWO;
    private static final BigInteger NEGATIVE_ONE;
    public static final BigInteger TEN;
    static int[] bnExpModThreshTable;
    private static String[] zeros;
    private static int[] digitsPerLong;
    private static BigInteger[] longRadix;
    private static int[] digitsPerInt;
    private static int[] intRadix;
    private static final long serialVersionUID = -8287574255936472291L;
    private static final ObjectStreamField[] serialPersistentFields;

    public BigInteger(byte[] val, int off, int len) {
        if (val.length == 0) {
            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
        } else {
            Objects.checkFromIndexSize(off, len, val.length);
            if (val[off] &lt; 0) {
                this.mag = makePositive(val, off, len);
                this.signum = -1;
            } else {
                this.mag = stripLeadingZeroBytes(val, off, len);
                this.signum = this.mag.length == 0 ? 0 : 1;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    public BigInteger(byte[] val) {
        this((byte[])val, 0, val.length);
    }

    private BigInteger(int[] val) {
        if (val.length == 0) {
            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
        } else {
            if (val[0] &lt; 0) {
                this.mag = makePositive(val);
                this.signum = -1;
            } else {
                this.mag = trustedStripLeadingZeroInts(val);
                this.signum = this.mag.length == 0 ? 0 : 1;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    public BigInteger(int signum, byte[] magnitude, int off, int len) {
        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) {
            Objects.checkFromIndexSize(off, len, magnitude.length);
            this.mag = stripLeadingZeroBytes(magnitude, off, len);
            if (this.mag.length == 0) {
                this.signum = 0;
            } else {
                if (signum == 0) {
                    throw new NumberFormatException(&quot;signum-magnitude mismatch&quot;);
                }

                this.signum = signum;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        } else {
            throw new NumberFormatException(&quot;Invalid signum value&quot;);
        }
    }

    public BigInteger(int signum, byte[] magnitude) {
        this(signum, magnitude, 0, magnitude.length);
    }

    private BigInteger(int signum, int[] magnitude) {
        this.mag = stripLeadingZeroInts(magnitude);
        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) {
            if (this.mag.length == 0) {
                this.signum = 0;
            } else {
                if (signum == 0) {
                    throw new NumberFormatException(&quot;signum-magnitude mismatch&quot;);
                }

                this.signum = signum;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        } else {
            throw new NumberFormatException(&quot;Invalid signum value&quot;);
        }
    }

    public BigInteger(String val, int radix) {
        int cursor = 0;
        int len = val.length();
        if (radix &gt;= 2 &amp;&amp; radix &lt;= 36) {
            if (len == 0) {
                throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
            } else {
                int sign = 1;
                int index1 = val.lastIndexOf(45);
                int index2 = val.lastIndexOf(43);
                if (index1 &gt;= 0) {
                    if (index1 != 0 || index2 &gt;= 0) {
                        throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);
                    }

                    sign = -1;
                    cursor = 1;
                } else if (index2 &gt;= 0) {
                    if (index2 != 0) {
                        throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);
                    }

                    cursor = 1;
                }

                if (cursor == len) {
                    throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
                } else {
                    while(cursor &lt; len &amp;&amp; Character.digit(val.charAt(cursor), radix) == 0) {
                        ++cursor;
                    }

                    if (cursor == len) {
                        this.signum = 0;
                        this.mag = ZERO.mag;
                    } else {
                        int numDigits = len - cursor;
                        this.signum = sign;
                        long numBits = ((long)numDigits * bitsPerDigit[radix] &gt;&gt;&gt; 10) + 1L;
                        if (numBits + 31L &gt;= 4294967296L) {
                            reportOverflow();
                        }

                        int numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;
                        int[] magnitude = new int[numWords];
                        int firstGroupLen = numDigits % digitsPerInt[radix];
                        if (firstGroupLen == 0) {
                            firstGroupLen = digitsPerInt[radix];
                        }

                        String group = val.substring(cursor, cursor += firstGroupLen);
                        magnitude[numWords - 1] = Integer.parseInt(group, radix);
                        if (magnitude[numWords - 1] &lt; 0) {
                            throw new NumberFormatException(&quot;Illegal digit&quot;);
                        } else {
                            int superRadix = intRadix[radix];
                            boolean var16 = false;

                            while(cursor &lt; len) {
                                group = val.substring(cursor, cursor += digitsPerInt[radix]);
                                int groupVal = Integer.parseInt(group, radix);
                                if (groupVal &lt; 0) {
                                    throw new NumberFormatException(&quot;Illegal digit&quot;);
                                }

                                destructiveMulAdd(magnitude, superRadix, groupVal);
                            }

                            this.mag = trustedStripLeadingZeroInts(magnitude);
                            if (this.mag.length &gt;= 67108864) {
                                this.checkRange();
                            }

                        }
                    }
                }
            }
        } else {
            throw new NumberFormatException(&quot;Radix out of range&quot;);
        }
    }

    BigInteger(char[] val, int sign, int len) {
        int cursor;
        for(cursor = 0; cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0; ++cursor) {
        }

        if (cursor == len) {
            this.signum = 0;
            this.mag = ZERO.mag;
        } else {
            int numDigits = len - cursor;
            this.signum = sign;
            int numWords;
            if (len &lt; 10) {
                numWords = 1;
            } else {
                long numBits = ((long)numDigits * bitsPerDigit[10] &gt;&gt;&gt; 10) + 1L;
                if (numBits + 31L &gt;= 4294967296L) {
                    reportOverflow();
                }

                numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;
            }

            int[] magnitude = new int[numWords];
            int firstGroupLen = numDigits % digitsPerInt[10];
            if (firstGroupLen == 0) {
                firstGroupLen = digitsPerInt[10];
            }

            magnitude[numWords - 1] = this.parseInt(val, cursor, cursor += firstGroupLen);

            while(cursor &lt; len) {
                int groupVal = this.parseInt(val, cursor, cursor += digitsPerInt[10]);
                destructiveMulAdd(magnitude, intRadix[10], groupVal);
            }

            this.mag = trustedStripLeadingZeroInts(magnitude);
            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    private int parseInt(char[] source, int start, int end) {
        int result = Character.digit(source[start++], 10);
        if (result == -1) {
            throw new NumberFormatException(new String(source));
        } else {
            for(int index = start; index &lt; end; ++index) {
                int nextVal = Character.digit(source[index], 10);
                if (nextVal == -1) {
                    throw new NumberFormatException(new String(source));
                }

                result = 10 * result + nextVal;
            }

            return result;
        }
    }

    private static void destructiveMulAdd(int[] x, int y, int z) {
        long ylong = (long)y &amp; 4294967295L;
        long zlong = (long)z &amp; 4294967295L;
        int len = x.length;
        long product = 0L;
        long carry = 0L;

        for(int i = len - 1; i &gt;= 0; --i) {
            product = ylong * ((long)x[i] &amp; 4294967295L) + carry;
            x[i] = (int)product;
            carry = product &gt;&gt;&gt; 32;
        }

        long sum = ((long)x[len - 1] &amp; 4294967295L) + zlong;
        x[len - 1] = (int)sum;
        carry = sum &gt;&gt;&gt; 32;

        for(int i = len - 2; i &gt;= 0; --i) {
            sum = ((long)x[i] &amp; 4294967295L) + carry;
            x[i] = (int)sum;
            carry = sum &gt;&gt;&gt; 32;
        }

    }

    public BigInteger(String val) {
        this((String)val, 10);
    }

    public BigInteger(int numBits, Random rnd) {
        this(1, (byte[])randomBits(numBits, rnd));
    }

    private static byte[] randomBits(int numBits, Random rnd) {
        if (numBits &lt; 0) {
            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);
        } else {
            int numBytes = (int)(((long)numBits + 7L) / 8L);
            byte[] randomBits = new byte[numBytes];
            if (numBytes &gt; 0) {
                rnd.nextBytes(randomBits);
                int excessBits = 8 * numBytes - numBits;
                randomBits[0] = (byte)(randomBits[0] &amp; (1 &lt;&lt; 8 - excessBits) - 1);
            }

            return randomBits;
        }
    }

    public BigInteger(int bitLength, int certainty, Random rnd) {
        if (bitLength &lt; 2) {
            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);
        } else {
            BigInteger prime = bitLength &lt; 95 ? smallPrime(bitLength, certainty, rnd) : largePrime(bitLength, certainty, rnd);
            this.signum = 1;
            this.mag = prime.mag;
        }
    }

    public static BigInteger probablePrime(int bitLength, Random rnd) {
        if (bitLength &lt; 2) {
            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);
        } else {
            return bitLength &lt; 95 ? smallPrime(bitLength, 100, rnd) : largePrime(bitLength, 100, rnd);
        }
    }

    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {
        int magLen = bitLength + 31 &gt;&gt;&gt; 5;
        int[] temp = new int[magLen];
        int highBit = 1 &lt;&lt; (bitLength + 31 &amp; 31);
        int highMask = (highBit &lt;&lt; 1) - 1;

        BigInteger p;
        do {
            long r;
            do {
                for(int i = 0; i &lt; magLen; ++i) {
                    temp[i] = rnd.nextInt();
                }

                temp[0] = temp[0] &amp; highMask | highBit;
                if (bitLength &gt; 2) {
                    temp[magLen - 1] |= 1;
                }

                p = new BigInteger(temp, 1);
                if (bitLength &lt;= 6) {
                    break;
                }

                r = p.remainder(SMALL_PRIME_PRODUCT).longValue();
            } while(r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L);

            if (bitLength &lt; 4) {
                return p;
            }
        } while(!p.primeToCertainty(certainty, rnd));

        return p;
    }

    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {
        BigInteger p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);
        int[] var10000 = p.mag;
        int var10001 = p.mag.length - 1;
        var10000[var10001] &amp;= -2;
        int searchLen = getPrimeSearchLen(bitLength);
        BitSieve searchSieve = new BitSieve(p, searchLen);

        BigInteger candidate;
        for(candidate = searchSieve.retrieve(p, certainty, rnd); candidate == null || candidate.bitLength() != bitLength; candidate = searchSieve.retrieve(p, certainty, rnd)) {
            p = p.add(valueOf((long)(2 * searchLen)));
            if (p.bitLength() != bitLength) {
                p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);
            }

            var10000 = p.mag;
            var10001 = p.mag.length - 1;
            var10000[var10001] &amp;= -2;
            searchSieve = new BitSieve(p, searchLen);
        }

        return candidate;
    }

    public BigInteger nextProbablePrime() {
        if (this.signum &lt; 0) {
            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);
        } else if (this.signum != 0 &amp;&amp; !this.equals(ONE)) {
            BigInteger result = this.add(ONE);
            if (result.bitLength() &lt; 95) {
                if (!result.testBit(0)) {
                    result = result.add(ONE);
                }

                while(true) {
                    while(true) {
                        if (result.bitLength() &gt; 6) {
                            long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();
                            if (r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L) {
                                result = result.add(TWO);
                                continue;
                            }
                        }

                        if (result.bitLength() &lt; 4) {
                            return result;
                        }

                        if (result.primeToCertainty(100, (Random)null)) {
                            return result;
                        }

                        result = result.add(TWO);
                    }
                }
            } else {
                if (result.testBit(0)) {
                    result = result.subtract(ONE);
                }

                int searchLen = getPrimeSearchLen(result.bitLength());

                while(true) {
                    BitSieve searchSieve = new BitSieve(result, searchLen);
                    BigInteger candidate = searchSieve.retrieve(result, 100, (Random)null);
                    if (candidate != null) {
                        return candidate;
                    }

                    result = result.add(valueOf((long)(2 * searchLen)));
                }
            }
        } else {
            return TWO;
        }
    }

    private static int getPrimeSearchLen(int bitLength) {
        if (bitLength &gt; 500000001) {
            throw new ArithmeticException(&quot;Prime search implementation restriction on bitLength&quot;);
        } else {
            return bitLength / 20 * 64;
        }
    }

    boolean primeToCertainty(int certainty, Random random) {
        int rounds = false;
        int n = (Math.min(certainty, 2147483646) + 1) / 2;
        int sizeInBits = this.bitLength();
        byte rounds;
        int rounds;
        if (sizeInBits &lt; 100) {
            rounds = 50;
            rounds = n &lt; rounds ? n : rounds;
            return this.passesMillerRabin(rounds, random);
        } else {
            if (sizeInBits &lt; 256) {
                rounds = 27;
            } else if (sizeInBits &lt; 512) {
                rounds = 15;
            } else if (sizeInBits &lt; 768) {
                rounds = 8;
            } else if (sizeInBits &lt; 1024) {
                rounds = 4;
            } else {
                rounds = 2;
            }

            rounds = n &lt; rounds ? n : rounds;
            return this.passesMillerRabin(rounds, random) &amp;&amp; this.passesLucasLehmer();
        }
    }

    private boolean passesLucasLehmer() {
        BigInteger thisPlusOne = this.add(ONE);

        int d;
        for(d = 5; jacobiSymbol(d, this) != -1; d = d &lt; 0 ? Math.abs(d) + 2 : -(d + 2)) {
        }

        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);
        return u.mod(this).equals(ZERO);
    }

    private static int jacobiSymbol(int p, BigInteger n) {
        if (p == 0) {
            return 0;
        } else {
            int j = 1;
            int u = n.mag[n.mag.length - 1];
            int t;
            if (p &lt; 0) {
                p = -p;
                t = u &amp; 7;
                if (t == 3 || t == 7) {
                    j = -j;
                }
            }

            while((p &amp; 3) == 0) {
                p &gt;&gt;= 2;
            }

            if ((p &amp; 1) == 0) {
                p &gt;&gt;= 1;
                if (((u ^ u &gt;&gt; 1) &amp; 2) != 0) {
                    j = -j;
                }
            }

            if (p == 1) {
                return j;
            } else {
                if ((p &amp; u &amp; 2) != 0) {
                    j = -j;
                }

                for(u = n.mod(valueOf((long)p)).intValue(); u != 0; u %= t) {
                    while((u &amp; 3) == 0) {
                        u &gt;&gt;= 2;
                    }

                    if ((u &amp; 1) == 0) {
                        u &gt;&gt;= 1;
                        if (((p ^ p &gt;&gt; 1) &amp; 2) != 0) {
                            j = -j;
                        }
                    }

                    if (u == 1) {
                        return j;
                    }

                    assert u &lt; p;

                    t = u;
                    u = p;
                    p = t;
                    if ((u &amp; t &amp; 2) != 0) {
                        j = -j;
                    }
                }

                return 0;
            }
        }
    }

    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {
        BigInteger d = valueOf((long)z);
        BigInteger u = ONE;
        BigInteger v = ONE;

        for(int i = k.bitLength() - 2; i &gt;= 0; --i) {
            BigInteger u2 = u.multiply(v).mod(n);
            BigInteger v2 = v.square().add(d.multiply(u.square())).mod(n);
            if (v2.testBit(0)) {
                v2 = v2.subtract(n);
            }

            v2 = v2.shiftRight(1);
            u = u2;
            v = v2;
            if (k.testBit(i)) {
                u2 = u2.add(v2).mod(n);
                if (u2.testBit(0)) {
                    u2 = u2.subtract(n);
                }

                u2 = u2.shiftRight(1);
                v2 = v2.add(d.multiply(u)).mod(n);
                if (v2.testBit(0)) {
                    v2 = v2.subtract(n);
                }

                v2 = v2.shiftRight(1);
                u = u2;
                v = v2;
            }
        }

        return u;
    }

    private boolean passesMillerRabin(int iterations, Random rnd) {
        BigInteger thisMinusOne = this.subtract(ONE);
        int a = thisMinusOne.getLowestSetBit();
        BigInteger m = thisMinusOne.shiftRight(a);
        if (rnd == null) {
            rnd = ThreadLocalRandom.current();
        }

        for(int i = 0; i &lt; iterations; ++i) {
            BigInteger b;
            do {
                do {
                    b = new BigInteger(this.bitLength(), (Random)rnd);
                } while(b.compareTo(ONE) &lt;= 0);
            } while(b.compareTo(this) &gt;= 0);

            int j = 0;

            for(BigInteger z = b.modPow(m, this); (j != 0 || !z.equals(ONE)) &amp;&amp; !z.equals(thisMinusOne); z = z.modPow(TWO, this)) {
                if (j &gt; 0 &amp;&amp; z.equals(ONE)) {
                    return false;
                }

                ++j;
                if (j == a) {
                    return false;
                }
            }
        }

        return true;
    }

    BigInteger(int[] magnitude, int signum) {
        this.signum = magnitude.length == 0 ? 0 : signum;
        this.mag = magnitude;
        if (this.mag.length &gt;= 67108864) {
            this.checkRange();
        }

    }

    private BigInteger(byte[] magnitude, int signum) {
        this.signum = magnitude.length == 0 ? 0 : signum;
        this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
        if (this.mag.length &gt;= 67108864) {
            this.checkRange();
        }

    }

    private void checkRange() {
        if (this.mag.length &gt; 67108864 || this.mag.length == 67108864 &amp;&amp; this.mag[0] &lt; 0) {
            reportOverflow();
        }

    }

    private static void reportOverflow() {
        throw new ArithmeticException(&quot;BigInteger would overflow supported range&quot;);
    }

    public static BigInteger valueOf(long val) {
        if (val == 0L) {
            return ZERO;
        } else if (val &gt; 0L &amp;&amp; val &lt;= 16L) {
            return posConst[(int)val];
        } else {
            return val &lt; 0L &amp;&amp; val &gt;= -16L ? negConst[(int)(-val)] : new BigInteger(val);
        }
    }

    private BigInteger(long val) {
        if (val &lt; 0L) {
            val = -val;
            this.signum = -1;
        } else {
            this.signum = 1;
        }

        int highWord = (int)(val &gt;&gt;&gt; 32);
        if (highWord == 0) {
            this.mag = new int[1];
            this.mag[0] = (int)val;
        } else {
            this.mag = new int[2];
            this.mag[0] = highWord;
            this.mag[1] = (int)val;
        }

    }

    private static BigInteger valueOf(int[] val) {
        return val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val);
    }

    public BigInteger add(BigInteger val) {
        if (val.signum == 0) {
            return this;
        } else if (this.signum == 0) {
            return val;
        } else if (val.signum == this.signum) {
            return new BigInteger(add(this.mag, val.mag), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    BigInteger add(long val) {
        if (val == 0L) {
            return this;
        } else if (this.signum == 0) {
            return valueOf(val);
        } else if (Long.signum(val) == this.signum) {
            return new BigInteger(add(this.mag, Math.abs(val)), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, Math.abs(val)) : subtract(Math.abs(val), this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    private static int[] add(int[] x, long val) {
        long sum = 0L;
        int xIndex = x.length;
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int[] result;
        if (highWord == 0) {
            result = new int[xIndex];
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + val;
            result[xIndex] = (int)sum;
        } else {
            if (xIndex == 1) {
                result = new int[2];
                sum = val + ((long)x[0] &amp; 4294967295L);
                result[1] = (int)sum;
                result[0] = (int)(sum &gt;&gt;&gt; 32);
                return result;
            }

            result = new int[xIndex];
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + (val &amp; 4294967295L);
            result[xIndex] = (int)sum;
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)highWord &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);
            result[xIndex] = (int)sum;
        }

        boolean carry;
        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) {
            --xIndex;
        }

        while(xIndex &gt; 0) {
            --xIndex;
            result[xIndex] = x[xIndex];
        }

        if (carry) {
            int[] bigger = new int[result.length + 1];
            System.arraycopy(result, 0, bigger, 1, result.length);
            bigger[0] = 1;
            return bigger;
        } else {
            return result;
        }
    }

    private static int[] add(int[] x, int[] y) {
        if (x.length &lt; y.length) {
            int[] tmp = x;
            x = y;
            y = tmp;
        }

        int xIndex = x.length;
        int yIndex = y.length;
        int[] result = new int[xIndex];
        long sum = 0L;
        if (yIndex == 1) {
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)y[0] &amp; 4294967295L);
            result[xIndex] = (int)sum;
        } else {
            while(yIndex &gt; 0) {
                --xIndex;
                long var10000 = (long)x[xIndex] &amp; 4294967295L;
                --yIndex;
                sum = var10000 + ((long)y[yIndex] &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);
                result[xIndex] = (int)sum;
            }
        }

        boolean carry;
        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) {
            --xIndex;
        }

        while(xIndex &gt; 0) {
            --xIndex;
            result[xIndex] = x[xIndex];
        }

        if (carry) {
            int[] bigger = new int[result.length + 1];
            System.arraycopy(result, 0, bigger, 1, result.length);
            bigger[0] = 1;
            return bigger;
        } else {
            return result;
        }
    }

    private static int[] subtract(long val, int[] little) {
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int[] result;
        if (highWord == 0) {
            result = new int[]{(int)(val - ((long)little[0] &amp; 4294967295L))};
            return result;
        } else {
            result = new int[2];
            long difference;
            if (little.length == 1) {
                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L);
                result[1] = (int)difference;
                boolean borrow = difference &gt;&gt; 32 != 0L;
                if (borrow) {
                    result[0] = highWord - 1;
                } else {
                    result[0] = highWord;
                }

                return result;
            } else {
                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[1] &amp; 4294967295L);
                result[1] = (int)difference;
                difference = ((long)highWord &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L) + (difference &gt;&gt; 32);
                result[0] = (int)difference;
                return result;
            }
        }
    }

    private static int[] subtract(int[] big, long val) {
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int bigIndex = big.length;
        int[] result = new int[bigIndex];
        long difference = 0L;
        if (highWord == 0) {
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - val;
            result[bigIndex] = (int)difference;
        } else {
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - (val &amp; 4294967295L);
            result[bigIndex] = (int)difference;
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - ((long)highWord &amp; 4294967295L) + (difference &gt;&gt; 32);
            result[bigIndex] = (int)difference;
        }

        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) {
            --bigIndex;
        }

        while(bigIndex &gt; 0) {
            --bigIndex;
            result[bigIndex] = big[bigIndex];
        }

        return result;
    }

    public BigInteger subtract(BigInteger val) {
        if (val.signum == 0) {
            return this;
        } else if (this.signum == 0) {
            return val.negate();
        } else if (val.signum != this.signum) {
            return new BigInteger(add(this.mag, val.mag), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    private static int[] subtract(int[] big, int[] little) {
        int bigIndex = big.length;
        int[] result = new int[bigIndex];
        int littleIndex = little.length;

        long difference;
        for(difference = 0L; littleIndex &gt; 0; result[bigIndex] = (int)difference) {
            --bigIndex;
            long var10000 = (long)big[bigIndex] &amp; 4294967295L;
            --littleIndex;
            difference = var10000 - ((long)little[littleIndex] &amp; 4294967295L) + (difference &gt;&gt; 32);
        }

        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) {
            --bigIndex;
        }

        while(bigIndex &gt; 0) {
            --bigIndex;
            result[bigIndex] = big[bigIndex];
        }

        return result;
    }

    public BigInteger multiply(BigInteger val) {
        return this.multiply(val, false);
    }

    private BigInteger multiply(BigInteger val, boolean isRecursion) {
        if (val.signum != 0 &amp;&amp; this.signum != 0) {
            int xlen = this.mag.length;
            if (val == this &amp;&amp; xlen &gt; 20) {
                return this.square();
            } else {
                int ylen = val.mag.length;
                if (xlen &gt;= 80 &amp;&amp; ylen &gt;= 80) {
                    if (xlen &lt; 240 &amp;&amp; ylen &lt; 240) {
                        return multiplyKaratsuba(this, val);
                    } else {
                        if (!isRecursion &amp;&amp; (long)(bitLength(this.mag, this.mag.length) + bitLength(val.mag, val.mag.length)) &gt; 2147483648L) {
                            reportOverflow();
                        }

                        return multiplyToomCook3(this, val);
                    }
                } else {
                    int resultSign = this.signum == val.signum ? 1 : -1;
                    if (val.mag.length == 1) {
                        return multiplyByInt(this.mag, val.mag[0], resultSign);
                    } else if (this.mag.length == 1) {
                        return multiplyByInt(val.mag, this.mag[0], resultSign);
                    } else {
                        int[] result = multiplyToLen(this.mag, xlen, val.mag, ylen, (int[])null);
                        result = trustedStripLeadingZeroInts(result);
                        return new BigInteger(result, resultSign);
                    }
                }
            }
        } else {
            return ZERO;
        }
    }

    private static BigInteger multiplyByInt(int[] x, int y, int sign) {
        if (Integer.bitCount(y) == 1) {
            return new BigInteger(shiftLeft(x, Integer.numberOfTrailingZeros(y)), sign);
        } else {
            int xlen = x.length;
            int[] rmag = new int[xlen + 1];
            long carry = 0L;
            long yl = (long)y &amp; 4294967295L;
            int rstart = rmag.length - 1;

            for(int i = xlen - 1; i &gt;= 0; --i) {
                long product = ((long)x[i] &amp; 4294967295L) * yl + carry;
                rmag[rstart--] = (int)product;
                carry = product &gt;&gt;&gt; 32;
            }

            if (carry == 0L) {
                rmag = Arrays.copyOfRange(rmag, 1, rmag.length);
            } else {
                rmag[rstart] = (int)carry;
            }

            return new BigInteger(rmag, sign);
        }
    }

    BigInteger multiply(long v) {
        if (v != 0L &amp;&amp; this.signum != 0) {
            if (v == -9223372036854775808L) {
                return this.multiply(valueOf(v));
            } else {
                int rsign = v &gt; 0L ? this.signum : -this.signum;
                if (v &lt; 0L) {
                    v = -v;
                }

                long dh = v &gt;&gt;&gt; 32;
                long dl = v &amp; 4294967295L;
                int xlen = this.mag.length;
                int[] value = this.mag;
                int[] rmag = dh == 0L ? new int[xlen + 1] : new int[xlen + 2];
                long carry = 0L;
                int rstart = rmag.length - 1;

                int i;
                long product;
                for(i = xlen - 1; i &gt;= 0; --i) {
                    product = ((long)value[i] &amp; 4294967295L) * dl + carry;
                    rmag[rstart--] = (int)product;
                    carry = product &gt;&gt;&gt; 32;
                }

                rmag[rstart] = (int)carry;
                if (dh != 0L) {
                    carry = 0L;
                    rstart = rmag.length - 2;

                    for(i = xlen - 1; i &gt;= 0; --i) {
                        product = ((long)value[i] &amp; 4294967295L) * dh + ((long)rmag[rstart] &amp; 4294967295L) + carry;
                        rmag[rstart--] = (int)product;
                        carry = product &gt;&gt;&gt; 32;
                    }

                    rmag[0] = (int)carry;
                }

                if (carry == 0L) {
                    rmag = Arrays.copyOfRange(rmag, 1, rmag.length);
                }

                return new BigInteger(rmag, rsign);
            }
        } else {
            return ZERO;
        }
    }

    private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
        multiplyToLenCheck(x, xlen);
        multiplyToLenCheck(y, ylen);
        return implMultiplyToLen(x, xlen, y, ylen, z);
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
        int xstart = xlen - 1;
        int ystart = ylen - 1;
        if (z == null || z.length &lt; xlen + ylen) {
            z = new int[xlen + ylen];
        }

        long carry = 0L;
        int i = ystart;

        int j;
        for(j = ystart + 1 + xstart; i &gt;= 0; --j) {
            long product = ((long)y[i] &amp; 4294967295L) * ((long)x[xstart] &amp; 4294967295L) + carry;
            z[j] = (int)product;
            carry = product &gt;&gt;&gt; 32;
            --i;
        }

        z[xstart] = (int)carry;

        for(i = xstart - 1; i &gt;= 0; --i) {
            carry = 0L;
            j = ystart;

            for(int k = ystart + 1 + i; j &gt;= 0; --k) {
                long product = ((long)y[j] &amp; 4294967295L) * ((long)x[i] &amp; 4294967295L) + ((long)z[k] &amp; 4294967295L) + carry;
                z[k] = (int)product;
                carry = product &gt;&gt;&gt; 32;
                --j;
            }

            z[i] = (int)carry;
        }

        return z;
    }

    private static void multiplyToLenCheck(int[] array, int length) {
        if (length &gt; 0) {
            Objects.requireNonNull(array);
            if (length &gt; array.length) {
                throw new ArrayIndexOutOfBoundsException(length - 1);
            }
        }
    }

    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {
        int xlen = x.mag.length;
        int ylen = y.mag.length;
        int half = (Math.max(xlen, ylen) + 1) / 2;
        BigInteger xl = x.getLower(half);
        BigInteger xh = x.getUpper(half);
        BigInteger yl = y.getLower(half);
        BigInteger yh = y.getUpper(half);
        BigInteger p1 = xh.multiply(yh);
        BigInteger p2 = xl.multiply(yl);
        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));
        BigInteger result = p1.shiftLeft(32 * half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32 * half).add(p2);
        return x.signum != y.signum ? result.negate() : result;
    }

    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {
        int alen = a.mag.length;
        int blen = b.mag.length;
        int largest = Math.max(alen, blen);
        int k = (largest + 2) / 3;
        int r = largest - 2 * k;
        BigInteger a2 = a.getToomSlice(k, r, 0, largest);
        BigInteger a1 = a.getToomSlice(k, r, 1, largest);
        BigInteger a0 = a.getToomSlice(k, r, 2, largest);
        BigInteger b2 = b.getToomSlice(k, r, 0, largest);
        BigInteger b1 = b.getToomSlice(k, r, 1, largest);
        BigInteger b0 = b.getToomSlice(k, r, 2, largest);
        BigInteger v0 = a0.multiply(b0, true);
        BigInteger da1 = a2.add(a0);
        BigInteger db1 = b2.add(b0);
        BigInteger vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);
        da1 = da1.add(a1);
        db1 = db1.add(b1);
        BigInteger v1 = da1.multiply(db1, true);
        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(db1.add(b2).shiftLeft(1).subtract(b0), true);
        BigInteger vinf = a2.multiply(b2, true);
        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();
        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);
        BigInteger t1 = v1.subtract(v0);
        t2 = t2.subtract(t1).shiftRight(1);
        t1 = t1.subtract(tm1).subtract(vinf);
        t2 = t2.subtract(vinf.shiftLeft(1));
        tm1 = tm1.subtract(t2);
        int ss = k * 32;
        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);
        return a.signum != b.signum ? result.negate() : result;
    }

    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice, int fullsize) {
        int len = this.mag.length;
        int offset = fullsize - len;
        int start;
        int end;
        if (slice == 0) {
            start = 0 - offset;
            end = upperSize - 1 - offset;
        } else {
            start = upperSize + (slice - 1) * lowerSize - offset;
            end = start + lowerSize - 1;
        }

        if (start &lt; 0) {
            start = 0;
        }

        if (end &lt; 0) {
            return ZERO;
        } else {
            int sliceSize = end - start + 1;
            if (sliceSize &lt;= 0) {
                return ZERO;
            } else if (start == 0 &amp;&amp; sliceSize &gt;= len) {
                return this.abs();
            } else {
                int[] intSlice = new int[sliceSize];
                System.arraycopy(this.mag, start, intSlice, 0, sliceSize);
                return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);
            }
        }
    }

    private BigInteger exactDivideBy3() {
        int len = this.mag.length;
        int[] result = new int[len];
        long borrow = 0L;

        for(int i = len - 1; i &gt;= 0; --i) {
            long x = (long)this.mag[i] &amp; 4294967295L;
            long w = x - borrow;
            if (borrow &gt; x) {
                borrow = 1L;
            } else {
                borrow = 0L;
            }

            long q = w * 2863311531L &amp; 4294967295L;
            result[i] = (int)q;
            if (q &gt;= 1431655766L) {
                ++borrow;
                if (q &gt;= 2863311531L) {
                    ++borrow;
                }
            }
        }

        result = trustedStripLeadingZeroInts(result);
        return new BigInteger(result, this.signum);
    }

    private BigInteger getLower(int n) {
        int len = this.mag.length;
        if (len &lt;= n) {
            return this.abs();
        } else {
            int[] lowerInts = new int[n];
            System.arraycopy(this.mag, len - n, lowerInts, 0, n);
            return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);
        }
    }

    private BigInteger getUpper(int n) {
        int len = this.mag.length;
        if (len &lt;= n) {
            return ZERO;
        } else {
            int upperLen = len - n;
            int[] upperInts = new int[upperLen];
            System.arraycopy(this.mag, 0, upperInts, 0, upperLen);
            return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);
        }
    }

    private BigInteger square() {
        return this.square(false);
    }

    private BigInteger square(boolean isRecursion) {
        if (this.signum == 0) {
            return ZERO;
        } else {
            int len = this.mag.length;
            if (len &lt; 128) {
                int[] z = squareToLen(this.mag, len, (int[])null);
                return new BigInteger(trustedStripLeadingZeroInts(z), 1);
            } else if (len &lt; 216) {
                return this.squareKaratsuba();
            } else {
                if (!isRecursion &amp;&amp; (long)bitLength(this.mag, this.mag.length) &gt; 1073741824L) {
                    reportOverflow();
                }

                return this.squareToomCook3();
            }
        }
    }

    private static final int[] squareToLen(int[] x, int len, int[] z) {
        int zlen = len &lt;&lt; 1;
        if (z == null || z.length &lt; zlen) {
            z = new int[zlen];
        }

        implSquareToLenChecks(x, len, z, zlen);
        return implSquareToLen(x, len, z, zlen);
    }

    private static void implSquareToLenChecks(int[] x, int len, int[] z, int zlen) throws RuntimeException {
        if (len &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);
        } else if (len &gt; x.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len + &quot; &gt; &quot; + x.length);
        } else if (len * 2 &gt; z.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len * 2 + &quot; &gt; &quot; + z.length);
        } else if (zlen &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + zlen);
        } else if (zlen &gt; z.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len + &quot; &gt; &quot; + z.length);
        }
    }

    @HotSpotIntrinsicCandidate
    private static final int[] implSquareToLen(int[] x, int len, int[] z, int zlen) {
        int lastProductLowWord = 0;
        int i = 0;

        int offset;
        for(offset = 0; i &lt; len; ++i) {
            long piece = (long)x[i] &amp; 4294967295L;
            long product = piece * piece;
            z[offset++] = lastProductLowWord &lt;&lt; 31 | (int)(product &gt;&gt;&gt; 33);
            z[offset++] = (int)(product &gt;&gt;&gt; 1);
            lastProductLowWord = (int)product;
        }

        i = len;

        for(offset = 1; i &gt; 0; offset += 2) {
            int t = x[i - 1];
            t = mulAdd(z, x, offset, i - 1, t);
            addOne(z, offset - 1, i, t);
            --i;
        }

        primitiveLeftShift(z, zlen, 1);
        z[zlen - 1] |= x[len - 1] &amp; 1;
        return z;
    }

    private BigInteger squareKaratsuba() {
        int half = (this.mag.length + 1) / 2;
        BigInteger xl = this.getLower(half);
        BigInteger xh = this.getUpper(half);
        BigInteger xhs = xh.square();
        BigInteger xls = xl.square();
        return xhs.shiftLeft(half * 32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half * 32).add(xls);
    }

    private BigInteger squareToomCook3() {
        int len = this.mag.length;
        int k = (len + 2) / 3;
        int r = len - 2 * k;
        BigInteger a2 = this.getToomSlice(k, r, 0, len);
        BigInteger a1 = this.getToomSlice(k, r, 1, len);
        BigInteger a0 = this.getToomSlice(k, r, 2, len);
        BigInteger v0 = a0.square(true);
        BigInteger da1 = a2.add(a0);
        BigInteger vm1 = da1.subtract(a1).square(true);
        da1 = da1.add(a1);
        BigInteger v1 = da1.square(true);
        BigInteger vinf = a2.square(true);
        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);
        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();
        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);
        BigInteger t1 = v1.subtract(v0);
        t2 = t2.subtract(t1).shiftRight(1);
        t1 = t1.subtract(tm1).subtract(vinf);
        t2 = t2.subtract(vinf.shiftLeft(1));
        tm1 = tm1.subtract(t2);
        int ss = k * 32;
        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);
    }

    public BigInteger divide(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideBurnikelZiegler(val) : this.divideKnuth(val);
    }

    private BigInteger divideKnuth(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        a.divideKnuth(b, q, false);
        return q.toBigInteger(this.signum * val.signum);
    }

    public BigInteger[] divideAndRemainder(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideAndRemainderBurnikelZiegler(val) : this.divideAndRemainderKnuth(val);
    }

    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {
        BigInteger[] result = new BigInteger[2];
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        MutableBigInteger r = a.divideKnuth(b, q);
        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);
        result[1] = r.toBigInteger(this.signum);
        return result;
    }

    public BigInteger remainder(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.remainderBurnikelZiegler(val) : this.remainderKnuth(val);
    }

    private BigInteger remainderKnuth(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        return a.divideKnuth(b, q).toBigInteger(this.signum);
    }

    private BigInteger divideBurnikelZiegler(BigInteger val) {
        return this.divideAndRemainderBurnikelZiegler(val)[0];
    }

    private BigInteger remainderBurnikelZiegler(BigInteger val) {
        return this.divideAndRemainderBurnikelZiegler(val)[1];
    }

    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger r = (new MutableBigInteger(this)).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);
        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(this.signum * val.signum);
        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(this.signum);
        return new BigInteger[]{qBigInt, rBigInt};
    }

    public BigInteger pow(int exponent) {
        if (exponent &lt; 0) {
            throw new ArithmeticException(&quot;Negative exponent&quot;);
        } else if (this.signum == 0) {
            return exponent == 0 ? ONE : this;
        } else {
            BigInteger partToSquare = this.abs();
            int powersOfTwo = partToSquare.getLowestSetBit();
            long bitsToShiftLong = (long)powersOfTwo * (long)exponent;
            if (bitsToShiftLong &gt; 2147483647L) {
                reportOverflow();
            }

            int bitsToShift = (int)bitsToShiftLong;
            int remainingBits;
            if (powersOfTwo &gt; 0) {
                partToSquare = partToSquare.shiftRight(powersOfTwo);
                remainingBits = partToSquare.bitLength();
                if (remainingBits == 1) {
                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                        return NEGATIVE_ONE.shiftLeft(bitsToShift);
                    }

                    return ONE.shiftLeft(bitsToShift);
                }
            } else {
                remainingBits = partToSquare.bitLength();
                if (remainingBits == 1) {
                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                        return NEGATIVE_ONE;
                    }

                    return ONE;
                }
            }

            long scaleFactor = (long)remainingBits * (long)exponent;
            if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62L) {
                int newSign = this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1 ? -1 : 1;
                long result = 1L;
                long baseToPow2 = (long)partToSquare.mag[0] &amp; 4294967295L;
                int workingExponent = exponent;

                while(workingExponent != 0) {
                    if ((workingExponent &amp; 1) == 1) {
                        result *= baseToPow2;
                    }

                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) {
                        baseToPow2 *= baseToPow2;
                    }
                }

                if (powersOfTwo &gt; 0) {
                    if ((long)bitsToShift + scaleFactor &lt;= 62L) {
                        return valueOf((result &lt;&lt; bitsToShift) * (long)newSign);
                    } else {
                        return valueOf(result * (long)newSign).shiftLeft(bitsToShift);
                    }
                } else {
                    return valueOf(result * (long)newSign);
                }
            } else {
                if ((long)this.bitLength() * (long)exponent / 32L &gt; 67108864L) {
                    reportOverflow();
                }

                BigInteger answer = ONE;
                int workingExponent = exponent;

                while(workingExponent != 0) {
                    if ((workingExponent &amp; 1) == 1) {
                        answer = answer.multiply(partToSquare);
                    }

                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) {
                        partToSquare = partToSquare.square();
                    }
                }

                if (powersOfTwo &gt; 0) {
                    answer = answer.shiftLeft(bitsToShift);
                }

                if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                    return answer.negate();
                } else {
                    return answer;
                }
            }
        }
    }

    public BigInteger sqrt() {
        if (this.signum &lt; 0) {
            throw new ArithmeticException(&quot;Negative BigInteger&quot;);
        } else {
            return (new MutableBigInteger(this.mag)).sqrt().toBigInteger();
        }
    }

    public BigInteger[] sqrtAndRemainder() {
        BigInteger s = this.sqrt();
        BigInteger r = this.subtract(s.square());

        assert r.compareTo(ZERO) &gt;= 0;

        return new BigInteger[]{s, r};
    }

    public BigInteger gcd(BigInteger val) {
        if (val.signum == 0) {
            return this.abs();
        } else if (this.signum == 0) {
            return val.abs();
        } else {
            MutableBigInteger a = new MutableBigInteger(this);
            MutableBigInteger b = new MutableBigInteger(val);
            MutableBigInteger result = a.hybridGCD(b);
            return result.toBigInteger(1);
        }
    }

    static int bitLengthForInt(int n) {
        return 32 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] leftShift(int[] a, int len, int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int bitsInHighWord = bitLengthForInt(a[0]);
        if (n &lt;= 32 - bitsInHighWord) {
            primitiveLeftShift(a, len, nBits);
            return a;
        } else {
            int[] result;
            if (nBits &lt;= 32 - bitsInHighWord) {
                result = new int[nInts + len];
                System.arraycopy(a, 0, result, 0, len);
                primitiveLeftShift(result, result.length, nBits);
                return result;
            } else {
                result = new int[nInts + len + 1];
                System.arraycopy(a, 0, result, 0, len);
                primitiveRightShift(result, result.length, 32 - nBits);
                return result;
            }
        }
    }

    static void primitiveRightShift(int[] a, int len, int n) {
        int n2 = 32 - n;
        int i = len - 1;

        for(int c = a[i]; i &gt; 0; --i) {
            int b = c;
            c = a[i - 1];
            a[i] = c &lt;&lt; n2 | b &gt;&gt;&gt; n;
        }

        a[0] &gt;&gt;&gt;= n;
    }

    static void primitiveLeftShift(int[] a, int len, int n) {
        if (len != 0 &amp;&amp; n != 0) {
            int n2 = 32 - n;
            int i = 0;
            int c = a[i];

            for(int m = i + len - 1; i &lt; m; ++i) {
                int b = c;
                c = a[i + 1];
                a[i] = b &lt;&lt; n | c &gt;&gt;&gt; n2;
            }

            a[len - 1] &lt;&lt;= n;
        }
    }

    private static int bitLength(int[] val, int len) {
        return len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(val[0]);
    }

    public BigInteger abs() {
        return this.signum &gt;= 0 ? this : this.negate();
    }

    public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }

    public int signum() {
        return this.signum;
    }

    public BigInteger mod(BigInteger m) {
        if (m.signum &lt;= 0) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else {
            BigInteger result = this.remainder(m);
            return result.signum &gt;= 0 ? result : result.add(m);
        }
    }

    public BigInteger modPow(BigInteger exponent, BigInteger m) {
        if (m.signum &lt;= 0) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else if (exponent.signum == 0) {
            return m.equals(ONE) ? ZERO : ONE;
        } else if (this.equals(ONE)) {
            return m.equals(ONE) ? ZERO : ONE;
        } else if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0) {
            return ZERO;
        } else if (this.equals(negConst[1]) &amp;&amp; !exponent.testBit(0)) {
            return m.equals(ONE) ? ZERO : ONE;
        } else {
            boolean invertResult;
            if (invertResult = exponent.signum &lt; 0) {
                exponent = exponent.negate();
            }

            BigInteger base = this.signum &gt;= 0 &amp;&amp; this.compareTo(m) &lt; 0 ? this : this.mod(m);
            BigInteger result;
            if (m.testBit(0)) {
                result = base.oddModPow(exponent, m);
            } else {
                int p = m.getLowestSetBit();
                BigInteger m1 = m.shiftRight(p);
                BigInteger m2 = ONE.shiftLeft(p);
                BigInteger base2 = this.signum &gt;= 0 &amp;&amp; this.compareTo(m1) &lt; 0 ? this : this.mod(m1);
                BigInteger a1 = m1.equals(ONE) ? ZERO : base2.oddModPow(exponent, m1);
                BigInteger a2 = base.modPow2(exponent, p);
                BigInteger y1 = m2.modInverse(m1);
                BigInteger y2 = m1.modInverse(m2);
                if (m.mag.length &lt; 33554432) {
                    result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);
                } else {
                    MutableBigInteger t1 = new MutableBigInteger();
                    (new MutableBigInteger(a1.multiply(m2))).multiply(new MutableBigInteger(y1), t1);
                    MutableBigInteger t2 = new MutableBigInteger();
                    (new MutableBigInteger(a2.multiply(m1))).multiply(new MutableBigInteger(y2), t2);
                    t1.add(t2);
                    MutableBigInteger q = new MutableBigInteger();
                    result = t1.divide(new MutableBigInteger(m), q).toBigInteger();
                }
            }

            return invertResult ? result.modInverse(m) : result;
        }
    }

    private static int[] montgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) {
        implMontgomeryMultiplyChecks(a, b, n, len, product);
        if (len &gt; 512) {
            product = multiplyToLen(a, len, b, len, product);
            return montReduce(product, n, len, (int)inv);
        } else {
            return implMontgomeryMultiply(a, b, n, len, inv, materialize(product, len));
        }
    }

    private static int[] montgomerySquare(int[] a, int[] n, int len, long inv, int[] product) {
        implMontgomeryMultiplyChecks(a, a, n, len, product);
        if (len &gt; 512) {
            product = squareToLen(a, len, product);
            return montReduce(product, n, len, (int)inv);
        } else {
            return implMontgomerySquare(a, n, len, inv, materialize(product, len));
        }
    }

    private static void implMontgomeryMultiplyChecks(int[] a, int[] b, int[] n, int len, int[] product) throws RuntimeException {
        if (len % 2 != 0) {
            throw new IllegalArgumentException(&quot;input array length must be even: &quot; + len);
        } else if (len &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);
        } else if (len &gt; a.length || len &gt; b.length || len &gt; n.length || product != null &amp;&amp; len &gt; product.length) {
            throw new IllegalArgumentException(&quot;input array length out of bound: &quot; + len);
        }
    }

    private static int[] materialize(int[] z, int len) {
        if (z == null || z.length &lt; len) {
            z = new int[len];
        }

        return z;
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMontgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) {
        product = multiplyToLen(a, len, b, len, product);
        return montReduce(product, n, len, (int)inv);
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMontgomerySquare(int[] a, int[] n, int len, long inv, int[] product) {
        product = squareToLen(a, len, product);
        return montReduce(product, n, len, (int)inv);
    }

    private BigInteger oddModPow(BigInteger y, BigInteger z) {
        if (y.equals(ONE)) {
            return this;
        } else if (this.signum == 0) {
            return ZERO;
        } else {
            int[] base = (int[])this.mag.clone();
            int[] exp = y.mag;
            int[] mod = z.mag;
            int modLen = mod.length;
            if ((modLen &amp; 1) != 0) {
                int[] x = new int[modLen + 1];
                System.arraycopy(mod, 0, x, 1, modLen);
                mod = x;
                ++modLen;
            }

            int wbits = 0;
            int ebits = bitLength(exp, exp.length);
            if (ebits != 17 || exp[0] != 65537) {
                while(ebits &gt; bnExpModThreshTable[wbits]) {
                    ++wbits;
                }
            }

            int tblmask = 1 &lt;&lt; wbits;
            int[][] table = new int[tblmask][];

            for(int i = 0; i &lt; tblmask; ++i) {
                table[i] = new int[modLen];
            }

            long n0 = ((long)mod[modLen - 1] &amp; 4294967295L) + (((long)mod[modLen - 2] &amp; 4294967295L) &lt;&lt; 32);
            long inv = -MutableBigInteger.inverseMod64(n0);
            int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);
            MutableBigInteger q = new MutableBigInteger();
            MutableBigInteger a2 = new MutableBigInteger(a);
            MutableBigInteger b2 = new MutableBigInteger(mod);
            b2.normalize();
            MutableBigInteger r = a2.divide(b2, q);
            table[0] = r.toIntArray();
            int[] t;
            if (table[0].length &lt; modLen) {
                int offset = modLen - table[0].length;
                t = new int[modLen];
                System.arraycopy(table[0], 0, t, offset, table[0].length);
                table[0] = t;
            }

            int[] b = montgomerySquare(table[0], mod, modLen, inv, (int[])null);
            t = Arrays.copyOf(b, modLen);

            int bitpos;
            for(bitpos = 1; bitpos &lt; tblmask; ++bitpos) {
                table[bitpos] = montgomeryMultiply(t, table[bitpos - 1], mod, modLen, inv, (int[])null);
            }

            bitpos = 1 &lt;&lt; (ebits - 1 &amp; 31);
            int buf = 0;
            int elen = exp.length;
            int eIndex = 0;

            int multpos;
            for(multpos = 0; multpos &lt;= wbits; ++multpos) {
                buf = buf &lt;&lt; 1 | ((exp[eIndex] &amp; bitpos) != 0 ? 1 : 0);
                bitpos &gt;&gt;&gt;= 1;
                if (bitpos == 0) {
                    ++eIndex;
                    bitpos = -2147483648;
                    --elen;
                }
            }

            --ebits;
            boolean isone = true;

            for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) {
                buf &gt;&gt;&gt;= 1;
            }

            int[] mult = table[buf &gt;&gt;&gt; 1];
            buf = 0;
            if (multpos == ebits) {
                isone = false;
            }

            while(true) {
                --ebits;
                buf &lt;&lt;= 1;
                if (elen != 0) {
                    buf |= (exp[eIndex] &amp; bitpos) != 0 ? 1 : 0;
                    bitpos &gt;&gt;&gt;= 1;
                    if (bitpos == 0) {
                        ++eIndex;
                        bitpos = -2147483648;
                        --elen;
                    }
                }

                if ((buf &amp; tblmask) != 0) {
                    for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) {
                        buf &gt;&gt;&gt;= 1;
                    }

                    mult = table[buf &gt;&gt;&gt; 1];
                    buf = 0;
                }

                if (ebits == multpos) {
                    if (isone) {
                        b = (int[])mult.clone();
                        isone = false;
                    } else {
                        a = montgomeryMultiply(b, mult, mod, modLen, inv, a);
                        t = a;
                        a = b;
                        b = t;
                    }
                }

                if (ebits == 0) {
                    int[] t2 = new int[2 * modLen];
                    System.arraycopy(b, 0, t2, modLen, modLen);
                    b = montReduce(t2, mod, modLen, (int)inv);
                    t2 = Arrays.copyOf(b, modLen);
                    return new BigInteger(1, t2);
                }

                if (!isone) {
                    a = montgomerySquare(b, mod, modLen, inv, a);
                    t = a;
                    a = b;
                    b = t;
                }
            }
        }
    }

    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) {
        int c = 0;
        int len = mlen;
        int offset = 0;

        do {
            int nEnd = n[n.length - 1 - offset];
            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);
            c += addOne(n, offset, mlen, carry);
            ++offset;
            --len;
        } while(len &gt; 0);

        while(c &gt; 0) {
            c += subN(n, mod, mlen);
        }

        while(intArrayCmpToLen(n, mod, mlen) &gt;= 0) {
            subN(n, mod, mlen);
        }

        return n;
    }

    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) {
        for(int i = 0; i &lt; len; ++i) {
            long b1 = (long)arg1[i] &amp; 4294967295L;
            long b2 = (long)arg2[i] &amp; 4294967295L;
            if (b1 &lt; b2) {
                return -1;
            }

            if (b1 &gt; b2) {
                return 1;
            }
        }

        return 0;
    }

    private static int subN(int[] a, int[] b, int len) {
        long sum = 0L;

        while(true) {
            --len;
            if (len &lt; 0) {
                return (int)(sum &gt;&gt; 32);
            }

            sum = ((long)a[len] &amp; 4294967295L) - ((long)b[len] &amp; 4294967295L) + (sum &gt;&gt; 32);
            a[len] = (int)sum;
        }
    }

    static int mulAdd(int[] out, int[] in, int offset, int len, int k) {
        implMulAddCheck(out, in, offset, len, k);
        return implMulAdd(out, in, offset, len, k);
    }

    private static void implMulAddCheck(int[] out, int[] in, int offset, int len, int k) {
        if (len &gt; in.length) {
            throw new IllegalArgumentException(&quot;input length is out of bound: &quot; + len + &quot; &gt; &quot; + in.length);
        } else if (offset &lt; 0) {
            throw new IllegalArgumentException(&quot;input offset is invalid: &quot; + offset);
        } else if (offset &gt; out.length - 1) {
            throw new IllegalArgumentException(&quot;input offset is out of bound: &quot; + offset + &quot; &gt; &quot; + (out.length - 1));
        } else if (len &gt; out.length - offset) {
            throw new IllegalArgumentException(&quot;input len is out of bound: &quot; + len + &quot; &gt; &quot; + (out.length - offset));
        }
    }

    @HotSpotIntrinsicCandidate
    private static int implMulAdd(int[] out, int[] in, int offset, int len, int k) {
        long kLong = (long)k &amp; 4294967295L;
        long carry = 0L;
        offset = out.length - offset - 1;

        for(int j = len - 1; j &gt;= 0; --j) {
            long product = ((long)in[j] &amp; 4294967295L) * kLong + ((long)out[offset] &amp; 4294967295L) + carry;
            out[offset--] = (int)product;
            carry = product &gt;&gt;&gt; 32;
        }

        return (int)carry;
    }

    static int addOne(int[] a, int offset, int mlen, int carry) {
        offset = a.length - 1 - mlen - offset;
        long t = ((long)a[offset] &amp; 4294967295L) + ((long)carry &amp; 4294967295L);
        a[offset] = (int)t;
        if (t &gt;&gt;&gt; 32 == 0L) {
            return 0;
        } else {
            do {
                --mlen;
                if (mlen &lt; 0) {
                    return 1;
                }

                --offset;
                if (offset &lt; 0) {
                    return 1;
                }

                int var10002 = a[offset]++;
            } while(a[offset] == 0);

            return 0;
        }
    }

    private BigInteger modPow2(BigInteger exponent, int p) {
        BigInteger result = ONE;
        BigInteger baseToPow2 = this.mod2(p);
        int expOffset = 0;
        int limit = exponent.bitLength();
        if (this.testBit(0)) {
            limit = p - 1 &lt; limit ? p - 1 : limit;
        }

        while(expOffset &lt; limit) {
            if (exponent.testBit(expOffset)) {
                result = result.multiply(baseToPow2).mod2(p);
            }

            ++expOffset;
            if (expOffset &lt; limit) {
                baseToPow2 = baseToPow2.square().mod2(p);
            }
        }

        return result;
    }

    private BigInteger mod2(int p) {
        if (this.bitLength() &lt;= p) {
            return this;
        } else {
            int numInts = p + 31 &gt;&gt;&gt; 5;
            int[] mag = new int[numInts];
            System.arraycopy(this.mag, this.mag.length - numInts, mag, 0, numInts);
            int excessBits = (numInts &lt;&lt; 5) - p;
            mag[0] = (int)((long)mag[0] &amp; (1L &lt;&lt; 32 - excessBits) - 1L);
            return mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1);
        }
    }

    public BigInteger modInverse(BigInteger m) {
        if (m.signum != 1) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else if (m.equals(ONE)) {
            return ZERO;
        } else {
            BigInteger modVal = this;
            if (this.signum &lt; 0 || this.compareMagnitude(m) &gt;= 0) {
                modVal = this.mod(m);
            }

            if (modVal.equals(ONE)) {
                return ONE;
            } else {
                MutableBigInteger a = new MutableBigInteger(modVal);
                MutableBigInteger b = new MutableBigInteger(m);
                MutableBigInteger result = a.mutableModInverse(b);
                return result.toBigInteger(1);
            }
        }
    }

    public BigInteger shiftLeft(int n) {
        if (this.signum == 0) {
            return ZERO;
        } else if (n &gt; 0) {
            return new BigInteger(shiftLeft(this.mag, n), this.signum);
        } else {
            return n == 0 ? this : this.shiftRightImpl(-n);
        }
    }

    private static int[] shiftLeft(int[] mag, int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int magLen = mag.length;
        int[] newMag = null;
        int[] newMag;
        if (nBits == 0) {
            newMag = new int[magLen + nInts];
            System.arraycopy(mag, 0, newMag, 0, magLen);
        } else {
            int i = 0;
            int nBits2 = 32 - nBits;
            int highBits = mag[0] &gt;&gt;&gt; nBits2;
            if (highBits != 0) {
                newMag = new int[magLen + nInts + 1];
                newMag[i++] = highBits;
            } else {
                newMag = new int[magLen + nInts];
            }

            int j;
            for(j = 0; j &lt; magLen - 1; newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2) {
            }

            newMag[i] = mag[j] &lt;&lt; nBits;
        }

        return newMag;
    }

    public BigInteger shiftRight(int n) {
        if (this.signum == 0) {
            return ZERO;
        } else if (n &gt; 0) {
            return this.shiftRightImpl(n);
        } else {
            return n == 0 ? this : new BigInteger(shiftLeft(this.mag, -n), this.signum);
        }
    }

    private BigInteger shiftRightImpl(int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int magLen = this.mag.length;
        int[] newMag = null;
        if (nInts &gt;= magLen) {
            return this.signum &gt;= 0 ? ZERO : negConst[1];
        } else {
            int newMagLen;
            int i;
            int nBits2;
            int[] newMag;
            if (nBits == 0) {
                newMagLen = magLen - nInts;
                newMag = Arrays.copyOf(this.mag, newMagLen);
            } else {
                newMagLen = 0;
                i = this.mag[0] &gt;&gt;&gt; nBits;
                if (i != 0) {
                    newMag = new int[magLen - nInts];
                    newMag[newMagLen++] = i;
                } else {
                    newMag = new int[magLen - nInts - 1];
                }

                nBits2 = 32 - nBits;

                for(int j = 0; j &lt; magLen - nInts - 1; newMag[newMagLen++] = this.mag[j++] &lt;&lt; nBits2 | this.mag[j] &gt;&gt;&gt; nBits) {
                }
            }

            if (this.signum &lt; 0) {
                boolean onesLost = false;
                i = magLen - 1;

                for(nBits2 = magLen - nInts; i &gt;= nBits2 &amp;&amp; !onesLost; --i) {
                    onesLost = this.mag[i] != 0;
                }

                if (!onesLost &amp;&amp; nBits != 0) {
                    onesLost = this.mag[magLen - nInts - 1] &lt;&lt; 32 - nBits != 0;
                }

                if (onesLost) {
                    newMag = this.javaIncrement(newMag);
                }
            }

            return new BigInteger(newMag, this.signum);
        }
    }

    int[] javaIncrement(int[] val) {
        int lastSum = 0;

        for(int i = val.length - 1; i &gt;= 0 &amp;&amp; lastSum == 0; --i) {
            lastSum = ++val[i];
        }

        if (lastSum == 0) {
            val = new int[val.length + 1];
            val[0] = 1;
        }

        return val;
    }

    public BigInteger and(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) &amp; val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger or(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) | val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger xor(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) ^ val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger not() {
        int[] result = new int[this.intLength()];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = ~this.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger andNot(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) &amp; ~val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public boolean testBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            return (this.getInt(n &gt;&gt;&gt; 5) &amp; 1 &lt;&lt; (n &amp; 31)) != 0;
        }
    }

    public BigInteger setBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), intNum + 2)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] |= 1 &lt;&lt; (n &amp; 31);
            return valueOf(result);
        }
    }

    public BigInteger clearBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), (n + 1 &gt;&gt;&gt; 5) + 1)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] &amp;= ~(1 &lt;&lt; (n &amp; 31));
            return valueOf(result);
        }
    }

    public BigInteger flipBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), intNum + 2)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] ^= 1 &lt;&lt; (n &amp; 31);
            return valueOf(result);
        }
    }

    public int getLowestSetBit() {
        int lsb = this.lowestSetBitPlusTwo - 2;
        if (lsb == -2) {
            int lsb = 0;
            if (this.signum == 0) {
                lsb = lsb - 1;
            } else {
                int i;
                int b;
                for(i = 0; (b = this.getInt(i)) == 0; ++i) {
                }

                lsb = lsb + (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);
            }

            this.lowestSetBitPlusTwo = lsb + 2;
        }

        return lsb;
    }

    public int bitLength() {
        int n = this.bitLengthPlusOne - 1;
        if (n == -1) {
            int[] m = this.mag;
            int len = m.length;
            if (len == 0) {
                n = 0;
            } else {
                int magBitLength = (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);
                if (this.signum &gt;= 0) {
                    n = magBitLength;
                } else {
                    boolean pow2 = Integer.bitCount(this.mag[0]) == 1;

                    for(int i = 1; i &lt; len &amp;&amp; pow2; ++i) {
                        pow2 = this.mag[i] == 0;
                    }

                    n = pow2 ? magBitLength - 1 : magBitLength;
                }
            }

            this.bitLengthPlusOne = n + 1;
        }

        return n;
    }

    public int bitCount() {
        int bc = this.bitCountPlusOne - 1;
        if (bc == -1) {
            bc = 0;

            int magTrailingZeroCount;
            for(magTrailingZeroCount = 0; magTrailingZeroCount &lt; this.mag.length; ++magTrailingZeroCount) {
                bc += Integer.bitCount(this.mag[magTrailingZeroCount]);
            }

            if (this.signum &lt; 0) {
                magTrailingZeroCount = 0;

                int j;
                for(j = this.mag.length - 1; this.mag[j] == 0; --j) {
                    magTrailingZeroCount += 32;
                }

                magTrailingZeroCount += Integer.numberOfTrailingZeros(this.mag[j]);
                bc += magTrailingZeroCount - 1;
            }

            this.bitCountPlusOne = bc + 1;
        }

        return bc;
    }

    public boolean isProbablePrime(int certainty) {
        if (certainty &lt;= 0) {
            return true;
        } else {
            BigInteger w = this.abs();
            if (w.equals(TWO)) {
                return true;
            } else {
                return w.testBit(0) &amp;&amp; !w.equals(ONE) ? w.primeToCertainty(certainty, (Random)null) : false;
            }
        }
    }

    public int compareTo(BigInteger val) {
        if (this.signum == val.signum) {
            switch(this.signum) {
            case -1:
                return val.compareMagnitude(this);
            case 1:
                return this.compareMagnitude(val);
            default:
                return 0;
            }
        } else {
            return this.signum &gt; val.signum ? 1 : -1;
        }
    }

    final int compareMagnitude(BigInteger val) {
        int[] m1 = this.mag;
        int len1 = m1.length;
        int[] m2 = val.mag;
        int len2 = m2.length;
        if (len1 &lt; len2) {
            return -1;
        } else if (len1 &gt; len2) {
            return 1;
        } else {
            for(int i = 0; i &lt; len1; ++i) {
                int a = m1[i];
                int b = m2[i];
                if (a != b) {
                    return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                }
            }

            return 0;
        }
    }

    final int compareMagnitude(long val) {
        assert val != -9223372036854775808L;

        int[] m1 = this.mag;
        int len = m1.length;
        if (len &gt; 2) {
            return 1;
        } else {
            if (val &lt; 0L) {
                val = -val;
            }

            int highWord = (int)(val &gt;&gt;&gt; 32);
            int a;
            int b;
            if (highWord == 0) {
                if (len &lt; 1) {
                    return -1;
                } else if (len &gt; 1) {
                    return 1;
                } else {
                    a = m1[0];
                    b = (int)val;
                    if (a != b) {
                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
            } else if (len &lt; 2) {
                return -1;
            } else {
                a = m1[0];
                if (a != highWord) {
                    return ((long)a &amp; 4294967295L) &lt; ((long)highWord &amp; 4294967295L) ? -1 : 1;
                } else {
                    a = m1[1];
                    b = (int)val;
                    if (a != b) {
                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
            }
        }
    }

    public boolean equals(Object x) {
        if (x == this) {
            return true;
        } else if (!(x instanceof BigInteger)) {
            return false;
        } else {
            BigInteger xInt = (BigInteger)x;
            if (xInt.signum != this.signum) {
                return false;
            } else {
                int[] m = this.mag;
                int len = m.length;
                int[] xm = xInt.mag;
                if (len != xm.length) {
                    return false;
                } else {
                    for(int i = 0; i &lt; len; ++i) {
                        if (xm[i] != m[i]) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        }
    }

    public BigInteger min(BigInteger val) {
        return this.compareTo(val) &lt; 0 ? this : val;
    }

    public BigInteger max(BigInteger val) {
        return this.compareTo(val) &gt; 0 ? this : val;
    }

    public int hashCode() {
        int hashCode = 0;

        for(int i = 0; i &lt; this.mag.length; ++i) {
            hashCode = (int)((long)(31 * hashCode) + ((long)this.mag[i] &amp; 4294967295L));
        }

        return hashCode * this.signum;
    }

    public String toString(int radix) {
        if (this.signum == 0) {
            return &quot;0&quot;;
        } else {
            if (radix &lt; 2 || radix &gt; 36) {
                radix = 10;
            }

            if (this.mag.length &lt;= 20) {
                return this.smallToString(radix);
            } else {
                StringBuilder sb = new StringBuilder();
                if (this.signum &lt; 0) {
                    toString(this.negate(), sb, radix, 0);
                    sb.insert(0, &#39;-&#39;);
                } else {
                    toString(this, sb, radix, 0);
                }

                return sb.toString();
            }
        }
    }

    private String smallToString(int radix) {
        if (this.signum == 0) {
            return &quot;0&quot;;
        } else {
            int maxNumDigitGroups = (4 * this.mag.length + 6) / 7;
            String[] digitGroup = new String[maxNumDigitGroups];
            BigInteger tmp = this.abs();

            int numGroups;
            BigInteger q2;
            for(numGroups = 0; tmp.signum != 0; tmp = q2) {
                BigInteger d = longRadix[radix];
                MutableBigInteger q = new MutableBigInteger();
                MutableBigInteger a = new MutableBigInteger(tmp.mag);
                MutableBigInteger b = new MutableBigInteger(d.mag);
                MutableBigInteger r = a.divide(b, q);
                q2 = q.toBigInteger(tmp.signum * d.signum);
                BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);
                digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);
            }

            StringBuilder buf = new StringBuilder(numGroups * digitsPerLong[radix] + 1);
            if (this.signum &lt; 0) {
                buf.append(&#39;-&#39;);
            }

            buf.append(digitGroup[numGroups - 1]);

            for(int i = numGroups - 2; i &gt;= 0; --i) {
                int numLeadingZeros = digitsPerLong[radix] - digitGroup[i].length();
                if (numLeadingZeros != 0) {
                    buf.append(zeros[numLeadingZeros]);
                }

                buf.append(digitGroup[i]);
            }

            return buf.toString();
        }
    }

    private static void toString(BigInteger u, StringBuilder sb, int radix, int digits) {
        int i;
        if (u.mag.length &gt; 20) {
            int b = u.bitLength();
            i = (int)Math.round(Math.log((double)b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0D);
            BigInteger v = getRadixConversionCache(radix, i);
            BigInteger[] results = u.divideAndRemainder(v);
            int expectedDigits = 1 &lt;&lt; i;
            toString(results[0], sb, radix, digits - expectedDigits);
            toString(results[1], sb, radix, expectedDigits);
        } else {
            String s = u.smallToString(radix);
            if (s.length() &lt; digits &amp;&amp; sb.length() &gt; 0) {
                for(i = s.length(); i &lt; digits; ++i) {
                    sb.append(&#39;0&#39;);
                }
            }

            sb.append(s);
        }
    }

    private static BigInteger getRadixConversionCache(int radix, int exponent) {
        BigInteger[] cacheLine = powerCache[radix];
        if (exponent &lt; cacheLine.length) {
            return cacheLine[exponent];
        } else {
            int oldLength = cacheLine.length;
            cacheLine = (BigInteger[])Arrays.copyOf(cacheLine, exponent + 1);

            for(int i = oldLength; i &lt;= exponent; ++i) {
                cacheLine[i] = cacheLine[i - 1].pow(2);
            }

            BigInteger[][] pc = powerCache;
            if (exponent &gt;= pc[radix].length) {
                pc = (BigInteger[][])pc.clone();
                pc[radix] = cacheLine;
                powerCache = pc;
            }

            return cacheLine[exponent];
        }
    }

    public String toString() {
        return this.toString(10);
    }

    public byte[] toByteArray() {
        int byteLen = this.bitLength() / 8 + 1;
        byte[] byteArray = new byte[byteLen];
        int i = byteLen - 1;
        int bytesCopied = 4;
        int nextInt = 0;

        for(int var6 = 0; i &gt;= 0; --i) {
            if (bytesCopied == 4) {
                nextInt = this.getInt(var6++);
                bytesCopied = 1;
            } else {
                nextInt &gt;&gt;&gt;= 8;
                ++bytesCopied;
            }

            byteArray[i] = (byte)nextInt;
        }

        return byteArray;
    }

    public int intValue() {
        int result = false;
        int result = this.getInt(0);
        return result;
    }

    public long longValue() {
        long result = 0L;

        for(int i = 1; i &gt;= 0; --i) {
            result = (result &lt;&lt; 32) + ((long)this.getInt(i) &amp; 4294967295L);
        }

        return result;
    }

    public float floatValue() {
        if (this.signum == 0) {
            return 0.0F;
        } else {
            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;
            if (exponent &lt; 63) {
                return (float)this.longValue();
            } else if (exponent &gt; 127) {
                return this.signum &gt; 0 ? 1.0F / 0.0 : -1.0F / 0.0;
            } else {
                int shift = exponent - 24;
                int nBits = shift &amp; 31;
                int nBits2 = 32 - nBits;
                int twiceSignifFloor;
                if (nBits == 0) {
                    twiceSignifFloor = this.mag[0];
                } else {
                    twiceSignifFloor = this.mag[0] &gt;&gt;&gt; nBits;
                    if (twiceSignifFloor == 0) {
                        twiceSignifFloor = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;
                    }
                }

                int signifFloor = twiceSignifFloor &gt;&gt; 1;
                signifFloor &amp;= 8388607;
                boolean increment = (twiceSignifFloor &amp; 1) != 0 &amp;&amp; ((signifFloor &amp; 1) != 0 || this.abs().getLowestSetBit() &lt; shift);
                int signifRounded = increment ? signifFloor + 1 : signifFloor;
                int bits = exponent + 127 &lt;&lt; 23;
                bits += signifRounded;
                bits |= this.signum &amp; -2147483648;
                return Float.intBitsToFloat(bits);
            }
        }
    }

    public double doubleValue() {
        if (this.signum == 0) {
            return 0.0D;
        } else {
            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;
            if (exponent &lt; 63) {
                return (double)this.longValue();
            } else if (exponent &gt; 1023) {
                return this.signum &gt; 0 ? 1.0D / 0.0 : -1.0D / 0.0;
            } else {
                int shift = exponent - 53;
                int nBits = shift &amp; 31;
                int nBits2 = 32 - nBits;
                int highBits;
                int lowBits;
                if (nBits == 0) {
                    highBits = this.mag[0];
                    lowBits = this.mag[1];
                } else {
                    highBits = this.mag[0] &gt;&gt;&gt; nBits;
                    lowBits = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;
                    if (highBits == 0) {
                        highBits = lowBits;
                        lowBits = this.mag[1] &lt;&lt; nBits2 | this.mag[2] &gt;&gt;&gt; nBits;
                    }
                }

                long twiceSignifFloor = ((long)highBits &amp; 4294967295L) &lt;&lt; 32 | (long)lowBits &amp; 4294967295L;
                long signifFloor = twiceSignifFloor &gt;&gt; 1;
                signifFloor &amp;= 4503599627370495L;
                boolean increment = (twiceSignifFloor &amp; 1L) != 0L &amp;&amp; ((signifFloor &amp; 1L) != 0L || this.abs().getLowestSetBit() &lt; shift);
                long signifRounded = increment ? signifFloor + 1L : signifFloor;
                long bits = (long)(exponent + 1023) &lt;&lt; 52;
                bits += signifRounded;
                bits |= (long)this.signum &amp; -9223372036854775808L;
                return Double.longBitsToDouble(bits);
            }
        }
    }

    private static int[] stripLeadingZeroInts(int[] val) {
        int vlen = val.length;

        int keep;
        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) {
        }

        return Arrays.copyOfRange(val, keep, vlen);
    }

    private static int[] trustedStripLeadingZeroInts(int[] val) {
        int vlen = val.length;

        int keep;
        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) {
        }

        return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen);
    }

    private static int[] stripLeadingZeroBytes(byte[] a, int off, int len) {
        int indexBound = off + len;

        int keep;
        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == 0; ++keep) {
        }

        int intLength = indexBound - keep + 3 &gt;&gt;&gt; 2;
        int[] result = new int[intLength];
        int b = indexBound - 1;

        for(int i = intLength - 1; i &gt;= 0; --i) {
            result[i] = a[b--] &amp; 255;
            int bytesRemaining = b - keep + 1;
            int bytesToTransfer = Math.min(3, bytesRemaining);

            for(int j = 8; j &lt;= bytesToTransfer &lt;&lt; 3; j += 8) {
                result[i] |= (a[b--] &amp; 255) &lt;&lt; j;
            }
        }

        return result;
    }

    private static int[] makePositive(byte[] a, int off, int len) {
        int indexBound = off + len;

        int keep;
        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == -1; ++keep) {
        }

        int k;
        for(k = keep; k &lt; indexBound &amp;&amp; a[k] == 0; ++k) {
        }

        int extraByte = k == indexBound ? 1 : 0;
        int intLength = indexBound - keep + extraByte + 3 &gt;&gt;&gt; 2;
        int[] result = new int[intLength];
        int b = indexBound - 1;

        int i;
        for(i = intLength - 1; i &gt;= 0; --i) {
            result[i] = a[b--] &amp; 255;
            int numBytesToTransfer = Math.min(3, b - keep + 1);
            if (numBytesToTransfer &lt; 0) {
                numBytesToTransfer = 0;
            }

            int mask;
            for(mask = 8; mask &lt;= 8 * numBytesToTransfer; mask += 8) {
                result[i] |= (a[b--] &amp; 255) &lt;&lt; mask;
            }

            mask = -1 &gt;&gt;&gt; 8 * (3 - numBytesToTransfer);
            result[i] = ~result[i] &amp; mask;
        }

        for(i = result.length - 1; i &gt;= 0; --i) {
            result[i] = (int)(((long)result[i] &amp; 4294967295L) + 1L);
            if (result[i] != 0) {
                break;
            }
        }

        return result;
    }

    private static int[] makePositive(int[] a) {
        int keep;
        for(keep = 0; keep &lt; a.length &amp;&amp; a[keep] == -1; ++keep) {
        }

        int j;
        for(j = keep; j &lt; a.length &amp;&amp; a[j] == 0; ++j) {
        }

        int extraInt = j == a.length ? 1 : 0;
        int[] result = new int[a.length - keep + extraInt];

        int i;
        for(i = keep; i &lt; a.length; ++i) {
            result[i - keep + extraInt] = ~a[i];
        }

        for(i = result.length - 1; ++result[i] == 0; --i) {
        }

        return result;
    }

    private int intLength() {
        return (this.bitLength() &gt;&gt;&gt; 5) + 1;
    }

    private int signBit() {
        return this.signum &lt; 0 ? 1 : 0;
    }

    private int signInt() {
        return this.signum &lt; 0 ? -1 : 0;
    }

    private int getInt(int n) {
        if (n &lt; 0) {
            return 0;
        } else if (n &gt;= this.mag.length) {
            return this.signInt();
        } else {
            int magInt = this.mag[this.mag.length - n - 1];
            return this.signum &gt;= 0 ? magInt : (n &lt;= this.firstNonzeroIntNum() ? -magInt : ~magInt);
        }
    }

    private int firstNonzeroIntNum() {
        int fn = this.firstNonzeroIntNumPlusTwo - 2;
        if (fn == -2) {
            int mlen = this.mag.length;

            int i;
            for(i = mlen - 1; i &gt;= 0 &amp;&amp; this.mag[i] == 0; --i) {
            }

            fn = mlen - i - 1;
            this.firstNonzeroIntNumPlusTwo = fn + 2;
        }

        return fn;
    }

    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
        GetField fields = s.readFields();
        int sign = fields.get(&quot;signum&quot;, -2);
        byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, (Object)null);
        if (sign &gt;= -1 &amp;&amp; sign &lt;= 1) {
            int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
            if (mag.length == 0 != (sign == 0)) {
                String message = &quot;BigInteger: signum-magnitude mismatch&quot;;
                if (fields.defaulted(&quot;magnitude&quot;)) {
                    message = &quot;BigInteger: Magnitude not present in stream&quot;;
                }

                throw new StreamCorruptedException(message);
            } else {
                BigInteger.UnsafeHolder.putSign(this, sign);
                BigInteger.UnsafeHolder.putMag(this, mag);
                if (mag.length &gt;= 67108864) {
                    try {
                        this.checkRange();
                    } catch (ArithmeticException var7) {
                        throw new StreamCorruptedException(&quot;BigInteger: Out of the supported range&quot;);
                    }
                }

            }
        } else {
            String message = &quot;BigInteger: Invalid signum value&quot;;
            if (fields.defaulted(&quot;signum&quot;)) {
                message = &quot;BigInteger: Signum not present in stream&quot;;
            }

            throw new StreamCorruptedException(message);
        }
    }

    private void writeObject(ObjectOutputStream s) throws IOException {
        PutField fields = s.putFields();
        fields.put(&quot;signum&quot;, this.signum);
        fields.put(&quot;magnitude&quot;, this.magSerializedForm());
        fields.put(&quot;bitCount&quot;, -1);
        fields.put(&quot;bitLength&quot;, -1);
        fields.put(&quot;lowestSetBit&quot;, -2);
        fields.put(&quot;firstNonzeroByteNum&quot;, -2);
        s.writeFields();
    }

    private byte[] magSerializedForm() {
        int len = this.mag.length;
        int bitLen = len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);
        int byteLen = bitLen + 7 &gt;&gt;&gt; 3;
        byte[] result = new byte[byteLen];
        int i = byteLen - 1;
        int bytesCopied = 4;
        int intIndex = len - 1;

        for(int nextInt = 0; i &gt;= 0; --i) {
            if (bytesCopied == 4) {
                nextInt = this.mag[intIndex--];
                bytesCopied = 1;
            } else {
                nextInt &gt;&gt;&gt;= 8;
                ++bytesCopied;
            }

            result[i] = (byte)nextInt;
        }

        return result;
    }

    public long longValueExact() {
        if (this.mag.length &lt;= 2 &amp;&amp; this.bitLength() &lt;= 63) {
            return this.longValue();
        } else {
            throw new ArithmeticException(&quot;BigInteger out of long range&quot;);
        }
    }

    public int intValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            return this.intValue();
        } else {
            throw new ArithmeticException(&quot;BigInteger out of int range&quot;);
        }
    }

    public short shortValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            int value = this.intValue();
            if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) {
                return this.shortValue();
            }
        }

        throw new ArithmeticException(&quot;BigInteger out of short range&quot;);
    }

    public byte byteValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            int value = this.intValue();
            if (value &gt;= -128 &amp;&amp; value &lt;= 127) {
                return this.byteValue();
            }
        }

        throw new ArithmeticException(&quot;BigInteger out of byte range&quot;);
    }

    static {
        int i;
        for(i = 1; i &lt;= 16; ++i) {
            int[] magnitude = new int[]{i};
            posConst[i] = new BigInteger(magnitude, 1);
            negConst[i] = new BigInteger(magnitude, -1);
        }

        powerCache = new BigInteger[37][];
        logCache = new double[37];

        for(i = 2; i &lt;= 36; ++i) {
            powerCache[i] = new BigInteger[]{valueOf((long)i)};
            logCache[i] = Math.log((double)i);
        }

        ZERO = new BigInteger(new int[0], 0);
        ONE = valueOf(1L);
        TWO = valueOf(2L);
        NEGATIVE_ONE = valueOf(-1L);
        TEN = valueOf(10L);
        bnExpModThreshTable = new int[]{7, 25, 81, 241, 673, 1793, 2147483647};
        zeros = new String[64];
        zeros[63] = &quot;000000000000000000000000000000000000000000000000000000000000000&quot;;

        for(i = 0; i &lt; 63; ++i) {
            zeros[i] = zeros[63].substring(0, i);
        }

        digitsPerLong = new int[]{0, 0, 62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};
        longRadix = new BigInteger[]{null, null, valueOf(4611686018427387904L), valueOf(4052555153018976267L), valueOf(4611686018427387904L), valueOf(7450580596923828125L), valueOf(4738381338321616896L), valueOf(3909821048582988049L), valueOf(1152921504606846976L), valueOf(1350851717672992089L), valueOf(1000000000000000000L), valueOf(5559917313492231481L), valueOf(2218611106740436992L), valueOf(8650415919381337933L), valueOf(2177953337809371136L), valueOf(6568408355712890625L), valueOf(1152921504606846976L), valueOf(2862423051509815793L), valueOf(6746640616477458432L), valueOf(799006685782884121L), valueOf(1638400000000000000L), valueOf(3243919932521508681L), valueOf(6221821273427820544L), valueOf(504036361936467383L), valueOf(876488338465357824L), valueOf(1490116119384765625L), valueOf(2481152873203736576L), valueOf(4052555153018976267L), valueOf(6502111422497947648L), valueOf(353814783205469041L), valueOf(531441000000000000L), valueOf(787662783788549761L), valueOf(1152921504606846976L), valueOf(1667889514952984961L), valueOf(2386420683693101056L), valueOf(3379220508056640625L), valueOf(4738381338321616896L)};
        digitsPerInt = new int[]{0, 0, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};
        intRadix = new int[]{0, 0, 1073741824, 1162261467, 1073741824, 1220703125, 362797056, 1977326743, 1073741824, 387420489, 1000000000, 214358881, 429981696, 815730721, 1475789056, 170859375, 268435456, 410338673, 612220032, 893871739, 1280000000, 1801088541, 113379904, 148035889, 191102976, 244140625, 308915776, 387420489, 481890304, 594823321, 729000000, 887503681, 1073741824, 1291467969, 1544804416, 1838265625, 60466176};
        serialPersistentFields = new ObjectStreamField[]{new ObjectStreamField(&quot;signum&quot;, Integer.TYPE), new ObjectStreamField(&quot;magnitude&quot;, byte[].class), new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE), new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE), new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE), new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)};
    }

    private static class UnsafeHolder {
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        private static final long signumOffset;
        private static final long magOffset;

        private UnsafeHolder() {
        }

        static void putSign(BigInteger bi, int sign) {
            unsafe.putInt(bi, signumOffset, sign);
        }

        static void putMag(BigInteger bi, int[] magnitude) {
            unsafe.putObject(bi, magOffset, magnitude);
        }

        static {
            signumOffset = unsafe.objectFieldOffset(BigInteger.class, &quot;signum&quot;);
            magOffset = unsafe.objectFieldOffset(BigInteger.class, &quot;mag&quot;);
        }
    }
}
</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-20T02:24:00.000Z">2019-09-20</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 7225 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/20/Java知识点/">Java知识点</a>
            
        </h1>
        <div class="content">
            <h1 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h1><h2 id="请问JDK和JRE的区别是什么？"><a href="#请问JDK和JRE的区别是什么？" class="headerlink" title="请问JDK和JRE的区别是什么？"></a>请问JDK和JRE的区别是什么？</h2><blockquote>
<p>JDK ：Java 开发工具包,jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。<br>JRE ：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。</p>
</blockquote>
<h2 id="springboot的注解有什么，原理？"><a href="#springboot的注解有什么，原理？" class="headerlink" title="springboot的注解有什么，原理？"></a>springboot的注解有什么，原理？</h2><p>@Bean<br>用来代替 XML 配置文件里面的 &lt;bean …&gt; 配置。<br>@ImportResource<br>如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 @Configuration 方式配置的非常管用。<br>@Import<br>用来引入额外的一个或者多个 @Configuration 修饰的配置文件类。<br>@SpringBootConfiguration<br>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。<br>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。<br>@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。<br>@EnableAutoConfiguration 自动配置。<br>@ComponentScan 组件扫描，可自动发现和装配一些Bean。<br>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。<br>@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。<br>@Autowired自动导入。<br>@PathVariable获取参数。<br>@JsonBackReference解决嵌套外链问题。<br>@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。</p>
<p>@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。<br>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
<p>@RequestParam：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p>
<p>@PathVariable:路径变量。如</p>
<pre><code class="java">@RequestMapping(“user/get/mac/{macAddress}”) 
public String getByMacAddress(@PathVariable String macAddress){ 
//do something; 
} </code></pre>
<p>Spring Boot的自动配置看起来神奇，其实原理非常简单，背后全依赖于@Conditional注解来实现的。</p>
<h2 id="object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的，-为什么有hash（）方法还有hashCode（）"><a href="#object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的，-为什么有hash（）方法还有hashCode（）" class="headerlink" title="object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）"></a>object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）</h2><p>哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:</p>
<pre><code class="java">public native int hashCode();</code></pre>
<p>根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p>
<p><strong>hashCode方法的作用</strong></p>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>
<p>　　为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）</p>
<p>　　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p>
<p><strong>hash 算法</strong></p>
<pre><code class="java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}</code></pre>
<p>首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。</p>
<p>如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。</p>
<p>但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。</p>
<p>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。</p>
<h2 id="hashmap的put过程-主要就是根据自己看过的源码说一下流程"><a href="#hashmap的put过程-主要就是根据自己看过的源码说一下流程" class="headerlink" title="hashmap的put过程 主要就是根据自己看过的源码说一下流程"></a>hashmap的put过程 主要就是根据自己看过的源码说一下流程</h2><p><strong>put 方法</strong><br>通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。</p>
<pre><code class="java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre>
<ol>
<li>判断数组是否为空，如果是空，则创建默认长度位 16 的数组。</li>
<li>通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。</li>
<li>如果有元素，说明 hash 冲突了，则再次进行 3 种判断。<ol>
<li>判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。</li>
<li>如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。</li>
<li>如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。</li>
</ol>
</li>
<li>最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。</li>
<li>对维护着迭代器的modCount 变量加一。</li>
<li>最后判断，如果当前数组的长度已经大于阀值了。则重新hash。</li>
</ol>
<h2 id="ArrayList-LinkList的特点"><a href="#ArrayList-LinkList的特点" class="headerlink" title="ArrayList LinkList的特点"></a>ArrayList LinkList的特点</h2><p>ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。</p>
<p>数据的更新和查找<br>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p>
<p>数据的增加和删除<br>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。</p>
<p>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。</p>
<p>由于 TreeMap 就是由红黑树实现的。</p>
<p>黑色高度<br>从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。</p>
<ol>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点永远是黑色的；</li>
<li>所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；</li>
<li>每个红色节点的两个子节点一定都是黑色；</li>
<li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li>
</ol>
<h2 id="Java-反射机制"><a href="#Java-反射机制" class="headerlink" title="Java 反射机制"></a>Java 反射机制</h2><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 java 的反射机制。</p>
<pre><code class="java">public class FatherClass {
    public String mFatherName;
    public int mFatherAge;

    public void printFatherMsg(){}
}</code></pre>
<h1 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。</p>
<p>锁机制有如下两种特性：</p>
<ul>
<li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p>
</li>
<li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
</li>
</ul>
<p>synchronized 可以修饰方法和代码块</p>
<ul>
<li>synchronized(this|object) {}</li>
<li>synchronized(类.class) {}</li>
<li>修饰非静态方法</li>
<li>修饰静态方法</li>
</ul>
<h2 id="reentrantLock-除了可重入还有什么关键特性"><a href="#reentrantLock-除了可重入还有什么关键特性" class="headerlink" title="reentrantLock 除了可重入还有什么关键特性"></a>reentrantLock 除了可重入还有什么关键特性</h2><ul>
<li>可重入</li>
</ul>
<p>现在有方法 m1 和 m2，两个方法均使用了同一把锁对方法进行同步控制，同时方法 m1 会调用 m2。线程 t 进入方法 m1 成功获得了锁，此时线程 t 要在没有释放锁的情况下，调用 m2 方法。由于 m1 和 m2 使用的是同一把可重入锁，所以线程 t 可以进入方法 m2，并再次获得锁，而不会被阻塞住。</p>
<ul>
<li>公平和非公平锁</li>
</ul>
<p>公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法ReentrantLock(boolean fair)调整加锁的模式。</p>
<h2 id="ThreadLocal-会造成什么问题-为什么会造成内存泄漏"><a href="#ThreadLocal-会造成什么问题-为什么会造成内存泄漏" class="headerlink" title="ThreadLocal 会造成什么问题? 为什么会造成内存泄漏?"></a>ThreadLocal 会造成什么问题? 为什么会造成内存泄漏?</h2><ul>
<li>ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型。 总结：ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。 </li>
<li>ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。</li>
</ul>
<p>ThreadLocal类提供了四个对外开放的接口方法</p>
<p>(1) void set(Object value)设置当前线程的线程局部变量的值。<br>(2) public Object get()该方法返回当前线程所对应的线程局部变量。<br>(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用。<br>(4) protected Object initialValue()返回该线程局部变量的初始值。</p>
<p>在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。</p>
<p>最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。<strong>比如使用线程池的时候，线程结束是不会销毁的，会再次使用的就可能出现内存泄露。</strong>（在web应用中，每次http请求都是一个线程，tomcat容器配置使用线程池时会出现内存泄漏问题）</p>
<ol>
<li>使用ThreadLocal，建议用static修饰 static ThreadLocal<httpheader> headerLocal = new ThreadLocal();</httpheader></li>
<li>使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</li>
</ol>
<h2 id="单例模式-synchronized实现懒汉模式？为什么用内部类是线程安全的？"><a href="#单例模式-synchronized实现懒汉模式？为什么用内部类是线程安全的？" class="headerlink" title="单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？"></a>单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？</h2><p>内部类</p>
<p>单例模式，有“懒汉式”和“饿汉式”两种。<br><strong>懒汉式</strong><br>单例类的实例在第一次被引用时候才被初始化。<br><strong>饿汉式</strong><br>单例类的实例在加载的时候就被初始化。</p>
<p><strong>静态内部类模式</strong></p>
<pre><code class="java">public class Singleton { 
    private Singleton(){
    }
      public static Singleton getSingleton(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} </code></pre>
<ol>
<li>实现代码简洁。和双重检查单例对比，静态内部类单例实现代码真的是太简洁，又清晰明了。</li>
<li>延迟初始化。调用getSingleton才初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。</li>
</ol>
<p>线程A和线程B同时试图获得Singleton对象的初始化锁，假设线程A获取到了，那么线程B一直等待初始化锁。线程A执行类初始化，就算双重检查模式中伪代码发生了重排序，也不会影响线程A的初始化结果。初始化完后，释放锁。线程B获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。</p>
<h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="添加索引的时候要注意什么"><a href="#添加索引的时候要注意什么" class="headerlink" title="添加索引的时候要注意什么"></a>添加索引的时候要注意什么</h2><p>索引可以提高数据的访问速度，但同时也增加了插入、更新和删除操作的处理时间。所以是否要为表增加索引、索引建立在那些字段上，是创建索引前必须要考虑的问题。解决此问题就是分析应用程序的业务处理、数据使用，为经常被用作查询条件、或者被要求排序的字段建立索引。</p>
<p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在<code>Where</code>子句中的<strong>字段</strong>，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；</p>
<p><strong>聚簇索引:</strong><br>通常由主键或者非空唯一索引实现的，叶子节点存储了一整行数据<br><strong>非聚簇索引：</strong><br>又称二级索引，就是我们常用的普通索引，叶子节点存了索引值和主键值，在根据主键从聚簇索引查</p>
<h2 id="索引优化以及在使用索引的时候要注意什么"><a href="#索引优化以及在使用索引的时候要注意什么" class="headerlink" title="索引优化以及在使用索引的时候要注意什么"></a>索引优化以及在使用索引的时候要注意什么</h2><p>1.索引列不要使用函数和运算</p>
<ol start="2">
<li>尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</li>
<li>当查询条件为多个的时候，可以采用复合索引</li>
<li>范围查询对多列查询的影响</li>
<li>遵循最左匹配原则<br> 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>索引列不会包含NULL值</li>
<li>尽量避免使用 or 来连接条件</li>
<li>隐式转换的影响</li>
<li>like 语句的索引失效问题</li>
</ol>
<h2 id="redis的键的淘汰策略，会达成了redis缓存的淘汰策略"><a href="#redis的键的淘汰策略，会达成了redis缓存的淘汰策略" class="headerlink" title="redis的键的淘汰策略，会达成了redis缓存的淘汰策略"></a>redis的键的淘汰策略，会达成了redis缓存的淘汰策略</h2><p>Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。<br>事实上，实例中的内存除了保存原始的键值对所需的开销外，还有一些运行时产生的额外内存，包括：</p>
<ol>
<li>垃圾数据和过期Key所占空间</li>
<li>字典渐进式Rehash导致未及时删除的空间</li>
<li>Redis管理数据，包括底层数据结构开销，客户端信息，读写缓冲区等</li>
<li>主从复制，bgsave时的额外开销</li>
</ol>
<p>为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。</p>
<ul>
<li>访问Key时，会判断Key是否过期，逐出过期Key;</li>
<li>CPU空闲时在定期serverCron任务中，逐出部分过期Key;</li>
<li>每次事件循环执行的时候，逐出部分过期Key;</li>
</ul>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="tcp四次握手，最后的状态是什么"><a href="#tcp四次握手，最后的状态是什么" class="headerlink" title="tcp四次握手，最后的状态是什么?"></a>tcp四次握手，最后的状态是什么?</h2><p>等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2）</p>
<h2 id="为什么要等着2MSL，等待多了会造成什么"><a href="#为什么要等着2MSL，等待多了会造成什么" class="headerlink" title="为什么要等着2MSL，等待多了会造成什么"></a>为什么要等着2MSL，等待多了会造成什么</h2><ol>
<li>保证A发送的最后一个ACK报文段能够到达B。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="http请求的报文结构，keep-alive是用来做什么的"><a href="#http请求的报文结构，keep-alive是用来做什么的" class="headerlink" title="http请求的报文结构，keep-alive是用来做什么的"></a>http请求的报文结构，keep-alive是用来做什么的</h2><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<pre><code class="shell">Keep-Alive: timeout=5, max=100
timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接</code></pre>
<h1 id="spring-spingboot"><a href="#spring-spingboot" class="headerlink" title="spring spingboot"></a>spring spingboot</h1><h2 id="spring为什么要注入接口，而不是实现类"><a href="#spring为什么要注入接口，而不是实现类" class="headerlink" title="spring为什么要注入接口，而不是实现类"></a>spring为什么要注入接口，而不是实现类</h2><p>首先说明，注入的对象确实为实现类的对象。（并不是实现类的代理对象，注入并不涉及代理）</p>
<p>　　如果只是单纯注入是可以用实现类接收注入对象的，但是往往开发中会对实现类做增强，如事务，日志等，实现增强的AOP技术是通过动态代理实现的，而spring默认是JDK动态代理，对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。</p>
<p>回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程</p>
<p>Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果目标对象没有实现接口我们该如何代理呢？这时候我们就需要使用CGLIB来实现AOP了。</p>
<p>假如我们要使用动态代理实现AOP，那么我们只能在写一个增强的接口，然后让目标类实现增强接口，然后我们就可以使用动态代理实现目标类的增强，可是假如我们不想让目标类实现其他的接口，那么我们就只能使用CGLIB技术来实现目标类的增强了。<br>CGLIB实现目标类增强的原理是这样的：CGLIB会动态创建一个目标类的子类，然后返回该子类的对象，也就是增强对象，至于增强的逻辑则是在子类中完成的。我们知道子类要么和父类有一样的功能，要么就比父类功能强大，所以CGLIB是通过创建目标类的子类对象来实现增强的，所以：</p>
<pre><code class="shell">目标子类 = 目标类 + 增强逻辑</code></pre>
<h1 id="口述算法思路"><a href="#口述算法思路" class="headerlink" title="口述算法思路"></a>口述算法思路</h1><h2 id="给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）"><a href="#给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）" class="headerlink" title="给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）"></a>给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）</h2><p>最小值思路：用一个辅助栈stack2记住每次入栈stack1的当前最小值:在stack1入栈时，往stack2中加入当前最小值；stack1元素出栈时，stack2也出栈一个元素。最小值从stack2中获取及栈顶元素。O(1)</p>
<p>最大值思路：同上O(1)</p>
<p><img src="/images/2019/09/20/e4dc2930-db6e-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="哪几种IO类型"><a href="#哪几种IO类型" class="headerlink" title="哪几种IO类型"></a>哪几种IO类型</h2><ul>
<li>阻塞I/O（blocking IO）</li>
<li>非阻塞I/O (nonblocking I/O)</li>
<li>I/O 复用 (I/O multiplexing)</li>
<li>信号驱动I/O (signal driven I/O (SIGIO))</li>
<li>异步I/O (asynchronous I/O)</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><ul>
<li>堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。</li>
<li>方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。</li>
<li>方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。</li>
<li>本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</li>
<li>程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。</li>
</ul>
<p><img src="/images/2019/09/20/801edd70-db6f-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*<br>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。</p>
<p><img src="/images/2019/09/20/96bb2250-db6f-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。</p>
<p>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。</p>
<h1 id="有什么想问我的"><a href="#有什么想问我的" class="headerlink" title="有什么想问我的"></a>有什么想问我的</h1><p>有的</p>
<ol>
<li>你怎样形容小米公司的企业文化？</li>
<li>什么类型的员工能在小米公司有比较好的发展？</li>
<li>关于软件开发工程师-Java方向岗位的技术栈、日常主要工作是什么、期间可以获得晋升机会？</li>
<li>能给我多讲讲招聘程序吗？</li>
<li>我没有其他问题了，与您交流非常愉快，能留一张您的名片么？（或者方便加一下您的微信么？）</li>
</ol>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-16T14:20:54.000Z">2019-09-16</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分钟 读完 (大约 2443 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/16/Java12的新特性/">Java12的新特性</a>
            
        </h1>
        <div class="content">
            <h1 id="Java12的新特性"><a href="#Java12的新特性" class="headerlink" title="Java12的新特性"></a>Java12的新特性</h1><blockquote>
<p>Java5的新特性<br>Java6的新特性<br>Java7的新特性<br>Java8的新特性<br>Java9的新特性<br>Java10的新特性<br>Java11的新特性<br>Java12的新特性<br>Java13的新特性</p>
</blockquote>
<p><img src="/images/2019/09/16/1c09f100-d88e-11e9-a339-273a38bbb2c9.png" alt="image.png"></p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><pre><code>java -version
openjdk version &quot;12&quot; 2019-03-19
OpenJDK Runtime Environment (build 12+33)
OpenJDK 64-Bit Server VM (build 12+33, mixed mode)</code></pre><blockquote>
<p>从version信息可以看出是build 12+33</p>
</blockquote>
<h2 id="特性列表"><a href="#特性列表" class="headerlink" title="特性列表"></a>特性列表</h2><ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F189" target="_blank" rel="noopener">189:    Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></li>
</ul>
<blockquote>
<p>Shenandoah GC是一个面向low-pause-time的垃圾收集器，它最初由Red Hat实现，支持aarch64及amd64 architecture；ZGC也是面向low-pause-time的垃圾收集器，不过ZGC是基于colored pointers来实现，而Shenandoah GC是基于brooks pointers来实现；如果要使用Shenandoah GC需要编译时–with-jvm-features选项带有shenandoahgc，然后启动时使用-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F230" target="_blank" rel="noopener">230:    Microbenchmark Suite</a></li>
</ul>
<blockquote>
<p>在jdk源码里头新增了一套基础的microbenchmarks suite</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F325" target="_blank" rel="noopener">325:    Switch Expressions (Preview)</a></li>
</ul>
<blockquote>
<p>对switch进行了增强，除了使用statement还可以使用expression，比如原来的写法如下：</p>
<pre><code class="java">switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}</code></pre>
<p>现在可以改为如下写法：</p>
<pre><code class="java">switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);
    case TUESDAY                -&gt; System.out.println(7);
    case THURSDAY, SATURDAY     -&gt; System.out.println(8);
    case WEDNESDAY              -&gt; System.out.println(9);
}</code></pre>
<p>以及在表达式返回值</p>
<pre><code class="java">int numLetters = switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; 6;
    case TUESDAY                -&gt; 7;
    case THURSDAY, SATURDAY     -&gt; 8;
    case WEDNESDAY              -&gt; 9;
};</code></pre>
<p>对于需要返回值的switch expression要么正常返回值要么抛出异常，以下这两种写法都是错误的</p>
<pre><code class="java">int i = switch (day) {
    case MONDAY -&gt; {
        System.out.println(&quot;Monday&quot;); 
        // ERROR! Block doesn&#39;t contain a break with value
    }
    default -&gt; 1;
};
i = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY: 
        break 0;
    default: 
        System.out.println(&quot;Second half of the week&quot;);
        // ERROR! Group doesn&#39;t contain a break with value
};</code></pre>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F334" target="_blank" rel="noopener">334:    JVM Constants API</a></li>
</ul>
</blockquote>
<blockquote>
<p>新增了JVM Constants API，具体来说就是java.base模块新增了java.lang.constant包，引入了ConstantDesc接口(ClassDesc、MethodTypeDesc、MethodHandleDesc这几个接口直接继承了ConstantDesc接口)以及Constable接口；ConstantDesc接口定义了resolveConstantDesc方法，Constable接口定义了describeConstable方法；String、Integer、Long、Float、Double均实现了这两个接口，而EnumDesc实现了ConstantDesc接口</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F340" target="_blank" rel="noopener">340:    One AArch64 Port, Not Two</a></li>
</ul>
<blockquote>
<p>64-bit Arm platform (arm64)，也可以称之为aarch64；之前JDK有两个关于aarch64的实现，分别是src/hotspot/cpu/arm以及open/src/hotspot/cpu/aarch64，它们的实现重复了，为了集中精力更好地实现aarch64，该特性在源码中删除了open/src/hotspot/cpu/arm中关于64-bit的实现，保留其中32-bit的实现，于是open/src/hotspot/cpu/aarch64部分就成了64-bit ARM architecture的默认实现</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F341" target="_blank" rel="noopener">341:    Default CDS Archives</a></li>
</ul>
<blockquote>
<p>java10的新特性JEP 310: Application Class-Data Sharing扩展了JDK5引入的Class-Data Sharing，支持application的Class-Data Sharing；Class-Data Sharing可以用于多个JVM共享class，提升启动速度，最早只支持system classes及serial GC，JDK9对其进行扩展以支持application classes及其他GC算法，并在JDK10中开源出来(以前是commercial feature)；JDK11将-Xshare:off改为默认-Xshare:auto，以更加方便使用CDS特性；JDK12的这个特性即在64-bit平台上编译jdk的时候就默认在${JAVA_HOME}/lib/server目录下生成一份名为classes.jsa的默认archive文件(大概有18M)方便大家使用</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F344" target="_blank" rel="noopener">344:    Abortable Mixed Collections for G1</a></li>
</ul>
<blockquote>
<p>G1在garbage collection的时候，一旦确定了collection set(CSet)开始垃圾收集这个过程是without stopping的，当collection set过大的时候，此时的STW时间会过长超出目标pause time，这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，允许将其分为mandatory及optional两部分(当完成mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F346" target="_blank" rel="noopener">346:    Promptly Return Unused Committed Memory from G1</a></li>
</ul>
<blockquote>
<p>G1目前只有在full GC或者concurrent cycle的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时会还committed Java heap memory给操作系统。JDK12的这个特性新增了两个参数分别是G1PeriodicGCInterval及G1PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。当上一次garbage collection pause过去G1PeriodicGCInterval(milliseconds)时间之后，如果getloadavg()(one-minute)低于G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(如果开启G1PeriodicGCInvokesConcurrent)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统</p>
</blockquote>
<h2 id="细项解读"><a href="#细项解读" class="headerlink" title="细项解读"></a>细项解读</h2><p>上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见JDK 12 Release Notes，这里举几个例子。<br>添加项</p>
<ul>
<li>支持unicode 11</li>
<li>支持Compact Number Formatting</li>
</ul>
<blockquote>
<p>使用实例如下</p>
<pre><code class="java">    @Test
    public void testCompactNumberFormat(){
        var cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);
        System.out.println(cnf.format(1_0000));
        System.out.println(cnf.format(1_9200));
        System.out.println(cnf.format(1_000_000));
        System.out.println(cnf.format(1L &lt;&lt; 30));
        System.out.println(cnf.format(1L &lt;&lt; 40));
        System.out.println(cnf.format(1L &lt;&lt; 50));
    }</code></pre>
</blockquote>
<p>输出</p>
<pre><code>1万
2万
100万
11亿
1兆
1126兆</code></pre><ul>
<li>String支持transform、indent操作</li>
</ul>
<pre><code class="java">    @Test
    public void testStringTransform(){
        System.out.println(&quot;hello&quot;.transform(new Function&lt;String, Integer&gt;() {
            @Override
            public Integer apply(String s) {
                return s.hashCode();
            }
        }));
    }

    @Test
    public void testStringIndent(){
        System.out.println(&quot;hello&quot;.indent(3));
    }</code></pre>
<p>Files新增mismatch方法</p>
<pre><code class="java">    @Test
    public void testFilesMismatch() throws IOException {
        FileWriter fileWriter = new FileWriter(&quot;/tmp/a.txt&quot;);
        fileWriter.write(&quot;a&quot;);
        fileWriter.write(&quot;b&quot;);
        fileWriter.write(&quot;c&quot;);
        fileWriter.close();

        FileWriter fileWriterB = new FileWriter(&quot;/tmp/b.txt&quot;);
        fileWriterB.write(&quot;a&quot;);
        fileWriterB.write(&quot;1&quot;);
        fileWriterB.write(&quot;c&quot;);
        fileWriterB.close();

        System.out.println(Files.mismatch(Path.of(&quot;/tmp/a.txt&quot;),Path.of(&quot;/tmp/b.txt&quot;)));
    }</code></pre>
<ul>
<li>Collectors新增teeing方法用于聚合两个downstream的结果</li>
</ul>
<pre><code class="java">    @Test
    public void testCollectorTeeing(){
        var result = Stream.of(&quot;Devoxx&quot;,&quot;Voxxed Days&quot;,&quot;Code One&quot;,&quot;Basel One&quot;)
                .collect(Collectors.teeing(Collectors.filtering(n -&gt; n.contains(&quot;xx&quot;),Collectors.toList()),
                                            Collectors.filtering(n -&gt; n.endsWith(&quot;One&quot;),Collectors.toList()),
                        (List&lt;String&gt; list1, List&lt;String&gt; list2) -&gt; List.of(list1,list2)
                                            ));

        System.out.println(result.get(0));
        System.out.println(result.get(1));
    }</code></pre>
<ul>
<li>CompletionStage新增exceptionallyAsync、exceptionallyCompose、exceptionallyComposeAsync方法</li>
</ul>
<pre><code class="java">    @Test
    public void testExceptionallyAsync() throws ExecutionException, InterruptedException {
        LOGGER.info(&quot;begin&quot;);
        int result = CompletableFuture.supplyAsync(() -&gt; {
            LOGGER.info(&quot;calculate&quot;);
            int i = 1/0;
            return 100;
        }).exceptionallyAsync((t) -&gt; {
            LOGGER.info(&quot;error error:{}&quot;,t.getMessage());
            return 0;
        }).get();

        LOGGER.info(&quot;result:{}&quot;,result);
    }</code></pre>
<ul>
<li><p>JDK12之前CompletionStage只有一个exceptionally，该方法体在主线程执行，JDK12新增了exceptionallyAsync、exceptionallyComposeAsync方法允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage</p>
</li>
<li><p>Allocation of Old Generation of Java Heap on Alternate Memory Devices</p>
</li>
</ul>
<blockquote>
<p>G1及Parallel GC引入experimental特性，允许将old generation分配在诸如NV-DIMM memory的alternative memory device</p>
</blockquote>
<ul>
<li>ZGC: Concurrent Class Unloading</li>
</ul>
<blockquote>
<p>ZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用</p>
</blockquote>
<ul>
<li>新增-XX:+ExtensiveErrorReports</li>
</ul>
<blockquote>
<p>-XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数</p>
</blockquote>
<ul>
<li>新增安全相关的改进</li>
</ul>
<blockquote>
<p>支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationException<br>keytool新增-groupname选项允许在生成key pair的时候指定一个named group<br>新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成<br>Java Flight Recorder新增了security-related的event<br>支持ChaCha20 and Poly1305 TLS Cipher Suites</p>
</blockquote>
<ul>
<li>jdeps Reports Transitive Dependences</li>
</ul>
<blockquote>
<p>jdeps的–print-module-deps, –list-deps, 以及–list-reduce-deps选项得到增强，新增–no-recursive用于non-transitive的依赖分析，–ignore-missing-deps用于suppress missing dependence errors</p>
</blockquote>
<h2 id="移除项"><a href="#移除项" class="headerlink" title="移除项"></a>移除项</h2><ul>
<li>移除com.sun.awt.SecurityWarnin</li>
<li>移除FileInputStream、FileOutputStream、Java.util.ZipFile/Inflator/Deflator的finalize方法</li>
<li>移除GTE CyberTrust Global Root</li>
<li>移除javac的-source, -target对6及1.6的支持，同时移除–release选项</li>
</ul>
<h2 id="废弃项"><a href="#废弃项" class="headerlink" title="废弃项"></a>废弃项</h2><ul>
<li>废弃的API列表见deprecated-list</li>
<li>废弃-XX:+/-MonitorInUseLists选项</li>
<li>废弃Default Keytool的-keyalg值</li>
</ul>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul>
<li>Swing不支持GTK+ 3.20及以后的版本</li>
<li>在使用JVMCI Compiler(比如Graal)的时候，JVMTI的can_pop_frame及can_force_early_return的capabilities是被禁用的</li>
</ul>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><ul>
<li>如果用户没有指定user.timezone且从操作系统获取的为空，那么user.timezone属性的初始值为空变为null</li>
<li>java.net.URLPermission的行为发生轻微变化，以前它会忽略url中的query及fragment部分，这次改动新增query及fragment部分，即scheme : // authority [ / path ]变动为scheme : // authority [ / path ] [ ignored-query-or-fragment ]</li>
<li>javax.net.ssl.SSLContext API及Java Security Standard Algorithm Names规范移除了必须实现TLSv1及TLSv1.1的规定</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>java12不是LTS(Long-Term Support)版本(oracle版本才有LTS)，oracle对该版本的support周期为6个月。这个版本主要有几个更新点，一个是语法层更新，一个是API层面的更新，另外主要是GC方面的更新。</li>
<li>语法层面引入了preview版本的Switch Expressions；API层面引入了JVM Constants API，引入CompactNumberFormat，让NumberFormat支持COMPACTSTYLE，对String、Files、Collectors、CompletionStage等新增方法；GC方面引入了experimental版本的Shenandoah GC，不过oracle build的openjdk没有enable Shenandoah GC support；另外主要对ZGC及G1 GC进行了改进</li>
<li>其中JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用；对于G1 GC则新增支持Abortable Mixed Collections以及Promptly Return Unused Committed Memory特性</li>
</ul>
<blockquote>
<p>作者：go4it<br>链接：<a href="https://juejin.im/post/5c91fcc9e51d45563b62382c" target="_blank" rel="noopener">https://juejin.im/post/5c91fcc9e51d45563b62382c</a><br>来源：掘金</p>
</blockquote>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-13T07:57:44.000Z">2019-09-13</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 分钟 读完 (大约 5627 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/13/Java面试题/">Java面试题</a>
            
        </h1>
        <div class="content">
            <h1 id="基础与框架"><a href="#基础与框架" class="headerlink" title="基础与框架"></a>基础与框架</h1><h2 id="String类能被继承吗，为什么"><a href="#String类能被继承吗，为什么" class="headerlink" title="String类能被继承吗，为什么?"></a>String类能被继承吗，为什么?</h2><blockquote>
<p>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。</p>
</blockquote>
<pre><code class="java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence </code></pre>
<p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>　　final类不能被继承，没有子类，final类中的方法默认是final的。<br>　　final方法不能被子类的方法覆盖，但可以被继承。<br>　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>　　final不能用于修饰构造方法。<br>　　注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>　　使用final方法的原因有二：<br>　　第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>　　第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑）</p>
<blockquote>
<p>下面这段话摘自《Java编程思想》第四版第143页：<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。”</p>
</blockquote>
<p>关于String类，要了解常量池的概念</p>
<pre><code class="java">String s = new String(“xyz”);  //创建了几个对象</code></pre>
<p>答案： 1个或2个， 如果”xyz”已经存在于常量池中，则只在堆中创建”xyz”对象的一个拷贝，否则还要在常量池中在创建一份</p>
<pre><code class="java">String s = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;; //创建了几个对象</code></pre>
<p>答案： 这个和JVM实现有关， 如果常量池为空，可能是1个也可能是7个等</p>
<h2 id="String，Stringbuffer，StringBuilder的区别？"><a href="#String，Stringbuffer，StringBuilder的区别？" class="headerlink" title="String，Stringbuffer，StringBuilder的区别？"></a>String，Stringbuffer，StringBuilder的区别？</h2><p>1、用来处理字符串常用的类有3种：String、StringBuffer和StringBuilder<br>2、三者之间的区别：<br>都是final类，都不允许被继承；<br>String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；<br>StringBuffer类是线程安全的，StringBuilder不是线程安全的；</p>
<p>String 和 StringBuffer：<br>1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；</p>
<p>2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；</p>
<p>3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如：</p>
<pre><code class="java">String s1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</code></pre>
<p>生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：</p>
<pre><code class="java">Java Compiler直接把上述第一条语句编译为：
String s2 = “This is only a”;
String s3 = “ simple”;
String s4 = “ test”;
String s1 = s2 + s3 + s4;</code></pre>
<p><a href="https://www.jianshu.com/p/8c724dd28fa4" target="_blank" rel="noopener">传送门</a></p>
<h2 id="ArrayList和LinkedList有什么区别"><a href="#ArrayList和LinkedList有什么区别" class="headerlink" title="ArrayList和LinkedList有什么区别"></a>ArrayList和LinkedList有什么区别</h2><p>ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。</p>
<p><strong>数据的更新和查找</strong><br>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p>
<p><strong>数据的增加和删除</strong><br>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p>
<p><a href="https://juejin.im/post/5adec492f265da0b9f3fea08#heading-2" target="_blank" rel="noopener">传送门</a></p>
<h2 id="类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序"><a href="#类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序" class="headerlink" title="类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序"></a>类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序</h2><blockquote>
<p>此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。<br>父类静态变量、<br>父类静态代码块、<br>子类静态变量、<br>子类静态代码块、<br>父类非静态变量（父类实例成员变量）、<br>父类构造函数、<br>子类非静态变量（子类实例成员变量）、<br>子类构造函数。 </p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000004527951#articleHeader0" target="_blank" rel="noopener">传送门</a></p>
<h2 id="用过哪些Map，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等"><a href="#用过哪些Map，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等" class="headerlink" title="用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等"></a>用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等</h2><blockquote>
<p>Hashtable,HashMap,ConcurrentHashMap</p>
</blockquote>
<p><strong>线程不安全的HashMap</strong><br>因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
<p><strong>HashMap</strong><br>HashMap内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。其中每个结点存储的是一个键值对整体（Entry），HashMap采用拉链法解决哈希冲突</p>
<p><a href="https://blog.csdn.net/u014532901/article/details/78936283" target="_blank" rel="noopener">传送门</a></p>
<p><strong>效率低下的HashTable容器</strong><br>     HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<p><strong>ConcurrentHashMap的锁分段技术</strong><br>     HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/52279473" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p>hashcode() 方法，在object类中定义如下：</p>
</blockquote>
<pre><code class="java">public native int hashCode();</code></pre>
<p>native说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double。。。。等等这些类都是覆盖了hashcode()方法的<br>例如String类中:就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。(为什么取31?主要是因为31是一个奇质数，所以31i=32i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多).</p>
<pre><code class="java">public int hashCode() {
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) {
        char val[] = value;

        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}</code></pre>
<h2 id="HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发"><a href="#HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发" class="headerlink" title="HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发"></a>HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发</h2><blockquote>
<p>HashMap 底层是基于 数组 + 链表 组成的</p>
</blockquote>
<p><a href="https://juejin.im/post/5b551e8df265da0f84562403#heading-9" target="_blank" rel="noopener">传送门</a></p>
<h2 id="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么"><a href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么" class="headerlink" title="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么"></a>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么</h2><blockquote>
<p>实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。<br><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">抽象类和接口的区别</a></p>
</blockquote>
<blockquote>
<p>由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</p>
</blockquote>
<blockquote>
<p>接口可以继承多个接口。<br>java类是单继承的。classB Extends classA<br>java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……<br>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？<br>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p>
</blockquote>
<h2 id="什么情况下会发生栈内存溢出"><a href="#什么情况下会发生栈内存溢出" class="headerlink" title="什么情况下会发生栈内存溢出"></a>什么情况下会发生栈内存溢出</h2><p><strong>方法递归调用产生这种结果</strong></p>
<blockquote>
<p>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）</p>
</blockquote>
<p>所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。栈溢出(StackOverflowError)</p>
<h2 id="什么是nio，原理"><a href="#什么是nio，原理" class="headerlink" title="什么是nio，原理"></a>什么是nio，原理</h2><blockquote>
<p>NIO是为了弥补传统I/O工作模式的不足而研发的，NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型I/O能力。</p>
</blockquote>
<p>NIO的工作原理是什么？</p>
<p>　　在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O操作完成即可返回，从而减少了管理I/O连接导致的系统开销，大幅度提高了系统性能。</p>
<p>　　当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。</p>
<p>　　并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络I/O设计的并发型服务器程序与以往基于阻塞I/O的实现程序有很大不同，在使用非阻塞网络I/O的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。</p>
<p>　　使用非阻塞型I/O进行并发型服务器程序设计分三个部分：1. 向Selector对象注册感兴趣的事件；2.从Selector中获取所感兴趣的事件；3. 根据不同的事件进行相应的处理。</p>
<p>　　在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展。</p>
<p><a href="https://www.cnblogs.com/johnvajicic/archive/2013/04/18/3028675.html" target="_blank" rel="noopener">传送门</a></p>
<h2 id="反射中，Class-forName和ClassLoader区别"><a href="#反射中，Class-forName和ClassLoader区别" class="headerlink" title="反射中，Class.forName和ClassLoader区别"></a>反射中，Class.forName和ClassLoader区别</h2><p>Java中Class.forName和classloader都可以用来对类进行加载。</p>
<ul>
<li><p>Class.forName(“className”);</p>
<pre><code>  其实这种方法调运的是：Class.forName(className, true, ClassLoader.getCallerClassLoader())方法
  参数一：className，需要加载的类的名称。
  参数二：true，是否对class进行初始化（需要initialize）
  参数三：classLoader，对应的类加载器</code></pre></li>
<li><p>ClassLoader.laodClass(“className”);</p>
<pre><code>  其实这种方法调运的是：ClassLoader.loadClass(name, false)方法
  参数一：name,需要加载的类的名称
  参数二：false，这个类加载以后是否需要去连接（不需要linking）</code></pre></li>
</ul>
<p>可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</p>
<p>而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</p>
<p><a href="https://blog.csdn.net/u013308490/article/details/87809824" target="_blank" rel="noopener">传送门</a></p>
<h2 id="tomcat结构，类加载器流程"><a href="#tomcat结构，类加载器流程" class="headerlink" title="tomcat结构，类加载器流程"></a>tomcat结构，类加载器流程</h2><blockquote>
<p>Tomcat 的总体结构</p>
</blockquote>
<p><img src="/images/2019/09/13/12f00090-d605-11e9-a6a7-0b204ec53b69.png" alt="image.png"></p>
<p>从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。</p>
<p><strong>什么是类加载器？</strong><br>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p><a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">传送门</a></p>
<h2 id="讲讲Spring事务的传播属性-AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式"><a href="#讲讲Spring事务的传播属性-AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式" class="headerlink" title="讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式"></a>讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式</h2><h2 id="Spring的beanFactory和factoryBean的区别"><a href="#Spring的beanFactory和factoryBean的区别" class="headerlink" title="Spring的beanFactory和factoryBean的区别"></a>Spring的beanFactory和factoryBean的区别</h2><h2 id="Spring加载流程"><a href="#Spring加载流程" class="headerlink" title="Spring加载流程"></a>Spring加载流程</h2><h2 id="Spring如何管理事务的"><a href="#Spring如何管理事务的" class="headerlink" title="Spring如何管理事务的"></a>Spring如何管理事务的</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线城池的最大线程数目根据什么确定"><a href="#线城池的最大线程数目根据什么确定" class="headerlink" title="线城池的最大线程数目根据什么确定"></a>线城池的最大线程数目根据什么确定</h2><h2 id="多线程的几种实现方式，什么是线程安全，什么是重排序"><a href="#多线程的几种实现方式，什么是线程安全，什么是重排序" class="headerlink" title="多线程的几种实现方式，什么是线程安全，什么是重排序"></a>多线程的几种实现方式，什么是线程安全，什么是重排序</h2><h2 id="volatile的原理，作用，能代替锁么"><a href="#volatile的原理，作用，能代替锁么" class="headerlink" title="volatile的原理，作用，能代替锁么"></a>volatile的原理，作用，能代替锁么</h2><h2 id="sleep和wait的区别，以及wait的实现原理"><a href="#sleep和wait的区别，以及wait的实现原理" class="headerlink" title="sleep和wait的区别，以及wait的实现原理"></a>sleep和wait的区别，以及wait的实现原理</h2><h2 id="Lock与synchronized-的区别，synchronized-的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁"><a href="#Lock与synchronized-的区别，synchronized-的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁" class="headerlink" title="Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁"></a>Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁</h2><h2 id="用过哪些原子类，他们的参数以及原理是什么"><a href="#用过哪些原子类，他们的参数以及原理是什么" class="headerlink" title="用过哪些原子类，他们的参数以及原理是什么"></a>用过哪些原子类，他们的参数以及原理是什么</h2><h2 id="用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等"><a href="#用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等" class="headerlink" title="用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等"></a>用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等</h2><h2 id="有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"><a href="#有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。" class="headerlink" title="有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"></a>有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。</h2><h2 id="spring的controller是单例还是多例，怎么保证并发的安全"><a href="#spring的controller是单例还是多例，怎么保证并发的安全" class="headerlink" title="spring的controller是单例还是多例，怎么保证并发的安全"></a>spring的controller是单例还是多例，怎么保证并发的安全</h2><h2 id="用三个线程按顺序循环打印abc三个字母，比如abcabcabc"><a href="#用三个线程按顺序循环打印abc三个字母，比如abcabcabc" class="headerlink" title="用三个线程按顺序循环打印abc三个字母，比如abcabcabc"></a>用三个线程按顺序循环打印abc三个字母，比如abcabcabc</h2><h2 id="ThreadLocal用过么，原理是什么，用的时候要注意什么"><a href="#ThreadLocal用过么，原理是什么，用的时候要注意什么" class="headerlink" title="ThreadLocal用过么，原理是什么，用的时候要注意什么"></a>ThreadLocal用过么，原理是什么，用的时候要注意什么</h2><h2 id="如果让你实现一个并发安全的链表，你会怎么做"><a href="#如果让你实现一个并发安全的链表，你会怎么做" class="headerlink" title="如果让你实现一个并发安全的链表，你会怎么做"></a>如果让你实现一个并发安全的链表，你会怎么做</h2><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h2 id="jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等"><a href="#jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等" class="headerlink" title="jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等"></a>jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等</h2><h2 id="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms"><a href="#你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms" class="headerlink" title="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms"></a>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms</h2><h2 id="当出现了内存溢出，你怎么排错"><a href="#当出现了内存溢出，你怎么排错" class="headerlink" title="当出现了内存溢出，你怎么排错"></a>当出现了内存溢出，你怎么排错</h2><h2 id="JVM内存模型的相关知识了解多少"><a href="#JVM内存模型的相关知识了解多少" class="headerlink" title="JVM内存模型的相关知识了解多少"></a>JVM内存模型的相关知识了解多少</h2><h2 id="简单说说你了解的类加载器"><a href="#简单说说你了解的类加载器" class="headerlink" title="简单说说你了解的类加载器"></a>简单说说你了解的类加载器</h2><h2 id="JAVA的反射机制"><a href="#JAVA的反射机制" class="headerlink" title="JAVA的反射机制"></a>JAVA的反射机制</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="http1-0和http1-1有什么区别"><a href="#http1-0和http1-1有什么区别" class="headerlink" title="http1.0和http1.1有什么区别"></a>http1.0和http1.1有什么区别</h2><h2 id="TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么"><a href="#TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么" class="headerlink" title="TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么"></a>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么</h2><h2 id="TIME-WAIT和CLOSE-WAIT的区别"><a href="#TIME-WAIT和CLOSE-WAIT的区别" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别"></a>TIME_WAIT和CLOSE_WAIT的区别</h2><h2 id="说说你知道的几种HTTP响应码"><a href="#说说你知道的几种HTTP响应码" class="headerlink" title="说说你知道的几种HTTP响应码"></a>说说你知道的几种HTTP响应码</h2><h2 id="当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤"><a href="#当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤" class="headerlink" title="当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤"></a>当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤</h2><h2 id="Linux下IO模型有几种，各自的含义是什么"><a href="#Linux下IO模型有几种，各自的含义是什么" class="headerlink" title="Linux下IO模型有几种，各自的含义是什么"></a>Linux下IO模型有几种，各自的含义是什么</h2><h2 id="TCP-IP如何保证可靠性，数据包有哪些数据组成"><a href="#TCP-IP如何保证可靠性，数据包有哪些数据组成" class="headerlink" title="TCP/IP如何保证可靠性，数据包有哪些数据组成"></a>TCP/IP如何保证可靠性，数据包有哪些数据组成</h2><h2 id="架构设计与分布式："><a href="#架构设计与分布式：" class="headerlink" title="架构设计与分布式："></a>架构设计与分布式：</h2><h2 id="tomcat如何调优，各种参数的意义"><a href="#tomcat如何调优，各种参数的意义" class="headerlink" title="tomcat如何调优，各种参数的意义"></a>tomcat如何调优，各种参数的意义</h2><h2 id="常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等"><a href="#常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等" class="headerlink" title="常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等"></a>常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等</h2><h2 id="如何防止缓存雪崩12-用java自己实现一个LRU"><a href="#如何防止缓存雪崩12-用java自己实现一个LRU" class="headerlink" title="如何防止缓存雪崩12.用java自己实现一个LRU"></a>如何防止缓存雪崩12.用java自己实现一个LRU</h2><h2 id="分布式集群下如何做到唯一序列号"><a href="#分布式集群下如何做到唯一序列号" class="headerlink" title="分布式集群下如何做到唯一序列号"></a>分布式集群下如何做到唯一序列号</h2><h2 id="设计一个秒杀系统，30分钟没付款就自动关闭交易"><a href="#设计一个秒杀系统，30分钟没付款就自动关闭交易" class="headerlink" title="设计一个秒杀系统，30分钟没付款就自动关闭交易"></a>设计一个秒杀系统，30分钟没付款就自动关闭交易</h2><h2 id="如何做一个分布式锁"><a href="#如何做一个分布式锁" class="headerlink" title="如何做一个分布式锁"></a>如何做一个分布式锁</h2><h2 id="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"><a href="#用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗" class="headerlink" title="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"></a>用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗</h2><h2 id="MQ系统的数据如何保证不丢失"><a href="#MQ系统的数据如何保证不丢失" class="headerlink" title="MQ系统的数据如何保证不丢失"></a>MQ系统的数据如何保证不丢失</h2><h2 id="分布式事务的原理，如何使用分布式事务"><a href="#分布式事务的原理，如何使用分布式事务" class="headerlink" title="分布式事务的原理，如何使用分布式事务"></a>分布式事务的原理，如何使用分布式事务</h2><h2 id="什么是一致性hash"><a href="#什么是一致性hash" class="headerlink" title="什么是一致性hash"></a>什么是一致性hash</h2><h2 id="什么是restful，讲讲你理解的restful"><a href="#什么是restful，讲讲你理解的restful" class="headerlink" title="什么是restful，讲讲你理解的restful"></a>什么是restful，讲讲你理解的restful</h2><h2 id="如何设计建立和保持100w的长连接？"><a href="#如何设计建立和保持100w的长连接？" class="headerlink" title="如何设计建立和保持100w的长连接？"></a>如何设计建立和保持100w的长连接？</h2><h2 id="解释什么是MESI协议-缓存一致性"><a href="#解释什么是MESI协议-缓存一致性" class="headerlink" title="解释什么是MESI协议(缓存一致性)"></a>解释什么是MESI协议(缓存一致性)</h2><h2 id="说说你知道的几种HASH算法，简单的也可以"><a href="#说说你知道的几种HASH算法，简单的也可以" class="headerlink" title="说说你知道的几种HASH算法，简单的也可以"></a>说说你知道的几种HASH算法，简单的也可以</h2><h2 id="什么是paxos算法"><a href="#什么是paxos算法" class="headerlink" title="什么是paxos算法"></a>什么是paxos算法</h2><h2 id="redis和memcached-的内存管理的区别"><a href="#redis和memcached-的内存管理的区别" class="headerlink" title="redis和memcached 的内存管理的区别"></a>redis和memcached 的内存管理的区别</h2><h2 id="一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新"><a href="#一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新" class="headerlink" title="一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新"></a>一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新</h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="10亿个数字里里面找最小的10个"><a href="#10亿个数字里里面找最小的10个" class="headerlink" title="10亿个数字里里面找最小的10个"></a>10亿个数字里里面找最小的10个</h2><h2 id="有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优"><a href="#有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优" class="headerlink" title="有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优"></a>有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优</h2><h2 id="2亿个随机生成的无序整数-找出中间大小的值"><a href="#2亿个随机生成的无序整数-找出中间大小的值" class="headerlink" title="2亿个随机生成的无序整数,找出中间大小的值"></a>2亿个随机生成的无序整数,找出中间大小的值</h2><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点"><a href="#数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点" class="headerlink" title="数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点"></a>数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点</h2><h2 id="高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义"><a href="#高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义" class="headerlink" title="高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义"></a>高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义</h2><h2 id="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？"><a href="#SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？" class="headerlink" title="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？"></a>SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？</h2><h2 id="数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁"><a href="#数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁" class="headerlink" title="数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁"></a>数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁</h2><h2 id="MYsql的索引实现方式"><a href="#MYsql的索引实现方式" class="headerlink" title="MYsql的索引实现方式"></a>MYsql的索引实现方式</h2><h2 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h2><h2 id="数据库中-BTREE和B-tree区别"><a href="#数据库中-BTREE和B-tree区别" class="headerlink" title="数据库中 BTREE和B+tree区别"></a>数据库中 BTREE和B+tree区别</h2>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-06T06:20:34.000Z">2019-09-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    37 分钟 读完 (大约 5584 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/06/System类/">System类</a>
            
        </h1>
        <div class="content">
            <p><img src="/images/2019/09/06/6505ce10-d06e-11e9-b8c8-91efca18534b.png" alt="image.png"></p>
<pre><code class="java">/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 */
package java.lang;

import java.io.*;
import java.lang.reflect.Executable;
import java.lang.annotation.Annotation;
import java.security.AccessControlContext;
import java.util.Properties;
import java.util.PropertyPermission;
import java.util.StringTokenizer;
import java.util.Map;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.AllPermission;
import java.nio.channels.Channel;
import java.nio.channels.spi.SelectorProvider;
import sun.nio.ch.Interruptible;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.security.util.SecurityConstants;
import sun.reflect.annotation.AnnotationType;

/**
 * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields
 * and methods. It cannot be instantiated.
 *
 * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class
 * are standard input, standard output, and error output streams;
 * access to externally defined properties and environment
 * variables; a means of loading files and libraries; and a utility
 * method for quickly copying a portion of an array.
 *
 * @author  unascribed
 * @since   JDK1.0
 */
public final class System {

    /* register the natives via the static initializer.
     *
     * VM will invoke the initializeSystemClass method to complete
     * the initialization for this class separated from clinit.
     * Note that to use properties set by the VM, see the constraints
     * described in the initializeSystemClass method.
     */
    private static native void registerNatives();
    static {
        registerNatives();
    }

    /** Don&#39;t let anyone instantiate this class */
    private System() {
    }

    /**
     * The &quot;standard&quot; input stream. This stream is already
     * open and ready to supply input data. Typically this stream
     * corresponds to keyboard input or another input source specified by
     * the host environment or user.
     */
    public final static InputStream in = null;

    /**
     * The &quot;standard&quot; output stream. This stream is already
     * open and ready to accept output data. Typically this stream
     * corresponds to display output or another output destination
     * specified by the host environment or user.
     * &lt;p&gt;
     * For simple stand-alone Java applications, a typical way to write
     * a line of output data is:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     System.out.println(data)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * See the &lt;code&gt;println&lt;/code&gt; methods in class &lt;code&gt;PrintStream&lt;/code&gt;.
     *
     * @see     java.io.PrintStream#println()
     * @see     java.io.PrintStream#println(boolean)
     * @see     java.io.PrintStream#println(char)
     * @see     java.io.PrintStream#println(char[])
     * @see     java.io.PrintStream#println(double)
     * @see     java.io.PrintStream#println(float)
     * @see     java.io.PrintStream#println(int)
     * @see     java.io.PrintStream#println(long)
     * @see     java.io.PrintStream#println(java.lang.Object)
     * @see     java.io.PrintStream#println(java.lang.String)
     */
    public final static PrintStream out = null;

    /**
     * The &quot;standard&quot; error output stream. This stream is already
     * open and ready to accept output data.
     * &lt;p&gt;
     * Typically this stream corresponds to display output or another
     * output destination specified by the host environment or user. By
     * convention, this output stream is used to display error messages
     * or other information that should come to the immediate attention
     * of a user even if the principal output stream, the value of the
     * variable &lt;code&gt;out&lt;/code&gt;, has been redirected to a file or other
     * destination that is typically not continuously monitored.
     */
    public final static PrintStream err = null;

    /* The security manager for the system.
     */
    private static volatile SecurityManager security = null;

    /**
     * Reassigns the &quot;standard&quot; input stream.
     *
     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with a &lt;code&gt;RuntimePermission(&quot;setIO&quot;)&lt;/code&gt; permission
     *  to see if it&#39;s ok to reassign the &quot;standard&quot; input stream.
     * &lt;p&gt;
     *
     * @param in the new standard input stream.
     *
     * @throws SecurityException
     *        if a security manager exists and its
     *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow
     *        reassigning of the standard input stream.
     *
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     *
     * @since   JDK1.1
     */
    public static void setIn(InputStream in) {
        checkIO();
        setIn0(in);
    }

    /**
     * Reassigns the &quot;standard&quot; output stream.
     *
     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with a &lt;code&gt;RuntimePermission(&quot;setIO&quot;)&lt;/code&gt; permission
     *  to see if it&#39;s ok to reassign the &quot;standard&quot; output stream.
     *
     * @param out the new standard output stream
     *
     * @throws SecurityException
     *        if a security manager exists and its
     *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow
     *        reassigning of the standard output stream.
     *
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     *
     * @since   JDK1.1
     */
    public static void setOut(PrintStream out) {
        checkIO();
        setOut0(out);
    }

    /**
     * Reassigns the &quot;standard&quot; error output stream.
     *
     * &lt;p&gt;First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with a &lt;code&gt;RuntimePermission(&quot;setIO&quot;)&lt;/code&gt; permission
     *  to see if it&#39;s ok to reassign the &quot;standard&quot; error output stream.
     *
     * @param err the new standard error output stream.
     *
     * @throws SecurityException
     *        if a security manager exists and its
     *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow
     *        reassigning of the standard error output stream.
     *
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     *
     * @since   JDK1.1
     */
    public static void setErr(PrintStream err) {
        checkIO();
        setErr0(err);
    }

    private static volatile Console cons = null;
    /**
     * Returns the unique {@link java.io.Console Console} object associated
     * with the current Java virtual machine, if any.
     *
     * @return  The system console, if any, otherwise &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @since   1.6
     */
     public static Console console() {
         if (cons == null) {
             synchronized (System.class) {
                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();
             }
         }
         return cons;
     }

    /**
     * Returns the channel inherited from the entity that created this
     * Java virtual machine.
     *
     * &lt;p&gt; This method returns the channel obtained by invoking the
     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
     * inheritedChannel} method of the system-wide default
     * {@link java.nio.channels.spi.SelectorProvider} object. &lt;/p&gt;
     *
     * &lt;p&gt; In addition to the network-oriented channels described in
     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
     * inheritedChannel}, this method may return other kinds of
     * channels in the future.
     *
     * @return  The inherited channel, if any, otherwise &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @throws  IOException
     *          If an I/O error occurs
     *
     * @throws  SecurityException
     *          If a security manager is present and it does not
     *          permit access to the channel.
     *
     * @since 1.5
     */
    public static Channel inheritedChannel() throws IOException {
        return SelectorProvider.provider().inheritedChannel();
    }

    private static void checkIO() {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission(&quot;setIO&quot;));
        }
    }

    private static native void setIn0(InputStream in);
    private static native void setOut0(PrintStream out);
    private static native void setErr0(PrintStream err);

    /**
     * Sets the System security.
     *
     * &lt;p&gt; If there is a security manager already installed, this method first
     * calls the security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method
     * with a &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt;
     * permission to ensure it&#39;s ok to replace the existing
     * security manager.
     * This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.
     *
     * &lt;p&gt; Otherwise, the argument is established as the current
     * security manager. If the argument is &lt;code&gt;null&lt;/code&gt; and no
     * security manager has been established, then no action is taken and
     * the method simply returns.
     *
     * @param      s   the security manager.
     * @exception  SecurityException  if the security manager has already
     *             been set and its &lt;code&gt;checkPermission&lt;/code&gt; method
     *             doesn&#39;t allow it to be replaced.
     * @see #getSecurityManager
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     */
    public static
    void setSecurityManager(final SecurityManager s) {
        try {
            s.checkPackageAccess(&quot;java.lang&quot;);
        } catch (Exception e) {
            // no-op
        }
        setSecurityManager0(s);
    }

    private static synchronized
    void setSecurityManager0(final SecurityManager s) {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            // ask the currently installed security manager if we
            // can replace it.
            sm.checkPermission(new RuntimePermission
                                     (&quot;setSecurityManager&quot;));
        }

        if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) {
            // New security manager class is not on bootstrap classpath.
            // Cause policy to get initialized before we install the new
            // security manager, in order to prevent infinite loops when
            // trying to initialize the policy (which usually involves
            // accessing some security and/or system properties, which in turn
            // calls the installed security manager&#39;s checkPermission method
            // which will loop infinitely if there is a non-system class
            // (in this case: the new security manager class) on the stack).
            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
                public Object run() {
                    s.getClass().getProtectionDomain().implies
                        (SecurityConstants.ALL_PERMISSION);
                    return null;
                }
            });
        }

        security = s;
    }

    /**
     * Gets the system security interface.
     *
     * @return  if a security manager has already been established for the
     *          current application, then that security manager is returned;
     *          otherwise, &lt;code&gt;null&lt;/code&gt; is returned.
     * @see     #setSecurityManager
     */
    public static SecurityManager getSecurityManager() {
        return security;
    }

    /**
     * Returns the current time in milliseconds.  Note that
     * while the unit of time of the return value is a millisecond,
     * the granularity of the value depends on the underlying
     * operating system and may be larger.  For example, many
     * operating systems measure time in units of tens of
     * milliseconds.
     *
     * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;/code&gt; for
     * a discussion of slight discrepancies that may arise between
     * &quot;computer time&quot; and coordinated universal time (UTC).
     *
     * @return  the difference, measured in milliseconds, between
     *          the current time and midnight, January 1, 1970 UTC.
     * @see     java.util.Date
     */
    public static native long currentTimeMillis();

    /**
     * Returns the current value of the running Java Virtual Machine&#39;s
     * high-resolution time source, in nanoseconds.
     *
     * &lt;p&gt;This method can only be used to measure elapsed time and is
     * not related to any other notion of system or wall-clock time.
     * The value returned represents nanoseconds since some fixed but
     * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values
     * may be negative).  The same origin is used by all invocations of
     * this method in an instance of a Java virtual machine; other
     * virtual machine instances are likely to use a different origin.
     *
     * &lt;p&gt;This method provides nanosecond precision, but not necessarily
     * nanosecond resolution (that is, how frequently the value changes)
     * - no guarantees are made except that the resolution is at least as
     * good as that of {@link #currentTimeMillis()}.
     *
     * &lt;p&gt;Differences in successive calls that span greater than
     * approximately 292 years (2&lt;sup&gt;63&lt;/sup&gt; nanoseconds) will not
     * correctly compute elapsed time due to numerical overflow.
     *
     * &lt;p&gt;The values returned by this method become meaningful only when
     * the difference between two such values, obtained within the same
     * instance of a Java virtual machine, is computed.
     *
     * &lt;p&gt; For example, to measure how long some code takes to execute:
     *  &lt;pre&gt; {@code
     * long startTime = System.nanoTime();
     * // ... the code being measured ...
     * long estimatedTime = System.nanoTime() - startTime;}&lt;/pre&gt;
     *
     * &lt;p&gt;To compare two nanoTime values
     *  &lt;pre&gt; {@code
     * long t0 = System.nanoTime();
     * ...
     * long t1 = System.nanoTime();}&lt;/pre&gt;
     *
     * one should use {@code t1 - t0 &lt; 0}, not {@code t1 &lt; t0},
     * because of the possibility of numerical overflow.
     *
     * @return the current value of the running Java Virtual Machine&#39;s
     *         high-resolution time source, in nanoseconds
     * @since 1.5
     */
    public static native long nanoTime();

    /**
     * Copies an array from the specified source array, beginning at the
     * specified position, to the specified position of the destination array.
     * A subsequence of array components are copied from the source
     * array referenced by &lt;code&gt;src&lt;/code&gt; to the destination array
     * referenced by &lt;code&gt;dest&lt;/code&gt;. The number of components copied is
     * equal to the &lt;code&gt;length&lt;/code&gt; argument. The components at
     * positions &lt;code&gt;srcPos&lt;/code&gt; through
     * &lt;code&gt;srcPos+length-1&lt;/code&gt; in the source array are copied into
     * positions &lt;code&gt;destPos&lt;/code&gt; through
     * &lt;code&gt;destPos+length-1&lt;/code&gt;, respectively, of the destination
     * array.
     * &lt;p&gt;
     * If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the
     * same array object, then the copying is performed as if the
     * components at positions &lt;code&gt;srcPos&lt;/code&gt; through
     * &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary
     * array with &lt;code&gt;length&lt;/code&gt; components and then the contents of
     * the temporary array were copied into positions
     * &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the
     * destination array.
     * &lt;p&gt;
     * If &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination
     * array is not modified.
     * &lt;p&gt;
     * Otherwise, if any of the following is true, an
     * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown and the destination is
     * not modified:
     * &lt;ul&gt;
     * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an object that is not an
     *     array.
     * &lt;li&gt;The &lt;code&gt;dest&lt;/code&gt; argument refers to an object that is not an
     *     array.
     * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument and &lt;code&gt;dest&lt;/code&gt; argument refer
     *     to arrays whose component types are different primitive types.
     * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a primitive
     *    component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array
     *     with a reference component type.
     * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a reference
     *    component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array
     *     with a primitive component type.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Otherwise, if any of the following is true, an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is
     * thrown and the destination is not modified:
     * &lt;ul&gt;
     * &lt;li&gt;The &lt;code&gt;srcPos&lt;/code&gt; argument is negative.
     * &lt;li&gt;The &lt;code&gt;destPos&lt;/code&gt; argument is negative.
     * &lt;li&gt;The &lt;code&gt;length&lt;/code&gt; argument is negative.
     * &lt;li&gt;&lt;code&gt;srcPos+length&lt;/code&gt; is greater than
     *     &lt;code&gt;src.length&lt;/code&gt;, the length of the source array.
     * &lt;li&gt;&lt;code&gt;destPos+length&lt;/code&gt; is greater than
     *     &lt;code&gt;dest.length&lt;/code&gt;, the length of the destination array.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Otherwise, if any actual component of the source array from
     * position &lt;code&gt;srcPos&lt;/code&gt; through
     * &lt;code&gt;srcPos+length-1&lt;/code&gt; cannot be converted to the component
     * type of the destination array by assignment conversion, an
     * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown. In this case, let
     * &lt;b&gt;&lt;i&gt;k&lt;/i&gt;&lt;/b&gt; be the smallest nonnegative integer less than
     * length such that &lt;code&gt;src[srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt;
     * cannot be converted to the component type of the destination
     * array; when the exception is thrown, source array components from
     * positions &lt;code&gt;srcPos&lt;/code&gt; through
     * &lt;code&gt;srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1&lt;/code&gt;
     * will already have been copied to destination array positions
     * &lt;code&gt;destPos&lt;/code&gt; through
     * &lt;code&gt;destPos+&lt;/code&gt;&lt;i&gt;k&lt;/I&gt;&lt;code&gt;-1&lt;/code&gt; and no other
     * positions of the destination array will have been modified.
     * (Because of the restrictions already itemized, this
     * paragraph effectively applies only to the situation where both
     * arrays have component types that are reference types.)
     *
     * @param      src      the source array.
     * @param      srcPos   starting position in the source array.
     * @param      dest     the destination array.
     * @param      destPos  starting position in the destination data.
     * @param      length   the number of array elements to be copied.
     * @exception  IndexOutOfBoundsException  if copying would cause
     *               access of data outside array bounds.
     * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;/code&gt;
     *               array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array
     *               because of a type mismatch.
     * @exception  NullPointerException if either &lt;code&gt;src&lt;/code&gt; or
     *               &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);

    /**
     * Returns the same hash code for the given object as
     * would be returned by the default method hashCode(),
     * whether or not the given object&#39;s class overrides
     * hashCode().
     * The hash code for the null reference is zero.
     *
     * @param x object for which the hashCode is to be calculated
     * @return  the hashCode
     * @since   JDK1.1
     */
    public static native int identityHashCode(Object x);

    /**
     * System properties. The following properties are guaranteed to be defined:
     * &lt;dl&gt;
     * &lt;dt&gt;java.version         &lt;dd&gt;Java version number
     * &lt;dt&gt;java.vendor          &lt;dd&gt;Java vendor specific string
     * &lt;dt&gt;java.vendor.url      &lt;dd&gt;Java vendor URL
     * &lt;dt&gt;java.home            &lt;dd&gt;Java installation directory
     * &lt;dt&gt;java.class.version   &lt;dd&gt;Java class version number
     * &lt;dt&gt;java.class.path      &lt;dd&gt;Java classpath
     * &lt;dt&gt;os.name              &lt;dd&gt;Operating System Name
     * &lt;dt&gt;os.arch              &lt;dd&gt;Operating System Architecture
     * &lt;dt&gt;os.version           &lt;dd&gt;Operating System Version
     * &lt;dt&gt;file.separator       &lt;dd&gt;File separator (&quot;/&quot; on Unix)
     * &lt;dt&gt;path.separator       &lt;dd&gt;Path separator (&quot;:&quot; on Unix)
     * &lt;dt&gt;line.separator       &lt;dd&gt;Line separator (&quot;\n&quot; on Unix)
     * &lt;dt&gt;user.name            &lt;dd&gt;User account name
     * &lt;dt&gt;user.home            &lt;dd&gt;User home directory
     * &lt;dt&gt;user.dir             &lt;dd&gt;User&#39;s current working directory
     * &lt;/dl&gt;
     */

    private static Properties props;
    private static native Properties initProperties(Properties props);

    /**
     * Determines the current system properties.
     * &lt;p&gt;
     * First, if there is a security manager, its
     * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called with no
     * arguments. This may result in a security exception.
     * &lt;p&gt;
     * The current set of system properties for use by the
     * {@link #getProperty(String)} method is returned as a
     * &lt;code&gt;Properties&lt;/code&gt; object. If there is no current set of
     * system properties, a set of system properties is first created and
     * initialized. This set of system properties always includes values
     * for the following keys:
     * &lt;table summary=&quot;Shows property keys and associated values&quot;&gt;
     * &lt;tr&gt;&lt;th&gt;Key&lt;/th&gt;
     *     &lt;th&gt;Description of Associated Value&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Runtime Environment version&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Runtime Environment vendor&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vendor.url&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java vendor URL&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.home&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java installation directory&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine specification version&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.vendor&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine specification vendor&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.specification.name&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine specification name&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine implementation version&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.vendor&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine implementation vendor&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.vm.name&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Virtual Machine implementation name&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Runtime Environment specification  version&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.vendor&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Runtime Environment specification  vendor&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.specification.name&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java Runtime Environment specification  name&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java class format version number&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.class.path&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Java class path&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.library.path&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;List of paths to search when loading libraries&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.io.tmpdir&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Default temp file path&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.compiler&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Name of JIT compiler to use&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;java.ext.dirs&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Path of extension directory or directories
     *         &lt;b&gt;Deprecated.&lt;/b&gt; &lt;i&gt;This property, and the mechanism
     *            which implements it, may be removed in a future
     *            release.&lt;/i&gt; &lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.name&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Operating system name&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.arch&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Operating system architecture&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;os.version&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Operating system version&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;file.separator&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;File separator (&quot;/&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;path.separator&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Path separator (&quot;:&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;line.separator&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;Line separator (&quot;\n&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.name&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;User&#39;s account name&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.home&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;User&#39;s home directory&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;user.dir&lt;/code&gt;&lt;/td&gt;
     *     &lt;td&gt;User&#39;s current working directory&lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;
     * &lt;p&gt;
     * Multiple paths in a system property value are separated by the path
     * separator character of the platform.
     * &lt;p&gt;
     * Note that even if the security manager does not permit the
     * &lt;code&gt;getProperties&lt;/code&gt; operation, it may choose to permit the
     * {@link #getProperty(String)} operation.
     *
     * @return     the system properties
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method doesn&#39;t allow access
     *              to the system properties.
     * @see        #setProperties
     * @see        java.lang.SecurityException
     * @see        java.lang.SecurityManager#checkPropertiesAccess()
     * @see        java.util.Properties
     */
    public static Properties getProperties() {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPropertiesAccess();
        }

        return props;
    }

    /**
     * Returns the system-dependent line separator string.  It always
     * returns the same value - the initial value of the {@linkplain
     * #getProperty(String) system property} {@code line.separator}.
     *
     * &lt;p&gt;On UNIX systems, it returns {@code &quot;\n&quot;}; on Microsoft
     * Windows systems it returns {@code &quot;\r\n&quot;}.
     *
     * @return the system-dependent line separator string
     * @since 1.7
     */
    public static String lineSeparator() {
        return lineSeparator;
    }

    private static String lineSeparator;

    /**
     * Sets the system properties to the &lt;code&gt;Properties&lt;/code&gt;
     * argument.
     * &lt;p&gt;
     * First, if there is a security manager, its
     * &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called with no
     * arguments. This may result in a security exception.
     * &lt;p&gt;
     * The argument becomes the current set of system properties for use
     * by the {@link #getProperty(String)} method. If the argument is
     * &lt;code&gt;null&lt;/code&gt;, then the current set of system properties is
     * forgotten.
     *
     * @param      props   the new system properties.
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method doesn&#39;t allow access
     *              to the system properties.
     * @see        #getProperties
     * @see        java.util.Properties
     * @see        java.lang.SecurityException
     * @see        java.lang.SecurityManager#checkPropertiesAccess()
     */
    public static void setProperties(Properties props) {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPropertiesAccess();
        }
        if (props == null) {
            props = new Properties();
            initProperties(props);
        }
        System.props = props;
    }

    /**
     * Gets the system property indicated by the specified key.
     * &lt;p&gt;
     * First, if there is a security manager, its
     * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method is called with the key as
     * its argument. This may result in a SecurityException.
     * &lt;p&gt;
     * If there is no current set of system properties, a set of system
     * properties is first created and initialized in the same manner as
     * for the &lt;code&gt;getProperties&lt;/code&gt; method.
     *
     * @param      key   the name of the system property.
     * @return     the string value of the system property,
     *             or &lt;code&gt;null&lt;/code&gt; if there is no property with that key.
     *
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn&#39;t allow
     *              access to the specified system property.
     * @exception  NullPointerException if &lt;code&gt;key&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.
     * @see        #setProperty
     * @see        java.lang.SecurityException
     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
     * @see        java.lang.System#getProperties()
     */
    public static String getProperty(String key) {
        checkKey(key);
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPropertyAccess(key);
        }

        return props.getProperty(key);
    }

    /**
     * Gets the system property indicated by the specified key.
     * &lt;p&gt;
     * First, if there is a security manager, its
     * &lt;code&gt;checkPropertyAccess&lt;/code&gt; method is called with the
     * &lt;code&gt;key&lt;/code&gt; as its argument.
     * &lt;p&gt;
     * If there is no current set of system properties, a set of system
     * properties is first created and initialized in the same manner as
     * for the &lt;code&gt;getProperties&lt;/code&gt; method.
     *
     * @param      key   the name of the system property.
     * @param      def   a default value.
     * @return     the string value of the system property,
     *             or the default value if there is no property with that key.
     *
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn&#39;t allow
     *             access to the specified system property.
     * @exception  NullPointerException if &lt;code&gt;key&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.
     * @see        #setProperty
     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
     * @see        java.lang.System#getProperties()
     */
    public static String getProperty(String key, String def) {
        checkKey(key);
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPropertyAccess(key);
        }

        return props.getProperty(key, def);
    }

    /**
     * Sets the system property indicated by the specified key.
     * &lt;p&gt;
     * First, if a security manager exists, its
     * &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method
     * is called with a &lt;code&gt;PropertyPermission(key, &quot;write&quot;)&lt;/code&gt;
     * permission. This may result in a SecurityException being thrown.
     * If no exception is thrown, the specified property is set to the given
     * value.
     * &lt;p&gt;
     *
     * @param      key   the name of the system property.
     * @param      value the value of the system property.
     * @return     the previous value of the system property,
     *             or &lt;code&gt;null&lt;/code&gt; if it did not have one.
     *
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow
     *             setting of the specified property.
     * @exception  NullPointerException if &lt;code&gt;key&lt;/code&gt; or
     *             &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.
     * @see        #getProperty
     * @see        java.lang.System#getProperty(java.lang.String)
     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)
     * @see        java.util.PropertyPermission
     * @see        SecurityManager#checkPermission
     * @since      1.2
     */
    public static String setProperty(String key, String value) {
        checkKey(key);
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new PropertyPermission(key,
                SecurityConstants.PROPERTY_WRITE_ACTION));
        }

        return (String) props.setProperty(key, value);
    }

    /**
     * Removes the system property indicated by the specified key.
     * &lt;p&gt;
     * First, if a security manager exists, its
     * &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method
     * is called with a &lt;code&gt;PropertyPermission(key, &quot;write&quot;)&lt;/code&gt;
     * permission. This may result in a SecurityException being thrown.
     * If no exception is thrown, the specified property is removed.
     * &lt;p&gt;
     *
     * @param      key   the name of the system property to be removed.
     * @return     the previous string value of the system property,
     *             or &lt;code&gt;null&lt;/code&gt; if there was no property with that key.
     *
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkPropertyAccess&lt;/code&gt; method doesn&#39;t allow
     *              access to the specified system property.
     * @exception  NullPointerException if &lt;code&gt;key&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;.
     * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.
     * @see        #getProperty
     * @see        #setProperty
     * @see        java.util.Properties
     * @see        java.lang.SecurityException
     * @see        java.lang.SecurityManager#checkPropertiesAccess()
     * @since 1.5
     */
    public static String clearProperty(String key) {
        checkKey(key);
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new PropertyPermission(key, &quot;write&quot;));
        }

        return (String) props.remove(key);
    }

    private static void checkKey(String key) {
        if (key == null) {
            throw new NullPointerException(&quot;key can&#39;t be null&quot;);
        }
        if (key.equals(&quot;&quot;)) {
            throw new IllegalArgumentException(&quot;key can&#39;t be empty&quot;);
        }
    }

    /**
     * Gets the value of the specified environment variable. An
     * environment variable is a system-dependent external named
     * value.
     *
     * &lt;p&gt;If a security manager exists, its
     * {@link SecurityManager#checkPermission checkPermission}
     * method is called with a
     * &lt;code&gt;{@link RuntimePermission}(&quot;getenv.&quot;+name)&lt;/code&gt;
     * permission.  This may result in a {@link SecurityException}
     * being thrown.  If no exception is thrown the value of the
     * variable &lt;code&gt;name&lt;/code&gt; is returned.
     *
     * &lt;p&gt;&lt;a name=&quot;EnvironmentVSSystemProperties&quot;&gt;&lt;i&gt;System
     * properties&lt;/i&gt; and &lt;i&gt;environment variables&lt;/i&gt;&lt;/a&gt; are both
     * conceptually mappings between names and values.  Both
     * mechanisms can be used to pass user-defined information to a
     * Java process.  Environment variables have a more global effect,
     * because they are visible to all descendants of the process
     * which defines them, not just the immediate Java subprocess.
     * They can have subtly different semantics, such as case
     * insensitivity, on different operating systems.  For these
     * reasons, environment variables are more likely to have
     * unintended side effects.  It is best to use system properties
     * where possible.  Environment variables should be used when a
     * global effect is desired, or when an external system interface
     * requires an environment variable (such as &lt;code&gt;PATH&lt;/code&gt;).
     *
     * &lt;p&gt;On UNIX systems the alphabetic case of &lt;code&gt;name&lt;/code&gt; is
     * typically significant, while on Microsoft Windows systems it is
     * typically not.  For example, the expression
     * &lt;code&gt;System.getenv(&quot;FOO&quot;).equals(System.getenv(&quot;foo&quot;))&lt;/code&gt;
     * is likely to be true on Microsoft Windows.
     *
     * @param  name the name of the environment variable
     * @return the string value of the variable, or &lt;code&gt;null&lt;/code&gt;
     *         if the variable is not defined in the system environment
     * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws SecurityException
     *         if a security manager exists and its
     *         {@link SecurityManager#checkPermission checkPermission}
     *         method doesn&#39;t allow access to the environment variable
     *         &lt;code&gt;name&lt;/code&gt;
     * @see    #getenv()
     * @see    ProcessBuilder#environment()
     */
    public static String getenv(String name) {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission(&quot;getenv.&quot;+name));
        }

        return ProcessEnvironment.getenv(name);
    }


    /**
     * Returns an unmodifiable string map view of the current system environment.
     * The environment is a system-dependent mapping from names to
     * values which is passed from parent to child processes.
     *
     * &lt;p&gt;If the system does not support environment variables, an
     * empty map is returned.
     *
     * &lt;p&gt;The returned map will never contain null keys or values.
     * Attempting to query the presence of a null key or value will
     * throw a {@link NullPointerException}.  Attempting to query
     * the presence of a key or value which is not of type
     * {@link String} will throw a {@link ClassCastException}.
     *
     * &lt;p&gt;The returned map and its collection views may not obey the
     * general contract of the {@link Object#equals} and
     * {@link Object#hashCode} methods.
     *
     * &lt;p&gt;The returned map is typically case-sensitive on all platforms.
     *
     * &lt;p&gt;If a security manager exists, its
     * {@link SecurityManager#checkPermission checkPermission}
     * method is called with a
     * &lt;code&gt;{@link RuntimePermission}(&quot;getenv.*&quot;)&lt;/code&gt;
     * permission.  This may result in a {@link SecurityException} being
     * thrown.
     *
     * &lt;p&gt;When passing information to a Java subprocess,
     * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;/a&gt;
     * are generally preferred over environment variables.
     *
     * @return the environment as a map of variable names to values
     * @throws SecurityException
     *         if a security manager exists and its
     *         {@link SecurityManager#checkPermission checkPermission}
     *         method doesn&#39;t allow access to the process environment
     * @see    #getenv(String)
     * @see    ProcessBuilder#environment()
     * @since  1.5
     */
    public static java.util.Map&lt;String,String&gt; getenv() {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission(&quot;getenv.*&quot;));
        }

        return ProcessEnvironment.getenv();
    }

    /**
     * Terminates the currently running Java Virtual Machine. The
     * argument serves as a status code; by convention, a nonzero status
     * code indicates abnormal termination.
     * &lt;p&gt;
     * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class
     * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally.
     * &lt;p&gt;
     * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to
     * the call:
     * &lt;blockquote&gt;&lt;pre&gt;
     * Runtime.getRuntime().exit(n)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param      status   exit status.
     * @throws  SecurityException
     *        if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt;
     *        method doesn&#39;t allow exit with the specified status.
     * @see        java.lang.Runtime#exit(int)
     */
    public static void exit(int status) {
        Runtime.getRuntime().exit(status);
    }

    /**
     * Runs the garbage collector.
     * &lt;p&gt;
     * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual
     * Machine expend effort toward recycling unused objects in order to
     * make the memory they currently occupy available for quick reuse.
     * When control returns from the method call, the Java Virtual
     * Machine has made a best effort to reclaim space from all discarded
     * objects.
     * &lt;p&gt;
     * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the
     * call:
     * &lt;blockquote&gt;&lt;pre&gt;
     * Runtime.getRuntime().gc()
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @see     java.lang.Runtime#gc()
     */
    public static void gc() {
        Runtime.getRuntime().gc();
    }

    /**
     * Runs the finalization methods of any objects pending finalization.
     * &lt;p&gt;
     * Calling this method suggests that the Java Virtual Machine expend
     * effort toward running the &lt;code&gt;finalize&lt;/code&gt; methods of objects
     * that have been found to be discarded but whose &lt;code&gt;finalize&lt;/code&gt;
     * methods have not yet been run. When control returns from the
     * method call, the Java Virtual Machine has made a best effort to
     * complete all outstanding finalizations.
     * &lt;p&gt;
     * The call &lt;code&gt;System.runFinalization()&lt;/code&gt; is effectively
     * equivalent to the call:
     * &lt;blockquote&gt;&lt;pre&gt;
     * Runtime.getRuntime().runFinalization()
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @see     java.lang.Runtime#runFinalization()
     */
    public static void runFinalization() {
        Runtime.getRuntime().runFinalization();
    }

    /**
     * Enable or disable finalization on exit; doing so specifies that the
     * finalizers of all objects that have finalizers that have not yet been
     * automatically invoked are to be run before the Java runtime exits.
     * By default, finalization on exit is disabled.
     *
     * &lt;p&gt;If there is a security manager,
     * its &lt;code&gt;checkExit&lt;/code&gt; method is first called
     * with 0 as its argument to ensure the exit is allowed.
     * This could result in a SecurityException.
     *
     * @deprecated  This method is inherently unsafe.  It may result in
     *      finalizers being called on live objects while other threads are
     *      concurrently manipulating those objects, resulting in erratic
     *      behavior or deadlock.
     * @param value indicating enabling or disabling of finalization
     * @throws  SecurityException
     *        if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt;
     *        method doesn&#39;t allow the exit.
     *
     * @see     java.lang.Runtime#exit(int)
     * @see     java.lang.Runtime#gc()
     * @see     java.lang.SecurityManager#checkExit(int)
     * @since   JDK1.1
     */
    @Deprecated
    public static void runFinalizersOnExit(boolean value) {
        Runtime.runFinalizersOnExit(value);
    }

    /**
     * Loads the native library specified by the filename argument.  The filename
     * argument must be an absolute path name.
     *
     * If the filename argument, when stripped of any platform-specific library
     * prefix, path, and file extension, indicates a library whose name is,
     * for example, L, and a native library called L is statically linked
     * with the VM, then the JNI_OnLoad_L function exported by the library
     * is invoked rather than attempting to load a dynamic library.
     * A filename matching the argument does not have to exist in the
     * file system.
     * See the JNI Specification for more details.
     *
     * Otherwise, the filename argument is mapped to a native library image in
     * an implementation-dependent manner.
     *
     * &lt;p&gt;
     * The call &lt;code&gt;System.load(name)&lt;/code&gt; is effectively equivalent
     * to the call:
     * &lt;blockquote&gt;&lt;pre&gt;
     * Runtime.getRuntime().load(name)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param      filename   the file to load.
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkLink&lt;/code&gt; method doesn&#39;t allow
     *             loading of the specified dynamic library
     * @exception  UnsatisfiedLinkError  if either the filename is not an
     *             absolute path name, the native library is not statically
     *             linked with the VM, or the library cannot be mapped to
     *             a native library image by the host system.
     * @exception  NullPointerException if &lt;code&gt;filename&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;
     * @see        java.lang.Runtime#load(java.lang.String)
     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
     */
    @CallerSensitive
    public static void load(String filename) {
        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
    }

    /**
     * Loads the native library specified by the &lt;code&gt;libname&lt;/code&gt;
     * argument.  The &lt;code&gt;libname&lt;/code&gt; argument must not contain any platform
     * specific prefix, file extension or path. If a native library
     * called &lt;code&gt;libname&lt;/code&gt; is statically linked with the VM, then the
     * JNI_OnLoad_&lt;code&gt;libname&lt;/code&gt; function exported by the library is invoked.
     * See the JNI Specification for more details.
     *
     * Otherwise, the libname argument is loaded from a system library
     * location and mapped to a native library image in an implementation-
     * dependent manner.
     * &lt;p&gt;
     * The call &lt;code&gt;System.loadLibrary(name)&lt;/code&gt; is effectively
     * equivalent to the call
     * &lt;blockquote&gt;&lt;pre&gt;
     * Runtime.getRuntime().loadLibrary(name)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param      libname   the name of the library.
     * @exception  SecurityException  if a security manager exists and its
     *             &lt;code&gt;checkLink&lt;/code&gt; method doesn&#39;t allow
     *             loading of the specified dynamic library
     * @exception  UnsatisfiedLinkError if either the libname argument
     *             contains a file path, the native library is not statically
     *             linked with the VM,  or the library cannot be mapped to a
     *             native library image by the host system.
     * @exception  NullPointerException if &lt;code&gt;libname&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;
     * @see        java.lang.Runtime#loadLibrary(java.lang.String)
     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
     */
    @CallerSensitive
    public static void loadLibrary(String libname) {
        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
    }

    /**
     * Maps a library name into a platform-specific string representing
     * a native library.
     *
     * @param      libname the name of the library.
     * @return     a platform-dependent native library name.
     * @exception  NullPointerException if &lt;code&gt;libname&lt;/code&gt; is
     *             &lt;code&gt;null&lt;/code&gt;
     * @see        java.lang.System#loadLibrary(java.lang.String)
     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)
     * @since      1.2
     */
    public static native String mapLibraryName(String libname);

    /**
     * Create PrintStream for stdout/err based on encoding.
     */
    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {
       if (enc != null) {
            try {
                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);
            } catch (UnsupportedEncodingException uee) {}
        }
        return new PrintStream(new BufferedOutputStream(fos, 128), true);
    }


    /**
     * Initialize the system class.  Called after thread initialization.
     */
    private static void initializeSystemClass() {

        // VM might invoke JNU_NewStringPlatform() to set those encoding
        // sensitive properties (user.home, user.name, boot.class.path, etc.)
        // during &quot;props&quot; initialization, in which it may need access, via
        // System.getProperty(), to the related system encoding property that
        // have been initialized (put into &quot;props&quot;) at early stage of the
        // initialization. So make sure the &quot;props&quot; is available at the
        // very beginning of the initialization and all system properties to
        // be put into it directly.
        props = new Properties();
        initProperties(props);  // initialized by the VM

        // There are certain system configurations that may be controlled by
        // VM options such as the maximum amount of direct memory and
        // Integer cache size used to support the object identity semantics
        // of autoboxing.  Typically, the library will obtain these values
        // from the properties set by the VM.  If the properties are for
        // internal implementation use only, these properties should be
        // removed from the system properties.
        //
        // See java.lang.Integer.IntegerCache and the
        // sun.misc.VM.saveAndRemoveProperties method for example.
        //
        // Save a private copy of the system properties object that
        // can only be accessed by the internal implementation.  Remove
        // certain system properties that are not intended for public access.
        sun.misc.VM.saveAndRemoveProperties(props);


        lineSeparator = props.getProperty(&quot;line.separator&quot;);
        sun.misc.Version.init();

        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);
        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);
        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);
        setIn0(new BufferedInputStream(fdIn));
        setOut0(newPrintStream(fdOut, props.getProperty(&quot;sun.stdout.encoding&quot;)));
        setErr0(newPrintStream(fdErr, props.getProperty(&quot;sun.stderr.encoding&quot;)));

        // Load the zip library now in order to keep java.util.zip.ZipFile
        // from trying to use itself to load this library later.
        loadLibrary(&quot;zip&quot;);

        // Setup Java signal handlers for HUP, TERM, and INT (where available).
        Terminator.setup();

        // Initialize any miscellenous operating system settings that need to be
        // set for the class libraries. Currently this is no-op everywhere except
        // for Windows where the process-wide error mode is set before the java.io
        // classes are used.
        sun.misc.VM.initializeOSEnvironment();

        // The main thread is not added to its thread group in the same
        // way as other threads; we must do it ourselves here.
        Thread current = Thread.currentThread();
        current.getThreadGroup().add(current);

        // register shared secrets
        setJavaLangAccess();

        // Subsystems that are invoked during initialization can invoke
        // sun.misc.VM.isBooted() in order to avoid doing things that should
        // wait until the application class loader has been set up.
        // IMPORTANT: Ensure that this remains the last initialization action!
        sun.misc.VM.booted();
    }

    private static void setJavaLangAccess() {
        // Allow privileged classes outside of java.lang
        sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess(){
            public sun.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) {
                return klass.getConstantPool();
            }
            public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) {
                return klass.casAnnotationType(oldType, newType);
            }
            public AnnotationType getAnnotationType(Class&lt;?&gt; klass) {
                return klass.getAnnotationType();
            }
            public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) {
                return klass.getDeclaredAnnotationMap();
            }
            public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) {
                return klass.getRawAnnotations();
            }
            public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) {
                return klass.getRawTypeAnnotations();
            }
            public byte[] getRawExecutableTypeAnnotations(Executable executable) {
                return Class.getExecutableTypeAnnotationBytes(executable);
            }
            public &lt;E extends Enum&lt;E&gt;&gt;
                    E[] getEnumConstantsShared(Class&lt;E&gt; klass) {
                return klass.getEnumConstantsShared();
            }
            public void blockedOn(Thread t, Interruptible b) {
                t.blockedOn(b);
            }
            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {
                Shutdown.add(slot, registerShutdownInProgress, hook);
            }
            public int getStackTraceDepth(Throwable t) {
                return t.getStackTraceDepth();
            }
            public StackTraceElement getStackTraceElement(Throwable t, int i) {
                return t.getStackTraceElement(i);
            }
            public String newStringUnsafe(char[] chars) {
                return new String(chars, true);
            }
            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {
                return new Thread(target, acc);
            }
            public void invokeFinalize(Object o) throws Throwable {
                o.finalize();
            }
        });
    }
}
</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-06T05:21:38.000Z">2019-09-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 710 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/06/Java反编译工具jad/">Java反编译工具jad</a>
            
        </h1>
        <div class="content">
            <p><img src="/images/2019/09/06/c8ac68c0-d064-11e9-baaa-a18a2b353fbb.png" alt="image.png"></p>
<h1 id="Jad-JAva-Decompiler"><a href="#Jad-JAva-Decompiler" class="headerlink" title="Jad(JAva Decompiler)"></a>Jad(JAva Decompiler)</h1><p>Jad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。下载<a href="https://varaneckas.com/jad/" target="_blank" rel="noopener">点击</a></p>
<p>使用方法：</p>
<p>[1] 反编译一个class文件：jad example.class，会生成example.jad，用文本编辑器打开就是java源代码</p>
<p>[2] 指定生成源代码的后缀名：jad -sjava example.class，生成example.java</p>
<p>[3] 改变生成的源代码的名称，可以先使用-p将反编译后的源代码输出到控制台窗口，然后使用重定向，输出到文件：jad -p example.class &gt; myexample.java</p>
<p>[4] 把源代码文件输出到指定的目录：jad -dnewdir -sjava example.class，在newdir目录下生成example.java</p>
<p>[5] 把packages目录下的class文件全部反编译：jad -sjava packages/*.class</p>
<p>[6] 把packages目录以及子目录下的文件全部反编译：jad -sjava packages/<em>*/</em>.class，不过你仍然会发现所有的源代码文件被放到了同一个文件中，没有按照class文件的包路径建立起路径</p>
<p>[7] 把packages目录以及子目录下的文件全部反编译并建立和java包一致的文件夹路径，可以使用-r命令：jad -r -sjava packages/<em>*/</em>.class</p>
<p>[8] 当重复使用命令反编译时，Jad会提示“whether you want to overwrite it or not”，使用-o可以强制覆盖旧文件</p>
<p>[9] 还有其他的参数可以设置生成的源代码的格式，可以输入jad命令查看帮助，这里有个人做了简单的翻译：jad命令总结</p>
<p>[10] 当然，你会发现有些源文件头部有些注释信息，不用找了，jad没有参数可以去掉它，用别的办法吧。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Main.java</p>
<pre><code class="java">
public class Main {

    static volatile int t = 0;
    public static void main(String[] args) {
        int n = 100;
        Thread[] threads = new Thread[n];
        for (int i = 0; i &lt; n; i++) {
            threads[i] = new Thread(new Runnable() {

                @Override
                public void run() {
                    for (int i = 0; i &lt; 10000; i++) {
                        add();
                    }
                }
            });
            threads[i].start();
        }

        while (Thread.activeCount() &gt; 1)
            Thread.yield();

        System.out.println(t);
    }

    static void add() {
        t++;
    }
}</code></pre>
<p>Main.class</p>
<pre><code class="class">cafe babe 0000 0034 0037 0a00 0d00 1d07
001e 0700 1f0a 0003 001d 0a00 0200 200a
0002 0021 0a00 0200 220a 0002 0023 0900
2400 2509 000c 0026 0a00 2700 2807 0029
0700 2a01 000c 496e 6e65 7243 6c61 7373
6573 0100 0174 0100 0149 0100 063c 696e
6974 3e01 0003 2829 5601 0004 436f 6465
0100 0f4c 696e 654e 756d 6265 7254 6162
6c65 0100 046d 6169 6e01 0016 285b 4c6a
6176 612f 6c61 6e67 2f53 7472 696e 673b
2956 0100 0d53 7461 636b 4d61 7054 6162
6c65 0700 2b01 0003 6164 6401 0008 3c63
6c69 6e69 743e 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0011 0012 0100 106a 6176 612f 6c61 6e67
2f54 6872 6561 6401 0006 4d61 696e 2431
...</code></pre>
<p><img src="/images/2019/09/06/fcb05680-d065-11e9-baaa-a18a2b353fbb.png" alt="image.png"></p>
<p>反编译后的结果</p>
<pre><code class="java">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   Main.java

import java.io.PrintStream;

public class Main
{

    public Main()
    {
    }

    public static void main(String args[])
    {
        byte byte0 = 100;
        Thread athread[] = new Thread[byte0];
        for(int i = 0; i &lt; byte0; i++)
        {
            athread[i] = new Thread(new Runnable() {

                public void run()
                {
                    for(int j = 0; j &lt; 10000; j++)
                        Main.add();

                }

            }
);
            athread[i].start();
        }

        for(; Thread.activeCount() &gt; 1; Thread.yield());
        System.out.println(t);
    }

    static void add()
    {
        t++;
    }

    static volatile int t = 0;

}</code></pre>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/tags/Java/page/0/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/tags/Java/page/2/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/tags/Java/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/Java/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="https://user-gold-cdn.xitu.io/2018/8/13/16530d7f26a413c2?imageView2/1/w/180/h/180/q/85/format/webp/interlace/1" alt="Time">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Time
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Developer
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Earth, Solar System</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            92
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            5
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            117
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/hsutimes" target="_blank">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/hsutimes">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Facebook" href="https://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Twitter" href="https://twitter.com/times26740863">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Dribbble" href="https://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/hsutimes" target="_blank">
                    <span class="level-left">
                        <span class="level-item">PPOffice</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https:hsutimes.club" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Time</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hsutimes.club</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/人工智能/">
            <span class="level-start">
                <span class="level-item">人工智能</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/文章/">
            <span class="level-start">
                <span class="level-item">文章</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">74</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/生活/">
            <span class="level-start">
                <span class="level-item">生活</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/笔试/">
            <span class="level-start">
                <span class="level-item">笔试</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/算法/">
            <span class="level-start">
                <span class="level-item">算法</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/11/14/hexo-theme-icarus/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/desert.jpg" alt="ICRUS">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-14T14:09:12.000Z">2019-11-14</time></div>
                    <a href="/2019/11/14/hexo-theme-icarus/" class="title has-link-black-ter is-size-6 has-text-weight-normal">ICRUS</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/13/3sum/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="3sum">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-13T13:12:37.000Z">2019-11-13</time></div>
                    <a href="/2019/11/13/3sum/" class="title has-link-black-ter is-size-6 has-text-weight-normal">3sum</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/12/minio/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="minio">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-12T14:22:14.000Z">2019-11-12</time></div>
                    <a href="/2019/11/12/minio/" class="title has-link-black-ter is-size-6 has-text-weight-normal">minio</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/11/graph-convolution/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="graph-convolution">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-11T15:22:46.000Z">2019-11-11</time></div>
                    <a href="/2019/11/11/graph-convolution/" class="title has-link-black-ter is-size-6 has-text-weight-normal">graph-convolution</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/10/falling-stone/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="falling-stone">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T14:49:09.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/falling-stone/" class="title has-link-black-ter is-size-6 has-text-weight-normal">falling-stone</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">16</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">40</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/2019/">
                        <span class="tag">2019</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/AI/">
                        <span class="tag">AI</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ASM/">
                        <span class="tag">ASM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Android/">
                        <span class="tag">Android</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B+树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B-树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Flutter/">
                        <span class="tag">Flutter</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Global/">
                        <span class="tag">Global </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HashMap/">
                        <span class="tag">HashMap</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Http/">
                        <span class="tag">Http</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ICRUS/">
                        <span class="tag">ICRUS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JNA/">
                        <span class="tag">JNA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">13</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Key/">
                        <span class="tag">Key </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/MD5/">
                        <span class="tag">MD5</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/NLP/">
                        <span class="tag">NLP</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Nodejs/">
                        <span class="tag">Nodejs</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OCR/">
                        <span class="tag">OCR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OpenCV/">
                        <span class="tag">OpenCV</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/RSA/">
                        <span class="tag">RSA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring-Boot/">
                        <span class="tag">Spring Boot</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack-Overflow/">
                        <span class="tag">Stack Overflow</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TabNine/">
                        <span class="tag">TabNine</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TensorFlow/">
                        <span class="tag">TensorFlow</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/VR/">
                        <span class="tag">VR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Windows/">
                        <span class="tag">Windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Xbox/">
                        <span class="tag">Xbox</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/dio/">
                        <span class="tag">dio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/edb/">
                        <span class="tag">edb</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/electron/">
                        <span class="tag">electron</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/github/">
                        <span class="tag">github</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hexo/">
                        <span class="tag">hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jad/">
                        <span class="tag">jad</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/lazydocker/">
                        <span class="tag">lazydocker</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/minio/">
                        <span class="tag">minio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/nohup/">
                        <span class="tag">nohup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/openssl/">
                        <span class="tag">openssl</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sha256/">
                        <span class="tag">sha256</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/webhooks/">
                        <span class="tag">webhooks</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/windows/">
                        <span class="tag">windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/x64dbg/">
                        <span class="tag">x64dbg</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/书籍/">
                        <span class="tag">书籍</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二叉树/">
                        <span class="tag">二叉树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/人工智能/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/信息安全/">
                        <span class="tag">信息安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/军事/">
                        <span class="tag">军事</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/加密算法/">
                        <span class="tag">加密算法</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/卷积神经网络/">
                        <span class="tag">卷积神经网络</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/双指针/">
                        <span class="tag">双指针</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反汇编/">
                        <span class="tag">反汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反编译/">
                        <span class="tag">反编译</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/后缀表达式/">
                        <span class="tag">后缀表达式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/国家/">
                        <span class="tag">国家</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/备份/">
                        <span class="tag">备份</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/天平/">
                        <span class="tag">天平</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/安全/">
                        <span class="tag">安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/工具/">
                        <span class="tag">工具</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/战斗机/">
                        <span class="tag">战斗机</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/拟真/">
                        <span class="tag">拟真</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/指纹/">
                        <span class="tag">指纹</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/推荐系统/">
                        <span class="tag">推荐系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/搜索引擎/">
                        <span class="tag">搜索引擎</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/操作系统/">
                        <span class="tag">操作系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数据库/">
                        <span class="tag">数据库</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数组/">
                        <span class="tag">数组</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/文章/">
                        <span class="tag">文章</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/暴力破解/">
                        <span class="tag">暴力破解</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/机器学习/">
                        <span class="tag">机器学习</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/树/">
                        <span class="tag">树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/框架/">
                        <span class="tag">框架</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/模拟/">
                        <span class="tag">模拟</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编/">
                        <span class="tag">汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编语言/">
                        <span class="tag">汇编语言</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/游戏/">
                        <span class="tag">游戏</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/爱因斯坦/">
                        <span class="tag">爱因斯坦</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/狂野飙车/">
                        <span class="tag">狂野飙车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/百科/">
                        <span class="tag">百科</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/相对论/">
                        <span class="tag">相对论</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/矩阵/">
                        <span class="tag">矩阵</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/算法/">
                        <span class="tag">算法</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/素数/">
                        <span class="tag">素数</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/红黑树/">
                        <span class="tag">红黑树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程/">
                        <span class="tag">编程</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程思想/">
                        <span class="tag">编程思想</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/网络安全/">
                        <span class="tag">网络安全</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/脚本/">
                        <span class="tag">脚本</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/自动化部署/">
                        <span class="tag">自动化部署</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/行业分析/">
                        <span class="tag">行业分析</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/计算机视觉/">
                        <span class="tag">计算机视觉</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/论文/">
                        <span class="tag">论文</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/诺贝尔奖/">
                        <span class="tag">诺贝尔奖</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/跑车/">
                        <span class="tag">跑车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/边缘检测/">
                        <span class="tag">边缘检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/逆向工程/">
                        <span class="tag">逆向工程</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/递归/">
                        <span class="tag">递归</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/链表/">
                        <span class="tag">链表</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/陨石/">
                        <span class="tag">陨石</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/面试/">
                        <span class="tag">面试</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/飞行/">
                        <span class="tag">飞行</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/魔方/">
                        <span class="tag">魔方</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/黄山/">
                        <span class="tag">黄山</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/11/14/hexo-theme-icarus/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/desert.jpg" alt="ICRUS">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-14T14:09:12.000Z">2019-11-14</time></div>
                    <a href="/2019/11/14/hexo-theme-icarus/" class="title has-link-black-ter is-size-6 has-text-weight-normal">ICRUS</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/13/3sum/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="3sum">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-13T13:12:37.000Z">2019-11-13</time></div>
                    <a href="/2019/11/13/3sum/" class="title has-link-black-ter is-size-6 has-text-weight-normal">3sum</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/12/minio/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="minio">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-12T14:22:14.000Z">2019-11-12</time></div>
                    <a href="/2019/11/12/minio/" class="title has-link-black-ter is-size-6 has-text-weight-normal">minio</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/11/graph-convolution/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="graph-convolution">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-11T15:22:46.000Z">2019-11-11</time></div>
                    <a href="/2019/11/11/graph-convolution/" class="title has-link-black-ter is-size-6 has-text-weight-normal">graph-convolution</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/10/falling-stone/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="falling-stone">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T14:49:09.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/falling-stone/" class="title has-link-black-ter is-size-6 has-text-weight-normal">falling-stone</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">16</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">40</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/2019/">
                        <span class="tag">2019</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/AI/">
                        <span class="tag">AI</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ASM/">
                        <span class="tag">ASM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Android/">
                        <span class="tag">Android</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B+树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B-树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Flutter/">
                        <span class="tag">Flutter</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Global/">
                        <span class="tag">Global </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HashMap/">
                        <span class="tag">HashMap</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Http/">
                        <span class="tag">Http</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ICRUS/">
                        <span class="tag">ICRUS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JNA/">
                        <span class="tag">JNA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">13</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Key/">
                        <span class="tag">Key </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/MD5/">
                        <span class="tag">MD5</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/NLP/">
                        <span class="tag">NLP</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Nodejs/">
                        <span class="tag">Nodejs</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OCR/">
                        <span class="tag">OCR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OpenCV/">
                        <span class="tag">OpenCV</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/RSA/">
                        <span class="tag">RSA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring-Boot/">
                        <span class="tag">Spring Boot</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack-Overflow/">
                        <span class="tag">Stack Overflow</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TabNine/">
                        <span class="tag">TabNine</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TensorFlow/">
                        <span class="tag">TensorFlow</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/VR/">
                        <span class="tag">VR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Windows/">
                        <span class="tag">Windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Xbox/">
                        <span class="tag">Xbox</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/dio/">
                        <span class="tag">dio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/edb/">
                        <span class="tag">edb</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/electron/">
                        <span class="tag">electron</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/github/">
                        <span class="tag">github</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hexo/">
                        <span class="tag">hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jad/">
                        <span class="tag">jad</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/lazydocker/">
                        <span class="tag">lazydocker</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/minio/">
                        <span class="tag">minio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/nohup/">
                        <span class="tag">nohup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/openssl/">
                        <span class="tag">openssl</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sha256/">
                        <span class="tag">sha256</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/webhooks/">
                        <span class="tag">webhooks</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/windows/">
                        <span class="tag">windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/x64dbg/">
                        <span class="tag">x64dbg</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/书籍/">
                        <span class="tag">书籍</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二叉树/">
                        <span class="tag">二叉树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/人工智能/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/信息安全/">
                        <span class="tag">信息安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/军事/">
                        <span class="tag">军事</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/加密算法/">
                        <span class="tag">加密算法</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/卷积神经网络/">
                        <span class="tag">卷积神经网络</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/双指针/">
                        <span class="tag">双指针</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反汇编/">
                        <span class="tag">反汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反编译/">
                        <span class="tag">反编译</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/后缀表达式/">
                        <span class="tag">后缀表达式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/国家/">
                        <span class="tag">国家</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/备份/">
                        <span class="tag">备份</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/天平/">
                        <span class="tag">天平</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/安全/">
                        <span class="tag">安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/工具/">
                        <span class="tag">工具</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/战斗机/">
                        <span class="tag">战斗机</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/拟真/">
                        <span class="tag">拟真</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/指纹/">
                        <span class="tag">指纹</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/推荐系统/">
                        <span class="tag">推荐系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/搜索引擎/">
                        <span class="tag">搜索引擎</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/操作系统/">
                        <span class="tag">操作系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数据库/">
                        <span class="tag">数据库</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数组/">
                        <span class="tag">数组</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/文章/">
                        <span class="tag">文章</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/暴力破解/">
                        <span class="tag">暴力破解</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/机器学习/">
                        <span class="tag">机器学习</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/树/">
                        <span class="tag">树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/框架/">
                        <span class="tag">框架</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/模拟/">
                        <span class="tag">模拟</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编/">
                        <span class="tag">汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编语言/">
                        <span class="tag">汇编语言</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/游戏/">
                        <span class="tag">游戏</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/爱因斯坦/">
                        <span class="tag">爱因斯坦</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/狂野飙车/">
                        <span class="tag">狂野飙车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/百科/">
                        <span class="tag">百科</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/相对论/">
                        <span class="tag">相对论</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/矩阵/">
                        <span class="tag">矩阵</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/算法/">
                        <span class="tag">算法</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/素数/">
                        <span class="tag">素数</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/红黑树/">
                        <span class="tag">红黑树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程/">
                        <span class="tag">编程</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程思想/">
                        <span class="tag">编程思想</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/网络安全/">
                        <span class="tag">网络安全</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/脚本/">
                        <span class="tag">脚本</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/自动化部署/">
                        <span class="tag">自动化部署</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/行业分析/">
                        <span class="tag">行业分析</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/计算机视觉/">
                        <span class="tag">计算机视觉</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/论文/">
                        <span class="tag">论文</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/诺贝尔奖/">
                        <span class="tag">诺贝尔奖</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/跑车/">
                        <span class="tag">跑车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/边缘检测/">
                        <span class="tag">边缘检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/逆向工程/">
                        <span class="tag">逆向工程</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/递归/">
                        <span class="tag">递归</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/链表/">
                        <span class="tag">链表</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/陨石/">
                        <span class="tag">陨石</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/面试/">
                        <span class="tag">面试</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/飞行/">
                        <span class="tag">飞行</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/魔方/">
                        <span class="tag">魔方</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/黄山/">
                        <span class="tag">黄山</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Time" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 times&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/hsutimes/hsutimes.github.io">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
<script src="/js/animation.js"></script>

    
    
<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>

    
    
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>

    
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>
    
    
<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>

    
    
    
    
    
    
    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>