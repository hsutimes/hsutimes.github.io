<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>分类: 文章 - Time</title>


    <meta name="description" content="blog">
<meta name="keywords" content="hsutimes">
<meta property="og:type" content="website">
<meta property="og:title" content="Time">
<meta property="og:url" content="https://blog.hsutimes.com/categories/文章/page/5/index.html">
<meta property="og:site_name" content="Time">
<meta property="og:description" content="blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://blog.hsutimes.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Time">
<meta name="twitter:description" content="blog">
<meta name="twitter:image" content="https://blog.hsutimes.com/images/og_image.png">
<meta name="twitter:site" content="https://twitter.com/times26740863">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134224598-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134224598-1');
</script>

    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Time" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/hsutimes/hsutimes.github.io">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">文章</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-23T03:50:26.000Z">2019-09-23</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 9054 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/23/HashMap类/">HashMap类</a>
            
        </h1>
        <div class="content">
            <h1 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h1><p><img src="/images/2019/09/23/2728b8b0-ddb5-11e9-82dd-cd65309cd62c.png" alt="image.png"></p>
<pre><code class="java">/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.util;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import sun.misc.SharedSecrets;

/**
 * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This
 * implementation provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;
 * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
 *
 * &lt;p&gt;This implementation provides constant-time performance for the basic
 * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function
 * disperses the elements properly among the buckets.  Iteration over
 * collection views requires time proportional to the &quot;capacity&quot; of the
 * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number
 * of key-value mappings).  Thus, it&#39;s very important not to set the initial
 * capacity too high (or the load factor too low) if iteration performance is
 * important.
 *
 * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its
 * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
 * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
 * capacity is simply the capacity at the time the hash table is created.  The
 * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
 * get before its capacity is automatically increased.  When the number of
 * entries in the hash table exceeds the product of the load factor and the
 * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
 * structures are rebuilt) so that the hash table has approximately twice the
 * number of buckets.
 *
 * &lt;p&gt;As a general rule, the default load factor (.75) offers a good
 * tradeoff between time and space costs.  Higher values decrease the
 * space overhead but increase the lookup cost (reflected in most of
 * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including
 * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in
 * the map and its load factor should be taken into account when
 * setting its initial capacity, so as to minimize the number of
 * rehash operations.  If the initial capacity is greater than the
 * maximum number of entries divided by the load factor, no rehash
 * operations will ever occur.
 *
 * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;
 * instance, creating it with a sufficiently large capacity will allow
 * the mappings to be stored more efficiently than letting it perform
 * automatic rehashing as needed to grow the table.  Note that using
 * many keys with the same {@code hashCode()} is a sure way to slow
 * down performance of any hash table. To ameliorate impact, when keys
 * are {@link Comparable}, this class may use comparison order among
 * keys to help break ties.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a hash map concurrently, and at least one of
 * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be &quot;wrapped&quot; using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map:&lt;pre&gt;
 *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by all of this class&#39;s &quot;collection view methods&quot;
 * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator&#39;s own
 * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 *
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {

    private static final long serialVersionUID = 362498820763181265L;

    /*
     * Implementation notes.
     *
     * This map usually acts as a binned (bucketed) hash table, but
     * when bins get too large, they are transformed into bins of
     * TreeNodes, each structured similarly to those in
     * java.util.TreeMap. Most methods try to use normal bins, but
     * relay to TreeNode methods when applicable (simply by checking
     * instanceof a node).  Bins of TreeNodes may be traversed and
     * used like any others, but additionally support faster lookup
     * when overpopulated. However, since the vast majority of bins in
     * normal use are not overpopulated, checking for existence of
     * tree bins may be delayed in the course of table methods.
     *
     * Tree bins (i.e., bins whose elements are all TreeNodes) are
     * ordered primarily by hashCode, but in the case of ties, if two
     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
     * type then their compareTo method is used for ordering. (We
     * conservatively check generic types via reflection to validate
     * this -- see method comparableClassFor).  The added complexity
     * of tree bins is worthwhile in providing worst-case O(log n)
     * operations when keys either have distinct hashes or are
     * orderable, Thus, performance degrades gracefully under
     * accidental or malicious usages in which hashCode() methods
     * return values that are poorly distributed, as well as those in
     * which many keys share a hashCode, so long as they are also
     * Comparable. (If neither of these apply, we may waste about a
     * factor of two in time and space compared to taking no
     * precautions. But the only known cases stem from poor user
     * programming practices that are already so slow that this makes
     * little difference.)
     *
     * Because TreeNodes are about twice the size of regular nodes, we
     * use them only when bins contain enough nodes to warrant use
     * (see TREEIFY_THRESHOLD). And when they become too small (due to
     * removal or resizing) they are converted back to plain bins.  In
     * usages with well-distributed user hashCodes, tree bins are
     * rarely used.  Ideally, under random hashCodes, the frequency of
     * nodes in bins follows a Poisson distribution
     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
     * parameter of about 0.5 on average for the default resizing
     * threshold of 0.75, although with a large variance because of
     * resizing granularity. Ignoring variance, the expected
     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
     * factorial(k)). The first values are:
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: less than 1 in ten million
     *
     * The root of a tree bin is normally its first node.  However,
     * sometimes (currently only upon Iterator.remove), the root might
     * be elsewhere, but can be recovered following parent links
     * (method TreeNode.root()).
     *
     * All applicable internal methods accept a hash code as an
     * argument (as normally supplied from a public method), allowing
     * them to call each other without recomputing user hashCodes.
     * Most internal methods also accept a &quot;tab&quot; argument, that is
     * normally the current table, but may be a new or old one when
     * resizing or converting.
     *
     * When bin lists are treeified, split, or untreeified, we keep
     * them in the same relative access/traversal order (i.e., field
     * Node.next) to better preserve locality, and to slightly
     * simplify handling of splits and traversals that invoke
     * iterator.remove. When using comparators on insertion, to keep a
     * total ordering (or as close as is required here) across
     * rebalancings, we compare classes and identityHashCodes as
     * tie-breakers.
     *
     * The use and transitions among plain vs tree modes is
     * complicated by the existence of subclass LinkedHashMap. See
     * below for hook methods defined to be invoked upon insertion,
     * removal and access that allow LinkedHashMap internals to
     * otherwise remain independent of these mechanics. (This also
     * requires that a map instance be passed to some utility methods
     * that may create new nodes.)
     *
     * The concurrent-programming-like SSA-based coding style helps
     * avoid aliasing errors amid all of the twisty pointer operations.
     */

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * The smallest table capacity for which bins may be treeified.
     * (Otherwise the table is resized if too many nodes in a bin.)
     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
     * between resizing and treeification thresholds.
     */
    static final int MIN_TREEIFY_CAPACITY = 64;

    /**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }

    /* ---------------- Static utilities -------------- */

    /**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don&#39;t benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }

    /**
     * Returns x&#39;s Class if it is of the form &quot;class C implements
     * Comparable&lt;C&gt;&quot;, else null.
     */
    static Class&lt;?&gt; comparableClassFor(Object x) {
        if (x instanceof Comparable) {
            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;
            if ((c = x.getClass()) == String.class) // bypass checks
                return c;
            if ((ts = c.getGenericInterfaces()) != null) {
                for (int i = 0; i &lt; ts.length; ++i) {
                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;
                        ((p = (ParameterizedType)t).getRawType() ==
                         Comparable.class) &amp;&amp;
                        (as = p.getActualTypeArguments()) != null &amp;&amp;
                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c
                        return c;
                }
            }
        }
        return null;
    }

    /**
     * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable
     * class), else 0.
     */
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable
    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {
        return (x == null || x.getClass() != kc ? 0 :
                ((Comparable)k).compareTo(x));
    }

    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

    /* ---------------- Fields -------------- */

    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     */
    transient Node&lt;K,V&gt;[] table;

    /**
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     */
    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

    /**
     * The number of key-value mappings contained in this map.
     */
    transient int size;

    /**
     * The number of times this HashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the HashMap or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the HashMap fail-fast.  (See ConcurrentModificationException).
     */
    transient int modCount;

    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    // (The javadoc description is true upon serialization.
    // Additionally, if the table array has not been allocated, this
    // field holds the initial array capacity, or zero signifying
    // DEFAULT_INITIAL_CAPACITY.)
    int threshold;

    /**
     * The load factor for the hash table.
     *
     * @serial
     */
    final float loadFactor;

    /* ---------------- Public operations -------------- */

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    /**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }

    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
        int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
        return size;
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise
     * it returns {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it&#39;s also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the
     * specified key.
     *
     * @param   key   The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     */
    public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;
    }

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don&#39;t change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
    final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

    /**
     * Replaces all linked nodes in bin at index for given hash unless
     * table is too small, in which case resizes instead.
     */
    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
        int n, index; Node&lt;K,V&gt; e;
        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
            TreeNode&lt;K,V&gt; hd = null, tl = null;
            do {
                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }

    /**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     * @throws NullPointerException if the specified map is null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        putMapEntries(m, true);
    }

    /**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param  key key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }

    /**
     * Implements Map.remove and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to match if matchValue, else ignored
     * @param matchValue if true only remove if value is equal
     * @param movable if false do not move other nodes while removing
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
            Node&lt;K,V&gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                if (p instanceof TreeNode)
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                else {
                    do {
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */
    public void clear() {
        Node&lt;K,V&gt;[] tab;
        modCount++;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            size = 0;
            for (int i = 0; i &lt; tab.length; ++i)
                tab[i] = null;
        }
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     * specified value.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     *         specified value
     */
    public boolean containsValue(Object value) {
        Node&lt;K,V&gt;[] tab; V v;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    if ((v = e.value) == value ||
                        (value != null &amp;&amp; value.equals(v)))
                        return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
     * the iteration are undefined.  The set supports element removal,
     * which removes the corresponding mapping from the map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
     * operations.
     *
     * @return a set view of the keys contained in this map
     */
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        if (ks == null) {
            ks = new KeySet();
            keySet = ks;
        }
        return ks;
    }

    final class KeySet extends AbstractSet&lt;K&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
        public final boolean contains(Object o) { return containsKey(o); }
        public final boolean remove(Object key) {
            return removeNode(hash(key), key, null, false, true) != null;
        }
        public final Spliterator&lt;K&gt; spliterator() {
            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super K&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e.key);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress
     * (except through the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation),
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a view of the values contained in this map
     */
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        if (vs == null) {
            vs = new Values();
            values = vs;
        }
        return vs;
    }

    final class Values extends AbstractCollection&lt;V&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
        public final boolean contains(Object o) { return containsValue(o); }
        public final Spliterator&lt;V&gt; spliterator() {
            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super V&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e.value);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator&#39;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a set view of the mappings contained in this map
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
    }

    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new EntryIterator();
        }
        public final boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
            Object key = e.getKey();
            Node&lt;K,V&gt; candidate = getNode(hash(key), key);
            return candidate != null &amp;&amp; candidate.equals(e);
        }
        public final boolean remove(Object o) {
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
                Object key = e.getKey();
                Object value = e.getValue();
                return removeNode(hash(key), key, value, true, true) != null;
            }
            return false;
        }
        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            Node&lt;K,V&gt;[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size &gt; 0 &amp;&amp; (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                        action.accept(e);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }

    // Overrides of JDK8 Map extension methods

    @Override
    public V getOrDefault(Object key, V defaultValue) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;
    }

    @Override
    public V putIfAbsent(K key, V value) {
        return putVal(hash(key), key, value, true, true);
    }

    @Override
    public boolean remove(Object key, Object value) {
        return removeNode(hash(key), key, value, true, true) != null;
    }

    @Override
    public boolean replace(K key, V oldValue, V newValue) {
        Node&lt;K,V&gt; e; V v;
        if ((e = getNode(hash(key), key)) != null &amp;&amp;
            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {
            e.value = newValue;
            afterNodeAccess(e);
            return true;
        }
        return false;
    }

    @Override
    public V replace(K key, V value) {
        Node&lt;K,V&gt; e;
        if ((e = getNode(hash(key), key)) != null) {
            V oldValue = e.value;
            e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
        return null;
    }

    @Override
    public V computeIfAbsent(K key,
                             Function&lt;? super K, ? extends V&gt; mappingFunction) {
        if (mappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
            V oldValue;
            if (old != null &amp;&amp; (oldValue = old.value) != null) {
                afterNodeAccess(old);
                return oldValue;
            }
        }
        V v = mappingFunction.apply(key);
        if (v == null) {
            return null;
        } else if (old != null) {
            old.value = v;
            afterNodeAccess(old);
            return v;
        }
        else if (t != null)
            t.putTreeVal(this, tab, hash, key, v);
        else {
            tab[i] = newNode(hash, key, v, first);
            if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                treeifyBin(tab, hash);
        }
        ++modCount;
        ++size;
        afterNodeInsertion(true);
        return v;
    }

    public V computeIfPresent(K key,
                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
        if (remappingFunction == null)
            throw new NullPointerException();
        Node&lt;K,V&gt; e; V oldValue;
        int hash = hash(key);
        if ((e = getNode(hash, key)) != null &amp;&amp;
            (oldValue = e.value) != null) {
            V v = remappingFunction.apply(key, oldValue);
            if (v != null) {
                e.value = v;
                afterNodeAccess(e);
                return v;
            }
            else
                removeNode(hash, key, null, false, true);
        }
        return null;
    }

    @Override
    public V compute(K key,
                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
        if (remappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
        }
        V oldValue = (old == null) ? null : old.value;
        V v = remappingFunction.apply(key, oldValue);
        if (old != null) {
            if (v != null) {
                old.value = v;
                afterNodeAccess(old);
            }
            else
                removeNode(hash, key, null, false, true);
        }
        else if (v != null) {
            if (t != null)
                t.putTreeVal(this, tab, hash, key, v);
            else {
                tab[i] = newNode(hash, key, v, first);
                if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                    treeifyBin(tab, hash);
            }
            ++modCount;
            ++size;
            afterNodeInsertion(true);
        }
        return v;
    }

    @Override
    public V merge(K key, V value,
                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
        if (value == null)
            throw new NullPointerException();
        if (remappingFunction == null)
            throw new NullPointerException();
        int hash = hash(key);
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
        int binCount = 0;
        TreeNode&lt;K,V&gt; t = null;
        Node&lt;K,V&gt; old = null;
        if (size &gt; threshold || (tab = table) == null ||
            (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((first = tab[i = (n - 1) &amp; hash]) != null) {
            if (first instanceof TreeNode)
                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            else {
                Node&lt;K,V&gt; e = first; K k;
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                        old = e;
                        break;
                    }
                    ++binCount;
                } while ((e = e.next) != null);
            }
        }
        if (old != null) {
            V v;
            if (old.value != null)
                v = remappingFunction.apply(old.value, value);
            else
                v = value;
            if (v != null) {
                old.value = v;
                afterNodeAccess(old);
            }
            else
                removeNode(hash, key, null, false, true);
            return v;
        }
        if (value != null) {
            if (t != null)
                t.putTreeVal(this, tab, hash, key, value);
            else {
                tab[i] = newNode(hash, key, value, first);
                if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                    treeifyBin(tab, hash);
            }
            ++modCount;
            ++size;
            afterNodeInsertion(true);
        }
        return value;
    }

    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Node&lt;K,V&gt;[] tab;
        if (action == null)
            throw new NullPointerException();
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            int mc = modCount;
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)
                    action.accept(e.key, e.value);
            }
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }

    @Override
    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
        Node&lt;K,V&gt;[] tab;
        if (function == null)
            throw new NullPointerException();
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            int mc = modCount;
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    e.value = function.apply(e.key, e.value);
                }
            }
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }

    /* ------------------------------------------------------------ */
    // Cloning and serialization

    /**
     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and
     * values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Object clone() {
        HashMap&lt;K,V&gt; result;
        try {
            result = (HashMap&lt;K,V&gt;)super.clone();
        } catch (CloneNotSupportedException e) {
            // this shouldn&#39;t happen, since we are Cloneable
            throw new InternalError(e);
        }
        result.reinitialize();
        result.putMapEntries(this, false);
        return result;
    }

    // These methods are also used when serializing HashSets
    final float loadFactor() { return loadFactor; }
    final int capacity() {
        return (table != null) ? table.length :
            (threshold &gt; 0) ? threshold :
            DEFAULT_INITIAL_CAPACITY;
    }

    /**
     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
     *             bucket array) is emitted (int), followed by the
     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
     *             mappings), followed by the key (Object) and value (Object)
     *             for each key-value mapping.  The key-value mappings are
     *             emitted in no particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
        int buckets = capacity();
        // Write out the threshold, loadfactor, and any hidden stuff
        s.defaultWriteObject();
        s.writeInt(buckets);
        s.writeInt(size);
        internalWriteEntries(s);
    }

    /**
     * Reconstitute the {@code HashMap} instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        // Read in the threshold (ignored), loadfactor, and any hidden stuff
        s.defaultReadObject();
        reinitialize();
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                             loadFactor);
        s.readInt();                // Read and ignore number of buckets
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings &lt; 0)
            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                             mappings);
        else if (mappings &gt; 0) { // (if zero, use defaults)
            // Size the table using given load factor only if within
            // range of 0.25...4.0
            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
            float fc = (float)mappings / lf + 1.0f;
            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
                       DEFAULT_INITIAL_CAPACITY :
                       (fc &gt;= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
                       tableSizeFor((int)fc));
            float ft = (float)cap * lf;
            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
                         (int)ft : Integer.MAX_VALUE);

            // Check Map.Entry[].class since it&#39;s the nearest public type to
            // what we&#39;re actually creating.
            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);
            @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
            table = tab;

            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i &lt; mappings; i++) {
                @SuppressWarnings(&quot;unchecked&quot;)
                    K key = (K) s.readObject();
                @SuppressWarnings(&quot;unchecked&quot;)
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
        }
    }

    /* ------------------------------------------------------------ */
    // iterators

    abstract class HashIterator {
        Node&lt;K,V&gt; next;        // next entry to return
        Node&lt;K,V&gt; current;     // current entry
        int expectedModCount;  // for fast-fail
        int index;             // current slot

        HashIterator() {
            expectedModCount = modCount;
            Node&lt;K,V&gt;[] t = table;
            current = next = null;
            index = 0;
            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry
                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
            }
        }

        public final boolean hasNext() {
            return next != null;
        }

        final Node&lt;K,V&gt; nextNode() {
            Node&lt;K,V&gt;[] t;
            Node&lt;K,V&gt; e = next;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (e == null)
                throw new NoSuchElementException();
            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {
                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
            }
            return e;
        }

        public final void remove() {
            Node&lt;K,V&gt; p = current;
            if (p == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            current = null;
            K key = p.key;
            removeNode(hash(key), key, null, false, false);
            expectedModCount = modCount;
        }
    }

    final class KeyIterator extends HashIterator
        implements Iterator&lt;K&gt; {
        public final K next() { return nextNode().key; }
    }

    final class ValueIterator extends HashIterator
        implements Iterator&lt;V&gt; {
        public final V next() { return nextNode().value; }
    }

    final class EntryIterator extends HashIterator
        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }
    }

    /* ------------------------------------------------------------ */
    // spliterators

    static class HashMapSpliterator&lt;K,V&gt; {
        final HashMap&lt;K,V&gt; map;
        Node&lt;K,V&gt; current;          // current node
        int index;                  // current index, modified on advance/split
        int fence;                  // one past last index
        int est;                    // size estimate
        int expectedModCount;       // for comodification checks

        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,
                           int fence, int est,
                           int expectedModCount) {
            this.map = m;
            this.index = origin;
            this.fence = fence;
            this.est = est;
            this.expectedModCount = expectedModCount;
        }

        final int getFence() { // initialize fence and size on first use
            int hi;
            if ((hi = fence) &lt; 0) {
                HashMap&lt;K,V&gt; m = map;
                est = m.size;
                expectedModCount = m.modCount;
                Node&lt;K,V&gt;[] tab = m.table;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            return hi;
        }

        public final long estimateSize() {
            getFence(); // force init
            return (long) est;
        }
    }

    static final class KeySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                       int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public KeySpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                        expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p.key);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        K k = current.key;
                        current = current.next;
                        action.accept(k);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
                Spliterator.DISTINCT;
        }
    }

    static final class ValueSpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;V&gt; {
        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public ValueSpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p.value);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        V v = current.value;
                        current = current.next;
                        action.accept(v);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);
        }
    }

    static final class EntrySpliterator&lt;K,V&gt;
        extends HashMapSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
                         int expectedModCount) {
            super(m, origin, fence, est, expectedModCount);
        }

        public EntrySpliterator&lt;K,V&gt; trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
            return (lo &gt;= mid || current != null) ? null :
                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
                                          expectedModCount);
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int i, hi, mc;
            if (action == null)
                throw new NullPointerException();
            HashMap&lt;K,V&gt; m = map;
            Node&lt;K,V&gt;[] tab = m.table;
            if ((hi = fence) &lt; 0) {
                mc = expectedModCount = m.modCount;
                hi = fence = (tab == null) ? 0 : tab.length;
            }
            else
                mc = expectedModCount;
            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
                Node&lt;K,V&gt; p = current;
                current = null;
                do {
                    if (p == null)
                        p = tab[i++];
                    else {
                        action.accept(p);
                        p = p.next;
                    }
                } while (p != null || i &lt; hi);
                if (m.modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
            int hi;
            if (action == null)
                throw new NullPointerException();
            Node&lt;K,V&gt;[] tab = map.table;
            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
                while (current != null || index &lt; hi) {
                    if (current == null)
                        current = tab[index++];
                    else {
                        Node&lt;K,V&gt; e = current;
                        current = current.next;
                        action.accept(e);
                        if (map.modCount != expectedModCount)
                            throw new ConcurrentModificationException();
                        return true;
                    }
                }
            }
            return false;
        }

        public int characteristics() {
            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
                Spliterator.DISTINCT;
        }
    }

    /* ------------------------------------------------------------ */
    // LinkedHashMap support


    /*
     * The following package-protected methods are designed to be
     * overridden by LinkedHashMap, but not by any other subclass.
     * Nearly all other internal methods are also package-protected
     * but are declared final, so can be used by LinkedHashMap, view
     * classes, and HashSet.
     */

    // Create a regular (non-tree) node
    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
        return new Node&lt;&gt;(hash, key, value, next);
    }

    // For conversion from TreeNodes to plain nodes
    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
        return new Node&lt;&gt;(p.hash, p.key, p.value, next);
    }

    // Create a tree bin node
    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
        return new TreeNode&lt;&gt;(hash, key, value, next);
    }

    // For treeifyBin
    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);
    }

    /**
     * Reset to initial default state.  Called by clone and readObject.
     */
    void reinitialize() {
        table = null;
        entrySet = null;
        keySet = null;
        values = null;
        modCount = 0;
        threshold = 0;
        size = 0;
    }

    // Callbacks to allow LinkedHashMap post-actions
    void afterNodeAccess(Node&lt;K,V&gt; p) { }
    void afterNodeInsertion(boolean evict) { }
    void afterNodeRemoval(Node&lt;K,V&gt; p) { }

    // Called only from writeObject, to ensure compatible ordering.
    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {
        Node&lt;K,V&gt;[] tab;
        if (size &gt; 0 &amp;&amp; (tab = table) != null) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    s.writeObject(e.key);
                    s.writeObject(e.value);
                }
            }
        }
    }

    /* ------------------------------------------------------------ */
    // Tree bins

    /**
     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn
     * extends Node) so can be used as extension of either regular or
     * linked node.
     */
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
            super(hash, key, val, next);
        }

        /**
         * Returns root of tree containing this node.
         */
        final TreeNode&lt;K,V&gt; root() {
            for (TreeNode&lt;K,V&gt; r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
            }
        }

        /**
         * Ensures that the given root is the first node of its bin.
         */
        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
            int n;
            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {
                int index = (n - 1) &amp; root.hash;
                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];
                if (root != first) {
                    Node&lt;K,V&gt; rn;
                    tab[index] = root;
                    TreeNode&lt;K,V&gt; rp = root.prev;
                    if ((rn = root.next) != null)
                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;
                    if (rp != null)
                        rp.next = rn;
                    if (first != null)
                        first.prev = root;
                    root.next = first;
                    root.prev = null;
                }
                assert checkInvariants(root);
            }
        }

        /**
         * Finds the node starting at root p with the given hash and key.
         * The kc argument caches comparableClassFor(key) upon first use
         * comparing keys.
         */
        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
            TreeNode&lt;K,V&gt; p = this;
            do {
                int ph, dir; K pk;
                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;
                if ((ph = p.hash) &gt; h)
                    p = pl;
                else if (ph &lt; h)
                    p = pr;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;
                else if (pl == null)
                    p = pr;
                else if (pr == null)
                    p = pl;
                else if ((kc != null ||
                          (kc = comparableClassFor(k)) != null) &amp;&amp;
                         (dir = compareComparables(kc, k, pk)) != 0)
                    p = (dir &lt; 0) ? pl : pr;
                else if ((q = pr.find(h, k, kc)) != null)
                    return q;
                else
                    p = pl;
            } while (p != null);
            return null;
        }

        /**
         * Calls find for root node.
         */
        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
            return ((parent != null) ? root() : this).find(h, k, null);
        }

        /**
         * Tie-breaking utility for ordering insertions when equal
         * hashCodes and non-comparable. We don&#39;t require a total
         * order, just a consistent insertion rule to maintain
         * equivalence across rebalancings. Tie-breaking further than
         * necessary simplifies testing a bit.
         */
        static int tieBreakOrder(Object a, Object b) {
            int d;
            if (a == null || b == null ||
                (d = a.getClass().getName().
                 compareTo(b.getClass().getName())) == 0)
                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?
                     -1 : 1);
            return d;
        }

        /**
         * Forms tree of the nodes linked from this node.
         * @return root of tree
         */
        final void treeify(Node&lt;K,V&gt;[] tab) {
            TreeNode&lt;K,V&gt; root = null;
            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {
                next = (TreeNode&lt;K,V&gt;)x.next;
                x.left = x.right = null;
                if (root == null) {
                    x.parent = null;
                    x.red = false;
                    root = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&lt;?&gt; kc = null;
                    for (TreeNode&lt;K,V&gt; p = root;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &gt; h)
                            dir = -1;
                        else if (ph &lt; h)
                            dir = 1;
                        else if ((kc == null &amp;&amp;
                                  (kc = comparableClassFor(k)) == null) ||
                                 (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);

                        TreeNode&lt;K,V&gt; xp = p;
                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir &lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            root = balanceInsertion(root, x);
                            break;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);
        }

        /**
         * Returns a list of non-TreeNodes replacing those linked from
         * this node.
         */
        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
            Node&lt;K,V&gt; hd = null, tl = null;
            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {
                Node&lt;K,V&gt; p = map.replacementNode(q, null);
                if (tl == null)
                    hd = p;
                else
                    tl.next = p;
                tl = p;
            }
            return hd;
        }

        /**
         * Tree version of putVal.
         */
        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                       int h, K k, V v) {
            Class&lt;?&gt; kc = null;
            boolean searched = false;
            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;
            for (TreeNode&lt;K,V&gt; p = root;;) {
                int dir, ph; K pk;
                if ((ph = p.hash) &gt; h)
                    dir = -1;
                else if (ph &lt; h)
                    dir = 1;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;
                else if ((kc == null &amp;&amp;
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = true;
                        if (((ch = p.left) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null) ||
                            ((ch = p.right) != null &amp;&amp;
                             (q = ch.find(h, k, kc)) != null))
                            return q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&lt;K,V&gt; xp = p;
                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                    Node&lt;K,V&gt; xpn = xp.next;
                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                    if (dir &lt;= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    if (xpn != null)
                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    return null;
                }
            }
        }

        /**
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by &quot;next&quot; pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         */
        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                  boolean movable) {
            int n;
            if (tab == null || (n = tab.length) == 0)
                return;
            int index = (n - 1) &amp; hash;
            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;
            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;
            if (pred == null)
                tab[index] = first = succ;
            else
                pred.next = succ;
            if (succ != null)
                succ.prev = pred;
            if (first == null)
                return;
            if (root.parent != null)
                root = root.root();
            if (root == null || root.right == null ||
                (rl = root.left) == null || rl.left == null) {
                tab[index] = first.untreeify(map);  // too small
                return;
            }
            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;
            if (pl != null &amp;&amp; pr != null) {
                TreeNode&lt;K,V&gt; s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode&lt;K,V&gt; sr = s.right;
                TreeNode&lt;K,V&gt; pp = p.parent;
                if (s == pr) { // p was s&#39;s direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode&lt;K,V&gt; sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                if (sr != null)
                    replacement = sr;
                else
                    replacement = p;
            }
            else if (pl != null)
                replacement = pl;
            else if (pr != null)
                replacement = pr;
            else
                replacement = p;
            if (replacement != p) {
                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }

            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);

            if (replacement == p) {  // detach
                TreeNode&lt;K,V&gt; pp = p.parent;
                p.parent = null;
                if (pp != null) {
                    if (p == pp.left)
                        pp.left = null;
                    else if (p == pp.right)
                        pp.right = null;
                }
            }
            if (movable)
                moveRootToFront(tab, r);
        }

        /**
         * Splits nodes in a tree bin into lower and upper tree bins,
         * or untreeifies if now too small. Called only from resize;
         * see above discussion about split bits and indices.
         *
         * @param map the map
         * @param tab the table for recording bin heads
         * @param index the index of the table being split
         * @param bit the bit of hash to split on
         */
        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
            TreeNode&lt;K,V&gt; b = this;
            // Relink into lo and hi lists, preserving order
            TreeNode&lt;K,V&gt; loHead = null, loTail = null;
            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;
            int lc = 0, hc = 0;
            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {
                next = (TreeNode&lt;K,V&gt;)e.next;
                e.next = null;
                if ((e.hash &amp; bit) == 0) {
                    if ((e.prev = loTail) == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                    ++lc;
                }
                else {
                    if ((e.prev = hiTail) == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                    ++hc;
                }
            }

            if (loHead != null) {
                if (lc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index] = loHead.untreeify(map);
                else {
                    tab[index] = loHead;
                    if (hiHead != null) // (else is already treeified)
                        loHead.treeify(tab);
                }
            }
            if (hiHead != null) {
                if (hc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
            }
        }

        /* ------------------------------------------------------------ */
        // Red-black tree methods, all adapted from CLR

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
                                              TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; r, pp, rl;
            if (p != null &amp;&amp; (r = p.right) != null) {
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                if ((pp = r.parent = p.parent) == null)
                    (root = r).red = false;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
            return root;
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
                                               TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; l, pp, lr;
            if (p != null &amp;&amp; (l = p.left) != null) {
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent) == null)
                    (root = l).red = false;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                                    TreeNode&lt;K,V&gt; x) {
            x.red = true;
            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
                if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null)
                    return root;
                if (xp == (xppl = xpp.left)) {
                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {
                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null &amp;&amp; xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }

        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,
                                                   TreeNode&lt;K,V&gt; x) {
            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  {
                if (x == null || x == root)
                    return root;
                else if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (x.red) {
                    x.red = false;
                    return root;
                }
                else if ((xpl = xp.left) == x) {
                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) {
                        xpr.red = false;
                        xp.red = true;
                        root = rotateLeft(root, xp);
                        xpr = (xp = x.parent) == null ? null : xp.right;
                    }
                    if (xpr == null)
                        x = xp;
                    else {
                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;
                        if ((sr == null || !sr.red) &amp;&amp;
                            (sl == null || !sl.red)) {
                            xpr.red = true;
                            x = xp;
                        }
                        else {
                            if (sr == null || !sr.red) {
                                if (sl != null)
                                    sl.red = false;
                                xpr.red = true;
                                root = rotateRight(root, xpr);
                                xpr = (xp = x.parent) == null ?
                                    null : xp.right;
                            }
                            if (xpr != null) {
                                xpr.red = (xp == null) ? false : xp.red;
                                if ((sr = xpr.right) != null)
                                    sr.red = false;
                            }
                            if (xp != null) {
                                xp.red = false;
                                root = rotateLeft(root, xp);
                            }
                            x = root;
                        }
                    }
                }
                else { // symmetric
                    if (xpl != null &amp;&amp; xpl.red) {
                        xpl.red = false;
                        xp.red = true;
                        root = rotateRight(root, xp);
                        xpl = (xp = x.parent) == null ? null : xp.left;
                    }
                    if (xpl == null)
                        x = xp;
                    else {
                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;
                        if ((sl == null || !sl.red) &amp;&amp;
                            (sr == null || !sr.red)) {
                            xpl.red = true;
                            x = xp;
                        }
                        else {
                            if (sl == null || !sl.red) {
                                if (sr != null)
                                    sr.red = false;
                                xpl.red = true;
                                root = rotateLeft(root, xpl);
                                xpl = (xp = x.parent) == null ?
                                    null : xp.left;
                            }
                            if (xpl != null) {
                                xpl.red = (xp == null) ? false : xp.red;
                                if ((sl = xpl.left) != null)
                                    sl.red = false;
                            }
                            if (xp != null) {
                                xp.red = false;
                                root = rotateRight(root, xp);
                            }
                            x = root;
                        }
                    }
                }
            }
        }

        /**
         * Recursive invariant check
         */
        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {
            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,
                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
            if (tb != null &amp;&amp; tb.next != t)
                return false;
            if (tn != null &amp;&amp; tn.prev != t)
                return false;
            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
                return false;
            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
                return false;
            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
                return false;
            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
                return false;
            if (tl != null &amp;&amp; !checkInvariants(tl))
                return false;
            if (tr != null &amp;&amp; !checkInvariants(tr))
                return false;
            return true;
        }
    }

}
</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-21T11:00:03.000Z">2019-09-21</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8837 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/21/BigInteger类/">BigInteger类</a>
            
        </h1>
        <div class="content">
            <h1 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h1><p><img src="/images/2019/09/21/f1ae7690-dc5e-11e9-8024-c70d44c51336.png" alt="image.png"></p>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package java.math;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.io.StreamCorruptedException;
import java.io.ObjectInputStream.GetField;
import java.io.ObjectOutputStream.PutField;
import java.util.Arrays;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import jdk.internal.HotSpotIntrinsicCandidate;
import jdk.internal.misc.Unsafe;

public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; {
    final int signum;
    final int[] mag;
    private int bitCountPlusOne;
    private int bitLengthPlusOne;
    private int lowestSetBitPlusTwo;
    private int firstNonzeroIntNumPlusTwo;
    static final long LONG_MASK = 4294967295L;
    private static final int MAX_MAG_LENGTH = 67108864;
    private static final int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;
    private static final int KARATSUBA_THRESHOLD = 80;
    private static final int TOOM_COOK_THRESHOLD = 240;
    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;
    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;
    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;
    static final int BURNIKEL_ZIEGLER_OFFSET = 40;
    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;
    private static final int MULTIPLY_SQUARE_THRESHOLD = 20;
    private static final int MONTGOMERY_INTRINSIC_THRESHOLD = 512;
    private static long[] bitsPerDigit = new long[]{0L, 0L, 1024L, 1624L, 2048L, 2378L, 2648L, 2875L, 3072L, 3247L, 3402L, 3543L, 3672L, 3790L, 3899L, 4001L, 4096L, 4186L, 4271L, 4350L, 4426L, 4498L, 4567L, 4633L, 4696L, 4756L, 4814L, 4870L, 4923L, 4975L, 5025L, 5074L, 5120L, 5166L, 5210L, 5253L, 5295L};
    private static final int SMALL_PRIME_THRESHOLD = 95;
    private static final int DEFAULT_PRIME_CERTAINTY = 100;
    private static final BigInteger SMALL_PRIME_PRODUCT = valueOf(152125131763605L);
    private static final int MAX_CONSTANT = 16;
    private static BigInteger[] posConst = new BigInteger[17];
    private static BigInteger[] negConst = new BigInteger[17];
    private static volatile BigInteger[][] powerCache;
    private static final double[] logCache;
    private static final double LOG_TWO = Math.log(2.0D);
    public static final BigInteger ZERO;
    public static final BigInteger ONE;
    public static final BigInteger TWO;
    private static final BigInteger NEGATIVE_ONE;
    public static final BigInteger TEN;
    static int[] bnExpModThreshTable;
    private static String[] zeros;
    private static int[] digitsPerLong;
    private static BigInteger[] longRadix;
    private static int[] digitsPerInt;
    private static int[] intRadix;
    private static final long serialVersionUID = -8287574255936472291L;
    private static final ObjectStreamField[] serialPersistentFields;

    public BigInteger(byte[] val, int off, int len) {
        if (val.length == 0) {
            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
        } else {
            Objects.checkFromIndexSize(off, len, val.length);
            if (val[off] &lt; 0) {
                this.mag = makePositive(val, off, len);
                this.signum = -1;
            } else {
                this.mag = stripLeadingZeroBytes(val, off, len);
                this.signum = this.mag.length == 0 ? 0 : 1;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    public BigInteger(byte[] val) {
        this((byte[])val, 0, val.length);
    }

    private BigInteger(int[] val) {
        if (val.length == 0) {
            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
        } else {
            if (val[0] &lt; 0) {
                this.mag = makePositive(val);
                this.signum = -1;
            } else {
                this.mag = trustedStripLeadingZeroInts(val);
                this.signum = this.mag.length == 0 ? 0 : 1;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    public BigInteger(int signum, byte[] magnitude, int off, int len) {
        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) {
            Objects.checkFromIndexSize(off, len, magnitude.length);
            this.mag = stripLeadingZeroBytes(magnitude, off, len);
            if (this.mag.length == 0) {
                this.signum = 0;
            } else {
                if (signum == 0) {
                    throw new NumberFormatException(&quot;signum-magnitude mismatch&quot;);
                }

                this.signum = signum;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        } else {
            throw new NumberFormatException(&quot;Invalid signum value&quot;);
        }
    }

    public BigInteger(int signum, byte[] magnitude) {
        this(signum, magnitude, 0, magnitude.length);
    }

    private BigInteger(int signum, int[] magnitude) {
        this.mag = stripLeadingZeroInts(magnitude);
        if (signum &gt;= -1 &amp;&amp; signum &lt;= 1) {
            if (this.mag.length == 0) {
                this.signum = 0;
            } else {
                if (signum == 0) {
                    throw new NumberFormatException(&quot;signum-magnitude mismatch&quot;);
                }

                this.signum = signum;
            }

            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        } else {
            throw new NumberFormatException(&quot;Invalid signum value&quot;);
        }
    }

    public BigInteger(String val, int radix) {
        int cursor = 0;
        int len = val.length();
        if (radix &gt;= 2 &amp;&amp; radix &lt;= 36) {
            if (len == 0) {
                throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
            } else {
                int sign = 1;
                int index1 = val.lastIndexOf(45);
                int index2 = val.lastIndexOf(43);
                if (index1 &gt;= 0) {
                    if (index1 != 0 || index2 &gt;= 0) {
                        throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);
                    }

                    sign = -1;
                    cursor = 1;
                } else if (index2 &gt;= 0) {
                    if (index2 != 0) {
                        throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);
                    }

                    cursor = 1;
                }

                if (cursor == len) {
                    throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
                } else {
                    while(cursor &lt; len &amp;&amp; Character.digit(val.charAt(cursor), radix) == 0) {
                        ++cursor;
                    }

                    if (cursor == len) {
                        this.signum = 0;
                        this.mag = ZERO.mag;
                    } else {
                        int numDigits = len - cursor;
                        this.signum = sign;
                        long numBits = ((long)numDigits * bitsPerDigit[radix] &gt;&gt;&gt; 10) + 1L;
                        if (numBits + 31L &gt;= 4294967296L) {
                            reportOverflow();
                        }

                        int numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;
                        int[] magnitude = new int[numWords];
                        int firstGroupLen = numDigits % digitsPerInt[radix];
                        if (firstGroupLen == 0) {
                            firstGroupLen = digitsPerInt[radix];
                        }

                        String group = val.substring(cursor, cursor += firstGroupLen);
                        magnitude[numWords - 1] = Integer.parseInt(group, radix);
                        if (magnitude[numWords - 1] &lt; 0) {
                            throw new NumberFormatException(&quot;Illegal digit&quot;);
                        } else {
                            int superRadix = intRadix[radix];
                            boolean var16 = false;

                            while(cursor &lt; len) {
                                group = val.substring(cursor, cursor += digitsPerInt[radix]);
                                int groupVal = Integer.parseInt(group, radix);
                                if (groupVal &lt; 0) {
                                    throw new NumberFormatException(&quot;Illegal digit&quot;);
                                }

                                destructiveMulAdd(magnitude, superRadix, groupVal);
                            }

                            this.mag = trustedStripLeadingZeroInts(magnitude);
                            if (this.mag.length &gt;= 67108864) {
                                this.checkRange();
                            }

                        }
                    }
                }
            }
        } else {
            throw new NumberFormatException(&quot;Radix out of range&quot;);
        }
    }

    BigInteger(char[] val, int sign, int len) {
        int cursor;
        for(cursor = 0; cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0; ++cursor) {
        }

        if (cursor == len) {
            this.signum = 0;
            this.mag = ZERO.mag;
        } else {
            int numDigits = len - cursor;
            this.signum = sign;
            int numWords;
            if (len &lt; 10) {
                numWords = 1;
            } else {
                long numBits = ((long)numDigits * bitsPerDigit[10] &gt;&gt;&gt; 10) + 1L;
                if (numBits + 31L &gt;= 4294967296L) {
                    reportOverflow();
                }

                numWords = (int)(numBits + 31L) &gt;&gt;&gt; 5;
            }

            int[] magnitude = new int[numWords];
            int firstGroupLen = numDigits % digitsPerInt[10];
            if (firstGroupLen == 0) {
                firstGroupLen = digitsPerInt[10];
            }

            magnitude[numWords - 1] = this.parseInt(val, cursor, cursor += firstGroupLen);

            while(cursor &lt; len) {
                int groupVal = this.parseInt(val, cursor, cursor += digitsPerInt[10]);
                destructiveMulAdd(magnitude, intRadix[10], groupVal);
            }

            this.mag = trustedStripLeadingZeroInts(magnitude);
            if (this.mag.length &gt;= 67108864) {
                this.checkRange();
            }

        }
    }

    private int parseInt(char[] source, int start, int end) {
        int result = Character.digit(source[start++], 10);
        if (result == -1) {
            throw new NumberFormatException(new String(source));
        } else {
            for(int index = start; index &lt; end; ++index) {
                int nextVal = Character.digit(source[index], 10);
                if (nextVal == -1) {
                    throw new NumberFormatException(new String(source));
                }

                result = 10 * result + nextVal;
            }

            return result;
        }
    }

    private static void destructiveMulAdd(int[] x, int y, int z) {
        long ylong = (long)y &amp; 4294967295L;
        long zlong = (long)z &amp; 4294967295L;
        int len = x.length;
        long product = 0L;
        long carry = 0L;

        for(int i = len - 1; i &gt;= 0; --i) {
            product = ylong * ((long)x[i] &amp; 4294967295L) + carry;
            x[i] = (int)product;
            carry = product &gt;&gt;&gt; 32;
        }

        long sum = ((long)x[len - 1] &amp; 4294967295L) + zlong;
        x[len - 1] = (int)sum;
        carry = sum &gt;&gt;&gt; 32;

        for(int i = len - 2; i &gt;= 0; --i) {
            sum = ((long)x[i] &amp; 4294967295L) + carry;
            x[i] = (int)sum;
            carry = sum &gt;&gt;&gt; 32;
        }

    }

    public BigInteger(String val) {
        this((String)val, 10);
    }

    public BigInteger(int numBits, Random rnd) {
        this(1, (byte[])randomBits(numBits, rnd));
    }

    private static byte[] randomBits(int numBits, Random rnd) {
        if (numBits &lt; 0) {
            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);
        } else {
            int numBytes = (int)(((long)numBits + 7L) / 8L);
            byte[] randomBits = new byte[numBytes];
            if (numBytes &gt; 0) {
                rnd.nextBytes(randomBits);
                int excessBits = 8 * numBytes - numBits;
                randomBits[0] = (byte)(randomBits[0] &amp; (1 &lt;&lt; 8 - excessBits) - 1);
            }

            return randomBits;
        }
    }

    public BigInteger(int bitLength, int certainty, Random rnd) {
        if (bitLength &lt; 2) {
            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);
        } else {
            BigInteger prime = bitLength &lt; 95 ? smallPrime(bitLength, certainty, rnd) : largePrime(bitLength, certainty, rnd);
            this.signum = 1;
            this.mag = prime.mag;
        }
    }

    public static BigInteger probablePrime(int bitLength, Random rnd) {
        if (bitLength &lt; 2) {
            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);
        } else {
            return bitLength &lt; 95 ? smallPrime(bitLength, 100, rnd) : largePrime(bitLength, 100, rnd);
        }
    }

    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {
        int magLen = bitLength + 31 &gt;&gt;&gt; 5;
        int[] temp = new int[magLen];
        int highBit = 1 &lt;&lt; (bitLength + 31 &amp; 31);
        int highMask = (highBit &lt;&lt; 1) - 1;

        BigInteger p;
        do {
            long r;
            do {
                for(int i = 0; i &lt; magLen; ++i) {
                    temp[i] = rnd.nextInt();
                }

                temp[0] = temp[0] &amp; highMask | highBit;
                if (bitLength &gt; 2) {
                    temp[magLen - 1] |= 1;
                }

                p = new BigInteger(temp, 1);
                if (bitLength &lt;= 6) {
                    break;
                }

                r = p.remainder(SMALL_PRIME_PRODUCT).longValue();
            } while(r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L);

            if (bitLength &lt; 4) {
                return p;
            }
        } while(!p.primeToCertainty(certainty, rnd));

        return p;
    }

    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {
        BigInteger p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);
        int[] var10000 = p.mag;
        int var10001 = p.mag.length - 1;
        var10000[var10001] &amp;= -2;
        int searchLen = getPrimeSearchLen(bitLength);
        BitSieve searchSieve = new BitSieve(p, searchLen);

        BigInteger candidate;
        for(candidate = searchSieve.retrieve(p, certainty, rnd); candidate == null || candidate.bitLength() != bitLength; candidate = searchSieve.retrieve(p, certainty, rnd)) {
            p = p.add(valueOf((long)(2 * searchLen)));
            if (p.bitLength() != bitLength) {
                p = (new BigInteger(bitLength, rnd)).setBit(bitLength - 1);
            }

            var10000 = p.mag;
            var10001 = p.mag.length - 1;
            var10000[var10001] &amp;= -2;
            searchSieve = new BitSieve(p, searchLen);
        }

        return candidate;
    }

    public BigInteger nextProbablePrime() {
        if (this.signum &lt; 0) {
            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);
        } else if (this.signum != 0 &amp;&amp; !this.equals(ONE)) {
            BigInteger result = this.add(ONE);
            if (result.bitLength() &lt; 95) {
                if (!result.testBit(0)) {
                    result = result.add(ONE);
                }

                while(true) {
                    while(true) {
                        if (result.bitLength() &gt; 6) {
                            long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();
                            if (r % 3L == 0L || r % 5L == 0L || r % 7L == 0L || r % 11L == 0L || r % 13L == 0L || r % 17L == 0L || r % 19L == 0L || r % 23L == 0L || r % 29L == 0L || r % 31L == 0L || r % 37L == 0L || r % 41L == 0L) {
                                result = result.add(TWO);
                                continue;
                            }
                        }

                        if (result.bitLength() &lt; 4) {
                            return result;
                        }

                        if (result.primeToCertainty(100, (Random)null)) {
                            return result;
                        }

                        result = result.add(TWO);
                    }
                }
            } else {
                if (result.testBit(0)) {
                    result = result.subtract(ONE);
                }

                int searchLen = getPrimeSearchLen(result.bitLength());

                while(true) {
                    BitSieve searchSieve = new BitSieve(result, searchLen);
                    BigInteger candidate = searchSieve.retrieve(result, 100, (Random)null);
                    if (candidate != null) {
                        return candidate;
                    }

                    result = result.add(valueOf((long)(2 * searchLen)));
                }
            }
        } else {
            return TWO;
        }
    }

    private static int getPrimeSearchLen(int bitLength) {
        if (bitLength &gt; 500000001) {
            throw new ArithmeticException(&quot;Prime search implementation restriction on bitLength&quot;);
        } else {
            return bitLength / 20 * 64;
        }
    }

    boolean primeToCertainty(int certainty, Random random) {
        int rounds = false;
        int n = (Math.min(certainty, 2147483646) + 1) / 2;
        int sizeInBits = this.bitLength();
        byte rounds;
        int rounds;
        if (sizeInBits &lt; 100) {
            rounds = 50;
            rounds = n &lt; rounds ? n : rounds;
            return this.passesMillerRabin(rounds, random);
        } else {
            if (sizeInBits &lt; 256) {
                rounds = 27;
            } else if (sizeInBits &lt; 512) {
                rounds = 15;
            } else if (sizeInBits &lt; 768) {
                rounds = 8;
            } else if (sizeInBits &lt; 1024) {
                rounds = 4;
            } else {
                rounds = 2;
            }

            rounds = n &lt; rounds ? n : rounds;
            return this.passesMillerRabin(rounds, random) &amp;&amp; this.passesLucasLehmer();
        }
    }

    private boolean passesLucasLehmer() {
        BigInteger thisPlusOne = this.add(ONE);

        int d;
        for(d = 5; jacobiSymbol(d, this) != -1; d = d &lt; 0 ? Math.abs(d) + 2 : -(d + 2)) {
        }

        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);
        return u.mod(this).equals(ZERO);
    }

    private static int jacobiSymbol(int p, BigInteger n) {
        if (p == 0) {
            return 0;
        } else {
            int j = 1;
            int u = n.mag[n.mag.length - 1];
            int t;
            if (p &lt; 0) {
                p = -p;
                t = u &amp; 7;
                if (t == 3 || t == 7) {
                    j = -j;
                }
            }

            while((p &amp; 3) == 0) {
                p &gt;&gt;= 2;
            }

            if ((p &amp; 1) == 0) {
                p &gt;&gt;= 1;
                if (((u ^ u &gt;&gt; 1) &amp; 2) != 0) {
                    j = -j;
                }
            }

            if (p == 1) {
                return j;
            } else {
                if ((p &amp; u &amp; 2) != 0) {
                    j = -j;
                }

                for(u = n.mod(valueOf((long)p)).intValue(); u != 0; u %= t) {
                    while((u &amp; 3) == 0) {
                        u &gt;&gt;= 2;
                    }

                    if ((u &amp; 1) == 0) {
                        u &gt;&gt;= 1;
                        if (((p ^ p &gt;&gt; 1) &amp; 2) != 0) {
                            j = -j;
                        }
                    }

                    if (u == 1) {
                        return j;
                    }

                    assert u &lt; p;

                    t = u;
                    u = p;
                    p = t;
                    if ((u &amp; t &amp; 2) != 0) {
                        j = -j;
                    }
                }

                return 0;
            }
        }
    }

    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {
        BigInteger d = valueOf((long)z);
        BigInteger u = ONE;
        BigInteger v = ONE;

        for(int i = k.bitLength() - 2; i &gt;= 0; --i) {
            BigInteger u2 = u.multiply(v).mod(n);
            BigInteger v2 = v.square().add(d.multiply(u.square())).mod(n);
            if (v2.testBit(0)) {
                v2 = v2.subtract(n);
            }

            v2 = v2.shiftRight(1);
            u = u2;
            v = v2;
            if (k.testBit(i)) {
                u2 = u2.add(v2).mod(n);
                if (u2.testBit(0)) {
                    u2 = u2.subtract(n);
                }

                u2 = u2.shiftRight(1);
                v2 = v2.add(d.multiply(u)).mod(n);
                if (v2.testBit(0)) {
                    v2 = v2.subtract(n);
                }

                v2 = v2.shiftRight(1);
                u = u2;
                v = v2;
            }
        }

        return u;
    }

    private boolean passesMillerRabin(int iterations, Random rnd) {
        BigInteger thisMinusOne = this.subtract(ONE);
        int a = thisMinusOne.getLowestSetBit();
        BigInteger m = thisMinusOne.shiftRight(a);
        if (rnd == null) {
            rnd = ThreadLocalRandom.current();
        }

        for(int i = 0; i &lt; iterations; ++i) {
            BigInteger b;
            do {
                do {
                    b = new BigInteger(this.bitLength(), (Random)rnd);
                } while(b.compareTo(ONE) &lt;= 0);
            } while(b.compareTo(this) &gt;= 0);

            int j = 0;

            for(BigInteger z = b.modPow(m, this); (j != 0 || !z.equals(ONE)) &amp;&amp; !z.equals(thisMinusOne); z = z.modPow(TWO, this)) {
                if (j &gt; 0 &amp;&amp; z.equals(ONE)) {
                    return false;
                }

                ++j;
                if (j == a) {
                    return false;
                }
            }
        }

        return true;
    }

    BigInteger(int[] magnitude, int signum) {
        this.signum = magnitude.length == 0 ? 0 : signum;
        this.mag = magnitude;
        if (this.mag.length &gt;= 67108864) {
            this.checkRange();
        }

    }

    private BigInteger(byte[] magnitude, int signum) {
        this.signum = magnitude.length == 0 ? 0 : signum;
        this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
        if (this.mag.length &gt;= 67108864) {
            this.checkRange();
        }

    }

    private void checkRange() {
        if (this.mag.length &gt; 67108864 || this.mag.length == 67108864 &amp;&amp; this.mag[0] &lt; 0) {
            reportOverflow();
        }

    }

    private static void reportOverflow() {
        throw new ArithmeticException(&quot;BigInteger would overflow supported range&quot;);
    }

    public static BigInteger valueOf(long val) {
        if (val == 0L) {
            return ZERO;
        } else if (val &gt; 0L &amp;&amp; val &lt;= 16L) {
            return posConst[(int)val];
        } else {
            return val &lt; 0L &amp;&amp; val &gt;= -16L ? negConst[(int)(-val)] : new BigInteger(val);
        }
    }

    private BigInteger(long val) {
        if (val &lt; 0L) {
            val = -val;
            this.signum = -1;
        } else {
            this.signum = 1;
        }

        int highWord = (int)(val &gt;&gt;&gt; 32);
        if (highWord == 0) {
            this.mag = new int[1];
            this.mag[0] = (int)val;
        } else {
            this.mag = new int[2];
            this.mag[0] = highWord;
            this.mag[1] = (int)val;
        }

    }

    private static BigInteger valueOf(int[] val) {
        return val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val);
    }

    public BigInteger add(BigInteger val) {
        if (val.signum == 0) {
            return this;
        } else if (this.signum == 0) {
            return val;
        } else if (val.signum == this.signum) {
            return new BigInteger(add(this.mag, val.mag), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    BigInteger add(long val) {
        if (val == 0L) {
            return this;
        } else if (this.signum == 0) {
            return valueOf(val);
        } else if (Long.signum(val) == this.signum) {
            return new BigInteger(add(this.mag, Math.abs(val)), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, Math.abs(val)) : subtract(Math.abs(val), this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    private static int[] add(int[] x, long val) {
        long sum = 0L;
        int xIndex = x.length;
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int[] result;
        if (highWord == 0) {
            result = new int[xIndex];
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + val;
            result[xIndex] = (int)sum;
        } else {
            if (xIndex == 1) {
                result = new int[2];
                sum = val + ((long)x[0] &amp; 4294967295L);
                result[1] = (int)sum;
                result[0] = (int)(sum &gt;&gt;&gt; 32);
                return result;
            }

            result = new int[xIndex];
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + (val &amp; 4294967295L);
            result[xIndex] = (int)sum;
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)highWord &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);
            result[xIndex] = (int)sum;
        }

        boolean carry;
        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) {
            --xIndex;
        }

        while(xIndex &gt; 0) {
            --xIndex;
            result[xIndex] = x[xIndex];
        }

        if (carry) {
            int[] bigger = new int[result.length + 1];
            System.arraycopy(result, 0, bigger, 1, result.length);
            bigger[0] = 1;
            return bigger;
        } else {
            return result;
        }
    }

    private static int[] add(int[] x, int[] y) {
        if (x.length &lt; y.length) {
            int[] tmp = x;
            x = y;
            y = tmp;
        }

        int xIndex = x.length;
        int yIndex = y.length;
        int[] result = new int[xIndex];
        long sum = 0L;
        if (yIndex == 1) {
            --xIndex;
            sum = ((long)x[xIndex] &amp; 4294967295L) + ((long)y[0] &amp; 4294967295L);
            result[xIndex] = (int)sum;
        } else {
            while(yIndex &gt; 0) {
                --xIndex;
                long var10000 = (long)x[xIndex] &amp; 4294967295L;
                --yIndex;
                sum = var10000 + ((long)y[yIndex] &amp; 4294967295L) + (sum &gt;&gt;&gt; 32);
                result[xIndex] = (int)sum;
            }
        }

        boolean carry;
        for(carry = sum &gt;&gt;&gt; 32 != 0L; xIndex &gt; 0 &amp;&amp; carry; carry = (result[xIndex] = x[xIndex] + 1) == 0) {
            --xIndex;
        }

        while(xIndex &gt; 0) {
            --xIndex;
            result[xIndex] = x[xIndex];
        }

        if (carry) {
            int[] bigger = new int[result.length + 1];
            System.arraycopy(result, 0, bigger, 1, result.length);
            bigger[0] = 1;
            return bigger;
        } else {
            return result;
        }
    }

    private static int[] subtract(long val, int[] little) {
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int[] result;
        if (highWord == 0) {
            result = new int[]{(int)(val - ((long)little[0] &amp; 4294967295L))};
            return result;
        } else {
            result = new int[2];
            long difference;
            if (little.length == 1) {
                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L);
                result[1] = (int)difference;
                boolean borrow = difference &gt;&gt; 32 != 0L;
                if (borrow) {
                    result[0] = highWord - 1;
                } else {
                    result[0] = highWord;
                }

                return result;
            } else {
                difference = ((long)((int)val) &amp; 4294967295L) - ((long)little[1] &amp; 4294967295L);
                result[1] = (int)difference;
                difference = ((long)highWord &amp; 4294967295L) - ((long)little[0] &amp; 4294967295L) + (difference &gt;&gt; 32);
                result[0] = (int)difference;
                return result;
            }
        }
    }

    private static int[] subtract(int[] big, long val) {
        int highWord = (int)(val &gt;&gt;&gt; 32);
        int bigIndex = big.length;
        int[] result = new int[bigIndex];
        long difference = 0L;
        if (highWord == 0) {
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - val;
            result[bigIndex] = (int)difference;
        } else {
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - (val &amp; 4294967295L);
            result[bigIndex] = (int)difference;
            --bigIndex;
            difference = ((long)big[bigIndex] &amp; 4294967295L) - ((long)highWord &amp; 4294967295L) + (difference &gt;&gt; 32);
            result[bigIndex] = (int)difference;
        }

        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) {
            --bigIndex;
        }

        while(bigIndex &gt; 0) {
            --bigIndex;
            result[bigIndex] = big[bigIndex];
        }

        return result;
    }

    public BigInteger subtract(BigInteger val) {
        if (val.signum == 0) {
            return this;
        } else if (this.signum == 0) {
            return val.negate();
        } else if (val.signum != this.signum) {
            return new BigInteger(add(this.mag, val.mag), this.signum);
        } else {
            int cmp = this.compareMagnitude(val);
            if (cmp == 0) {
                return ZERO;
            } else {
                int[] resultMag = cmp &gt; 0 ? subtract(this.mag, val.mag) : subtract(val.mag, this.mag);
                resultMag = trustedStripLeadingZeroInts(resultMag);
                return new BigInteger(resultMag, cmp == this.signum ? 1 : -1);
            }
        }
    }

    private static int[] subtract(int[] big, int[] little) {
        int bigIndex = big.length;
        int[] result = new int[bigIndex];
        int littleIndex = little.length;

        long difference;
        for(difference = 0L; littleIndex &gt; 0; result[bigIndex] = (int)difference) {
            --bigIndex;
            long var10000 = (long)big[bigIndex] &amp; 4294967295L;
            --littleIndex;
            difference = var10000 - ((long)little[littleIndex] &amp; 4294967295L) + (difference &gt;&gt; 32);
        }

        for(boolean borrow = difference &gt;&gt; 32 != 0L; bigIndex &gt; 0 &amp;&amp; borrow; borrow = (result[bigIndex] = big[bigIndex] - 1) == -1) {
            --bigIndex;
        }

        while(bigIndex &gt; 0) {
            --bigIndex;
            result[bigIndex] = big[bigIndex];
        }

        return result;
    }

    public BigInteger multiply(BigInteger val) {
        return this.multiply(val, false);
    }

    private BigInteger multiply(BigInteger val, boolean isRecursion) {
        if (val.signum != 0 &amp;&amp; this.signum != 0) {
            int xlen = this.mag.length;
            if (val == this &amp;&amp; xlen &gt; 20) {
                return this.square();
            } else {
                int ylen = val.mag.length;
                if (xlen &gt;= 80 &amp;&amp; ylen &gt;= 80) {
                    if (xlen &lt; 240 &amp;&amp; ylen &lt; 240) {
                        return multiplyKaratsuba(this, val);
                    } else {
                        if (!isRecursion &amp;&amp; (long)(bitLength(this.mag, this.mag.length) + bitLength(val.mag, val.mag.length)) &gt; 2147483648L) {
                            reportOverflow();
                        }

                        return multiplyToomCook3(this, val);
                    }
                } else {
                    int resultSign = this.signum == val.signum ? 1 : -1;
                    if (val.mag.length == 1) {
                        return multiplyByInt(this.mag, val.mag[0], resultSign);
                    } else if (this.mag.length == 1) {
                        return multiplyByInt(val.mag, this.mag[0], resultSign);
                    } else {
                        int[] result = multiplyToLen(this.mag, xlen, val.mag, ylen, (int[])null);
                        result = trustedStripLeadingZeroInts(result);
                        return new BigInteger(result, resultSign);
                    }
                }
            }
        } else {
            return ZERO;
        }
    }

    private static BigInteger multiplyByInt(int[] x, int y, int sign) {
        if (Integer.bitCount(y) == 1) {
            return new BigInteger(shiftLeft(x, Integer.numberOfTrailingZeros(y)), sign);
        } else {
            int xlen = x.length;
            int[] rmag = new int[xlen + 1];
            long carry = 0L;
            long yl = (long)y &amp; 4294967295L;
            int rstart = rmag.length - 1;

            for(int i = xlen - 1; i &gt;= 0; --i) {
                long product = ((long)x[i] &amp; 4294967295L) * yl + carry;
                rmag[rstart--] = (int)product;
                carry = product &gt;&gt;&gt; 32;
            }

            if (carry == 0L) {
                rmag = Arrays.copyOfRange(rmag, 1, rmag.length);
            } else {
                rmag[rstart] = (int)carry;
            }

            return new BigInteger(rmag, sign);
        }
    }

    BigInteger multiply(long v) {
        if (v != 0L &amp;&amp; this.signum != 0) {
            if (v == -9223372036854775808L) {
                return this.multiply(valueOf(v));
            } else {
                int rsign = v &gt; 0L ? this.signum : -this.signum;
                if (v &lt; 0L) {
                    v = -v;
                }

                long dh = v &gt;&gt;&gt; 32;
                long dl = v &amp; 4294967295L;
                int xlen = this.mag.length;
                int[] value = this.mag;
                int[] rmag = dh == 0L ? new int[xlen + 1] : new int[xlen + 2];
                long carry = 0L;
                int rstart = rmag.length - 1;

                int i;
                long product;
                for(i = xlen - 1; i &gt;= 0; --i) {
                    product = ((long)value[i] &amp; 4294967295L) * dl + carry;
                    rmag[rstart--] = (int)product;
                    carry = product &gt;&gt;&gt; 32;
                }

                rmag[rstart] = (int)carry;
                if (dh != 0L) {
                    carry = 0L;
                    rstart = rmag.length - 2;

                    for(i = xlen - 1; i &gt;= 0; --i) {
                        product = ((long)value[i] &amp; 4294967295L) * dh + ((long)rmag[rstart] &amp; 4294967295L) + carry;
                        rmag[rstart--] = (int)product;
                        carry = product &gt;&gt;&gt; 32;
                    }

                    rmag[0] = (int)carry;
                }

                if (carry == 0L) {
                    rmag = Arrays.copyOfRange(rmag, 1, rmag.length);
                }

                return new BigInteger(rmag, rsign);
            }
        } else {
            return ZERO;
        }
    }

    private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
        multiplyToLenCheck(x, xlen);
        multiplyToLenCheck(y, ylen);
        return implMultiplyToLen(x, xlen, y, ylen, z);
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
        int xstart = xlen - 1;
        int ystart = ylen - 1;
        if (z == null || z.length &lt; xlen + ylen) {
            z = new int[xlen + ylen];
        }

        long carry = 0L;
        int i = ystart;

        int j;
        for(j = ystart + 1 + xstart; i &gt;= 0; --j) {
            long product = ((long)y[i] &amp; 4294967295L) * ((long)x[xstart] &amp; 4294967295L) + carry;
            z[j] = (int)product;
            carry = product &gt;&gt;&gt; 32;
            --i;
        }

        z[xstart] = (int)carry;

        for(i = xstart - 1; i &gt;= 0; --i) {
            carry = 0L;
            j = ystart;

            for(int k = ystart + 1 + i; j &gt;= 0; --k) {
                long product = ((long)y[j] &amp; 4294967295L) * ((long)x[i] &amp; 4294967295L) + ((long)z[k] &amp; 4294967295L) + carry;
                z[k] = (int)product;
                carry = product &gt;&gt;&gt; 32;
                --j;
            }

            z[i] = (int)carry;
        }

        return z;
    }

    private static void multiplyToLenCheck(int[] array, int length) {
        if (length &gt; 0) {
            Objects.requireNonNull(array);
            if (length &gt; array.length) {
                throw new ArrayIndexOutOfBoundsException(length - 1);
            }
        }
    }

    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {
        int xlen = x.mag.length;
        int ylen = y.mag.length;
        int half = (Math.max(xlen, ylen) + 1) / 2;
        BigInteger xl = x.getLower(half);
        BigInteger xh = x.getUpper(half);
        BigInteger yl = y.getLower(half);
        BigInteger yh = y.getUpper(half);
        BigInteger p1 = xh.multiply(yh);
        BigInteger p2 = xl.multiply(yl);
        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));
        BigInteger result = p1.shiftLeft(32 * half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32 * half).add(p2);
        return x.signum != y.signum ? result.negate() : result;
    }

    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {
        int alen = a.mag.length;
        int blen = b.mag.length;
        int largest = Math.max(alen, blen);
        int k = (largest + 2) / 3;
        int r = largest - 2 * k;
        BigInteger a2 = a.getToomSlice(k, r, 0, largest);
        BigInteger a1 = a.getToomSlice(k, r, 1, largest);
        BigInteger a0 = a.getToomSlice(k, r, 2, largest);
        BigInteger b2 = b.getToomSlice(k, r, 0, largest);
        BigInteger b1 = b.getToomSlice(k, r, 1, largest);
        BigInteger b0 = b.getToomSlice(k, r, 2, largest);
        BigInteger v0 = a0.multiply(b0, true);
        BigInteger da1 = a2.add(a0);
        BigInteger db1 = b2.add(b0);
        BigInteger vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);
        da1 = da1.add(a1);
        db1 = db1.add(b1);
        BigInteger v1 = da1.multiply(db1, true);
        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(db1.add(b2).shiftLeft(1).subtract(b0), true);
        BigInteger vinf = a2.multiply(b2, true);
        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();
        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);
        BigInteger t1 = v1.subtract(v0);
        t2 = t2.subtract(t1).shiftRight(1);
        t1 = t1.subtract(tm1).subtract(vinf);
        t2 = t2.subtract(vinf.shiftLeft(1));
        tm1 = tm1.subtract(t2);
        int ss = k * 32;
        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);
        return a.signum != b.signum ? result.negate() : result;
    }

    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice, int fullsize) {
        int len = this.mag.length;
        int offset = fullsize - len;
        int start;
        int end;
        if (slice == 0) {
            start = 0 - offset;
            end = upperSize - 1 - offset;
        } else {
            start = upperSize + (slice - 1) * lowerSize - offset;
            end = start + lowerSize - 1;
        }

        if (start &lt; 0) {
            start = 0;
        }

        if (end &lt; 0) {
            return ZERO;
        } else {
            int sliceSize = end - start + 1;
            if (sliceSize &lt;= 0) {
                return ZERO;
            } else if (start == 0 &amp;&amp; sliceSize &gt;= len) {
                return this.abs();
            } else {
                int[] intSlice = new int[sliceSize];
                System.arraycopy(this.mag, start, intSlice, 0, sliceSize);
                return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);
            }
        }
    }

    private BigInteger exactDivideBy3() {
        int len = this.mag.length;
        int[] result = new int[len];
        long borrow = 0L;

        for(int i = len - 1; i &gt;= 0; --i) {
            long x = (long)this.mag[i] &amp; 4294967295L;
            long w = x - borrow;
            if (borrow &gt; x) {
                borrow = 1L;
            } else {
                borrow = 0L;
            }

            long q = w * 2863311531L &amp; 4294967295L;
            result[i] = (int)q;
            if (q &gt;= 1431655766L) {
                ++borrow;
                if (q &gt;= 2863311531L) {
                    ++borrow;
                }
            }
        }

        result = trustedStripLeadingZeroInts(result);
        return new BigInteger(result, this.signum);
    }

    private BigInteger getLower(int n) {
        int len = this.mag.length;
        if (len &lt;= n) {
            return this.abs();
        } else {
            int[] lowerInts = new int[n];
            System.arraycopy(this.mag, len - n, lowerInts, 0, n);
            return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);
        }
    }

    private BigInteger getUpper(int n) {
        int len = this.mag.length;
        if (len &lt;= n) {
            return ZERO;
        } else {
            int upperLen = len - n;
            int[] upperInts = new int[upperLen];
            System.arraycopy(this.mag, 0, upperInts, 0, upperLen);
            return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);
        }
    }

    private BigInteger square() {
        return this.square(false);
    }

    private BigInteger square(boolean isRecursion) {
        if (this.signum == 0) {
            return ZERO;
        } else {
            int len = this.mag.length;
            if (len &lt; 128) {
                int[] z = squareToLen(this.mag, len, (int[])null);
                return new BigInteger(trustedStripLeadingZeroInts(z), 1);
            } else if (len &lt; 216) {
                return this.squareKaratsuba();
            } else {
                if (!isRecursion &amp;&amp; (long)bitLength(this.mag, this.mag.length) &gt; 1073741824L) {
                    reportOverflow();
                }

                return this.squareToomCook3();
            }
        }
    }

    private static final int[] squareToLen(int[] x, int len, int[] z) {
        int zlen = len &lt;&lt; 1;
        if (z == null || z.length &lt; zlen) {
            z = new int[zlen];
        }

        implSquareToLenChecks(x, len, z, zlen);
        return implSquareToLen(x, len, z, zlen);
    }

    private static void implSquareToLenChecks(int[] x, int len, int[] z, int zlen) throws RuntimeException {
        if (len &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);
        } else if (len &gt; x.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len + &quot; &gt; &quot; + x.length);
        } else if (len * 2 &gt; z.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len * 2 + &quot; &gt; &quot; + z.length);
        } else if (zlen &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + zlen);
        } else if (zlen &gt; z.length) {
            throw new IllegalArgumentException(&quot;input length out of bound: &quot; + len + &quot; &gt; &quot; + z.length);
        }
    }

    @HotSpotIntrinsicCandidate
    private static final int[] implSquareToLen(int[] x, int len, int[] z, int zlen) {
        int lastProductLowWord = 0;
        int i = 0;

        int offset;
        for(offset = 0; i &lt; len; ++i) {
            long piece = (long)x[i] &amp; 4294967295L;
            long product = piece * piece;
            z[offset++] = lastProductLowWord &lt;&lt; 31 | (int)(product &gt;&gt;&gt; 33);
            z[offset++] = (int)(product &gt;&gt;&gt; 1);
            lastProductLowWord = (int)product;
        }

        i = len;

        for(offset = 1; i &gt; 0; offset += 2) {
            int t = x[i - 1];
            t = mulAdd(z, x, offset, i - 1, t);
            addOne(z, offset - 1, i, t);
            --i;
        }

        primitiveLeftShift(z, zlen, 1);
        z[zlen - 1] |= x[len - 1] &amp; 1;
        return z;
    }

    private BigInteger squareKaratsuba() {
        int half = (this.mag.length + 1) / 2;
        BigInteger xl = this.getLower(half);
        BigInteger xh = this.getUpper(half);
        BigInteger xhs = xh.square();
        BigInteger xls = xl.square();
        return xhs.shiftLeft(half * 32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half * 32).add(xls);
    }

    private BigInteger squareToomCook3() {
        int len = this.mag.length;
        int k = (len + 2) / 3;
        int r = len - 2 * k;
        BigInteger a2 = this.getToomSlice(k, r, 0, len);
        BigInteger a1 = this.getToomSlice(k, r, 1, len);
        BigInteger a0 = this.getToomSlice(k, r, 2, len);
        BigInteger v0 = a0.square(true);
        BigInteger da1 = a2.add(a0);
        BigInteger vm1 = da1.subtract(a1).square(true);
        da1 = da1.add(a1);
        BigInteger v1 = da1.square(true);
        BigInteger vinf = a2.square(true);
        BigInteger v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);
        BigInteger t2 = v2.subtract(vm1).exactDivideBy3();
        BigInteger tm1 = v1.subtract(vm1).shiftRight(1);
        BigInteger t1 = v1.subtract(v0);
        t2 = t2.subtract(t1).shiftRight(1);
        t1 = t1.subtract(tm1).subtract(vinf);
        t2 = t2.subtract(vinf.shiftLeft(1));
        tm1 = tm1.subtract(t2);
        int ss = k * 32;
        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);
    }

    public BigInteger divide(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideBurnikelZiegler(val) : this.divideKnuth(val);
    }

    private BigInteger divideKnuth(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        a.divideKnuth(b, q, false);
        return q.toBigInteger(this.signum * val.signum);
    }

    public BigInteger[] divideAndRemainder(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.divideAndRemainderBurnikelZiegler(val) : this.divideAndRemainderKnuth(val);
    }

    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {
        BigInteger[] result = new BigInteger[2];
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        MutableBigInteger r = a.divideKnuth(b, q);
        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);
        result[1] = r.toBigInteger(this.signum);
        return result;
    }

    public BigInteger remainder(BigInteger val) {
        return val.mag.length &gt;= 80 &amp;&amp; this.mag.length - val.mag.length &gt;= 40 ? this.remainderBurnikelZiegler(val) : this.remainderKnuth(val);
    }

    private BigInteger remainderKnuth(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger a = new MutableBigInteger(this.mag);
        MutableBigInteger b = new MutableBigInteger(val.mag);
        return a.divideKnuth(b, q).toBigInteger(this.signum);
    }

    private BigInteger divideBurnikelZiegler(BigInteger val) {
        return this.divideAndRemainderBurnikelZiegler(val)[0];
    }

    private BigInteger remainderBurnikelZiegler(BigInteger val) {
        return this.divideAndRemainderBurnikelZiegler(val)[1];
    }

    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger r = (new MutableBigInteger(this)).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);
        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(this.signum * val.signum);
        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(this.signum);
        return new BigInteger[]{qBigInt, rBigInt};
    }

    public BigInteger pow(int exponent) {
        if (exponent &lt; 0) {
            throw new ArithmeticException(&quot;Negative exponent&quot;);
        } else if (this.signum == 0) {
            return exponent == 0 ? ONE : this;
        } else {
            BigInteger partToSquare = this.abs();
            int powersOfTwo = partToSquare.getLowestSetBit();
            long bitsToShiftLong = (long)powersOfTwo * (long)exponent;
            if (bitsToShiftLong &gt; 2147483647L) {
                reportOverflow();
            }

            int bitsToShift = (int)bitsToShiftLong;
            int remainingBits;
            if (powersOfTwo &gt; 0) {
                partToSquare = partToSquare.shiftRight(powersOfTwo);
                remainingBits = partToSquare.bitLength();
                if (remainingBits == 1) {
                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                        return NEGATIVE_ONE.shiftLeft(bitsToShift);
                    }

                    return ONE.shiftLeft(bitsToShift);
                }
            } else {
                remainingBits = partToSquare.bitLength();
                if (remainingBits == 1) {
                    if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                        return NEGATIVE_ONE;
                    }

                    return ONE;
                }
            }

            long scaleFactor = (long)remainingBits * (long)exponent;
            if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62L) {
                int newSign = this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1 ? -1 : 1;
                long result = 1L;
                long baseToPow2 = (long)partToSquare.mag[0] &amp; 4294967295L;
                int workingExponent = exponent;

                while(workingExponent != 0) {
                    if ((workingExponent &amp; 1) == 1) {
                        result *= baseToPow2;
                    }

                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) {
                        baseToPow2 *= baseToPow2;
                    }
                }

                if (powersOfTwo &gt; 0) {
                    if ((long)bitsToShift + scaleFactor &lt;= 62L) {
                        return valueOf((result &lt;&lt; bitsToShift) * (long)newSign);
                    } else {
                        return valueOf(result * (long)newSign).shiftLeft(bitsToShift);
                    }
                } else {
                    return valueOf(result * (long)newSign);
                }
            } else {
                if ((long)this.bitLength() * (long)exponent / 32L &gt; 67108864L) {
                    reportOverflow();
                }

                BigInteger answer = ONE;
                int workingExponent = exponent;

                while(workingExponent != 0) {
                    if ((workingExponent &amp; 1) == 1) {
                        answer = answer.multiply(partToSquare);
                    }

                    if ((workingExponent &gt;&gt;&gt;= 1) != 0) {
                        partToSquare = partToSquare.square();
                    }
                }

                if (powersOfTwo &gt; 0) {
                    answer = answer.shiftLeft(bitsToShift);
                }

                if (this.signum &lt; 0 &amp;&amp; (exponent &amp; 1) == 1) {
                    return answer.negate();
                } else {
                    return answer;
                }
            }
        }
    }

    public BigInteger sqrt() {
        if (this.signum &lt; 0) {
            throw new ArithmeticException(&quot;Negative BigInteger&quot;);
        } else {
            return (new MutableBigInteger(this.mag)).sqrt().toBigInteger();
        }
    }

    public BigInteger[] sqrtAndRemainder() {
        BigInteger s = this.sqrt();
        BigInteger r = this.subtract(s.square());

        assert r.compareTo(ZERO) &gt;= 0;

        return new BigInteger[]{s, r};
    }

    public BigInteger gcd(BigInteger val) {
        if (val.signum == 0) {
            return this.abs();
        } else if (this.signum == 0) {
            return val.abs();
        } else {
            MutableBigInteger a = new MutableBigInteger(this);
            MutableBigInteger b = new MutableBigInteger(val);
            MutableBigInteger result = a.hybridGCD(b);
            return result.toBigInteger(1);
        }
    }

    static int bitLengthForInt(int n) {
        return 32 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] leftShift(int[] a, int len, int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int bitsInHighWord = bitLengthForInt(a[0]);
        if (n &lt;= 32 - bitsInHighWord) {
            primitiveLeftShift(a, len, nBits);
            return a;
        } else {
            int[] result;
            if (nBits &lt;= 32 - bitsInHighWord) {
                result = new int[nInts + len];
                System.arraycopy(a, 0, result, 0, len);
                primitiveLeftShift(result, result.length, nBits);
                return result;
            } else {
                result = new int[nInts + len + 1];
                System.arraycopy(a, 0, result, 0, len);
                primitiveRightShift(result, result.length, 32 - nBits);
                return result;
            }
        }
    }

    static void primitiveRightShift(int[] a, int len, int n) {
        int n2 = 32 - n;
        int i = len - 1;

        for(int c = a[i]; i &gt; 0; --i) {
            int b = c;
            c = a[i - 1];
            a[i] = c &lt;&lt; n2 | b &gt;&gt;&gt; n;
        }

        a[0] &gt;&gt;&gt;= n;
    }

    static void primitiveLeftShift(int[] a, int len, int n) {
        if (len != 0 &amp;&amp; n != 0) {
            int n2 = 32 - n;
            int i = 0;
            int c = a[i];

            for(int m = i + len - 1; i &lt; m; ++i) {
                int b = c;
                c = a[i + 1];
                a[i] = b &lt;&lt; n | c &gt;&gt;&gt; n2;
            }

            a[len - 1] &lt;&lt;= n;
        }
    }

    private static int bitLength(int[] val, int len) {
        return len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(val[0]);
    }

    public BigInteger abs() {
        return this.signum &gt;= 0 ? this : this.negate();
    }

    public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }

    public int signum() {
        return this.signum;
    }

    public BigInteger mod(BigInteger m) {
        if (m.signum &lt;= 0) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else {
            BigInteger result = this.remainder(m);
            return result.signum &gt;= 0 ? result : result.add(m);
        }
    }

    public BigInteger modPow(BigInteger exponent, BigInteger m) {
        if (m.signum &lt;= 0) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else if (exponent.signum == 0) {
            return m.equals(ONE) ? ZERO : ONE;
        } else if (this.equals(ONE)) {
            return m.equals(ONE) ? ZERO : ONE;
        } else if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0) {
            return ZERO;
        } else if (this.equals(negConst[1]) &amp;&amp; !exponent.testBit(0)) {
            return m.equals(ONE) ? ZERO : ONE;
        } else {
            boolean invertResult;
            if (invertResult = exponent.signum &lt; 0) {
                exponent = exponent.negate();
            }

            BigInteger base = this.signum &gt;= 0 &amp;&amp; this.compareTo(m) &lt; 0 ? this : this.mod(m);
            BigInteger result;
            if (m.testBit(0)) {
                result = base.oddModPow(exponent, m);
            } else {
                int p = m.getLowestSetBit();
                BigInteger m1 = m.shiftRight(p);
                BigInteger m2 = ONE.shiftLeft(p);
                BigInteger base2 = this.signum &gt;= 0 &amp;&amp; this.compareTo(m1) &lt; 0 ? this : this.mod(m1);
                BigInteger a1 = m1.equals(ONE) ? ZERO : base2.oddModPow(exponent, m1);
                BigInteger a2 = base.modPow2(exponent, p);
                BigInteger y1 = m2.modInverse(m1);
                BigInteger y2 = m1.modInverse(m2);
                if (m.mag.length &lt; 33554432) {
                    result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);
                } else {
                    MutableBigInteger t1 = new MutableBigInteger();
                    (new MutableBigInteger(a1.multiply(m2))).multiply(new MutableBigInteger(y1), t1);
                    MutableBigInteger t2 = new MutableBigInteger();
                    (new MutableBigInteger(a2.multiply(m1))).multiply(new MutableBigInteger(y2), t2);
                    t1.add(t2);
                    MutableBigInteger q = new MutableBigInteger();
                    result = t1.divide(new MutableBigInteger(m), q).toBigInteger();
                }
            }

            return invertResult ? result.modInverse(m) : result;
        }
    }

    private static int[] montgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) {
        implMontgomeryMultiplyChecks(a, b, n, len, product);
        if (len &gt; 512) {
            product = multiplyToLen(a, len, b, len, product);
            return montReduce(product, n, len, (int)inv);
        } else {
            return implMontgomeryMultiply(a, b, n, len, inv, materialize(product, len));
        }
    }

    private static int[] montgomerySquare(int[] a, int[] n, int len, long inv, int[] product) {
        implMontgomeryMultiplyChecks(a, a, n, len, product);
        if (len &gt; 512) {
            product = squareToLen(a, len, product);
            return montReduce(product, n, len, (int)inv);
        } else {
            return implMontgomerySquare(a, n, len, inv, materialize(product, len));
        }
    }

    private static void implMontgomeryMultiplyChecks(int[] a, int[] b, int[] n, int len, int[] product) throws RuntimeException {
        if (len % 2 != 0) {
            throw new IllegalArgumentException(&quot;input array length must be even: &quot; + len);
        } else if (len &lt; 1) {
            throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);
        } else if (len &gt; a.length || len &gt; b.length || len &gt; n.length || product != null &amp;&amp; len &gt; product.length) {
            throw new IllegalArgumentException(&quot;input array length out of bound: &quot; + len);
        }
    }

    private static int[] materialize(int[] z, int len) {
        if (z == null || z.length &lt; len) {
            z = new int[len];
        }

        return z;
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMontgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv, int[] product) {
        product = multiplyToLen(a, len, b, len, product);
        return montReduce(product, n, len, (int)inv);
    }

    @HotSpotIntrinsicCandidate
    private static int[] implMontgomerySquare(int[] a, int[] n, int len, long inv, int[] product) {
        product = squareToLen(a, len, product);
        return montReduce(product, n, len, (int)inv);
    }

    private BigInteger oddModPow(BigInteger y, BigInteger z) {
        if (y.equals(ONE)) {
            return this;
        } else if (this.signum == 0) {
            return ZERO;
        } else {
            int[] base = (int[])this.mag.clone();
            int[] exp = y.mag;
            int[] mod = z.mag;
            int modLen = mod.length;
            if ((modLen &amp; 1) != 0) {
                int[] x = new int[modLen + 1];
                System.arraycopy(mod, 0, x, 1, modLen);
                mod = x;
                ++modLen;
            }

            int wbits = 0;
            int ebits = bitLength(exp, exp.length);
            if (ebits != 17 || exp[0] != 65537) {
                while(ebits &gt; bnExpModThreshTable[wbits]) {
                    ++wbits;
                }
            }

            int tblmask = 1 &lt;&lt; wbits;
            int[][] table = new int[tblmask][];

            for(int i = 0; i &lt; tblmask; ++i) {
                table[i] = new int[modLen];
            }

            long n0 = ((long)mod[modLen - 1] &amp; 4294967295L) + (((long)mod[modLen - 2] &amp; 4294967295L) &lt;&lt; 32);
            long inv = -MutableBigInteger.inverseMod64(n0);
            int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);
            MutableBigInteger q = new MutableBigInteger();
            MutableBigInteger a2 = new MutableBigInteger(a);
            MutableBigInteger b2 = new MutableBigInteger(mod);
            b2.normalize();
            MutableBigInteger r = a2.divide(b2, q);
            table[0] = r.toIntArray();
            int[] t;
            if (table[0].length &lt; modLen) {
                int offset = modLen - table[0].length;
                t = new int[modLen];
                System.arraycopy(table[0], 0, t, offset, table[0].length);
                table[0] = t;
            }

            int[] b = montgomerySquare(table[0], mod, modLen, inv, (int[])null);
            t = Arrays.copyOf(b, modLen);

            int bitpos;
            for(bitpos = 1; bitpos &lt; tblmask; ++bitpos) {
                table[bitpos] = montgomeryMultiply(t, table[bitpos - 1], mod, modLen, inv, (int[])null);
            }

            bitpos = 1 &lt;&lt; (ebits - 1 &amp; 31);
            int buf = 0;
            int elen = exp.length;
            int eIndex = 0;

            int multpos;
            for(multpos = 0; multpos &lt;= wbits; ++multpos) {
                buf = buf &lt;&lt; 1 | ((exp[eIndex] &amp; bitpos) != 0 ? 1 : 0);
                bitpos &gt;&gt;&gt;= 1;
                if (bitpos == 0) {
                    ++eIndex;
                    bitpos = -2147483648;
                    --elen;
                }
            }

            --ebits;
            boolean isone = true;

            for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) {
                buf &gt;&gt;&gt;= 1;
            }

            int[] mult = table[buf &gt;&gt;&gt; 1];
            buf = 0;
            if (multpos == ebits) {
                isone = false;
            }

            while(true) {
                --ebits;
                buf &lt;&lt;= 1;
                if (elen != 0) {
                    buf |= (exp[eIndex] &amp; bitpos) != 0 ? 1 : 0;
                    bitpos &gt;&gt;&gt;= 1;
                    if (bitpos == 0) {
                        ++eIndex;
                        bitpos = -2147483648;
                        --elen;
                    }
                }

                if ((buf &amp; tblmask) != 0) {
                    for(multpos = ebits - wbits; (buf &amp; 1) == 0; ++multpos) {
                        buf &gt;&gt;&gt;= 1;
                    }

                    mult = table[buf &gt;&gt;&gt; 1];
                    buf = 0;
                }

                if (ebits == multpos) {
                    if (isone) {
                        b = (int[])mult.clone();
                        isone = false;
                    } else {
                        a = montgomeryMultiply(b, mult, mod, modLen, inv, a);
                        t = a;
                        a = b;
                        b = t;
                    }
                }

                if (ebits == 0) {
                    int[] t2 = new int[2 * modLen];
                    System.arraycopy(b, 0, t2, modLen, modLen);
                    b = montReduce(t2, mod, modLen, (int)inv);
                    t2 = Arrays.copyOf(b, modLen);
                    return new BigInteger(1, t2);
                }

                if (!isone) {
                    a = montgomerySquare(b, mod, modLen, inv, a);
                    t = a;
                    a = b;
                    b = t;
                }
            }
        }
    }

    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) {
        int c = 0;
        int len = mlen;
        int offset = 0;

        do {
            int nEnd = n[n.length - 1 - offset];
            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);
            c += addOne(n, offset, mlen, carry);
            ++offset;
            --len;
        } while(len &gt; 0);

        while(c &gt; 0) {
            c += subN(n, mod, mlen);
        }

        while(intArrayCmpToLen(n, mod, mlen) &gt;= 0) {
            subN(n, mod, mlen);
        }

        return n;
    }

    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) {
        for(int i = 0; i &lt; len; ++i) {
            long b1 = (long)arg1[i] &amp; 4294967295L;
            long b2 = (long)arg2[i] &amp; 4294967295L;
            if (b1 &lt; b2) {
                return -1;
            }

            if (b1 &gt; b2) {
                return 1;
            }
        }

        return 0;
    }

    private static int subN(int[] a, int[] b, int len) {
        long sum = 0L;

        while(true) {
            --len;
            if (len &lt; 0) {
                return (int)(sum &gt;&gt; 32);
            }

            sum = ((long)a[len] &amp; 4294967295L) - ((long)b[len] &amp; 4294967295L) + (sum &gt;&gt; 32);
            a[len] = (int)sum;
        }
    }

    static int mulAdd(int[] out, int[] in, int offset, int len, int k) {
        implMulAddCheck(out, in, offset, len, k);
        return implMulAdd(out, in, offset, len, k);
    }

    private static void implMulAddCheck(int[] out, int[] in, int offset, int len, int k) {
        if (len &gt; in.length) {
            throw new IllegalArgumentException(&quot;input length is out of bound: &quot; + len + &quot; &gt; &quot; + in.length);
        } else if (offset &lt; 0) {
            throw new IllegalArgumentException(&quot;input offset is invalid: &quot; + offset);
        } else if (offset &gt; out.length - 1) {
            throw new IllegalArgumentException(&quot;input offset is out of bound: &quot; + offset + &quot; &gt; &quot; + (out.length - 1));
        } else if (len &gt; out.length - offset) {
            throw new IllegalArgumentException(&quot;input len is out of bound: &quot; + len + &quot; &gt; &quot; + (out.length - offset));
        }
    }

    @HotSpotIntrinsicCandidate
    private static int implMulAdd(int[] out, int[] in, int offset, int len, int k) {
        long kLong = (long)k &amp; 4294967295L;
        long carry = 0L;
        offset = out.length - offset - 1;

        for(int j = len - 1; j &gt;= 0; --j) {
            long product = ((long)in[j] &amp; 4294967295L) * kLong + ((long)out[offset] &amp; 4294967295L) + carry;
            out[offset--] = (int)product;
            carry = product &gt;&gt;&gt; 32;
        }

        return (int)carry;
    }

    static int addOne(int[] a, int offset, int mlen, int carry) {
        offset = a.length - 1 - mlen - offset;
        long t = ((long)a[offset] &amp; 4294967295L) + ((long)carry &amp; 4294967295L);
        a[offset] = (int)t;
        if (t &gt;&gt;&gt; 32 == 0L) {
            return 0;
        } else {
            do {
                --mlen;
                if (mlen &lt; 0) {
                    return 1;
                }

                --offset;
                if (offset &lt; 0) {
                    return 1;
                }

                int var10002 = a[offset]++;
            } while(a[offset] == 0);

            return 0;
        }
    }

    private BigInteger modPow2(BigInteger exponent, int p) {
        BigInteger result = ONE;
        BigInteger baseToPow2 = this.mod2(p);
        int expOffset = 0;
        int limit = exponent.bitLength();
        if (this.testBit(0)) {
            limit = p - 1 &lt; limit ? p - 1 : limit;
        }

        while(expOffset &lt; limit) {
            if (exponent.testBit(expOffset)) {
                result = result.multiply(baseToPow2).mod2(p);
            }

            ++expOffset;
            if (expOffset &lt; limit) {
                baseToPow2 = baseToPow2.square().mod2(p);
            }
        }

        return result;
    }

    private BigInteger mod2(int p) {
        if (this.bitLength() &lt;= p) {
            return this;
        } else {
            int numInts = p + 31 &gt;&gt;&gt; 5;
            int[] mag = new int[numInts];
            System.arraycopy(this.mag, this.mag.length - numInts, mag, 0, numInts);
            int excessBits = (numInts &lt;&lt; 5) - p;
            mag[0] = (int)((long)mag[0] &amp; (1L &lt;&lt; 32 - excessBits) - 1L);
            return mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1);
        }
    }

    public BigInteger modInverse(BigInteger m) {
        if (m.signum != 1) {
            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
        } else if (m.equals(ONE)) {
            return ZERO;
        } else {
            BigInteger modVal = this;
            if (this.signum &lt; 0 || this.compareMagnitude(m) &gt;= 0) {
                modVal = this.mod(m);
            }

            if (modVal.equals(ONE)) {
                return ONE;
            } else {
                MutableBigInteger a = new MutableBigInteger(modVal);
                MutableBigInteger b = new MutableBigInteger(m);
                MutableBigInteger result = a.mutableModInverse(b);
                return result.toBigInteger(1);
            }
        }
    }

    public BigInteger shiftLeft(int n) {
        if (this.signum == 0) {
            return ZERO;
        } else if (n &gt; 0) {
            return new BigInteger(shiftLeft(this.mag, n), this.signum);
        } else {
            return n == 0 ? this : this.shiftRightImpl(-n);
        }
    }

    private static int[] shiftLeft(int[] mag, int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int magLen = mag.length;
        int[] newMag = null;
        int[] newMag;
        if (nBits == 0) {
            newMag = new int[magLen + nInts];
            System.arraycopy(mag, 0, newMag, 0, magLen);
        } else {
            int i = 0;
            int nBits2 = 32 - nBits;
            int highBits = mag[0] &gt;&gt;&gt; nBits2;
            if (highBits != 0) {
                newMag = new int[magLen + nInts + 1];
                newMag[i++] = highBits;
            } else {
                newMag = new int[magLen + nInts];
            }

            int j;
            for(j = 0; j &lt; magLen - 1; newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2) {
            }

            newMag[i] = mag[j] &lt;&lt; nBits;
        }

        return newMag;
    }

    public BigInteger shiftRight(int n) {
        if (this.signum == 0) {
            return ZERO;
        } else if (n &gt; 0) {
            return this.shiftRightImpl(n);
        } else {
            return n == 0 ? this : new BigInteger(shiftLeft(this.mag, -n), this.signum);
        }
    }

    private BigInteger shiftRightImpl(int n) {
        int nInts = n &gt;&gt;&gt; 5;
        int nBits = n &amp; 31;
        int magLen = this.mag.length;
        int[] newMag = null;
        if (nInts &gt;= magLen) {
            return this.signum &gt;= 0 ? ZERO : negConst[1];
        } else {
            int newMagLen;
            int i;
            int nBits2;
            int[] newMag;
            if (nBits == 0) {
                newMagLen = magLen - nInts;
                newMag = Arrays.copyOf(this.mag, newMagLen);
            } else {
                newMagLen = 0;
                i = this.mag[0] &gt;&gt;&gt; nBits;
                if (i != 0) {
                    newMag = new int[magLen - nInts];
                    newMag[newMagLen++] = i;
                } else {
                    newMag = new int[magLen - nInts - 1];
                }

                nBits2 = 32 - nBits;

                for(int j = 0; j &lt; magLen - nInts - 1; newMag[newMagLen++] = this.mag[j++] &lt;&lt; nBits2 | this.mag[j] &gt;&gt;&gt; nBits) {
                }
            }

            if (this.signum &lt; 0) {
                boolean onesLost = false;
                i = magLen - 1;

                for(nBits2 = magLen - nInts; i &gt;= nBits2 &amp;&amp; !onesLost; --i) {
                    onesLost = this.mag[i] != 0;
                }

                if (!onesLost &amp;&amp; nBits != 0) {
                    onesLost = this.mag[magLen - nInts - 1] &lt;&lt; 32 - nBits != 0;
                }

                if (onesLost) {
                    newMag = this.javaIncrement(newMag);
                }
            }

            return new BigInteger(newMag, this.signum);
        }
    }

    int[] javaIncrement(int[] val) {
        int lastSum = 0;

        for(int i = val.length - 1; i &gt;= 0 &amp;&amp; lastSum == 0; --i) {
            lastSum = ++val[i];
        }

        if (lastSum == 0) {
            val = new int[val.length + 1];
            val[0] = 1;
        }

        return val;
    }

    public BigInteger and(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) &amp; val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger or(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) | val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger xor(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) ^ val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger not() {
        int[] result = new int[this.intLength()];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = ~this.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public BigInteger andNot(BigInteger val) {
        int[] result = new int[Math.max(this.intLength(), val.intLength())];

        for(int i = 0; i &lt; result.length; ++i) {
            result[i] = this.getInt(result.length - i - 1) &amp; ~val.getInt(result.length - i - 1);
        }

        return valueOf(result);
    }

    public boolean testBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            return (this.getInt(n &gt;&gt;&gt; 5) &amp; 1 &lt;&lt; (n &amp; 31)) != 0;
        }
    }

    public BigInteger setBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), intNum + 2)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] |= 1 &lt;&lt; (n &amp; 31);
            return valueOf(result);
        }
    }

    public BigInteger clearBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), (n + 1 &gt;&gt;&gt; 5) + 1)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] &amp;= ~(1 &lt;&lt; (n &amp; 31));
            return valueOf(result);
        }
    }

    public BigInteger flipBit(int n) {
        if (n &lt; 0) {
            throw new ArithmeticException(&quot;Negative bit address&quot;);
        } else {
            int intNum = n &gt;&gt;&gt; 5;
            int[] result = new int[Math.max(this.intLength(), intNum + 2)];

            for(int i = 0; i &lt; result.length; ++i) {
                result[result.length - i - 1] = this.getInt(i);
            }

            result[result.length - intNum - 1] ^= 1 &lt;&lt; (n &amp; 31);
            return valueOf(result);
        }
    }

    public int getLowestSetBit() {
        int lsb = this.lowestSetBitPlusTwo - 2;
        if (lsb == -2) {
            int lsb = 0;
            if (this.signum == 0) {
                lsb = lsb - 1;
            } else {
                int i;
                int b;
                for(i = 0; (b = this.getInt(i)) == 0; ++i) {
                }

                lsb = lsb + (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);
            }

            this.lowestSetBitPlusTwo = lsb + 2;
        }

        return lsb;
    }

    public int bitLength() {
        int n = this.bitLengthPlusOne - 1;
        if (n == -1) {
            int[] m = this.mag;
            int len = m.length;
            if (len == 0) {
                n = 0;
            } else {
                int magBitLength = (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);
                if (this.signum &gt;= 0) {
                    n = magBitLength;
                } else {
                    boolean pow2 = Integer.bitCount(this.mag[0]) == 1;

                    for(int i = 1; i &lt; len &amp;&amp; pow2; ++i) {
                        pow2 = this.mag[i] == 0;
                    }

                    n = pow2 ? magBitLength - 1 : magBitLength;
                }
            }

            this.bitLengthPlusOne = n + 1;
        }

        return n;
    }

    public int bitCount() {
        int bc = this.bitCountPlusOne - 1;
        if (bc == -1) {
            bc = 0;

            int magTrailingZeroCount;
            for(magTrailingZeroCount = 0; magTrailingZeroCount &lt; this.mag.length; ++magTrailingZeroCount) {
                bc += Integer.bitCount(this.mag[magTrailingZeroCount]);
            }

            if (this.signum &lt; 0) {
                magTrailingZeroCount = 0;

                int j;
                for(j = this.mag.length - 1; this.mag[j] == 0; --j) {
                    magTrailingZeroCount += 32;
                }

                magTrailingZeroCount += Integer.numberOfTrailingZeros(this.mag[j]);
                bc += magTrailingZeroCount - 1;
            }

            this.bitCountPlusOne = bc + 1;
        }

        return bc;
    }

    public boolean isProbablePrime(int certainty) {
        if (certainty &lt;= 0) {
            return true;
        } else {
            BigInteger w = this.abs();
            if (w.equals(TWO)) {
                return true;
            } else {
                return w.testBit(0) &amp;&amp; !w.equals(ONE) ? w.primeToCertainty(certainty, (Random)null) : false;
            }
        }
    }

    public int compareTo(BigInteger val) {
        if (this.signum == val.signum) {
            switch(this.signum) {
            case -1:
                return val.compareMagnitude(this);
            case 1:
                return this.compareMagnitude(val);
            default:
                return 0;
            }
        } else {
            return this.signum &gt; val.signum ? 1 : -1;
        }
    }

    final int compareMagnitude(BigInteger val) {
        int[] m1 = this.mag;
        int len1 = m1.length;
        int[] m2 = val.mag;
        int len2 = m2.length;
        if (len1 &lt; len2) {
            return -1;
        } else if (len1 &gt; len2) {
            return 1;
        } else {
            for(int i = 0; i &lt; len1; ++i) {
                int a = m1[i];
                int b = m2[i];
                if (a != b) {
                    return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                }
            }

            return 0;
        }
    }

    final int compareMagnitude(long val) {
        assert val != -9223372036854775808L;

        int[] m1 = this.mag;
        int len = m1.length;
        if (len &gt; 2) {
            return 1;
        } else {
            if (val &lt; 0L) {
                val = -val;
            }

            int highWord = (int)(val &gt;&gt;&gt; 32);
            int a;
            int b;
            if (highWord == 0) {
                if (len &lt; 1) {
                    return -1;
                } else if (len &gt; 1) {
                    return 1;
                } else {
                    a = m1[0];
                    b = (int)val;
                    if (a != b) {
                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
            } else if (len &lt; 2) {
                return -1;
            } else {
                a = m1[0];
                if (a != highWord) {
                    return ((long)a &amp; 4294967295L) &lt; ((long)highWord &amp; 4294967295L) ? -1 : 1;
                } else {
                    a = m1[1];
                    b = (int)val;
                    if (a != b) {
                        return ((long)a &amp; 4294967295L) &lt; ((long)b &amp; 4294967295L) ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
            }
        }
    }

    public boolean equals(Object x) {
        if (x == this) {
            return true;
        } else if (!(x instanceof BigInteger)) {
            return false;
        } else {
            BigInteger xInt = (BigInteger)x;
            if (xInt.signum != this.signum) {
                return false;
            } else {
                int[] m = this.mag;
                int len = m.length;
                int[] xm = xInt.mag;
                if (len != xm.length) {
                    return false;
                } else {
                    for(int i = 0; i &lt; len; ++i) {
                        if (xm[i] != m[i]) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        }
    }

    public BigInteger min(BigInteger val) {
        return this.compareTo(val) &lt; 0 ? this : val;
    }

    public BigInteger max(BigInteger val) {
        return this.compareTo(val) &gt; 0 ? this : val;
    }

    public int hashCode() {
        int hashCode = 0;

        for(int i = 0; i &lt; this.mag.length; ++i) {
            hashCode = (int)((long)(31 * hashCode) + ((long)this.mag[i] &amp; 4294967295L));
        }

        return hashCode * this.signum;
    }

    public String toString(int radix) {
        if (this.signum == 0) {
            return &quot;0&quot;;
        } else {
            if (radix &lt; 2 || radix &gt; 36) {
                radix = 10;
            }

            if (this.mag.length &lt;= 20) {
                return this.smallToString(radix);
            } else {
                StringBuilder sb = new StringBuilder();
                if (this.signum &lt; 0) {
                    toString(this.negate(), sb, radix, 0);
                    sb.insert(0, &#39;-&#39;);
                } else {
                    toString(this, sb, radix, 0);
                }

                return sb.toString();
            }
        }
    }

    private String smallToString(int radix) {
        if (this.signum == 0) {
            return &quot;0&quot;;
        } else {
            int maxNumDigitGroups = (4 * this.mag.length + 6) / 7;
            String[] digitGroup = new String[maxNumDigitGroups];
            BigInteger tmp = this.abs();

            int numGroups;
            BigInteger q2;
            for(numGroups = 0; tmp.signum != 0; tmp = q2) {
                BigInteger d = longRadix[radix];
                MutableBigInteger q = new MutableBigInteger();
                MutableBigInteger a = new MutableBigInteger(tmp.mag);
                MutableBigInteger b = new MutableBigInteger(d.mag);
                MutableBigInteger r = a.divide(b, q);
                q2 = q.toBigInteger(tmp.signum * d.signum);
                BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);
                digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);
            }

            StringBuilder buf = new StringBuilder(numGroups * digitsPerLong[radix] + 1);
            if (this.signum &lt; 0) {
                buf.append(&#39;-&#39;);
            }

            buf.append(digitGroup[numGroups - 1]);

            for(int i = numGroups - 2; i &gt;= 0; --i) {
                int numLeadingZeros = digitsPerLong[radix] - digitGroup[i].length();
                if (numLeadingZeros != 0) {
                    buf.append(zeros[numLeadingZeros]);
                }

                buf.append(digitGroup[i]);
            }

            return buf.toString();
        }
    }

    private static void toString(BigInteger u, StringBuilder sb, int radix, int digits) {
        int i;
        if (u.mag.length &gt; 20) {
            int b = u.bitLength();
            i = (int)Math.round(Math.log((double)b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0D);
            BigInteger v = getRadixConversionCache(radix, i);
            BigInteger[] results = u.divideAndRemainder(v);
            int expectedDigits = 1 &lt;&lt; i;
            toString(results[0], sb, radix, digits - expectedDigits);
            toString(results[1], sb, radix, expectedDigits);
        } else {
            String s = u.smallToString(radix);
            if (s.length() &lt; digits &amp;&amp; sb.length() &gt; 0) {
                for(i = s.length(); i &lt; digits; ++i) {
                    sb.append(&#39;0&#39;);
                }
            }

            sb.append(s);
        }
    }

    private static BigInteger getRadixConversionCache(int radix, int exponent) {
        BigInteger[] cacheLine = powerCache[radix];
        if (exponent &lt; cacheLine.length) {
            return cacheLine[exponent];
        } else {
            int oldLength = cacheLine.length;
            cacheLine = (BigInteger[])Arrays.copyOf(cacheLine, exponent + 1);

            for(int i = oldLength; i &lt;= exponent; ++i) {
                cacheLine[i] = cacheLine[i - 1].pow(2);
            }

            BigInteger[][] pc = powerCache;
            if (exponent &gt;= pc[radix].length) {
                pc = (BigInteger[][])pc.clone();
                pc[radix] = cacheLine;
                powerCache = pc;
            }

            return cacheLine[exponent];
        }
    }

    public String toString() {
        return this.toString(10);
    }

    public byte[] toByteArray() {
        int byteLen = this.bitLength() / 8 + 1;
        byte[] byteArray = new byte[byteLen];
        int i = byteLen - 1;
        int bytesCopied = 4;
        int nextInt = 0;

        for(int var6 = 0; i &gt;= 0; --i) {
            if (bytesCopied == 4) {
                nextInt = this.getInt(var6++);
                bytesCopied = 1;
            } else {
                nextInt &gt;&gt;&gt;= 8;
                ++bytesCopied;
            }

            byteArray[i] = (byte)nextInt;
        }

        return byteArray;
    }

    public int intValue() {
        int result = false;
        int result = this.getInt(0);
        return result;
    }

    public long longValue() {
        long result = 0L;

        for(int i = 1; i &gt;= 0; --i) {
            result = (result &lt;&lt; 32) + ((long)this.getInt(i) &amp; 4294967295L);
        }

        return result;
    }

    public float floatValue() {
        if (this.signum == 0) {
            return 0.0F;
        } else {
            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;
            if (exponent &lt; 63) {
                return (float)this.longValue();
            } else if (exponent &gt; 127) {
                return this.signum &gt; 0 ? 1.0F / 0.0 : -1.0F / 0.0;
            } else {
                int shift = exponent - 24;
                int nBits = shift &amp; 31;
                int nBits2 = 32 - nBits;
                int twiceSignifFloor;
                if (nBits == 0) {
                    twiceSignifFloor = this.mag[0];
                } else {
                    twiceSignifFloor = this.mag[0] &gt;&gt;&gt; nBits;
                    if (twiceSignifFloor == 0) {
                        twiceSignifFloor = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;
                    }
                }

                int signifFloor = twiceSignifFloor &gt;&gt; 1;
                signifFloor &amp;= 8388607;
                boolean increment = (twiceSignifFloor &amp; 1) != 0 &amp;&amp; ((signifFloor &amp; 1) != 0 || this.abs().getLowestSetBit() &lt; shift);
                int signifRounded = increment ? signifFloor + 1 : signifFloor;
                int bits = exponent + 127 &lt;&lt; 23;
                bits += signifRounded;
                bits |= this.signum &amp; -2147483648;
                return Float.intBitsToFloat(bits);
            }
        }
    }

    public double doubleValue() {
        if (this.signum == 0) {
            return 0.0D;
        } else {
            int exponent = (this.mag.length - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]) - 1;
            if (exponent &lt; 63) {
                return (double)this.longValue();
            } else if (exponent &gt; 1023) {
                return this.signum &gt; 0 ? 1.0D / 0.0 : -1.0D / 0.0;
            } else {
                int shift = exponent - 53;
                int nBits = shift &amp; 31;
                int nBits2 = 32 - nBits;
                int highBits;
                int lowBits;
                if (nBits == 0) {
                    highBits = this.mag[0];
                    lowBits = this.mag[1];
                } else {
                    highBits = this.mag[0] &gt;&gt;&gt; nBits;
                    lowBits = this.mag[0] &lt;&lt; nBits2 | this.mag[1] &gt;&gt;&gt; nBits;
                    if (highBits == 0) {
                        highBits = lowBits;
                        lowBits = this.mag[1] &lt;&lt; nBits2 | this.mag[2] &gt;&gt;&gt; nBits;
                    }
                }

                long twiceSignifFloor = ((long)highBits &amp; 4294967295L) &lt;&lt; 32 | (long)lowBits &amp; 4294967295L;
                long signifFloor = twiceSignifFloor &gt;&gt; 1;
                signifFloor &amp;= 4503599627370495L;
                boolean increment = (twiceSignifFloor &amp; 1L) != 0L &amp;&amp; ((signifFloor &amp; 1L) != 0L || this.abs().getLowestSetBit() &lt; shift);
                long signifRounded = increment ? signifFloor + 1L : signifFloor;
                long bits = (long)(exponent + 1023) &lt;&lt; 52;
                bits += signifRounded;
                bits |= (long)this.signum &amp; -9223372036854775808L;
                return Double.longBitsToDouble(bits);
            }
        }
    }

    private static int[] stripLeadingZeroInts(int[] val) {
        int vlen = val.length;

        int keep;
        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) {
        }

        return Arrays.copyOfRange(val, keep, vlen);
    }

    private static int[] trustedStripLeadingZeroInts(int[] val) {
        int vlen = val.length;

        int keep;
        for(keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; ++keep) {
        }

        return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen);
    }

    private static int[] stripLeadingZeroBytes(byte[] a, int off, int len) {
        int indexBound = off + len;

        int keep;
        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == 0; ++keep) {
        }

        int intLength = indexBound - keep + 3 &gt;&gt;&gt; 2;
        int[] result = new int[intLength];
        int b = indexBound - 1;

        for(int i = intLength - 1; i &gt;= 0; --i) {
            result[i] = a[b--] &amp; 255;
            int bytesRemaining = b - keep + 1;
            int bytesToTransfer = Math.min(3, bytesRemaining);

            for(int j = 8; j &lt;= bytesToTransfer &lt;&lt; 3; j += 8) {
                result[i] |= (a[b--] &amp; 255) &lt;&lt; j;
            }
        }

        return result;
    }

    private static int[] makePositive(byte[] a, int off, int len) {
        int indexBound = off + len;

        int keep;
        for(keep = off; keep &lt; indexBound &amp;&amp; a[keep] == -1; ++keep) {
        }

        int k;
        for(k = keep; k &lt; indexBound &amp;&amp; a[k] == 0; ++k) {
        }

        int extraByte = k == indexBound ? 1 : 0;
        int intLength = indexBound - keep + extraByte + 3 &gt;&gt;&gt; 2;
        int[] result = new int[intLength];
        int b = indexBound - 1;

        int i;
        for(i = intLength - 1; i &gt;= 0; --i) {
            result[i] = a[b--] &amp; 255;
            int numBytesToTransfer = Math.min(3, b - keep + 1);
            if (numBytesToTransfer &lt; 0) {
                numBytesToTransfer = 0;
            }

            int mask;
            for(mask = 8; mask &lt;= 8 * numBytesToTransfer; mask += 8) {
                result[i] |= (a[b--] &amp; 255) &lt;&lt; mask;
            }

            mask = -1 &gt;&gt;&gt; 8 * (3 - numBytesToTransfer);
            result[i] = ~result[i] &amp; mask;
        }

        for(i = result.length - 1; i &gt;= 0; --i) {
            result[i] = (int)(((long)result[i] &amp; 4294967295L) + 1L);
            if (result[i] != 0) {
                break;
            }
        }

        return result;
    }

    private static int[] makePositive(int[] a) {
        int keep;
        for(keep = 0; keep &lt; a.length &amp;&amp; a[keep] == -1; ++keep) {
        }

        int j;
        for(j = keep; j &lt; a.length &amp;&amp; a[j] == 0; ++j) {
        }

        int extraInt = j == a.length ? 1 : 0;
        int[] result = new int[a.length - keep + extraInt];

        int i;
        for(i = keep; i &lt; a.length; ++i) {
            result[i - keep + extraInt] = ~a[i];
        }

        for(i = result.length - 1; ++result[i] == 0; --i) {
        }

        return result;
    }

    private int intLength() {
        return (this.bitLength() &gt;&gt;&gt; 5) + 1;
    }

    private int signBit() {
        return this.signum &lt; 0 ? 1 : 0;
    }

    private int signInt() {
        return this.signum &lt; 0 ? -1 : 0;
    }

    private int getInt(int n) {
        if (n &lt; 0) {
            return 0;
        } else if (n &gt;= this.mag.length) {
            return this.signInt();
        } else {
            int magInt = this.mag[this.mag.length - n - 1];
            return this.signum &gt;= 0 ? magInt : (n &lt;= this.firstNonzeroIntNum() ? -magInt : ~magInt);
        }
    }

    private int firstNonzeroIntNum() {
        int fn = this.firstNonzeroIntNumPlusTwo - 2;
        if (fn == -2) {
            int mlen = this.mag.length;

            int i;
            for(i = mlen - 1; i &gt;= 0 &amp;&amp; this.mag[i] == 0; --i) {
            }

            fn = mlen - i - 1;
            this.firstNonzeroIntNumPlusTwo = fn + 2;
        }

        return fn;
    }

    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
        GetField fields = s.readFields();
        int sign = fields.get(&quot;signum&quot;, -2);
        byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, (Object)null);
        if (sign &gt;= -1 &amp;&amp; sign &lt;= 1) {
            int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
            if (mag.length == 0 != (sign == 0)) {
                String message = &quot;BigInteger: signum-magnitude mismatch&quot;;
                if (fields.defaulted(&quot;magnitude&quot;)) {
                    message = &quot;BigInteger: Magnitude not present in stream&quot;;
                }

                throw new StreamCorruptedException(message);
            } else {
                BigInteger.UnsafeHolder.putSign(this, sign);
                BigInteger.UnsafeHolder.putMag(this, mag);
                if (mag.length &gt;= 67108864) {
                    try {
                        this.checkRange();
                    } catch (ArithmeticException var7) {
                        throw new StreamCorruptedException(&quot;BigInteger: Out of the supported range&quot;);
                    }
                }

            }
        } else {
            String message = &quot;BigInteger: Invalid signum value&quot;;
            if (fields.defaulted(&quot;signum&quot;)) {
                message = &quot;BigInteger: Signum not present in stream&quot;;
            }

            throw new StreamCorruptedException(message);
        }
    }

    private void writeObject(ObjectOutputStream s) throws IOException {
        PutField fields = s.putFields();
        fields.put(&quot;signum&quot;, this.signum);
        fields.put(&quot;magnitude&quot;, this.magSerializedForm());
        fields.put(&quot;bitCount&quot;, -1);
        fields.put(&quot;bitLength&quot;, -1);
        fields.put(&quot;lowestSetBit&quot;, -2);
        fields.put(&quot;firstNonzeroByteNum&quot;, -2);
        s.writeFields();
    }

    private byte[] magSerializedForm() {
        int len = this.mag.length;
        int bitLen = len == 0 ? 0 : (len - 1 &lt;&lt; 5) + bitLengthForInt(this.mag[0]);
        int byteLen = bitLen + 7 &gt;&gt;&gt; 3;
        byte[] result = new byte[byteLen];
        int i = byteLen - 1;
        int bytesCopied = 4;
        int intIndex = len - 1;

        for(int nextInt = 0; i &gt;= 0; --i) {
            if (bytesCopied == 4) {
                nextInt = this.mag[intIndex--];
                bytesCopied = 1;
            } else {
                nextInt &gt;&gt;&gt;= 8;
                ++bytesCopied;
            }

            result[i] = (byte)nextInt;
        }

        return result;
    }

    public long longValueExact() {
        if (this.mag.length &lt;= 2 &amp;&amp; this.bitLength() &lt;= 63) {
            return this.longValue();
        } else {
            throw new ArithmeticException(&quot;BigInteger out of long range&quot;);
        }
    }

    public int intValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            return this.intValue();
        } else {
            throw new ArithmeticException(&quot;BigInteger out of int range&quot;);
        }
    }

    public short shortValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            int value = this.intValue();
            if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) {
                return this.shortValue();
            }
        }

        throw new ArithmeticException(&quot;BigInteger out of short range&quot;);
    }

    public byte byteValueExact() {
        if (this.mag.length &lt;= 1 &amp;&amp; this.bitLength() &lt;= 31) {
            int value = this.intValue();
            if (value &gt;= -128 &amp;&amp; value &lt;= 127) {
                return this.byteValue();
            }
        }

        throw new ArithmeticException(&quot;BigInteger out of byte range&quot;);
    }

    static {
        int i;
        for(i = 1; i &lt;= 16; ++i) {
            int[] magnitude = new int[]{i};
            posConst[i] = new BigInteger(magnitude, 1);
            negConst[i] = new BigInteger(magnitude, -1);
        }

        powerCache = new BigInteger[37][];
        logCache = new double[37];

        for(i = 2; i &lt;= 36; ++i) {
            powerCache[i] = new BigInteger[]{valueOf((long)i)};
            logCache[i] = Math.log((double)i);
        }

        ZERO = new BigInteger(new int[0], 0);
        ONE = valueOf(1L);
        TWO = valueOf(2L);
        NEGATIVE_ONE = valueOf(-1L);
        TEN = valueOf(10L);
        bnExpModThreshTable = new int[]{7, 25, 81, 241, 673, 1793, 2147483647};
        zeros = new String[64];
        zeros[63] = &quot;000000000000000000000000000000000000000000000000000000000000000&quot;;

        for(i = 0; i &lt; 63; ++i) {
            zeros[i] = zeros[63].substring(0, i);
        }

        digitsPerLong = new int[]{0, 0, 62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};
        longRadix = new BigInteger[]{null, null, valueOf(4611686018427387904L), valueOf(4052555153018976267L), valueOf(4611686018427387904L), valueOf(7450580596923828125L), valueOf(4738381338321616896L), valueOf(3909821048582988049L), valueOf(1152921504606846976L), valueOf(1350851717672992089L), valueOf(1000000000000000000L), valueOf(5559917313492231481L), valueOf(2218611106740436992L), valueOf(8650415919381337933L), valueOf(2177953337809371136L), valueOf(6568408355712890625L), valueOf(1152921504606846976L), valueOf(2862423051509815793L), valueOf(6746640616477458432L), valueOf(799006685782884121L), valueOf(1638400000000000000L), valueOf(3243919932521508681L), valueOf(6221821273427820544L), valueOf(504036361936467383L), valueOf(876488338465357824L), valueOf(1490116119384765625L), valueOf(2481152873203736576L), valueOf(4052555153018976267L), valueOf(6502111422497947648L), valueOf(353814783205469041L), valueOf(531441000000000000L), valueOf(787662783788549761L), valueOf(1152921504606846976L), valueOf(1667889514952984961L), valueOf(2386420683693101056L), valueOf(3379220508056640625L), valueOf(4738381338321616896L)};
        digitsPerInt = new int[]{0, 0, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};
        intRadix = new int[]{0, 0, 1073741824, 1162261467, 1073741824, 1220703125, 362797056, 1977326743, 1073741824, 387420489, 1000000000, 214358881, 429981696, 815730721, 1475789056, 170859375, 268435456, 410338673, 612220032, 893871739, 1280000000, 1801088541, 113379904, 148035889, 191102976, 244140625, 308915776, 387420489, 481890304, 594823321, 729000000, 887503681, 1073741824, 1291467969, 1544804416, 1838265625, 60466176};
        serialPersistentFields = new ObjectStreamField[]{new ObjectStreamField(&quot;signum&quot;, Integer.TYPE), new ObjectStreamField(&quot;magnitude&quot;, byte[].class), new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE), new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE), new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE), new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)};
    }

    private static class UnsafeHolder {
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        private static final long signumOffset;
        private static final long magOffset;

        private UnsafeHolder() {
        }

        static void putSign(BigInteger bi, int sign) {
            unsafe.putInt(bi, signumOffset, sign);
        }

        static void putMag(BigInteger bi, int[] magnitude) {
            unsafe.putObject(bi, magOffset, magnitude);
        }

        static {
            signumOffset = unsafe.objectFieldOffset(BigInteger.class, &quot;signum&quot;);
            magOffset = unsafe.objectFieldOffset(BigInteger.class, &quot;mag&quot;);
        }
    }
}
</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-21T09:14:08.000Z">2019-09-21</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 377 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/21/客户端面试/">客户端面试</a>
            
        </h1>
        <div class="content">
            <ul>
<li>100级台阶，每次上一步或两步，有多少种走法。</li>
</ul>
<p>573147844013817084101<br>21</p>
<ul>
<li>如果200级，你估计有多少种走法（不用编程）。</li>
</ul>
<p>453973694165307953197296969697410619233826<br>42</p>
<blockquote>
<p>不用编程，估算</p>
</blockquote>
<pre><code class="java">import java.math.BigInteger;
public class Main {

    public static void main(String[] args) {
        int n = 200;
        BigInteger a = BigInteger.ONE;
        BigInteger b = BigInteger.ONE;
        BigInteger res = BigInteger.ZERO;
        for (int i = 2; i &lt;= n; i++) {
            res = a.add(b);
            a = b;
            b = res;
        }
        System.out.println(res);
        System.out.println(res.toString().length());

    }
}
</code></pre>
<ul>
<li><p>给出一个数组，找出两个数[a,b]和为n，不存在则返回[-1,-1]。写出两种解法，不能暴力穷举。</p>
</li>
<li><p>讲讲面向过程、面向对象、面向切面。</p>
</li>
<li><p>指针和数组的关系和区别。</p>
</li>
<li><p>讲讲Android handler。</p>
</li>
<li><p>队列和栈的区别和用途。</p>
</li>
<li><p>两个栈实现队列。</p>
</li>
<li><p>输入Url到浏览器显示过程。</p>
</li>
<li><p>http请求方法。</p>
</li>
<li><p>get和post区别。</p>
</li>
<li><p>surficeView和view的区别。</p>
</li>
<li><p>app从点击图标开始的启动全过程。</p>
</li>
<li><p>什么是线程安全。</p>
</li>
<li><p>线程安全有哪些机制。</p>
</li>
<li><p>如何保证 int加加（加号打不出来）线程安全。</p>
</li>
<li><p>Android线程间通信有哪些机制。</p>
</li>
<li><p>cpu调度方式有哪些。</p>
</li>
<li><p>空间局部性和时间局部性。</p>
</li>
<li><p>数据库乐观锁和悲观锁。</p>
</li>
<li><p>数据库索引作用，优缺点。</p>
</li>
<li><p>TCP拥塞控制。</p>
</li>
<li><p>https加密传输过程。</p>
</li>
<li><p>java内存模型。</p>
</li>
<li><p>java垃圾回收算法有哪些。</p>
</li>
<li><p>讲讲标记清除算法。</p>
</li>
<li><p>java四中引用。</p>
</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-20T02:24:00.000Z">2019-09-20</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 7225 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/20/Java知识点/">Java知识点</a>
            
        </h1>
        <div class="content">
            <h1 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h1><h2 id="请问JDK和JRE的区别是什么？"><a href="#请问JDK和JRE的区别是什么？" class="headerlink" title="请问JDK和JRE的区别是什么？"></a>请问JDK和JRE的区别是什么？</h2><blockquote>
<p>JDK ：Java 开发工具包,jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。<br>JRE ：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。</p>
</blockquote>
<h2 id="springboot的注解有什么，原理？"><a href="#springboot的注解有什么，原理？" class="headerlink" title="springboot的注解有什么，原理？"></a>springboot的注解有什么，原理？</h2><p>@Bean<br>用来代替 XML 配置文件里面的 &lt;bean …&gt; 配置。<br>@ImportResource<br>如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 @Configuration 方式配置的非常管用。<br>@Import<br>用来引入额外的一个或者多个 @Configuration 修饰的配置文件类。<br>@SpringBootConfiguration<br>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。<br>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。<br>@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。<br>@EnableAutoConfiguration 自动配置。<br>@ComponentScan 组件扫描，可自动发现和装配一些Bean。<br>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。<br>@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。<br>@Autowired自动导入。<br>@PathVariable获取参数。<br>@JsonBackReference解决嵌套外链问题。<br>@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。</p>
<p>@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。<br>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
<p>@RequestParam：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p>
<p>@PathVariable:路径变量。如</p>
<pre><code class="java">@RequestMapping(“user/get/mac/{macAddress}”) 
public String getByMacAddress(@PathVariable String macAddress){ 
//do something; 
} </code></pre>
<p>Spring Boot的自动配置看起来神奇，其实原理非常简单，背后全依赖于@Conditional注解来实现的。</p>
<h2 id="object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的，-为什么有hash（）方法还有hashCode（）"><a href="#object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的，-为什么有hash（）方法还有hashCode（）" class="headerlink" title="object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）"></a>object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）</h2><p>哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:</p>
<pre><code class="java">public native int hashCode();</code></pre>
<p>根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p>
<p><strong>hashCode方法的作用</strong></p>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>
<p>　　为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）</p>
<p>　　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p>
<p><strong>hash 算法</strong></p>
<pre><code class="java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}</code></pre>
<p>首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。</p>
<p>如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。</p>
<p>但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。</p>
<p>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。</p>
<h2 id="hashmap的put过程-主要就是根据自己看过的源码说一下流程"><a href="#hashmap的put过程-主要就是根据自己看过的源码说一下流程" class="headerlink" title="hashmap的put过程 主要就是根据自己看过的源码说一下流程"></a>hashmap的put过程 主要就是根据自己看过的源码说一下流程</h2><p><strong>put 方法</strong><br>通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。</p>
<pre><code class="java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre>
<ol>
<li>判断数组是否为空，如果是空，则创建默认长度位 16 的数组。</li>
<li>通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。</li>
<li>如果有元素，说明 hash 冲突了，则再次进行 3 种判断。<ol>
<li>判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。</li>
<li>如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。</li>
<li>如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。</li>
</ol>
</li>
<li>最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。</li>
<li>对维护着迭代器的modCount 变量加一。</li>
<li>最后判断，如果当前数组的长度已经大于阀值了。则重新hash。</li>
</ol>
<h2 id="ArrayList-LinkList的特点"><a href="#ArrayList-LinkList的特点" class="headerlink" title="ArrayList LinkList的特点"></a>ArrayList LinkList的特点</h2><p>ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。</p>
<p>数据的更新和查找<br>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p>
<p>数据的增加和删除<br>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p>
<h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。</p>
<p>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。</p>
<p>由于 TreeMap 就是由红黑树实现的。</p>
<p>黑色高度<br>从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。</p>
<ol>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点永远是黑色的；</li>
<li>所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；</li>
<li>每个红色节点的两个子节点一定都是黑色；</li>
<li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li>
</ol>
<h2 id="Java-反射机制"><a href="#Java-反射机制" class="headerlink" title="Java 反射机制"></a>Java 反射机制</h2><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 java 的反射机制。</p>
<pre><code class="java">public class FatherClass {
    public String mFatherName;
    public int mFatherAge;

    public void printFatherMsg(){}
}</code></pre>
<h1 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。</p>
<p>锁机制有如下两种特性：</p>
<ul>
<li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p>
</li>
<li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
</li>
</ul>
<p>synchronized 可以修饰方法和代码块</p>
<ul>
<li>synchronized(this|object) {}</li>
<li>synchronized(类.class) {}</li>
<li>修饰非静态方法</li>
<li>修饰静态方法</li>
</ul>
<h2 id="reentrantLock-除了可重入还有什么关键特性"><a href="#reentrantLock-除了可重入还有什么关键特性" class="headerlink" title="reentrantLock 除了可重入还有什么关键特性"></a>reentrantLock 除了可重入还有什么关键特性</h2><ul>
<li>可重入</li>
</ul>
<p>现在有方法 m1 和 m2，两个方法均使用了同一把锁对方法进行同步控制，同时方法 m1 会调用 m2。线程 t 进入方法 m1 成功获得了锁，此时线程 t 要在没有释放锁的情况下，调用 m2 方法。由于 m1 和 m2 使用的是同一把可重入锁，所以线程 t 可以进入方法 m2，并再次获得锁，而不会被阻塞住。</p>
<ul>
<li>公平和非公平锁</li>
</ul>
<p>公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法ReentrantLock(boolean fair)调整加锁的模式。</p>
<h2 id="ThreadLocal-会造成什么问题-为什么会造成内存泄漏"><a href="#ThreadLocal-会造成什么问题-为什么会造成内存泄漏" class="headerlink" title="ThreadLocal 会造成什么问题? 为什么会造成内存泄漏?"></a>ThreadLocal 会造成什么问题? 为什么会造成内存泄漏?</h2><ul>
<li>ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型。 总结：ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。 </li>
<li>ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。</li>
</ul>
<p>ThreadLocal类提供了四个对外开放的接口方法</p>
<p>(1) void set(Object value)设置当前线程的线程局部变量的值。<br>(2) public Object get()该方法返回当前线程所对应的线程局部变量。<br>(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用。<br>(4) protected Object initialValue()返回该线程局部变量的初始值。</p>
<p>在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。</p>
<p>最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。<strong>比如使用线程池的时候，线程结束是不会销毁的，会再次使用的就可能出现内存泄露。</strong>（在web应用中，每次http请求都是一个线程，tomcat容器配置使用线程池时会出现内存泄漏问题）</p>
<ol>
<li>使用ThreadLocal，建议用static修饰 static ThreadLocal<httpheader> headerLocal = new ThreadLocal();</httpheader></li>
<li>使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</li>
</ol>
<h2 id="单例模式-synchronized实现懒汉模式？为什么用内部类是线程安全的？"><a href="#单例模式-synchronized实现懒汉模式？为什么用内部类是线程安全的？" class="headerlink" title="单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？"></a>单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？</h2><p>内部类</p>
<p>单例模式，有“懒汉式”和“饿汉式”两种。<br><strong>懒汉式</strong><br>单例类的实例在第一次被引用时候才被初始化。<br><strong>饿汉式</strong><br>单例类的实例在加载的时候就被初始化。</p>
<p><strong>静态内部类模式</strong></p>
<pre><code class="java">public class Singleton { 
    private Singleton(){
    }
      public static Singleton getSingleton(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} </code></pre>
<ol>
<li>实现代码简洁。和双重检查单例对比，静态内部类单例实现代码真的是太简洁，又清晰明了。</li>
<li>延迟初始化。调用getSingleton才初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。</li>
</ol>
<p>线程A和线程B同时试图获得Singleton对象的初始化锁，假设线程A获取到了，那么线程B一直等待初始化锁。线程A执行类初始化，就算双重检查模式中伪代码发生了重排序，也不会影响线程A的初始化结果。初始化完后，释放锁。线程B获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。</p>
<h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="添加索引的时候要注意什么"><a href="#添加索引的时候要注意什么" class="headerlink" title="添加索引的时候要注意什么"></a>添加索引的时候要注意什么</h2><p>索引可以提高数据的访问速度，但同时也增加了插入、更新和删除操作的处理时间。所以是否要为表增加索引、索引建立在那些字段上，是创建索引前必须要考虑的问题。解决此问题就是分析应用程序的业务处理、数据使用，为经常被用作查询条件、或者被要求排序的字段建立索引。</p>
<p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在<code>Where</code>子句中的<strong>字段</strong>，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；</p>
<p><strong>聚簇索引:</strong><br>通常由主键或者非空唯一索引实现的，叶子节点存储了一整行数据<br><strong>非聚簇索引：</strong><br>又称二级索引，就是我们常用的普通索引，叶子节点存了索引值和主键值，在根据主键从聚簇索引查</p>
<h2 id="索引优化以及在使用索引的时候要注意什么"><a href="#索引优化以及在使用索引的时候要注意什么" class="headerlink" title="索引优化以及在使用索引的时候要注意什么"></a>索引优化以及在使用索引的时候要注意什么</h2><p>1.索引列不要使用函数和运算</p>
<ol start="2">
<li>尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</li>
<li>当查询条件为多个的时候，可以采用复合索引</li>
<li>范围查询对多列查询的影响</li>
<li>遵循最左匹配原则<br> 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>索引列不会包含NULL值</li>
<li>尽量避免使用 or 来连接条件</li>
<li>隐式转换的影响</li>
<li>like 语句的索引失效问题</li>
</ol>
<h2 id="redis的键的淘汰策略，会达成了redis缓存的淘汰策略"><a href="#redis的键的淘汰策略，会达成了redis缓存的淘汰策略" class="headerlink" title="redis的键的淘汰策略，会达成了redis缓存的淘汰策略"></a>redis的键的淘汰策略，会达成了redis缓存的淘汰策略</h2><p>Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。<br>事实上，实例中的内存除了保存原始的键值对所需的开销外，还有一些运行时产生的额外内存，包括：</p>
<ol>
<li>垃圾数据和过期Key所占空间</li>
<li>字典渐进式Rehash导致未及时删除的空间</li>
<li>Redis管理数据，包括底层数据结构开销，客户端信息，读写缓冲区等</li>
<li>主从复制，bgsave时的额外开销</li>
</ol>
<p>为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。</p>
<ul>
<li>访问Key时，会判断Key是否过期，逐出过期Key;</li>
<li>CPU空闲时在定期serverCron任务中，逐出部分过期Key;</li>
<li>每次事件循环执行的时候，逐出部分过期Key;</li>
</ul>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="tcp四次握手，最后的状态是什么"><a href="#tcp四次握手，最后的状态是什么" class="headerlink" title="tcp四次握手，最后的状态是什么?"></a>tcp四次握手，最后的状态是什么?</h2><p>等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2）</p>
<h2 id="为什么要等着2MSL，等待多了会造成什么"><a href="#为什么要等着2MSL，等待多了会造成什么" class="headerlink" title="为什么要等着2MSL，等待多了会造成什么"></a>为什么要等着2MSL，等待多了会造成什么</h2><ol>
<li>保证A发送的最后一个ACK报文段能够到达B。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="http请求的报文结构，keep-alive是用来做什么的"><a href="#http请求的报文结构，keep-alive是用来做什么的" class="headerlink" title="http请求的报文结构，keep-alive是用来做什么的"></a>http请求的报文结构，keep-alive是用来做什么的</h2><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<pre><code class="shell">Keep-Alive: timeout=5, max=100
timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接</code></pre>
<h1 id="spring-spingboot"><a href="#spring-spingboot" class="headerlink" title="spring spingboot"></a>spring spingboot</h1><h2 id="spring为什么要注入接口，而不是实现类"><a href="#spring为什么要注入接口，而不是实现类" class="headerlink" title="spring为什么要注入接口，而不是实现类"></a>spring为什么要注入接口，而不是实现类</h2><p>首先说明，注入的对象确实为实现类的对象。（并不是实现类的代理对象，注入并不涉及代理）</p>
<p>　　如果只是单纯注入是可以用实现类接收注入对象的，但是往往开发中会对实现类做增强，如事务，日志等，实现增强的AOP技术是通过动态代理实现的，而spring默认是JDK动态代理，对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。</p>
<p>回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程</p>
<p>Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果目标对象没有实现接口我们该如何代理呢？这时候我们就需要使用CGLIB来实现AOP了。</p>
<p>假如我们要使用动态代理实现AOP，那么我们只能在写一个增强的接口，然后让目标类实现增强接口，然后我们就可以使用动态代理实现目标类的增强，可是假如我们不想让目标类实现其他的接口，那么我们就只能使用CGLIB技术来实现目标类的增强了。<br>CGLIB实现目标类增强的原理是这样的：CGLIB会动态创建一个目标类的子类，然后返回该子类的对象，也就是增强对象，至于增强的逻辑则是在子类中完成的。我们知道子类要么和父类有一样的功能，要么就比父类功能强大，所以CGLIB是通过创建目标类的子类对象来实现增强的，所以：</p>
<pre><code class="shell">目标子类 = 目标类 + 增强逻辑</code></pre>
<h1 id="口述算法思路"><a href="#口述算法思路" class="headerlink" title="口述算法思路"></a>口述算法思路</h1><h2 id="给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）"><a href="#给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）" class="headerlink" title="给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）"></a>给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）</h2><p>最小值思路：用一个辅助栈stack2记住每次入栈stack1的当前最小值:在stack1入栈时，往stack2中加入当前最小值；stack1元素出栈时，stack2也出栈一个元素。最小值从stack2中获取及栈顶元素。O(1)</p>
<p>最大值思路：同上O(1)</p>
<p><img src="/images/2019/09/20/e4dc2930-db6e-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="哪几种IO类型"><a href="#哪几种IO类型" class="headerlink" title="哪几种IO类型"></a>哪几种IO类型</h2><ul>
<li>阻塞I/O（blocking IO）</li>
<li>非阻塞I/O (nonblocking I/O)</li>
<li>I/O 复用 (I/O multiplexing)</li>
<li>信号驱动I/O (signal driven I/O (SIGIO))</li>
<li>异步I/O (asynchronous I/O)</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><ul>
<li>堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。</li>
<li>方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。</li>
<li>方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。</li>
<li>本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</li>
<li>程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。</li>
</ul>
<p><img src="/images/2019/09/20/801edd70-db6f-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*<br>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。</p>
<p><img src="/images/2019/09/20/96bb2250-db6f-11e9-a4dc-99db33a3ba56.png" alt="image.png"></p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。</p>
<p>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。</p>
<h1 id="有什么想问我的"><a href="#有什么想问我的" class="headerlink" title="有什么想问我的"></a>有什么想问我的</h1><p>有的</p>
<ol>
<li>你怎样形容小米公司的企业文化？</li>
<li>什么类型的员工能在小米公司有比较好的发展？</li>
<li>关于软件开发工程师-Java方向岗位的技术栈、日常主要工作是什么、期间可以获得晋升机会？</li>
<li>能给我多讲讲招聘程序吗？</li>
<li>我没有其他问题了，与您交流非常愉快，能留一张您的名片么？（或者方便加一下您的微信么？）</li>
</ol>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-18T15:44:09.000Z">2019-09-18</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 789 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/18/面试笔记/">面试笔记</a>
            
        </h1>
        <div class="content">
            <p>牛客许愿的小米一面，贡献面经<del>~<br>许愿能挺进二面，加油，向着目标冲呀</del></p>
<p>——java集合相关</p>
<p>object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）</p>
<p>hashmap的put过程 主要就是根据自己看过的源码说一下流程<br>ArrayList LinkList的特点</p>
<p>——多线程相关</p>
<p>synchronized</p>
<p>reettrantLock 除了可重入还有什么关键特性</p>
<p>threadLocal threadLocal 会造成什么问题 为什么会造成内存泄漏</p>
<p>单例模式 synchronized实现懒汉模式 答 内部类 为什么用内部类是线程安全的？</p>
<p>——数据库相关</p>
<p>添加索引的时候要注意什么</p>
<p>索引优化以及在使用索引的时候要注意什么</p>
<p>redis的键的淘汰策略，会达成了redis缓存的淘汰策略</p>
<p>——网络相关</p>
<p>tcp四次握手，最后的状态是什么，回答等待2MSL</p>
<p>为什么要等着2MSL，等待多了会造成什么</p>
<p>http请求的报文结构，keep-alive是用来做什么的</p>
<p>——spring spingboot</p>
<p>spring中对象增强如何实现 回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程</p>
<p>——口述算法思路</p>
<p>给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）</p>
<p>之前一直没明白是要做什么，后来想到做过类似的题。幸好只是说思路，没有要手写，那个时候已经被前面几个回答的不太好的问题难的很紧张，说做个简单的算法题的时候，我的心紧紧一颤，心想，你确定会简单，还好，还好，结果下来没那么难</p>
<p>——网络编程</p>
<p>哪几种IO类型</p>
<p>还有一个问题 有点忘了，这一块在简历上写了，不过掌握的不是很好</p>
<p>——JVM</p>
<p>类加载机制——回答了一下双亲委派模型相关的内容</p>
<p>——有什么想问我的</p>
<p>面试官蛮年轻，真的很好，一直在引导我回答问题，不会的也没有揪着不放很喜欢说，我们接下来问一个简单的问题，哈哈哈，简单简单着就变得不简单了</p>
<p>是自己比较满意的一次面试</p>
<p>既展示了自己所掌握的知识，也暴露了掌握知识中的问题，给自己后面的复习有了一定的指引</p>
<p>感谢CYC大佬的秘籍<del>~</del></p>
<p>最后，重要的话再来几次</p>
<p>许愿能挺进二面，加油，向着目标冲呀<del>~<br>许愿能挺进二面，加油，向着目标冲呀</del><br>许愿能挺进二面，加油，向着目标冲呀<del>~</del></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-16T14:20:54.000Z">2019-09-16</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分钟 读完 (大约 2443 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/16/Java12的新特性/">Java12的新特性</a>
            
        </h1>
        <div class="content">
            <h1 id="Java12的新特性"><a href="#Java12的新特性" class="headerlink" title="Java12的新特性"></a>Java12的新特性</h1><blockquote>
<p>Java5的新特性<br>Java6的新特性<br>Java7的新特性<br>Java8的新特性<br>Java9的新特性<br>Java10的新特性<br>Java11的新特性<br>Java12的新特性<br>Java13的新特性</p>
</blockquote>
<p><img src="/images/2019/09/16/1c09f100-d88e-11e9-a339-273a38bbb2c9.png" alt="image.png"></p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><pre><code>java -version
openjdk version &quot;12&quot; 2019-03-19
OpenJDK Runtime Environment (build 12+33)
OpenJDK 64-Bit Server VM (build 12+33, mixed mode)</code></pre><blockquote>
<p>从version信息可以看出是build 12+33</p>
</blockquote>
<h2 id="特性列表"><a href="#特性列表" class="headerlink" title="特性列表"></a>特性列表</h2><ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F189" target="_blank" rel="noopener">189:    Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></li>
</ul>
<blockquote>
<p>Shenandoah GC是一个面向low-pause-time的垃圾收集器，它最初由Red Hat实现，支持aarch64及amd64 architecture；ZGC也是面向low-pause-time的垃圾收集器，不过ZGC是基于colored pointers来实现，而Shenandoah GC是基于brooks pointers来实现；如果要使用Shenandoah GC需要编译时–with-jvm-features选项带有shenandoahgc，然后启动时使用-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F230" target="_blank" rel="noopener">230:    Microbenchmark Suite</a></li>
</ul>
<blockquote>
<p>在jdk源码里头新增了一套基础的microbenchmarks suite</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F325" target="_blank" rel="noopener">325:    Switch Expressions (Preview)</a></li>
</ul>
<blockquote>
<p>对switch进行了增强，除了使用statement还可以使用expression，比如原来的写法如下：</p>
<pre><code class="java">switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}</code></pre>
<p>现在可以改为如下写法：</p>
<pre><code class="java">switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);
    case TUESDAY                -&gt; System.out.println(7);
    case THURSDAY, SATURDAY     -&gt; System.out.println(8);
    case WEDNESDAY              -&gt; System.out.println(9);
}</code></pre>
<p>以及在表达式返回值</p>
<pre><code class="java">int numLetters = switch (day) {
    case MONDAY, FRIDAY, SUNDAY -&gt; 6;
    case TUESDAY                -&gt; 7;
    case THURSDAY, SATURDAY     -&gt; 8;
    case WEDNESDAY              -&gt; 9;
};</code></pre>
<p>对于需要返回值的switch expression要么正常返回值要么抛出异常，以下这两种写法都是错误的</p>
<pre><code class="java">int i = switch (day) {
    case MONDAY -&gt; {
        System.out.println(&quot;Monday&quot;); 
        // ERROR! Block doesn&#39;t contain a break with value
    }
    default -&gt; 1;
};
i = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY: 
        break 0;
    default: 
        System.out.println(&quot;Second half of the week&quot;);
        // ERROR! Group doesn&#39;t contain a break with value
};</code></pre>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F334" target="_blank" rel="noopener">334:    JVM Constants API</a></li>
</ul>
</blockquote>
<blockquote>
<p>新增了JVM Constants API，具体来说就是java.base模块新增了java.lang.constant包，引入了ConstantDesc接口(ClassDesc、MethodTypeDesc、MethodHandleDesc这几个接口直接继承了ConstantDesc接口)以及Constable接口；ConstantDesc接口定义了resolveConstantDesc方法，Constable接口定义了describeConstable方法；String、Integer、Long、Float、Double均实现了这两个接口，而EnumDesc实现了ConstantDesc接口</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F340" target="_blank" rel="noopener">340:    One AArch64 Port, Not Two</a></li>
</ul>
<blockquote>
<p>64-bit Arm platform (arm64)，也可以称之为aarch64；之前JDK有两个关于aarch64的实现，分别是src/hotspot/cpu/arm以及open/src/hotspot/cpu/aarch64，它们的实现重复了，为了集中精力更好地实现aarch64，该特性在源码中删除了open/src/hotspot/cpu/arm中关于64-bit的实现，保留其中32-bit的实现，于是open/src/hotspot/cpu/aarch64部分就成了64-bit ARM architecture的默认实现</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F341" target="_blank" rel="noopener">341:    Default CDS Archives</a></li>
</ul>
<blockquote>
<p>java10的新特性JEP 310: Application Class-Data Sharing扩展了JDK5引入的Class-Data Sharing，支持application的Class-Data Sharing；Class-Data Sharing可以用于多个JVM共享class，提升启动速度，最早只支持system classes及serial GC，JDK9对其进行扩展以支持application classes及其他GC算法，并在JDK10中开源出来(以前是commercial feature)；JDK11将-Xshare:off改为默认-Xshare:auto，以更加方便使用CDS特性；JDK12的这个特性即在64-bit平台上编译jdk的时候就默认在${JAVA_HOME}/lib/server目录下生成一份名为classes.jsa的默认archive文件(大概有18M)方便大家使用</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F344" target="_blank" rel="noopener">344:    Abortable Mixed Collections for G1</a></li>
</ul>
<blockquote>
<p>G1在garbage collection的时候，一旦确定了collection set(CSet)开始垃圾收集这个过程是without stopping的，当collection set过大的时候，此时的STW时间会过长超出目标pause time，这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，允许将其分为mandatory及optional两部分(当完成mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fopenjdk.java.net%2Fjeps%2F346" target="_blank" rel="noopener">346:    Promptly Return Unused Committed Memory from G1</a></li>
</ul>
<blockquote>
<p>G1目前只有在full GC或者concurrent cycle的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时会还committed Java heap memory给操作系统。JDK12的这个特性新增了两个参数分别是G1PeriodicGCInterval及G1PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。当上一次garbage collection pause过去G1PeriodicGCInterval(milliseconds)时间之后，如果getloadavg()(one-minute)低于G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(如果开启G1PeriodicGCInvokesConcurrent)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统</p>
</blockquote>
<h2 id="细项解读"><a href="#细项解读" class="headerlink" title="细项解读"></a>细项解读</h2><p>上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见JDK 12 Release Notes，这里举几个例子。<br>添加项</p>
<ul>
<li>支持unicode 11</li>
<li>支持Compact Number Formatting</li>
</ul>
<blockquote>
<p>使用实例如下</p>
<pre><code class="java">    @Test
    public void testCompactNumberFormat(){
        var cnf = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);
        System.out.println(cnf.format(1_0000));
        System.out.println(cnf.format(1_9200));
        System.out.println(cnf.format(1_000_000));
        System.out.println(cnf.format(1L &lt;&lt; 30));
        System.out.println(cnf.format(1L &lt;&lt; 40));
        System.out.println(cnf.format(1L &lt;&lt; 50));
    }</code></pre>
</blockquote>
<p>输出</p>
<pre><code>1万
2万
100万
11亿
1兆
1126兆</code></pre><ul>
<li>String支持transform、indent操作</li>
</ul>
<pre><code class="java">    @Test
    public void testStringTransform(){
        System.out.println(&quot;hello&quot;.transform(new Function&lt;String, Integer&gt;() {
            @Override
            public Integer apply(String s) {
                return s.hashCode();
            }
        }));
    }

    @Test
    public void testStringIndent(){
        System.out.println(&quot;hello&quot;.indent(3));
    }</code></pre>
<p>Files新增mismatch方法</p>
<pre><code class="java">    @Test
    public void testFilesMismatch() throws IOException {
        FileWriter fileWriter = new FileWriter(&quot;/tmp/a.txt&quot;);
        fileWriter.write(&quot;a&quot;);
        fileWriter.write(&quot;b&quot;);
        fileWriter.write(&quot;c&quot;);
        fileWriter.close();

        FileWriter fileWriterB = new FileWriter(&quot;/tmp/b.txt&quot;);
        fileWriterB.write(&quot;a&quot;);
        fileWriterB.write(&quot;1&quot;);
        fileWriterB.write(&quot;c&quot;);
        fileWriterB.close();

        System.out.println(Files.mismatch(Path.of(&quot;/tmp/a.txt&quot;),Path.of(&quot;/tmp/b.txt&quot;)));
    }</code></pre>
<ul>
<li>Collectors新增teeing方法用于聚合两个downstream的结果</li>
</ul>
<pre><code class="java">    @Test
    public void testCollectorTeeing(){
        var result = Stream.of(&quot;Devoxx&quot;,&quot;Voxxed Days&quot;,&quot;Code One&quot;,&quot;Basel One&quot;)
                .collect(Collectors.teeing(Collectors.filtering(n -&gt; n.contains(&quot;xx&quot;),Collectors.toList()),
                                            Collectors.filtering(n -&gt; n.endsWith(&quot;One&quot;),Collectors.toList()),
                        (List&lt;String&gt; list1, List&lt;String&gt; list2) -&gt; List.of(list1,list2)
                                            ));

        System.out.println(result.get(0));
        System.out.println(result.get(1));
    }</code></pre>
<ul>
<li>CompletionStage新增exceptionallyAsync、exceptionallyCompose、exceptionallyComposeAsync方法</li>
</ul>
<pre><code class="java">    @Test
    public void testExceptionallyAsync() throws ExecutionException, InterruptedException {
        LOGGER.info(&quot;begin&quot;);
        int result = CompletableFuture.supplyAsync(() -&gt; {
            LOGGER.info(&quot;calculate&quot;);
            int i = 1/0;
            return 100;
        }).exceptionallyAsync((t) -&gt; {
            LOGGER.info(&quot;error error:{}&quot;,t.getMessage());
            return 0;
        }).get();

        LOGGER.info(&quot;result:{}&quot;,result);
    }</code></pre>
<ul>
<li><p>JDK12之前CompletionStage只有一个exceptionally，该方法体在主线程执行，JDK12新增了exceptionallyAsync、exceptionallyComposeAsync方法允许方法体在异步线程执行，同时新增了exceptionallyCompose方法支持在exceptionally的时候构建新的CompletionStage</p>
</li>
<li><p>Allocation of Old Generation of Java Heap on Alternate Memory Devices</p>
</li>
</ul>
<blockquote>
<p>G1及Parallel GC引入experimental特性，允许将old generation分配在诸如NV-DIMM memory的alternative memory device</p>
</blockquote>
<ul>
<li>ZGC: Concurrent Class Unloading</li>
</ul>
<blockquote>
<p>ZGC在JDK11的时候还不支持class unloading，JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用</p>
</blockquote>
<ul>
<li>新增-XX:+ExtensiveErrorReports</li>
</ul>
<blockquote>
<p>-XX:+ExtensiveErrorReports可以用于在jvm crash的时候收集更多的报告信息到hs_err.log文件中，product builds中默认是关闭的，要开启的话，需要自己添加-XX:+ExtensiveErrorReports参数</p>
</blockquote>
<ul>
<li>新增安全相关的改进</li>
</ul>
<blockquote>
<p>支持java.security.manager系统属性，当设置为disallow的时候，则不使用SecurityManager以提升性能，如果此时调用System.setSecurityManager则会抛出UnsupportedOperationException<br>keytool新增-groupname选项允许在生成key pair的时候指定一个named group<br>新增PKCS12 KeyStore配置属性用于自定义PKCS12 keystores的生成<br>Java Flight Recorder新增了security-related的event<br>支持ChaCha20 and Poly1305 TLS Cipher Suites</p>
</blockquote>
<ul>
<li>jdeps Reports Transitive Dependences</li>
</ul>
<blockquote>
<p>jdeps的–print-module-deps, –list-deps, 以及–list-reduce-deps选项得到增强，新增–no-recursive用于non-transitive的依赖分析，–ignore-missing-deps用于suppress missing dependence errors</p>
</blockquote>
<h2 id="移除项"><a href="#移除项" class="headerlink" title="移除项"></a>移除项</h2><ul>
<li>移除com.sun.awt.SecurityWarnin</li>
<li>移除FileInputStream、FileOutputStream、Java.util.ZipFile/Inflator/Deflator的finalize方法</li>
<li>移除GTE CyberTrust Global Root</li>
<li>移除javac的-source, -target对6及1.6的支持，同时移除–release选项</li>
</ul>
<h2 id="废弃项"><a href="#废弃项" class="headerlink" title="废弃项"></a>废弃项</h2><ul>
<li>废弃的API列表见deprecated-list</li>
<li>废弃-XX:+/-MonitorInUseLists选项</li>
<li>废弃Default Keytool的-keyalg值</li>
</ul>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul>
<li>Swing不支持GTK+ 3.20及以后的版本</li>
<li>在使用JVMCI Compiler(比如Graal)的时候，JVMTI的can_pop_frame及can_force_early_return的capabilities是被禁用的</li>
</ul>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><ul>
<li>如果用户没有指定user.timezone且从操作系统获取的为空，那么user.timezone属性的初始值为空变为null</li>
<li>java.net.URLPermission的行为发生轻微变化，以前它会忽略url中的query及fragment部分，这次改动新增query及fragment部分，即scheme : // authority [ / path ]变动为scheme : // authority [ / path ] [ ignored-query-or-fragment ]</li>
<li>javax.net.ssl.SSLContext API及Java Security Standard Algorithm Names规范移除了必须实现TLSv1及TLSv1.1的规定</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>java12不是LTS(Long-Term Support)版本(oracle版本才有LTS)，oracle对该版本的support周期为6个月。这个版本主要有几个更新点，一个是语法层更新，一个是API层面的更新，另外主要是GC方面的更新。</li>
<li>语法层面引入了preview版本的Switch Expressions；API层面引入了JVM Constants API，引入CompactNumberFormat，让NumberFormat支持COMPACTSTYLE，对String、Files、Collectors、CompletionStage等新增方法；GC方面引入了experimental版本的Shenandoah GC，不过oracle build的openjdk没有enable Shenandoah GC support；另外主要对ZGC及G1 GC进行了改进</li>
<li>其中JDK12对ZGC支持了Concurrent Class Unloading，默认是开启，使用-XX:-ClassUnloading可以禁用；对于G1 GC则新增支持Abortable Mixed Collections以及Promptly Return Unused Committed Memory特性</li>
</ul>
<blockquote>
<p>作者：go4it<br>链接：<a href="https://juejin.im/post/5c91fcc9e51d45563b62382c" target="_blank" rel="noopener">https://juejin.im/post/5c91fcc9e51d45563b62382c</a><br>来源：掘金</p>
</blockquote>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-14T06:04:05.000Z">2019-09-14</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    几秒 读完 (大约 70 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/14/OpenCV边缘检测/">OpenCV边缘检测</a>
            
        </h1>
        <div class="content">
            <h1 id="OpenCV边缘检测"><a href="#OpenCV边缘检测" class="headerlink" title="OpenCV边缘检测"></a>OpenCV边缘检测</h1><p><img src="/images/2019/09/14/54fef350-d6b5-11e9-ae59-4f17e83b2f0c.png" alt="image.png"></p>
<pre><code class="python">import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread(&#39;1024.jpg&#39;,0)
edges = cv2.Canny(img,100,200)

plt.subplot(121),plt.imshow(img,cmap=&#39;gray&#39;)
plt.title(&#39;original&#39;),plt.xticks([]),plt.yticks([])
plt.subplot(122),plt.imshow(edges,cmap=&#39;gray&#39;)
plt.title(&#39;edge&#39;),plt.xticks([]),plt.yticks([])

plt.show()</code></pre>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-13T07:57:44.000Z">2019-09-13</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 分钟 读完 (大约 5627 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/13/Java面试题/">Java面试题</a>
            
        </h1>
        <div class="content">
            <h1 id="基础与框架"><a href="#基础与框架" class="headerlink" title="基础与框架"></a>基础与框架</h1><h2 id="String类能被继承吗，为什么"><a href="#String类能被继承吗，为什么" class="headerlink" title="String类能被继承吗，为什么?"></a>String类能被继承吗，为什么?</h2><blockquote>
<p>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。</p>
</blockquote>
<pre><code class="java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence </code></pre>
<p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>　　final类不能被继承，没有子类，final类中的方法默认是final的。<br>　　final方法不能被子类的方法覆盖，但可以被继承。<br>　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>　　final不能用于修饰构造方法。<br>　　注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>　　使用final方法的原因有二：<br>　　第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>　　第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑）</p>
<blockquote>
<p>下面这段话摘自《Java编程思想》第四版第143页：<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。”</p>
</blockquote>
<p>关于String类，要了解常量池的概念</p>
<pre><code class="java">String s = new String(“xyz”);  //创建了几个对象</code></pre>
<p>答案： 1个或2个， 如果”xyz”已经存在于常量池中，则只在堆中创建”xyz”对象的一个拷贝，否则还要在常量池中在创建一份</p>
<pre><code class="java">String s = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;; //创建了几个对象</code></pre>
<p>答案： 这个和JVM实现有关， 如果常量池为空，可能是1个也可能是7个等</p>
<h2 id="String，Stringbuffer，StringBuilder的区别？"><a href="#String，Stringbuffer，StringBuilder的区别？" class="headerlink" title="String，Stringbuffer，StringBuilder的区别？"></a>String，Stringbuffer，StringBuilder的区别？</h2><p>1、用来处理字符串常用的类有3种：String、StringBuffer和StringBuilder<br>2、三者之间的区别：<br>都是final类，都不允许被继承；<br>String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；<br>StringBuffer类是线程安全的，StringBuilder不是线程安全的；</p>
<p>String 和 StringBuffer：<br>1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；</p>
<p>2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；</p>
<p>3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如：</p>
<pre><code class="java">String s1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</code></pre>
<p>生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：</p>
<pre><code class="java">Java Compiler直接把上述第一条语句编译为：
String s2 = “This is only a”;
String s3 = “ simple”;
String s4 = “ test”;
String s1 = s2 + s3 + s4;</code></pre>
<p><a href="https://www.jianshu.com/p/8c724dd28fa4" target="_blank" rel="noopener">传送门</a></p>
<h2 id="ArrayList和LinkedList有什么区别"><a href="#ArrayList和LinkedList有什么区别" class="headerlink" title="ArrayList和LinkedList有什么区别"></a>ArrayList和LinkedList有什么区别</h2><p>ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。</p>
<p><strong>数据的更新和查找</strong><br>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p>
<p><strong>数据的增加和删除</strong><br>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p>
<p><a href="https://juejin.im/post/5adec492f265da0b9f3fea08#heading-2" target="_blank" rel="noopener">传送门</a></p>
<h2 id="类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序"><a href="#类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序" class="headerlink" title="类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序"></a>类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序</h2><blockquote>
<p>此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。<br>父类静态变量、<br>父类静态代码块、<br>子类静态变量、<br>子类静态代码块、<br>父类非静态变量（父类实例成员变量）、<br>父类构造函数、<br>子类非静态变量（子类实例成员变量）、<br>子类构造函数。 </p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000004527951#articleHeader0" target="_blank" rel="noopener">传送门</a></p>
<h2 id="用过哪些Map，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等"><a href="#用过哪些Map，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等" class="headerlink" title="用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等"></a>用过哪些Map，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如hashcode，扩容等</h2><blockquote>
<p>Hashtable,HashMap,ConcurrentHashMap</p>
</blockquote>
<p><strong>线程不安全的HashMap</strong><br>因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
<p><strong>HashMap</strong><br>HashMap内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。其中每个结点存储的是一个键值对整体（Entry），HashMap采用拉链法解决哈希冲突</p>
<p><a href="https://blog.csdn.net/u014532901/article/details/78936283" target="_blank" rel="noopener">传送门</a></p>
<p><strong>效率低下的HashTable容器</strong><br>     HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<p><strong>ConcurrentHashMap的锁分段技术</strong><br>     HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/52279473" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p>hashcode() 方法，在object类中定义如下：</p>
</blockquote>
<pre><code class="java">public native int hashCode();</code></pre>
<p>native说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double。。。。等等这些类都是覆盖了hashcode()方法的<br>例如String类中:就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。(为什么取31?主要是因为31是一个奇质数，所以31i=32i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多).</p>
<pre><code class="java">public int hashCode() {
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) {
        char val[] = value;

        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}</code></pre>
<h2 id="HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发"><a href="#HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发" class="headerlink" title="HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发"></a>HashMap为什么get和set那么快，concurrentHashMap为什么能提高并发</h2><blockquote>
<p>HashMap 底层是基于 数组 + 链表 组成的</p>
</blockquote>
<p><a href="https://juejin.im/post/5b551e8df265da0f84562403#heading-9" target="_blank" rel="noopener">传送门</a></p>
<h2 id="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么"><a href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么" class="headerlink" title="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么"></a>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么</h2><blockquote>
<p>实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。<br><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">抽象类和接口的区别</a></p>
</blockquote>
<blockquote>
<p>由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</p>
</blockquote>
<blockquote>
<p>接口可以继承多个接口。<br>java类是单继承的。classB Extends classA<br>java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……<br>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？<br>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p>
</blockquote>
<h2 id="什么情况下会发生栈内存溢出"><a href="#什么情况下会发生栈内存溢出" class="headerlink" title="什么情况下会发生栈内存溢出"></a>什么情况下会发生栈内存溢出</h2><p><strong>方法递归调用产生这种结果</strong></p>
<blockquote>
<p>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）</p>
</blockquote>
<p>所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。栈溢出(StackOverflowError)</p>
<h2 id="什么是nio，原理"><a href="#什么是nio，原理" class="headerlink" title="什么是nio，原理"></a>什么是nio，原理</h2><blockquote>
<p>NIO是为了弥补传统I/O工作模式的不足而研发的，NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型I/O能力。</p>
</blockquote>
<p>NIO的工作原理是什么？</p>
<p>　　在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O操作完成即可返回，从而减少了管理I/O连接导致的系统开销，大幅度提高了系统性能。</p>
<p>　　当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。</p>
<p>　　并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络I/O设计的并发型服务器程序与以往基于阻塞I/O的实现程序有很大不同，在使用非阻塞网络I/O的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。</p>
<p>　　使用非阻塞型I/O进行并发型服务器程序设计分三个部分：1. 向Selector对象注册感兴趣的事件；2.从Selector中获取所感兴趣的事件；3. 根据不同的事件进行相应的处理。</p>
<p>　　在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展。</p>
<p><a href="https://www.cnblogs.com/johnvajicic/archive/2013/04/18/3028675.html" target="_blank" rel="noopener">传送门</a></p>
<h2 id="反射中，Class-forName和ClassLoader区别"><a href="#反射中，Class-forName和ClassLoader区别" class="headerlink" title="反射中，Class.forName和ClassLoader区别"></a>反射中，Class.forName和ClassLoader区别</h2><p>Java中Class.forName和classloader都可以用来对类进行加载。</p>
<ul>
<li><p>Class.forName(“className”);</p>
<pre><code>  其实这种方法调运的是：Class.forName(className, true, ClassLoader.getCallerClassLoader())方法
  参数一：className，需要加载的类的名称。
  参数二：true，是否对class进行初始化（需要initialize）
  参数三：classLoader，对应的类加载器</code></pre></li>
<li><p>ClassLoader.laodClass(“className”);</p>
<pre><code>  其实这种方法调运的是：ClassLoader.loadClass(name, false)方法
  参数一：name,需要加载的类的名称
  参数二：false，这个类加载以后是否需要去连接（不需要linking）</code></pre></li>
</ul>
<p>可见Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</p>
<p>而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</p>
<p><a href="https://blog.csdn.net/u013308490/article/details/87809824" target="_blank" rel="noopener">传送门</a></p>
<h2 id="tomcat结构，类加载器流程"><a href="#tomcat结构，类加载器流程" class="headerlink" title="tomcat结构，类加载器流程"></a>tomcat结构，类加载器流程</h2><blockquote>
<p>Tomcat 的总体结构</p>
</blockquote>
<p><img src="/images/2019/09/13/12f00090-d605-11e9-a6a7-0b204ec53b69.png" alt="image.png"></p>
<p>从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。</p>
<p><strong>什么是类加载器？</strong><br>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p><a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">传送门</a></p>
<h2 id="讲讲Spring事务的传播属性-AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式"><a href="#讲讲Spring事务的传播属性-AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式" class="headerlink" title="讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式"></a>讲讲Spring事务的传播属性,AOP原理，动态代理与cglib实现的区别，AOP有哪几种实现方式</h2><h2 id="Spring的beanFactory和factoryBean的区别"><a href="#Spring的beanFactory和factoryBean的区别" class="headerlink" title="Spring的beanFactory和factoryBean的区别"></a>Spring的beanFactory和factoryBean的区别</h2><h2 id="Spring加载流程"><a href="#Spring加载流程" class="headerlink" title="Spring加载流程"></a>Spring加载流程</h2><h2 id="Spring如何管理事务的"><a href="#Spring如何管理事务的" class="headerlink" title="Spring如何管理事务的"></a>Spring如何管理事务的</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线城池的最大线程数目根据什么确定"><a href="#线城池的最大线程数目根据什么确定" class="headerlink" title="线城池的最大线程数目根据什么确定"></a>线城池的最大线程数目根据什么确定</h2><h2 id="多线程的几种实现方式，什么是线程安全，什么是重排序"><a href="#多线程的几种实现方式，什么是线程安全，什么是重排序" class="headerlink" title="多线程的几种实现方式，什么是线程安全，什么是重排序"></a>多线程的几种实现方式，什么是线程安全，什么是重排序</h2><h2 id="volatile的原理，作用，能代替锁么"><a href="#volatile的原理，作用，能代替锁么" class="headerlink" title="volatile的原理，作用，能代替锁么"></a>volatile的原理，作用，能代替锁么</h2><h2 id="sleep和wait的区别，以及wait的实现原理"><a href="#sleep和wait的区别，以及wait的实现原理" class="headerlink" title="sleep和wait的区别，以及wait的实现原理"></a>sleep和wait的区别，以及wait的实现原理</h2><h2 id="Lock与synchronized-的区别，synchronized-的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁"><a href="#Lock与synchronized-的区别，synchronized-的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁" class="headerlink" title="Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁"></a>Lock与synchronized 的区别，synchronized 的原理，什么是自旋锁，偏向锁，轻量级锁，什么叫可重入锁，什么叫公平锁和非公平锁</h2><h2 id="用过哪些原子类，他们的参数以及原理是什么"><a href="#用过哪些原子类，他们的参数以及原理是什么" class="headerlink" title="用过哪些原子类，他们的参数以及原理是什么"></a>用过哪些原子类，他们的参数以及原理是什么</h2><h2 id="用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等"><a href="#用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等" class="headerlink" title="用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等"></a>用过哪些线程池，他们的原理简单概括下，构造函数的各个参数的含义，比如coreSize，maxsize等</h2><h2 id="有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"><a href="#有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。" class="headerlink" title="有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"></a>有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。</h2><h2 id="spring的controller是单例还是多例，怎么保证并发的安全"><a href="#spring的controller是单例还是多例，怎么保证并发的安全" class="headerlink" title="spring的controller是单例还是多例，怎么保证并发的安全"></a>spring的controller是单例还是多例，怎么保证并发的安全</h2><h2 id="用三个线程按顺序循环打印abc三个字母，比如abcabcabc"><a href="#用三个线程按顺序循环打印abc三个字母，比如abcabcabc" class="headerlink" title="用三个线程按顺序循环打印abc三个字母，比如abcabcabc"></a>用三个线程按顺序循环打印abc三个字母，比如abcabcabc</h2><h2 id="ThreadLocal用过么，原理是什么，用的时候要注意什么"><a href="#ThreadLocal用过么，原理是什么，用的时候要注意什么" class="headerlink" title="ThreadLocal用过么，原理是什么，用的时候要注意什么"></a>ThreadLocal用过么，原理是什么，用的时候要注意什么</h2><h2 id="如果让你实现一个并发安全的链表，你会怎么做"><a href="#如果让你实现一个并发安全的链表，你会怎么做" class="headerlink" title="如果让你实现一个并发安全的链表，你会怎么做"></a>如果让你实现一个并发安全的链表，你会怎么做</h2><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h2 id="jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等"><a href="#jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等" class="headerlink" title="jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等"></a>jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等</h2><h2 id="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms"><a href="#你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms" class="headerlink" title="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms"></a>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms</h2><h2 id="当出现了内存溢出，你怎么排错"><a href="#当出现了内存溢出，你怎么排错" class="headerlink" title="当出现了内存溢出，你怎么排错"></a>当出现了内存溢出，你怎么排错</h2><h2 id="JVM内存模型的相关知识了解多少"><a href="#JVM内存模型的相关知识了解多少" class="headerlink" title="JVM内存模型的相关知识了解多少"></a>JVM内存模型的相关知识了解多少</h2><h2 id="简单说说你了解的类加载器"><a href="#简单说说你了解的类加载器" class="headerlink" title="简单说说你了解的类加载器"></a>简单说说你了解的类加载器</h2><h2 id="JAVA的反射机制"><a href="#JAVA的反射机制" class="headerlink" title="JAVA的反射机制"></a>JAVA的反射机制</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="http1-0和http1-1有什么区别"><a href="#http1-0和http1-1有什么区别" class="headerlink" title="http1.0和http1.1有什么区别"></a>http1.0和http1.1有什么区别</h2><h2 id="TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么"><a href="#TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么" class="headerlink" title="TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么"></a>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么</h2><h2 id="TIME-WAIT和CLOSE-WAIT的区别"><a href="#TIME-WAIT和CLOSE-WAIT的区别" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别"></a>TIME_WAIT和CLOSE_WAIT的区别</h2><h2 id="说说你知道的几种HTTP响应码"><a href="#说说你知道的几种HTTP响应码" class="headerlink" title="说说你知道的几种HTTP响应码"></a>说说你知道的几种HTTP响应码</h2><h2 id="当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤"><a href="#当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤" class="headerlink" title="当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤"></a>当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤</h2><h2 id="Linux下IO模型有几种，各自的含义是什么"><a href="#Linux下IO模型有几种，各自的含义是什么" class="headerlink" title="Linux下IO模型有几种，各自的含义是什么"></a>Linux下IO模型有几种，各自的含义是什么</h2><h2 id="TCP-IP如何保证可靠性，数据包有哪些数据组成"><a href="#TCP-IP如何保证可靠性，数据包有哪些数据组成" class="headerlink" title="TCP/IP如何保证可靠性，数据包有哪些数据组成"></a>TCP/IP如何保证可靠性，数据包有哪些数据组成</h2><h2 id="架构设计与分布式："><a href="#架构设计与分布式：" class="headerlink" title="架构设计与分布式："></a>架构设计与分布式：</h2><h2 id="tomcat如何调优，各种参数的意义"><a href="#tomcat如何调优，各种参数的意义" class="headerlink" title="tomcat如何调优，各种参数的意义"></a>tomcat如何调优，各种参数的意义</h2><h2 id="常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等"><a href="#常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等" class="headerlink" title="常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等"></a>常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的，Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等</h2><h2 id="如何防止缓存雪崩12-用java自己实现一个LRU"><a href="#如何防止缓存雪崩12-用java自己实现一个LRU" class="headerlink" title="如何防止缓存雪崩12.用java自己实现一个LRU"></a>如何防止缓存雪崩12.用java自己实现一个LRU</h2><h2 id="分布式集群下如何做到唯一序列号"><a href="#分布式集群下如何做到唯一序列号" class="headerlink" title="分布式集群下如何做到唯一序列号"></a>分布式集群下如何做到唯一序列号</h2><h2 id="设计一个秒杀系统，30分钟没付款就自动关闭交易"><a href="#设计一个秒杀系统，30分钟没付款就自动关闭交易" class="headerlink" title="设计一个秒杀系统，30分钟没付款就自动关闭交易"></a>设计一个秒杀系统，30分钟没付款就自动关闭交易</h2><h2 id="如何做一个分布式锁"><a href="#如何做一个分布式锁" class="headerlink" title="如何做一个分布式锁"></a>如何做一个分布式锁</h2><h2 id="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"><a href="#用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗" class="headerlink" title="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"></a>用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗</h2><h2 id="MQ系统的数据如何保证不丢失"><a href="#MQ系统的数据如何保证不丢失" class="headerlink" title="MQ系统的数据如何保证不丢失"></a>MQ系统的数据如何保证不丢失</h2><h2 id="分布式事务的原理，如何使用分布式事务"><a href="#分布式事务的原理，如何使用分布式事务" class="headerlink" title="分布式事务的原理，如何使用分布式事务"></a>分布式事务的原理，如何使用分布式事务</h2><h2 id="什么是一致性hash"><a href="#什么是一致性hash" class="headerlink" title="什么是一致性hash"></a>什么是一致性hash</h2><h2 id="什么是restful，讲讲你理解的restful"><a href="#什么是restful，讲讲你理解的restful" class="headerlink" title="什么是restful，讲讲你理解的restful"></a>什么是restful，讲讲你理解的restful</h2><h2 id="如何设计建立和保持100w的长连接？"><a href="#如何设计建立和保持100w的长连接？" class="headerlink" title="如何设计建立和保持100w的长连接？"></a>如何设计建立和保持100w的长连接？</h2><h2 id="解释什么是MESI协议-缓存一致性"><a href="#解释什么是MESI协议-缓存一致性" class="headerlink" title="解释什么是MESI协议(缓存一致性)"></a>解释什么是MESI协议(缓存一致性)</h2><h2 id="说说你知道的几种HASH算法，简单的也可以"><a href="#说说你知道的几种HASH算法，简单的也可以" class="headerlink" title="说说你知道的几种HASH算法，简单的也可以"></a>说说你知道的几种HASH算法，简单的也可以</h2><h2 id="什么是paxos算法"><a href="#什么是paxos算法" class="headerlink" title="什么是paxos算法"></a>什么是paxos算法</h2><h2 id="redis和memcached-的内存管理的区别"><a href="#redis和memcached-的内存管理的区别" class="headerlink" title="redis和memcached 的内存管理的区别"></a>redis和memcached 的内存管理的区别</h2><h2 id="一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新"><a href="#一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新" class="headerlink" title="一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新"></a>一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新</h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="10亿个数字里里面找最小的10个"><a href="#10亿个数字里里面找最小的10个" class="headerlink" title="10亿个数字里里面找最小的10个"></a>10亿个数字里里面找最小的10个</h2><h2 id="有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优"><a href="#有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优" class="headerlink" title="有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优"></a>有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优</h2><h2 id="2亿个随机生成的无序整数-找出中间大小的值"><a href="#2亿个随机生成的无序整数-找出中间大小的值" class="headerlink" title="2亿个随机生成的无序整数,找出中间大小的值"></a>2亿个随机生成的无序整数,找出中间大小的值</h2><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点"><a href="#数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点" class="headerlink" title="数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点"></a>数据库隔离级别有哪些，各自的含义是什么，MYsql默认的隔离级别是是什么，各个存储引擎优缺点</h2><h2 id="高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义"><a href="#高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义" class="headerlink" title="高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义"></a>高并发下，如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义</h2><h2 id="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？"><a href="#SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？" class="headerlink" title="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？"></a>SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义，索引的原理？</h2><h2 id="数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁"><a href="#数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁" class="headerlink" title="数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁"></a>数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁</h2><h2 id="MYsql的索引实现方式"><a href="#MYsql的索引实现方式" class="headerlink" title="MYsql的索引实现方式"></a>MYsql的索引实现方式</h2><h2 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h2><h2 id="数据库中-BTREE和B-tree区别"><a href="#数据库中-BTREE和B-tree区别" class="headerlink" title="数据库中 BTREE和B+tree区别"></a>数据库中 BTREE和B+tree区别</h2>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-12T13:41:44.000Z">2019-09-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 382 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/12/TensorFlow-2-0-RC-is-available/">TensorFlow 2.0 RC is available</a>
            
        </h1>
        <div class="content">
            <p><img src="/images/2019/09/12/fc47ee60-d560-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h1 id="TensorFlow-2-0-RC"><a href="#TensorFlow-2-0-RC" class="headerlink" title="TensorFlow 2.0 RC"></a>TensorFlow 2.0 RC</h1><p>工具<br>探索可支持和加速 TensorFlow 工作流程的工具。</p>
<p><img src="/images/2019/09/12/0d102030-d563-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h2 id="CoLab"><a href="#CoLab" class="headerlink" title="CoLab"></a>CoLab</h2><p>Colaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您只需点击一下鼠标，即可在浏览器中执行 TensorFlow 代码。</p>
<h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>一套可视化工具，用于理解、调试和优化TensorFlow程序。</p>
<h2 id="What-If工具"><a href="#What-If工具" class="headerlink" title="What-If工具"></a>What-If工具</h2><p>一种无代码的方式探究机器学习模型的工具，对模型的理解、调试和公平性很有用。可在TensorFlow和Jupyter或CoLab笔记本中使用。</p>
<h2 id="ML-Perf"><a href="#ML-Perf" class="headerlink" title="ML Perf"></a>ML Perf</h2><p>全面的机器学习基准测试套件，用于衡量机器学习软件框架、机器学习硬件加速器和机器学习云端平台的性能。</p>
<h2 id="XLA"><a href="#XLA" class="headerlink" title="XLA"></a>XLA</h2><p>XLA(加速线性代数)是一种特定领域的线性代数编译器，能够优化TensorFlow计算，它可以提高服务器和移动平台的运行速度改进内存使用情况和可移植性。</p>
<h2 id="TensorFlow-Playground"><a href="#TensorFlow-Playground" class="headerlink" title="TensorFlow Playground"></a>TensorFlow Playground</h2><p>在浏览器中设计神经网络。别担心，不会使浏览器崩溃。</p>
<h2 id="TensorFlow-Research-Cloud"><a href="#TensorFlow-Research-Cloud" class="headerlink" title="TensorFlow Research Cloud"></a>TensorFlow Research Cloud</h2><p>加入TensorFlow Research Cloud（TFRC）计划后，研究人员可于申请访问Cloud TPU来加快实现下一波研究突破；我们免费提供1000个Cloud TPU.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-12T13:15:04.000Z">2019-09-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4 分钟 读完 (大约 652 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/12/nohup-在linux后台运行程序/">nohup:在linux后台运行程序</a>
            
        </h1>
        <div class="content">
            <p><img src="/images/2019/09/12/0188c220-d55f-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h1 id="nohup-在linux后台运行程序"><a href="#nohup-在linux后台运行程序" class="headerlink" title="nohup:在linux后台运行程序"></a>nohup:在linux后台运行程序</h1><p>今天在工作中，lz要在Linux系统上运行一个java程序，这个程序要在系统中持续运行。随后lz无意将ssh窗口关掉了，发现java程序停止了。原来，当使用ssh连接到系统运行程序的时候，该程序已经和你的ssh连接绑定了。如果你关闭连接，该程序就会停止。还有一个情景：如果要在后台运行多个java程序的时候，就需要启动多个ssh窗口，这样很麻烦。有没有方法来解决这个问题呢？答案是肯定的。</p>
<p>1.使用nohup来执行命令，它会把命令自动调到linux后台运行，不锁定当前ssh窗口，也不会被ctrl + c，alt + F4之类打断程序的动行。</p>
<pre><code>nohup java -jar test.jar &amp;</code></pre><p>执行完该命令后，终端会显示如下信息：</p>
<pre><code>[1] 27945
nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;</code></pre><p>[1]：该后台任务的jobid<br>27945：是该进程的pid<br>nohup.out：是该任务的输出位置</p>
<p>2.要指定重定向的文件，如下：</p>
<pre><code>nohup java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp;</code></pre><p>3.如果一个任务已经在前台执行，那就使用以下方法来将任务调整到后台：</p>
<p>（1）首先，在正在执行任务的终端使用ctrl+z</p>
<pre><code>[1]+  已停止               java -jar test.jar</code></pre><p>（2）使用bg命令将该任务调整至后台（fg与之相反，将后台任务调整至前台）</p>
<pre><code>bg %1(1是jobid)</code></pre><p>如果不知道jobid，也可以使用jobs命令来查询。</p>
<p>但是任务的输出还是会打印到终端上的（具体怎么将输出重定向到别的地方，lz也不造）。而且，这时该任务还是与当前终端相关联的，关闭终端还是会断掉该任务的。使用下面命令来解决：</p>
<pre><code>disown -h %1</code></pre><p>这样再也不用担心关掉终端会停止掉任务喽！！！</p>
<p>PS：再来说说nohup吧。nohup的意思是no hang up，就是说关掉终端是不会挂掉程序的。如果开始执行命令时只使用&amp;：</p>
<pre><code>java -jar test.jar &amp;</code></pre><p>那么该任务也会在后台执行，但是一旦关掉终端该任务还是会挂掉，所以这就是nohup的用处了。</p>
<p><a href="http://ee-dreamer.com/?p=327" target="_blank" rel="noopener">原文链接</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-10T13:45:18.000Z">2019-09-10</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分钟 读完 (大约 968 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/10/Git-Rebase-黄金法则问题/">Git Rebase 黄金法则问题</a>
            
        </h1>
        <div class="content">
            <h1 id="Git-Rebase-黄金法则问题"><a href="#Git-Rebase-黄金法则问题" class="headerlink" title="Git Rebase 黄金法则问题"></a>Git Rebase 黄金法则问题</h1><p>git 整合来自不同分支的修改主要有两种方法：merge 操作和rebase操作，<br>merge初学者可能很熟悉。我们今天来主要说一下 rebase 操作，文章结尾会简单说一下 merge 操作的 –no-ff 参数问题。</p>
<p>rebase的简单定义：你可以把某一分支的所有修改都移至另外一个分支就像重新播放一样。<br>有点儿像金庸武侠小说里面的乾坤大挪移。<br>举个🌰<br>假设我们本地库的代码，如下所示</p>
<pre><code>      A---B---C  remotes/origin/master
     /
D---E---F---G  master</code></pre><p>如果此时我们执行 git pull 操作，就会变成下面的样子，因为 pull 默认执行的是 merge 操作，多出来H这次没必要的提交。如下所示</p>
<pre><code>     A---B---C  remotes/origin/master
     /         \
D---E---F---G---H master</code></pre><p>如果我们执行 git pull –rebase 操作，将会变成下面的样子，这里我们用rebase代替了默认的merge操作</p>
<pre><code>            remotes/origin
                |
D---E---A---B---C---F---G
                        |
                        master</code></pre><p>rebase 作用就是变成线性了，这在多人协作的情况变得非常关键。因为多人合作是不允许随意制造分叉的。大家可以参考我这篇文章。</p>
<p>这就引出了这篇博文要主要阐述的问题，rebase golden rule 问题。</p>
<blockquote>
<p>Rebase golden rule<br>“No one shall rebase a shared branch” — Everyone about rebase</p>
</blockquote>
<p>简单来说就是不要在你的公共分支上做任何rebase操作。<br>再举一个🌰。</p>
<p>图一是我们做rebase操作前的样子</p>
<p><img src="/images/2019/09/10/75e5c990-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>图二是我们正确rebase的结果，即在feature分支执行rebase develop命令</p>
<p><img src="/images/2019/09/10/7a0f9d20-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>图三是我们错误rebase的结果，即违反黄金法则的结果，我们在develop分支上执行了rebase feature操作</p>
<p><img src="/images/2019/09/10/7ce48f10-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>当我们在图三这种情况下对develop分支进行提交的话，会发现和远程分支冲突，然后我们手动或自动解决冲突，继续提交上去之后发现，我们修改的功能代码已经提交上去了，但是当我们看我们提交历史的记录的时候会发现有一部分重复的提交log。<br>这就是问题所在，你的项目组长是绝对不允许在他的项目里出现这种情况，因为会影响后续的代码追查，code review等问题。<br>说完了这个问题，这篇博文的主要任务基本完成了，最后在简单说一下 merge 的 –no-ff 参数，这也是我们在分支合并的时候经常遇到的问题。<br>–no-ff 的意思就是关闭 merge 的 fast-forwarded，merge 操作默认执行的是 fast-forwarded。<br>fast-forwarded 的意思就是在合并分支的时候，如果不涉及三方合并，git 只会简单的移动指针。<br>再再举一个🌰</p>
<pre><code>        dev
        |
A---B---C
         \
          D---E
              |
              feature</code></pre><p>此时我们执行 merge –no-ff 操作，将会得到如下图</p>
<pre><code>                dev
                |
A---B---C--------F
         \      /
          D---E</code></pre><p>执行 merge 之后得到的结果如下</p>
<pre><code>               dev
                |
A---B---C---D---E</code></pre><p>如上git 将指针从C移到了E。</p>
<p>简单来说就是 –no-ff 的作用就是保持分支的非线性。方便我们看到分支的变化。</p>
<blockquote>
<p>本文作者： Frank<br>本文链接： <a href="http://hellofrank.github.io/2018/04/27/Git-Rebase-黄金法则问题/" target="_blank" rel="noopener">http://hellofrank.github.io/2018/04/27/Git-Rebase-黄金法则问题/</a><br>版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！</p>
</blockquote>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-09T00:39:17.000Z">2019-09-09</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28 分钟 读完 (大约 4164 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/09/09/Flutter-Http请求开源库-dio/">Flutter Http请求开源库-dio</a>
            
        </h1>
        <div class="content">
            <p>文档语言: <a href="README.md">English</a> | <a href="README-ZH.md">中文简体</a></p>
<h1 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h1><p><img src="/images/2019/09/09/3ed7aff0-d29a-11e9-a25e-85ff34c3f186.png" alt="image.png"></p>
<p>dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等…</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="yaml">dependencies:
  dio: ^x.x.x  // 请使用pub上的最新版本</code></pre>
<h2 id="一个极简的示例"><a href="#一个极简的示例" class="headerlink" title="一个极简的示例"></a>一个极简的示例</h2><pre><code class="dart">import &#39;package:dio/dio.dart&#39;;
void getHttp() async {
  try {
    Response response;
    response = await Dio().get(&quot;http://www.baidu.com&quot;);
    return print(response);
  } catch (e) {
    return print(e);
  }
}</code></pre>
<h2 id="内容列表"><a href="#内容列表" class="headerlink" title="内容列表"></a>内容列表</h2><ul>
<li><a href="#示例">示例</a></li>
<li><a href="#dio-apis">Dio APIs</a></li>
<li><a href="#请求配置">请求配置</a></li>
<li><a href="#响应数据">响应数据</a></li>
<li><a href="#拦截器">拦截器</a></li>
<li><a href="#错误处理">错误处理</a></li>
<li><a href="#使用applicationx-www-form-urlencoded编码">使用application/x-www-form-urlencoded编码</a></li>
<li><a href="#formdata">FormData</a></li>
<li><a href="#转换器">转换器</a></li>
<li><a href="#设置Http代理">设置Http代理</a></li>
<li><a href="#Https证书校验">Https证书校验</a></li>
<li><a href="#请求取消">请求取消</a></li>
<li><a href="#cookie管理">Cookie管理</a></li>
<li><a href="#features-and-bugs">Features and bugs</a></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>发起一个 <code>GET</code> 请求 :</p>
<pre><code class="dart">  Response response;
  Dio dio = new Dio();
  response = await dio.get(&quot;/test?id=12&amp;name=wendu&quot;)
  print(response.data.toString());
// 请求参数也可以通过对象传递，上面的代码等同于：
  response = await dio.get(&quot;/test&quot;, data: {&quot;id&quot;: 12, &quot;name&quot;: &quot;wendu&quot;});
  print(response.data.toString());</code></pre>
<p>发起一个 <code>POST</code> 请求:</p>
<pre><code class="dart">  response = await dio.post(&quot;/test&quot;, data: {&quot;id&quot;: 12, &quot;name&quot;: &quot;wendu&quot;});</code></pre>
<p>发起多个并发请求:</p>
<pre><code class="dart">  response = await Future.wait([dio.post(&quot;/info&quot;), dio.get(&quot;/token&quot;)]);</code></pre>
<p>下载文件:</p>
<pre><code class="dart">  response = await dio.download(&quot;https://www.google.com/&quot;, &quot;./xx.html&quot;);</code></pre>
<p>发送 FormData:</p>
<pre><code class="dart">FormData formData = new FormData.from({
    &quot;name&quot;: &quot;wendux&quot;,
    &quot;age&quot;: 25,
  });
  response = await dio.post(&quot;/info&quot;, data: formData);</code></pre>
<p>通过FormData上传多个文件:</p>
<pre><code class="dart">  FormData formData = new FormData.from({
    &quot;name&quot;: &quot;wendux&quot;,
    &quot;age&quot;: 25,
    &quot;file1&quot;: new UploadFileInfo(new File(&quot;./upload.txt&quot;), &quot;upload1.txt&quot;),
    //支持直接上传字节数组 (List&lt;int&gt;) ，方便直接上传内存中的内容
    &quot;file2&quot;: new UploadFileInfo.fromBytes(
        utf8.encode(&quot;hello world&quot;), &quot;word.txt&quot;),
    // 支持文件数组上传
    &quot;files&quot;: [
      new UploadFileInfo(new File(&quot;./example/upload.txt&quot;), &quot;upload.txt&quot;),
      new UploadFileInfo(new File(&quot;./example/upload.txt&quot;), &quot;upload.txt&quot;)
    ]
  });
  response = await dio.post(&quot;/info&quot;, data: formData);</code></pre>
<p>监听发送(上传)数据进度:</p>
<pre><code class="dart">response = await dio.post(
  &quot;http://www.dtworkroom.com/doris/1/2.0.0/test&quot;,
  data: {&quot;aa&quot;: &quot;bb&quot; * 22},
  onUploadProgress: (int sent, int total) {
    print(&quot;$sent $total&quot;);
  },
);</code></pre>
<p>…你可以在这里获取所有<a href="https://github.com/flutterchina/dio/tree/flutter/example" target="_blank" rel="noopener">示例代码</a>.</p>
<h2 id="Dio-APIs"><a href="#Dio-APIs" class="headerlink" title="Dio APIs"></a>Dio APIs</h2><h3 id="创建一个Dio实例，并配置它"><a href="#创建一个Dio实例，并配置它" class="headerlink" title="创建一个Dio实例，并配置它"></a>创建一个Dio实例，并配置它</h3><p>你可以使用默认配置或传递一个可选 <code>Options</code>参数来创建一个Dio实例 :</p>
<pre><code class="dart">Dio dio = new Dio; // 使用默认配置

// 配置dio实例
  dio.options.baseUrl = &quot;https://www.xx.com/api&quot;;
  dio.options.connectTimeout = 5000; //5s
  dio.options.receiveTimeout = 3000;

// 或者通过传递一个 `options`来创建dio实例
  Options options = new Options(
      baseUrl: &quot;https://www.xx.com/api&quot;,
      connectTimeout: 5000,
      receiveTimeout: 3000);
  Dio dio = new Dio(options);</code></pre>
<p>Dio实例的核心API是 :</p>
<p><strong>Future<response> request(String path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<pre><code class="dart">  response = await request(
      &quot;/test&quot;, data: {&quot;id&quot;: 12, &quot;name&quot;: &quot;xx&quot;}, new Options(method: &quot;GET&quot;));</code></pre>
<h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便使用，Dio提供了一些其它的Restful API, 这些API都是<code>request</code>的别名。</p>
<p><strong>Future<response> get(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> post(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> put(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> delete(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> head(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> put(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> path(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> download(String urlPath, savePath,</response></strong><br>​    <strong>{OnDownloadProgress onProgress, data, bool flush: false, Options options,CancelToken cancelToken})</strong></p>
<h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>下面是所有的请求配置选项。 如果请求<code>method</code>没有指定，则默认为<code>GET</code> :</p>
<pre><code class="dart">{
  /// Http method.
  String method;

  /// 请求基地址,可以包含子路径，如: &quot;https://www.google.com/api/&quot;.
  String baseUrl;

  /// Http请求头.
  Map&lt;String, dynamic&gt; headers;

  /// 连接服务器超时时间，单位是毫秒.
  int connectTimeout;

  ///  响应流上前后两次接受到数据的间隔，单位为毫秒。如果两次间隔超过[receiveTimeout]，
  ///  [Dio] 将会抛出一个[DioErrorType.RECEIVE_TIMEOUT]的异常.
  ///  注意: 这并不是接收数据的总时限.
  int receiveTimeout;

  /// 请求数据,可以是任意类型.
  var data;

  /// 请求路径，如果 `path` 以 &quot;http(s)&quot;开始, 则 `baseURL` 会被忽略； 否则,
  /// 将会和baseUrl拼接出完整的的url.
  String path = &quot;&quot;;

  /// 请求的Content-Type，默认值是[ContentType.JSON].
  /// 如果您想以&quot;application/x-www-form-urlencoded&quot;格式编码请求数据,
  /// 可以设置此选项为 `ContentType.parse(&quot;application/x-www-form-urlencoded&quot;)`,  这样[Dio]
  /// 就会自动编码请求体.
  ContentType contentType;

  /// [responseType] 表示期望以那种格式(方式)接受响应数据。
  /// 目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`.
  ///
  /// 默认值是 `JSON`, 当响应头中content-type为&quot;application/json&quot;时，dio 会自动将响应内容转化为json对象。
  /// 如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`.
  ///
  /// 如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`.
  ResponseType responseType;

  /// `validateStatus` 决定http响应状态码是否被dio视为请求成功， 返回`validateStatus`
  ///  返回`true` , 请求结果就会按成功处理，否则会按失败处理.
  ValidateStatus validateStatus;

  /// 用户自定义字段，可以在 [Interceptor]、[Transformer] 和 [Response] 中取到.
  Map&lt;String, dynamic&gt; extra;
}</code></pre>
<p>这里有一个完成的<a href="https://github.com/flutterchina/dio/blob/flutter/example/options.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><p>当请求成功时会返回一个Response对象，它包含如下字段：</p>
<pre><code class="dart">{
  /// 响应数据，可能已经被转换了类型, 详情请参考Options中的[ResponseType].
  var data;
  /// 响应头
  HttpHeaders headers;
  /// 本次请求信息
  Options request;
  /// Http status code.
  int statusCode;
  /// 响应对象的自定义字段（可以在拦截器中设置它），调用方可以在`then`中获取.
  Map&lt;String, dynamic&gt; extra;
}</code></pre>
<p>示例如下:</p>
<pre><code class="dart">  Response response = await dio.get(&quot;https://www.google.com&quot;);
  print(response.data);
  print(response.headers);
  print(response.request);
  print(response.statusCode);</code></pre>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>每一个 Dio 实例都有一个请求拦截器  <code>RequestInterceptor</code> 和一个响应拦截器 <code>ResponseInterceptor</code>, 通过拦截器你可以在请求之前或响应之后(但还没有被 <code>then</code> 或 <code>catchError</code>处理)做一些统一的预处理操作。</p>
<pre><code class="dart"> dio.interceptor.request.onSend = (Options options){
     // 在请求被发送之前做一些事情
     return options; //continue
     // 如果你想完成请求并返回一些自定义数据，可以返回一个`Response`对象或返回`dio.resolve(data)`。
     // 这样请求将会被终止，上层then会被调用，then中返回的数据将是你的自定义数据data.
     //
     // 如果你想终止请求并触发一个错误,你可以返回一个`DioError`对象，或返回`dio.reject(errMsg)`，
     // 这样请求将被中止并触发异常，上层catchError会被调用。
 }
 dio.interceptor.response.onSuccess = (Response response) {
     // 在返回响应数据之前做一些预处理
     return response; // continue
 };
 dio.interceptor.response.onError = (DioError e){
     // 当请求失败时做一些预处理
     return e;//continue
 }</code></pre>
<p>如果你想移除拦截器，你可以将它们置为null:</p>
<pre><code class="dart">  dio.interceptor.request.onSend = null;
  dio.interceptor.response.onSuccess = null;
  dio.interceptor.response.onError = null;</code></pre>
<h3 id="完成和终止请求-响应"><a href="#完成和终止请求-响应" class="headerlink" title="完成和终止请求/响应"></a>完成和终止请求/响应</h3><p>在所有拦截器中，你都可以改变请求执行流， 如果你想完成请求/响应并返回自定义数据，你可以返回一个 <code>Response</code> 对象或返回 <code>dio.resolve(data)</code>的结果。 如果你想终止(触发一个错误，上层<code>catchError</code>会被调用)一个请求/响应，那么可以返回一个<code>DioError</code> 对象或返回 <code>dio.reject(errMsg)</code> 的结果.</p>
<pre><code class="dart">  dio.interceptor.request.onSend = (Options options) {
    return dio.resolve(&quot;fake data&quot;)
  }
  Response response = await dio.get(&quot;/test&quot;);
  print(response.data); //&quot;fake data&quot;</code></pre>
<h3 id="拦截器中支持异步任务"><a href="#拦截器中支持异步任务" class="headerlink" title="拦截器中支持异步任务"></a>拦截器中支持异步任务</h3><p>拦截器中不仅支持同步任务，而且也支持异步任务, 下面是在请求拦截器中发起异步任务的一个实例:</p>
<pre><code class="dart">  dio.interceptor.request.onSend = (Options options) async {
     //...If no token, request token firstly.
     Response response = await dio.get(&quot;/token&quot;);
     //Set the token to headers
     options.headers[&quot;token&quot;] = response.data[&quot;data&quot;][&quot;token&quot;];
     return options; //continue
 }</code></pre>
<h3 id="Lock-unlock-拦截器"><a href="#Lock-unlock-拦截器" class="headerlink" title="Lock/unlock 拦截器"></a>Lock/unlock 拦截器</h3><p>你可以通过调用拦截器的 <code>lock()</code>/<code>unlock</code> 方法来锁定/解锁拦截器。一旦请求/响应拦截器被锁定，接下来的请求/响应将会在进入请求/响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行(进入拦截器)。这在一些需要串行化请求/响应的场景中非常实用，后面我们将给出一个示例。</p>
<pre><code class="dart">  tokenDio = new Dio(); //Create a new instance to request the token.
  tokenDio.options = dio;
  dio.interceptor.request.onSend = (Options options) async {
    // If no token, request token firstly and lock this interceptor
    // to prevent other request enter this interceptor.
    dio.interceptor.request.lock();
    // We use a new Dio(to avoid dead lock) instance to request token.
    Response response = await tokenDio.get(&quot;/token&quot;);
    //Set the token to headers
    options.headers[&quot;token&quot;] = response.data[&quot;data&quot;][&quot;token&quot;];
    dio.interceptor.request.unlock();
    return options; //continue
  }</code></pre>
<p><strong>Clear()</strong></p>
<p>你也可以调用拦截器的<code>clear()</code>方法来清空等待队列。</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>当<strong>请求</strong>拦截器被锁定时，接下来的请求将会暂停，这等价于锁住了dio实例，因此，Dio示例上提供了<strong>请求</strong>拦截器<code>lock/unlock</code>的别名方法：</p>
<p><strong>dio.lock() ==  dio.interceptor.request.lock()</strong></p>
<p><strong>dio.unlock() ==  dio.interceptor.request.unlock()</strong></p>
<p><strong>dio.clear() ==  dio.interceptor.request.clear()</strong></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设这么一个场景：出于安全原因，我们需要给所有的请求头中添加一个csrfToken，如果csrfToken不存在，我们先去请求csrfToken，获取到csrfToken后，再发起后续请求。 由于请求csrfToken的过程是异步的，我们需要在请求过程中锁定后续请求（因为它们需要csrfToken), 直到csrfToken请求成功后，再解锁，代码如下：</p>
<pre><code class="dart">dio.interceptor.request.onSend = (Options options) {
    print(&#39;send request：path:${options.path}，baseURL:${options.baseUrl}&#39;);
    if (csrfToken == null) {
      print(&quot;no token，request token firstly...&quot;);
      //lock the dio.
      dio.lock();
      return tokenDio.get(&quot;/token&quot;).then((d) {
        options.headers[&quot;csrfToken&quot;] = csrfToken = d.data[&#39;data&#39;][&#39;token&#39;];
        print(&quot;request token succeed, value: &quot; + d.data[&#39;data&#39;][&#39;token&#39;]);
        print(&#39;continue to perform request：path:${options.path}，baseURL:${options.path}&#39;);
        return options;
      }).whenComplete(() =&gt; dio.unlock()); // unlock the dio
    } else {
      options.headers[&quot;csrfToken&quot;] = csrfToken;
      return options;
    }
  };</code></pre>
<p>完整的示例代码请点击 <a href="https://github.com/flutterchina/dio/blob/flutter/example/interceptorLock.dart" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当请求过程中发生错误时, Dio 会包装 <code>Error/Exception</code> 为一个 <code>DioError</code>:</p>
<pre><code class="dart">  try {
    //404
    await dio.get(&quot;https://wendux.github.io/xsddddd&quot;);
  } on DioError catch (e) {
    // The request was made and the server responded with a status code
    // that falls out of the range of 2xx and is also not 304.
    if (e.response) {
      print(e.response.data);
      print(e.response.headers);
      print(e.response.request);
    } else {
      // Something happened in setting up or sending the request that triggered an Error
      print(e.request);
      print(e.message);
    }
  }</code></pre>
<h3 id="DioError-字段"><a href="#DioError-字段" class="headerlink" title="DioError 字段"></a>DioError 字段</h3><pre><code class="dart"> {
  /// 响应信息, 如果错误发生在在服务器返回数据之前，它为 `null`
  Response response;

  /// 错误描述.
  String message;

  /// 错误类型，见下文
  DioErrorType type;

  /// 错误栈信息，可能为null
  StackTrace stackTrace;
}</code></pre>
<h3 id="DioErrorType"><a href="#DioErrorType" class="headerlink" title="DioErrorType"></a>DioErrorType</h3><pre><code class="dart">enum DioErrorType {
  /// Default error type, usually occurs before connecting the server.
  DEFAULT,

  /// When opening  url timeout, it occurs.
  CONNECT_TIMEOUT,

  ///  Whenever more than [receiveTimeout] (in milliseconds) passes between two events from response stream,
  ///  [Dio] will throw the [DioError] with [DioErrorType.RECEIVE_TIMEOUT].
  ///
  ///  Note: This is not the receiving time limitation.
  RECEIVE_TIMEOUT,

  /// When the server response, but with a incorrect status, such as 404, 503...
  RESPONSE,

  /// When the request is cancelled, dio will throw a error with this type.
  CANCEL
}</code></pre>
<h2 id="使用application-x-www-form-urlencoded编码"><a href="#使用application-x-www-form-urlencoded编码" class="headerlink" title="使用application/x-www-form-urlencoded编码"></a>使用application/x-www-form-urlencoded编码</h2><p>默认情况下, Dio 会将请求数据(除过String类型)序列化为 <code>JSON</code>. 如果想要以 <code>application/x-www-form-urlencoded</code>格式编码, 你可以显式设置<code>contentType</code> :</p>
<pre><code class="dart">//Instance level
dio.options.contentType=ContentType.parse(&quot;application/x-www-form-urlencoded&quot;);
//or works once
dio.post(&quot;/info&quot;,data:{&quot;id&quot;:5}, options: new Options(contentType:ContentType.parse(&quot;application/x-www-form-urlencoded&quot;)));</code></pre>
<p>这里有一个<a href="https://github.com/flutterchina/dio/blob/flutter/example/options.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h2><p>Dio支持发送 FormData, 请求数据将会以 <code>multipart/form-data</code>方式编码, FormData中可以一个或多个包含文件 .</p>
<pre><code class="dart">FormData formData = new FormData.from({
    &quot;name&quot;: &quot;wendux&quot;,
    &quot;age&quot;: 25,
    &quot;file&quot;: new UploadFileInfo(new File(&quot;./example/upload.txt&quot;), &quot;upload.txt&quot;)
});
response = await dio.post(&quot;/info&quot;, data: formData);</code></pre>
<blockquote>
<p>注意: 只有 post 方法支持发送 FormData.</p>
</blockquote>
<p>这里有一个完整的<a href="https://github.com/flutterchina/dio/blob/flutter/example/formdata.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>转换器<code>Transformer</code> 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器<code>DefaultTransformer</code>作为默认的 <code>Transformer</code>. 如果你想对请求/响应数据进行自定义编解码处理，可以提供自定义转换器，通过 <code>dio.transformer</code>设置。</p>
<blockquote>
<p>请求转换器  <code>Transformer.transformRequest(...)</code>   只会被用于 ‘PUT’、 ‘POST’、 ‘PATCH’方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 <code>Transformer.transformResponse()</code> 会被用于所有请求方法的返回数据。</p>
</blockquote>
<h3 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h3><p>虽然在拦截器中也可以对数据进行预处理，但是转换器主要职责是对请求/响应数据进行编解码，之所以将转化器单独分离，一是为了和拦截器解耦，二是为了不修改原始请求数据(如果你在拦截器中修改请求数据(options.data)，会覆盖原始请求数据，而在某些时候您可能需要原始请求数据). Dio的请求流是：</p>
<p><em>请求拦截器</em> &gt;&gt; <em>请求转换器</em> &gt;&gt; <em>发起请求</em>  &gt;&gt; <em>响应转换器</em>  &gt;&gt; <em>响应拦截器</em>  &gt;&gt; <em>最终结果</em>。</p>
<p>这是一个自定义转换器的<a href="https://github.com/wendux/dio/blob/flutter/example/Transformer.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="设置Http代理"><a href="#设置Http代理" class="headerlink" title="设置Http代理"></a>设置Http代理</h2><p>Dio 是使用 HttpClient发起的http请求，所以你可以通过配置 <code>httpClient</code>来支持代理，示例如下：</p>
<pre><code class="dart">  dio.onHttpClientCreate = (HttpClient client) {
    client.findProxy = (uri) {
      //proxy all request to localhost:8888
      return &quot;PROXY localhost:8888&quot;;
    };
    // 你也可以自己创建一个新的HttpClient实例返回。
    // return new HttpClient(SecurityContext);
  };</code></pre>
<p>完整的示例请查看<a href="https://github.com/wendux/dio/tree/flutter/example/proxy.dart" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="Https证书校验"><a href="#Https证书校验" class="headerlink" title="Https证书校验"></a>Https证书校验</h2><p>有两种方法可以校验https证书，假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下：</p>
<pre><code class="dart">  String PEM=&quot;XXXXX&quot;; //证书内容
  dio.onHttpClientCreate = (HttpClient client) {
    client.badCertificateCallback=(X509Certificate cert, String host, int port){
      if(cert.pem==PEM){ // 证书一致，则放行
        return true; 
      }
      return false;
    };
  };</code></pre>
<p><code>X509Certificate</code>是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。</p>
<p>对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到<code>badCertificateCallback</code>回调中：</p>
<pre><code class="dart">  dio.onHttpClientCreate = (HttpClient client) {
    SecurityContext sc = new SecurityContext();
    //file为证书路径
    sc.setTrustedCertificates(file);
    HttpClient httpClient = new HttpClient(context: sc);
    return httpClient;
  };</code></pre>
<p>注意，通过<code>setTrustedCertificates()</code>设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。</p>
<h2 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h2><p>你可以通过 <em>cancel token</em> 来取消发起的请求：</p>
<pre><code class="dart">CancelToken token = new CancelToken();
dio.get(url, cancelToken: token)
    .catchError((DioError err){
        if (CancelToken.isCancel(err)) {
            print(&#39;Request canceled! &#39;+ err.message)
        }else{
            // handle error.
        }
    });
// cancel the requests with &quot;cancelled&quot; message.
token.cancel(&quot;cancelled&quot;);</code></pre>
<blockquote>
<p>注意: 同一个cancel token 可以用于多个请求，当一个cancel token取消时，所有使用该cancel token的请求都会被取消。</p>
</blockquote>
<p>完整的示例请参考<a href="https://github.com/flutterchina/dio/blob/flutter/example/cancelRequest.dart" target="_blank" rel="noopener">取消示例</a>.</p>
<h2 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h2><p>你可以通过 <code>cookieJar</code> 来自动管理请求/响应cookie.</p>
<blockquote>
<p> dio cookie 管理 API 是基于开源库 <a href="https://github.com/flutterchina/cookie_jar" target="_blank" rel="noopener">cookie_jar</a>.</p>
</blockquote>
<p>你可以创建一个<code>CookieJar</code> 或 <code>PersistCookieJar</code> 来帮您自动管理cookie,  dio 默认使用  <code>CookieJar</code> , 它会将cookie保存在内存中。 如果您想对cookie进行持久化,  请使用 <code>PersistCookieJar</code> ,  示例代码如下:</p>
<pre><code class="dart">var dio = new Dio();
dio.cookieJar = new PersistCookieJar(&quot;./cookies&quot;);</code></pre>
<p><code>PersistCookieJar</code> 实现了RFC中标准的cookie策略.  <code>PersistCookieJar</code> 会将cookie保存在文件中，所以 cookies 会一直存在除非显式调用 <code>delete</code> 删除.</p>
<p>更多关于 <a href="https://github.com/flutterchina/" target="_blank" rel="noopener">cookie_jar</a>  请参考 : <a href="https://github.com/flutterchina/cookie_jar" target="_blank" rel="noopener">https://github.com/flutterchina/cookie_jar</a> .</p>
<h2 id="Copyright-amp-License"><a href="#Copyright-amp-License" class="headerlink" title="Copyright &amp; License"></a>Copyright &amp; License</h2><p>此开源项目为Flutter中文网(<a href="https://flutterchina.club" target="_blank" rel="noopener">https://flutterchina.club</a>) 授权 ，license 是 MIT.   如果您喜欢，欢迎star.</p>
<p><strong>Flutter中文网开源项目计划</strong></p>
<p>开发一系列Flutter SDK之外常用(实用)的Package、插件，丰富Flutter第三方库，为Flutter生态贡献来自中国开发者的力量。所有项目将发布在 <a href="https://github.com/flutterchina/" target="_blank" rel="noopener">Github Flutter中文网 Organization</a> ，所有源码贡献者将加入到我们的Organization，成为成员. 目前社区已有几个开源项目开始公测，欢迎您加入开发或测试，详情请查看: <a href="https://flutterchina.club/opensource.html" target="_blank" rel="noopener">Flutter中文网开源项目</a>。 如果您想加入到“开源项目计划”， 请发邮件到<a href="mailto:824783146@qq.com" target="_blank" rel="noopener">824783146@qq.com</a>， 并附上自我介绍(个人基本信息+擅长/关注技术)。</p>
<h2 id="Features-and-bugs"><a href="#Features-and-bugs" class="headerlink" title="Features and bugs"></a>Features and bugs</h2><p>Please file feature requests and bugs at the <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">issue tracker</a>.</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/categories/文章/page/4/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/文章/page/6/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/文章/">1</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/文章/page/4/">4</a></li>
            
            <li><a class="pagination-link is-current" href="/categories/文章/page/5/">5</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/文章/page/6/">6</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/文章/page/7/">7</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="https://user-gold-cdn.xitu.io/2018/8/13/16530d7f26a413c2?imageView2/1/w/180/h/180/q/85/format/webp/interlace/1" alt="Time">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Time
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Developer
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Earth, Solar System</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            92
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            5
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            117
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/hsutimes" target="_blank">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/hsutimes">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Facebook" href="https://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Twitter" href="https://twitter.com/times26740863">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Dribbble" href="https://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/hsutimes" target="_blank">
                    <span class="level-left">
                        <span class="level-item">PPOffice</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https:hsutimes.club" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Time</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hsutimes.club</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/人工智能/">
            <span class="level-start">
                <span class="level-item">人工智能</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/文章/">
            <span class="level-start">
                <span class="level-item">文章</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">74</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/生活/">
            <span class="level-start">
                <span class="level-item">生活</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/笔试/">
            <span class="level-start">
                <span class="level-item">笔试</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/算法/">
            <span class="level-start">
                <span class="level-item">算法</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/11/14/hexo-theme-icarus/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/desert.jpg" alt="ICRUS">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-14T14:09:12.000Z">2019-11-14</time></div>
                    <a href="/2019/11/14/hexo-theme-icarus/" class="title has-link-black-ter is-size-6 has-text-weight-normal">ICRUS</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/13/3sum/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="3sum">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-13T13:12:37.000Z">2019-11-13</time></div>
                    <a href="/2019/11/13/3sum/" class="title has-link-black-ter is-size-6 has-text-weight-normal">3sum</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/12/minio/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="minio">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-12T14:22:14.000Z">2019-11-12</time></div>
                    <a href="/2019/11/12/minio/" class="title has-link-black-ter is-size-6 has-text-weight-normal">minio</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/11/graph-convolution/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="graph-convolution">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-11T15:22:46.000Z">2019-11-11</time></div>
                    <a href="/2019/11/11/graph-convolution/" class="title has-link-black-ter is-size-6 has-text-weight-normal">graph-convolution</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/10/falling-stone/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="falling-stone">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T14:49:09.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/falling-stone/" class="title has-link-black-ter is-size-6 has-text-weight-normal">falling-stone</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">16</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">40</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/2019/">
                        <span class="tag">2019</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/AI/">
                        <span class="tag">AI</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ASM/">
                        <span class="tag">ASM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Android/">
                        <span class="tag">Android</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B+树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B-树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Flutter/">
                        <span class="tag">Flutter</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Global/">
                        <span class="tag">Global </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HashMap/">
                        <span class="tag">HashMap</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Http/">
                        <span class="tag">Http</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ICRUS/">
                        <span class="tag">ICRUS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JNA/">
                        <span class="tag">JNA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">13</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Key/">
                        <span class="tag">Key </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/MD5/">
                        <span class="tag">MD5</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/NLP/">
                        <span class="tag">NLP</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Nodejs/">
                        <span class="tag">Nodejs</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OCR/">
                        <span class="tag">OCR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OpenCV/">
                        <span class="tag">OpenCV</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/RSA/">
                        <span class="tag">RSA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring-Boot/">
                        <span class="tag">Spring Boot</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack-Overflow/">
                        <span class="tag">Stack Overflow</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TabNine/">
                        <span class="tag">TabNine</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TensorFlow/">
                        <span class="tag">TensorFlow</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/VR/">
                        <span class="tag">VR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Windows/">
                        <span class="tag">Windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Xbox/">
                        <span class="tag">Xbox</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/dio/">
                        <span class="tag">dio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/edb/">
                        <span class="tag">edb</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/electron/">
                        <span class="tag">electron</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/github/">
                        <span class="tag">github</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hexo/">
                        <span class="tag">hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jad/">
                        <span class="tag">jad</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/lazydocker/">
                        <span class="tag">lazydocker</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/minio/">
                        <span class="tag">minio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/nohup/">
                        <span class="tag">nohup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/openssl/">
                        <span class="tag">openssl</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sha256/">
                        <span class="tag">sha256</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/webhooks/">
                        <span class="tag">webhooks</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/windows/">
                        <span class="tag">windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/x64dbg/">
                        <span class="tag">x64dbg</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/书籍/">
                        <span class="tag">书籍</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二叉树/">
                        <span class="tag">二叉树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/人工智能/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/信息安全/">
                        <span class="tag">信息安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/军事/">
                        <span class="tag">军事</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/加密算法/">
                        <span class="tag">加密算法</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/卷积神经网络/">
                        <span class="tag">卷积神经网络</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/双指针/">
                        <span class="tag">双指针</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反汇编/">
                        <span class="tag">反汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反编译/">
                        <span class="tag">反编译</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/后缀表达式/">
                        <span class="tag">后缀表达式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/国家/">
                        <span class="tag">国家</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/备份/">
                        <span class="tag">备份</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/天平/">
                        <span class="tag">天平</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/安全/">
                        <span class="tag">安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/工具/">
                        <span class="tag">工具</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/战斗机/">
                        <span class="tag">战斗机</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/拟真/">
                        <span class="tag">拟真</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/指纹/">
                        <span class="tag">指纹</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/推荐系统/">
                        <span class="tag">推荐系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/搜索引擎/">
                        <span class="tag">搜索引擎</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/操作系统/">
                        <span class="tag">操作系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数据库/">
                        <span class="tag">数据库</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数组/">
                        <span class="tag">数组</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/文章/">
                        <span class="tag">文章</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/暴力破解/">
                        <span class="tag">暴力破解</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/机器学习/">
                        <span class="tag">机器学习</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/树/">
                        <span class="tag">树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/框架/">
                        <span class="tag">框架</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/模拟/">
                        <span class="tag">模拟</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编/">
                        <span class="tag">汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编语言/">
                        <span class="tag">汇编语言</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/游戏/">
                        <span class="tag">游戏</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/爱因斯坦/">
                        <span class="tag">爱因斯坦</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/狂野飙车/">
                        <span class="tag">狂野飙车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/百科/">
                        <span class="tag">百科</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/相对论/">
                        <span class="tag">相对论</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/矩阵/">
                        <span class="tag">矩阵</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/算法/">
                        <span class="tag">算法</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/素数/">
                        <span class="tag">素数</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/红黑树/">
                        <span class="tag">红黑树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程/">
                        <span class="tag">编程</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程思想/">
                        <span class="tag">编程思想</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/网络安全/">
                        <span class="tag">网络安全</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/脚本/">
                        <span class="tag">脚本</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/自动化部署/">
                        <span class="tag">自动化部署</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/行业分析/">
                        <span class="tag">行业分析</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/计算机视觉/">
                        <span class="tag">计算机视觉</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/论文/">
                        <span class="tag">论文</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/诺贝尔奖/">
                        <span class="tag">诺贝尔奖</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/跑车/">
                        <span class="tag">跑车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/边缘检测/">
                        <span class="tag">边缘检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/逆向工程/">
                        <span class="tag">逆向工程</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/递归/">
                        <span class="tag">递归</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/链表/">
                        <span class="tag">链表</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/陨石/">
                        <span class="tag">陨石</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/面试/">
                        <span class="tag">面试</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/飞行/">
                        <span class="tag">飞行</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/魔方/">
                        <span class="tag">魔方</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/黄山/">
                        <span class="tag">黄山</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/11/14/hexo-theme-icarus/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/desert.jpg" alt="ICRUS">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-14T14:09:12.000Z">2019-11-14</time></div>
                    <a href="/2019/11/14/hexo-theme-icarus/" class="title has-link-black-ter is-size-6 has-text-weight-normal">ICRUS</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/13/3sum/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="3sum">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-13T13:12:37.000Z">2019-11-13</time></div>
                    <a href="/2019/11/13/3sum/" class="title has-link-black-ter is-size-6 has-text-weight-normal">3sum</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/12/minio/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="minio">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-12T14:22:14.000Z">2019-11-12</time></div>
                    <a href="/2019/11/12/minio/" class="title has-link-black-ter is-size-6 has-text-weight-normal">minio</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/11/graph-convolution/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="graph-convolution">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-11T15:22:46.000Z">2019-11-11</time></div>
                    <a href="/2019/11/11/graph-convolution/" class="title has-link-black-ter is-size-6 has-text-weight-normal">graph-convolution</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/11/10/falling-stone/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="falling-stone">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-10T14:49:09.000Z">2019-11-10</time></div>
                    <a href="/2019/11/10/falling-stone/" class="title has-link-black-ter is-size-6 has-text-weight-normal">falling-stone</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/文章/">文章</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">16</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">40</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/2019/">
                        <span class="tag">2019</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/AI/">
                        <span class="tag">AI</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ASM/">
                        <span class="tag">ASM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Android/">
                        <span class="tag">Android</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B+树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/B-树/">
                        <span class="tag">B-树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Flutter/">
                        <span class="tag">Flutter</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Global/">
                        <span class="tag">Global </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HashMap/">
                        <span class="tag">HashMap</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Http/">
                        <span class="tag">Http</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ICRUS/">
                        <span class="tag">ICRUS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JNA/">
                        <span class="tag">JNA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">13</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Key/">
                        <span class="tag">Key </span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/MD5/">
                        <span class="tag">MD5</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/NLP/">
                        <span class="tag">NLP</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Nodejs/">
                        <span class="tag">Nodejs</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OCR/">
                        <span class="tag">OCR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/OpenCV/">
                        <span class="tag">OpenCV</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/RSA/">
                        <span class="tag">RSA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring-Boot/">
                        <span class="tag">Spring Boot</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack-Overflow/">
                        <span class="tag">Stack Overflow</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TabNine/">
                        <span class="tag">TabNine</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/TensorFlow/">
                        <span class="tag">TensorFlow</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/VR/">
                        <span class="tag">VR</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Windows/">
                        <span class="tag">Windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Xbox/">
                        <span class="tag">Xbox</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/c/">
                        <span class="tag">c++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/dio/">
                        <span class="tag">dio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/edb/">
                        <span class="tag">edb</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/electron/">
                        <span class="tag">electron</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/github/">
                        <span class="tag">github</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hexo/">
                        <span class="tag">hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jad/">
                        <span class="tag">jad</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/lazydocker/">
                        <span class="tag">lazydocker</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/minio/">
                        <span class="tag">minio</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/nohup/">
                        <span class="tag">nohup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/openssl/">
                        <span class="tag">openssl</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sha256/">
                        <span class="tag">sha256</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/webhooks/">
                        <span class="tag">webhooks</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/windows/">
                        <span class="tag">windows</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/x64dbg/">
                        <span class="tag">x64dbg</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/书籍/">
                        <span class="tag">书籍</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二叉树/">
                        <span class="tag">二叉树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/人工智能/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/信息安全/">
                        <span class="tag">信息安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/军事/">
                        <span class="tag">军事</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/加密算法/">
                        <span class="tag">加密算法</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/卷积神经网络/">
                        <span class="tag">卷积神经网络</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/双指针/">
                        <span class="tag">双指针</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反汇编/">
                        <span class="tag">反汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/反编译/">
                        <span class="tag">反编译</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/后缀表达式/">
                        <span class="tag">后缀表达式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/国家/">
                        <span class="tag">国家</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/备份/">
                        <span class="tag">备份</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/天平/">
                        <span class="tag">天平</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/安全/">
                        <span class="tag">安全</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/工具/">
                        <span class="tag">工具</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/战斗机/">
                        <span class="tag">战斗机</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/拟真/">
                        <span class="tag">拟真</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/指纹/">
                        <span class="tag">指纹</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/推荐系统/">
                        <span class="tag">推荐系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/搜索引擎/">
                        <span class="tag">搜索引擎</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/操作系统/">
                        <span class="tag">操作系统</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数据库/">
                        <span class="tag">数据库</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/数组/">
                        <span class="tag">数组</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/文章/">
                        <span class="tag">文章</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/暴力破解/">
                        <span class="tag">暴力破解</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/机器学习/">
                        <span class="tag">机器学习</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/树/">
                        <span class="tag">树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/框架/">
                        <span class="tag">框架</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/模拟/">
                        <span class="tag">模拟</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编/">
                        <span class="tag">汇编</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/汇编语言/">
                        <span class="tag">汇编语言</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/游戏/">
                        <span class="tag">游戏</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/爱因斯坦/">
                        <span class="tag">爱因斯坦</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/狂野飙车/">
                        <span class="tag">狂野飙车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/百科/">
                        <span class="tag">百科</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/相对论/">
                        <span class="tag">相对论</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/矩阵/">
                        <span class="tag">矩阵</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/算法/">
                        <span class="tag">算法</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/素数/">
                        <span class="tag">素数</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/红黑树/">
                        <span class="tag">红黑树</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程/">
                        <span class="tag">编程</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/编程思想/">
                        <span class="tag">编程思想</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/网络安全/">
                        <span class="tag">网络安全</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/脚本/">
                        <span class="tag">脚本</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/自动化部署/">
                        <span class="tag">自动化部署</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/行业分析/">
                        <span class="tag">行业分析</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/计算机视觉/">
                        <span class="tag">计算机视觉</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/论文/">
                        <span class="tag">论文</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/诺贝尔奖/">
                        <span class="tag">诺贝尔奖</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/跑车/">
                        <span class="tag">跑车</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/边缘检测/">
                        <span class="tag">边缘检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/逆向工程/">
                        <span class="tag">逆向工程</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/递归/">
                        <span class="tag">递归</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/链表/">
                        <span class="tag">链表</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/陨石/">
                        <span class="tag">陨石</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/面试/">
                        <span class="tag">面试</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/飞行/">
                        <span class="tag">飞行</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/魔方/">
                        <span class="tag">魔方</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/黄山/">
                        <span class="tag">黄山</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Time" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 times&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/hsutimes/hsutimes.github.io">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
<script src="/js/animation.js"></script>

    
    
<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>

    
    
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>

    
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>
    
    
<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>

    
    
    
    
    
    
    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>