<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Time</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Time">
<meta property="og:url" content="https://blog.hsutimes.com/page/2/index.html">
<meta property="og:site_name" content="Time">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Time">
  
    <link rel="alternate" href="/atom.xml" title="Time" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Time</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">time</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.hsutimes.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TensorFlow-2-0-RC-is-available" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/12/TensorFlow-2-0-RC-is-available/" class="article-date">
  <time datetime="2019-09-12T13:41:44.000Z" itemprop="datePublished">2019-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/12/TensorFlow-2-0-RC-is-available/">TensorFlow 2.0 RC is available</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/2019/09/12/fc47ee60-d560-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h1 id="TensorFlow-2-0-RC"><a href="#TensorFlow-2-0-RC" class="headerlink" title="TensorFlow 2.0 RC"></a>TensorFlow 2.0 RC</h1><p>工具<br>探索可支持和加速 TensorFlow 工作流程的工具。</p>
<p><img src="/images/2019/09/12/0d102030-d563-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h2 id="CoLab"><a href="#CoLab" class="headerlink" title="CoLab"></a>CoLab</h2><p>Colaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您只需点击一下鼠标，即可在浏览器中执行 TensorFlow 代码。</p>
<h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>一套可视化工具，用于理解、调试和优化TensorFlow程序。</p>
<h2 id="What-If工具"><a href="#What-If工具" class="headerlink" title="What-If工具"></a>What-If工具</h2><p>一种无代码的方式探究机器学习模型的工具，对模型的理解、调试和公平性很有用。可在TensorFlow和Jupyter或CoLab笔记本中使用。</p>
<h2 id="ML-Perf"><a href="#ML-Perf" class="headerlink" title="ML Perf"></a>ML Perf</h2><p>全面的机器学习基准测试套件，用于衡量机器学习软件框架、机器学习硬件加速器和机器学习云端平台的性能。</p>
<h2 id="XLA"><a href="#XLA" class="headerlink" title="XLA"></a>XLA</h2><p>XLA(加速线性代数)是一种特定领域的线性代数编译器，能够优化TensorFlow计算，它可以提高服务器和移动平台的运行速度改进内存使用情况和可移植性。</p>
<h2 id="TensorFlow-Playground"><a href="#TensorFlow-Playground" class="headerlink" title="TensorFlow Playground"></a>TensorFlow Playground</h2><p>在浏览器中设计神经网络。别担心，不会使浏览器崩溃。</p>
<h2 id="TensorFlow-Research-Cloud"><a href="#TensorFlow-Research-Cloud" class="headerlink" title="TensorFlow Research Cloud"></a>TensorFlow Research Cloud</h2><p>加入TensorFlow Research Cloud（TFRC）计划后，研究人员可于申请访问Cloud TPU来加快实现下一波研究突破；我们免费提供1000个Cloud TPU.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/12/TensorFlow-2-0-RC-is-available/" data-id="ck0gqz2u90000nggb1fcan40g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nohup-在linux后台运行程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/12/nohup-在linux后台运行程序/" class="article-date">
  <time datetime="2019-09-12T13:15:04.000Z" itemprop="datePublished">2019-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/12/nohup-在linux后台运行程序/">nohup:在linux后台运行程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/2019/09/12/0188c220-d55f-11e9-b847-b9c45ddd4bb9.png" alt="image.png"></p>
<h1 id="nohup-在linux后台运行程序"><a href="#nohup-在linux后台运行程序" class="headerlink" title="nohup:在linux后台运行程序"></a>nohup:在linux后台运行程序</h1><p>今天在工作中，lz要在Linux系统上运行一个java程序，这个程序要在系统中持续运行。随后lz无意将ssh窗口关掉了，发现java程序停止了。原来，当使用ssh连接到系统运行程序的时候，该程序已经和你的ssh连接绑定了。如果你关闭连接，该程序就会停止。还有一个情景：如果要在后台运行多个java程序的时候，就需要启动多个ssh窗口，这样很麻烦。有没有方法来解决这个问题呢？答案是肯定的。</p>
<p>1.使用nohup来执行命令，它会把命令自动调到linux后台运行，不锁定当前ssh窗口，也不会被ctrl + c，alt + F4之类打断程序的动行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar test.jar &amp;</span><br></pre></td></tr></table></figure>

<p>执行完该命令后，终端会显示如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 27945</span><br><span class="line">nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;</span><br></pre></td></tr></table></figure>

<p>[1]：该后台任务的jobid<br>27945：是该进程的pid<br>nohup.out：是该任务的输出位置</p>
<p>2.要指定重定向的文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>3.如果一个任务已经在前台执行，那就使用以下方法来将任务调整到后台：</p>
<p>（1）首先，在正在执行任务的终端使用ctrl+z</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  已停止               java -jar test.jar</span><br></pre></td></tr></table></figure>

<p>（2）使用bg命令将该任务调整至后台（fg与之相反，将后台任务调整至前台）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %1(1是jobid)</span><br></pre></td></tr></table></figure>

<p>如果不知道jobid，也可以使用jobs命令来查询。</p>
<p>但是任务的输出还是会打印到终端上的（具体怎么将输出重定向到别的地方，lz也不造）。而且，这时该任务还是与当前终端相关联的，关闭终端还是会断掉该任务的。使用下面命令来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disown -h %1</span><br></pre></td></tr></table></figure>

<p>这样再也不用担心关掉终端会停止掉任务喽！！！</p>
<p>PS：再来说说nohup吧。nohup的意思是no hang up，就是说关掉终端是不会挂掉程序的。如果开始执行命令时只使用&amp;：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar test.jar &amp;</span><br></pre></td></tr></table></figure>

<p>那么该任务也会在后台执行，但是一旦关掉终端该任务还是会挂掉，所以这就是nohup的用处了。</p>
<p><a href="http://ee-dreamer.com/?p=327" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/12/nohup-在linux后台运行程序/" data-id="ck0gptkv20000p8gbki1j2l8d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nohup/">nohup</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-骨传导" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/12/骨传导/" class="article-date">
  <time datetime="2019-09-12T11:49:16.000Z" itemprop="datePublished">2019-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/12/骨传导/">骨传导</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="骨传导"><a href="#骨传导" class="headerlink" title="骨传导"></a>骨传导</h1><p><img src="/images/2019/09/12/3570d660-d553-11e9-b519-9f31cc87a9f9.png" alt="image.png"></p>
<p>骨传导是一种声音传导方式，即通过将声音转化为不同频率的机械振动，通过人的颅骨、骨迷路、内耳淋巴液传递、螺旋器、听神经、听觉中枢来传递声波。相对于通过振膜产生声波的经典声音传导方式，骨传导省去了许多声波传递的步骤，能在嘈杂的环境中实现清晰的声音还原，而且声波也不会因为在空气中扩散而影响到他人。</p>
<p>骨传导技术分为骨传导扬声器技术和骨传导麦克风技术：</p>
<ol>
<li>骨传导扬声器技术 用于受话，受话即听取声音。气导扬声器是把电信号转化为的声波（振动信号传至听神经。而骨传导扬声器则是电信号转化的声波（振动信号）直接通过骨头传至听神经。声波（振动信号）的传递介质不同。</li>
<li>骨传导麦克风技术 用于送话，送话即收集声音。气导送话是声波通过空气传至麦克风，而骨传导送话则直接通过骨头传递。</li>
</ol>
<p>利用这些骨传导技术制造的耳机，称之为骨传导耳机，也被称作骨导耳机、骨感耳机、骨传耳机和骨传感耳机。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%AA%A8%E4%BC%A0%E5%AF%BC" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/12/骨传导/" data-id="ck0gmrs5e0000zogbz8t9jzdi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/百科/">百科</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三阶魔方解法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/12/三阶魔方解法/" class="article-date">
  <time datetime="2019-09-12T10:09:12.000Z" itemprop="datePublished">2019-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/12/三阶魔方解法/">三阶魔方解法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="三阶魔方解法"><a href="#三阶魔方解法" class="headerlink" title="三阶魔方解法"></a>三阶魔方解法</h1><p>预备篇：三阶魔方相关知识<br>在本教程中，统一使用官方配色（上黄、下白、左橙、右红、前蓝、后绿），并在还原的过程中，白色作为底色。</p>
<p>下图中，A、B、C分别表示顶层、中层、底层；D为中心块，在还原的过程中以此作为参照色（即该面所最终还原的颜色）；E为棱块，每块有两个颜色；F为角块，每块有三个颜色。</p>
<p>在本教程中，分别用Front、Back、Left、Right、Up、Down的首字母表示前面、后面、左面、右面、上面、下面的顺时针90度旋转，带撇号的为逆时针90度逆转，带数字2的为180度旋转。</p>
<p><img src="/images/2019/09/12/15512550-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p><img src="/images/2019/09/12/196bddb0-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p>第一步：完成底层四棱<br>子步骤一：拼成黄心白瓣小花<br>如下图①所示，我们只要在黄色中心块的四周的棱块都挨着白色即可。</p>
<p>对于在中层的白色棱，如②所示，只需转一个90度即可将白色朝上；对于在顶层、底层朝外的白色棱，如③所示，先在白色所在面转动90度后变成②的情况再处理；而在底层朝下的白色棱，如④所示，则通过180度旋转即可将白色朝上。</p>
<p>值得留意的是⑤之类的情况，如果直接转90度将中层白色块朝上，那么会破坏掉上方原先已有的白色块。此时要先转动顶层（此例为U’），将空位转到对应位置，方可使该白色块转上去。</p>
<p><img src="/images/2019/09/12/2458a640-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p>子步骤二：找到相应颜色并掉落花瓣<br>先随意选定一个白色棱（下图以白红棱为例），转动顶层（或扭转中底层），直到该棱侧面的颜色与中心块吻合时，以该中心块为轴转动180度，使其落到白色中心旁边。用同样的方法处理其他三个棱之后，在底层会形成白色的十字，棱的侧面也与中心块相连。</p>
<p><img src="/images/2019/09/12/29f0fdf0-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p>第二步：完成底层四角<br>这一步我们不仅要让白色的四角全都聚集在下面，还要留意其角块侧面的颜色也要吻合。</p>
<p>如下图的上半部分所示，我们先在顶层寻找含白色的角块，同时观察该角块另外两种颜色，转动顶层（或扭转中底层），使之处在相应颜色的两个中心块之间。</p>
<p>当角块转到相应位置后，观察白色的朝向，做相应的公式：</p>
<p>①为白色朝右，做U’ F’ U F；<br>②为白色朝前，做U R U’ R’；<br>③为白色朝上，做三遍的公式①。<br>当顶层无任何白色角块时，此时再观察底层有无错误朝向或位置的白色角块：</p>
<p>④在底层，白色朝右，做两遍的公式①；<br>⑤在底层，白色朝前，做两遍的公式②；<br>⑥在底层，错误位置角块，先做公式①将其赶回顶层，然后找到相应正确位置还原。<br>用同样的方法处理其他三个角之后，底面为全白色，侧面会形成倒T字。</p>
<p><img src="/images/2019/09/12/32aa1da0-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p>第三步：完成中层四棱<br>如下图的上半部分所示，我们先在顶层寻找不含黄色的棱块，同时观察该棱块另外两种颜色，转动顶层（或扭转中底层），使之朝外的颜色与中心块相吻合。</p>
<p>当棱块转到相应位置后，观察最终所归的空位，并将空位置于右前方，做相应的公式（前面的公式①与②，在这里称为甲与乙）：</p>
<p>①情况做U’ F’ U F U R U’ R’（先甲后乙）；<br>②情况做U R U’ R’ U’ F’ U F（先乙后甲）；<br>当顶层全为有黄色的棱块时，此时再观察中层有无错误朝向或位置的棱块：</p>
<p>③与④情况，先做甲+乙将其赶回顶层，然后找到相应正确位置还原。<br>用同样的方法处理其他三个棱之后，第二层即完成。</p>
<p><img src="/images/2019/09/12/3a6a1040-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png"></p>
<p>第四步：完成顶面十字<br>现在观察顶面的棱与中心块所构成的图形（忽视角块黄色是否朝上与否）分为“点、线、拐、十字”四种情况。找到相应的情况并按图示朝向摆放后，按照下流程图每次做R’ U’ F’ U F R（R’+甲+R）直到变成十字为止。其中“线”的情况还有一条捷径，即F R U R’ U’ F’。</p>
<p><img src="/images/2019/09/12/3e428f80-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png">Cube solve 7a.png</p>
<p>第五步：调整顶棱顺序<br>先转动顶层（或扭转中底层），直到至少有两个棱侧面的颜色与中心块吻合。</p>
<p>现在观察另外两个错误的棱处于相邻还是相对位置，如果没有，则此步跳过；如果是相邻的，则将两个错误的置一前一右，做丙公式U’ F’ U’ F U’ F’ U2 F；如果是相对的，则将两个错误的置一左一后，先做丙公式，然后转下顶层变为相邻的，再置一前一右做丙公式完成。</p>
<p><img src="/images/2019/09/12/42486050-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png">Cube solve 8.png</p>
<p>第六步：调整顶角顺序<br>观察顶角，找到在正确位置的一个角（朝向是否正确暂时不考虑）。如果四角都在正确位置，则此步跳过；如果只有一个，则将正确的角置于左前方，做丁公式U’ L’ U R U’ L U R’（做一遍仍未成功则再做第二遍）；如果没有一个角在正确位置，则先做丁公式然后变成有一个角在正确位置再相应处理。</p>
<p><img src="/images/2019/09/12/48ad7de0-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png">Cube solve 9.png</p>
<p>第七步：调整顶角朝向<br>此时我们统一将蓝色中心块保持前面放置，需要注意的是在操作的过程中魔方的底层会被暂时性打乱，不过不要紧，只要正确操作完后魔方会正常还原。</p>
<p>观察顶层前右方的角块的黄色朝向，做戊公式F’ R F R’二或四遍使黄色朝上。完成一个角块的朝向处理之后，要转动顶层（U、U’、U2），并保持蓝色中心块在前面不动，再处理其他角块朝向。(在每一角落都要扭)</p>
<p><img src="/images/2019/09/12/4cc8d280-d545-11e9-8235-2d6944e8ee9c.png" alt="image.png">Cube solve 10.png</p>
<p><a href="https://zh.wikibooks.org/zh-hans/%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9%E8%A7%A3%E6%B3%95" target="_blank" rel="noopener">维基百科</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/12/三阶魔方解法/" data-id="ck0gj8yt2000zf4gb6o915iei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/魔方/">魔方</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git-Rebase-黄金法则问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/10/Git-Rebase-黄金法则问题/" class="article-date">
  <time datetime="2019-09-10T13:45:18.000Z" itemprop="datePublished">2019-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/10/Git-Rebase-黄金法则问题/">Git Rebase 黄金法则问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-Rebase-黄金法则问题"><a href="#Git-Rebase-黄金法则问题" class="headerlink" title="Git Rebase 黄金法则问题"></a>Git Rebase 黄金法则问题</h1><p>git 整合来自不同分支的修改主要有两种方法：merge 操作和rebase操作，<br>merge初学者可能很熟悉。我们今天来主要说一下 rebase 操作，文章结尾会简单说一下 merge 操作的 –no-ff 参数问题。</p>
<p>rebase的简单定义：你可以把某一分支的所有修改都移至另外一个分支就像重新播放一样。<br>有点儿像金庸武侠小说里面的乾坤大挪移。<br>举个🌰<br>假设我们本地库的代码，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C  remotes/origin/master</span><br><span class="line">     /</span><br><span class="line">D---E---F---G  master</span><br></pre></td></tr></table></figure>

<p>如果此时我们执行 git pull 操作，就会变成下面的样子，因为 pull 默认执行的是 merge 操作，多出来H这次没必要的提交。如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     A---B---C  remotes/origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>如果我们执行 git pull –rebase 操作，将会变成下面的样子，这里我们用rebase代替了默认的merge操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            remotes/origin</span><br><span class="line">                |</span><br><span class="line">D---E---A---B---C---F---G</span><br><span class="line">                        |</span><br><span class="line">                        master</span><br></pre></td></tr></table></figure>

<p>rebase 作用就是变成线性了，这在多人协作的情况变得非常关键。因为多人合作是不允许随意制造分叉的。大家可以参考我这篇文章。</p>
<p>这就引出了这篇博文要主要阐述的问题，rebase golden rule 问题。</p>
<blockquote>
<p>Rebase golden rule<br>“No one shall rebase a shared branch” — Everyone about rebase</p>
</blockquote>
<p>简单来说就是不要在你的公共分支上做任何rebase操作。<br>再举一个🌰。</p>
<p>图一是我们做rebase操作前的样子</p>
<p><img src="/images/2019/09/10/75e5c990-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>图二是我们正确rebase的结果，即在feature分支执行rebase develop命令</p>
<p><img src="/images/2019/09/10/7a0f9d20-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>图三是我们错误rebase的结果，即违反黄金法则的结果，我们在develop分支上执行了rebase feature操作</p>
<p><img src="/images/2019/09/10/7ce48f10-d3d1-11e9-903f-858fa70b7712.png" alt="image.png"></p>
<p>当我们在图三这种情况下对develop分支进行提交的话，会发现和远程分支冲突，然后我们手动或自动解决冲突，继续提交上去之后发现，我们修改的功能代码已经提交上去了，但是当我们看我们提交历史的记录的时候会发现有一部分重复的提交log。<br>这就是问题所在，你的项目组长是绝对不允许在他的项目里出现这种情况，因为会影响后续的代码追查，code review等问题。<br>说完了这个问题，这篇博文的主要任务基本完成了，最后在简单说一下 merge 的 –no-ff 参数，这也是我们在分支合并的时候经常遇到的问题。<br>–no-ff 的意思就是关闭 merge 的 fast-forwarded，merge 操作默认执行的是 fast-forwarded。<br>fast-forwarded 的意思就是在合并分支的时候，如果不涉及三方合并，git 只会简单的移动指针。<br>再再举一个🌰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        dev</span><br><span class="line">        |</span><br><span class="line">A---B---C</span><br><span class="line">         \</span><br><span class="line">          D---E</span><br><span class="line">              |</span><br><span class="line">              feature</span><br></pre></td></tr></table></figure>

<p>此时我们执行 merge –no-ff 操作，将会得到如下图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                dev</span><br><span class="line">                |</span><br><span class="line">A---B---C--------F</span><br><span class="line">         \      /</span><br><span class="line">          D---E</span><br></pre></td></tr></table></figure>

<p>执行 merge 之后得到的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">               dev</span><br><span class="line">                |</span><br><span class="line">A---B---C---D---E</span><br></pre></td></tr></table></figure>

<p>如上git 将指针从C移到了E。</p>
<p>简单来说就是 –no-ff 的作用就是保持分支的非线性。方便我们看到分支的变化。</p>
<blockquote>
<p>本文作者： Frank<br>本文链接： <a href="http://hellofrank.github.io/2018/04/27/Git-Rebase-黄金法则问题/" target="_blank" rel="noopener">http://hellofrank.github.io/2018/04/27/Git-Rebase-黄金法则问题/</a><br>版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/10/Git-Rebase-黄金法则问题/" data-id="ck0gj8yrt000bf4gbmz4yqw8l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Flutter-Http请求开源库-dio" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/Flutter-Http请求开源库-dio/" class="article-date">
  <time datetime="2019-09-09T00:39:17.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/Flutter-Http请求开源库-dio/">Flutter Http请求开源库-dio</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文档语言: <a href="README.md">English</a> | <a href="README-ZH.md">中文简体</a></p>
<h1 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h1><p><img src="/images/2019/09/09/3ed7aff0-d29a-11e9-a25e-85ff34c3f186.png" alt="image.png"></p>
<p>dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等…</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  dio:</span> <span class="string">^x.x.x</span>  <span class="string">//</span> <span class="string">请使用pub上的最新版本</span></span><br></pre></td></tr></table></figure>

<h2 id="一个极简的示例"><a href="#一个极简的示例" class="headerlink" title="一个极简的示例"></a>一个极简的示例</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> getHttp() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response = <span class="keyword">await</span> Dio().<span class="keyword">get</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内容列表"><a href="#内容列表" class="headerlink" title="内容列表"></a>内容列表</h2><ul>
<li><a href="#示例">示例</a></li>
<li><a href="#dio-apis">Dio APIs</a></li>
<li><a href="#请求配置">请求配置</a></li>
<li><a href="#响应数据">响应数据</a></li>
<li><a href="#拦截器">拦截器</a></li>
<li><a href="#错误处理">错误处理</a></li>
<li><a href="#使用applicationx-www-form-urlencoded编码">使用application/x-www-form-urlencoded编码</a></li>
<li><a href="#formdata">FormData</a></li>
<li><a href="#转换器">转换器</a></li>
<li><a href="#设置Http代理">设置Http代理</a></li>
<li><a href="#Https证书校验">Https证书校验</a></li>
<li><a href="#请求取消">请求取消</a></li>
<li><a href="#cookie管理">Cookie管理</a></li>
<li><a href="#features-and-bugs">Features and bugs</a></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>发起一个 <code>GET</code> 请求 :</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Response response;</span><br><span class="line">  Dio dio = <span class="keyword">new</span> Dio();</span><br><span class="line">  response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"/test?id=12&amp;name=wendu"</span>)</span><br><span class="line">  <span class="built_in">print</span>(response.data.toString());</span><br><span class="line"><span class="comment">// 请求参数也可以通过对象传递，上面的代码等同于：</span></span><br><span class="line">  response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"/test"</span>, data: &#123;<span class="string">"id"</span>: <span class="number">12</span>, <span class="string">"name"</span>: <span class="string">"wendu"</span>&#125;);</span><br><span class="line">  <span class="built_in">print</span>(response.data.toString());</span><br></pre></td></tr></table></figure>

<p>发起一个 <code>POST</code> 请求:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = <span class="keyword">await</span> dio.post(<span class="string">"/test"</span>, data: &#123;<span class="string">"id"</span>: <span class="number">12</span>, <span class="string">"name"</span>: <span class="string">"wendu"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>发起多个并发请求:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = <span class="keyword">await</span> Future.wait([dio.post(<span class="string">"/info"</span>), dio.<span class="keyword">get</span>(<span class="string">"/token"</span>)]);</span><br></pre></td></tr></table></figure>

<p>下载文件:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = <span class="keyword">await</span> dio.download(<span class="string">"https://www.google.com/"</span>, <span class="string">"./xx.html"</span>);</span><br></pre></td></tr></table></figure>

<p>发送 FormData:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  response = <span class="keyword">await</span> dio.post(<span class="string">"/info"</span>, data: formData);</span><br></pre></td></tr></table></figure>

<p>通过FormData上传多个文件:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="string">"file1"</span>: <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./upload.txt"</span>), <span class="string">"upload1.txt"</span>),</span><br><span class="line">  <span class="comment">//支持直接上传字节数组 (List&lt;int&gt;) ，方便直接上传内存中的内容</span></span><br><span class="line">  <span class="string">"file2"</span>: <span class="keyword">new</span> UploadFileInfo.fromBytes(</span><br><span class="line">      utf8.encode(<span class="string">"hello world"</span>), <span class="string">"word.txt"</span>),</span><br><span class="line">  <span class="comment">// 支持文件数组上传</span></span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>),</span><br><span class="line">    <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">response = <span class="keyword">await</span> dio.post(<span class="string">"/info"</span>, data: formData);</span><br></pre></td></tr></table></figure>

<p>监听发送(上传)数据进度:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">response = <span class="keyword">await</span> dio.post(</span><br><span class="line">  <span class="string">"http://www.dtworkroom.com/doris/1/2.0.0/test"</span>,</span><br><span class="line">  data: &#123;<span class="string">"aa"</span>: <span class="string">"bb"</span> * <span class="number">22</span>&#125;,</span><br><span class="line">  onUploadProgress: (<span class="built_in">int</span> sent, <span class="built_in">int</span> total) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$sent</span> <span class="subst">$total</span>"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>…你可以在这里获取所有<a href="https://github.com/flutterchina/dio/tree/flutter/example" target="_blank" rel="noopener">示例代码</a>.</p>
<h2 id="Dio-APIs"><a href="#Dio-APIs" class="headerlink" title="Dio APIs"></a>Dio APIs</h2><h3 id="创建一个Dio实例，并配置它"><a href="#创建一个Dio实例，并配置它" class="headerlink" title="创建一个Dio实例，并配置它"></a>创建一个Dio实例，并配置它</h3><p>你可以使用默认配置或传递一个可选 <code>Options</code>参数来创建一个Dio实例 :</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dio dio = <span class="keyword">new</span> Dio; <span class="comment">// 使用默认配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置dio实例</span></span><br><span class="line">  dio.options.baseUrl = <span class="string">"https://www.xx.com/api"</span>;</span><br><span class="line">  dio.options.connectTimeout = <span class="number">5000</span>; <span class="comment">//5s</span></span><br><span class="line">  dio.options.receiveTimeout = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过传递一个 `options`来创建dio实例</span></span><br><span class="line">  Options options = <span class="keyword">new</span> Options(</span><br><span class="line">      baseUrl: <span class="string">"https://www.xx.com/api"</span>,</span><br><span class="line">      connectTimeout: <span class="number">5000</span>,</span><br><span class="line">      receiveTimeout: <span class="number">3000</span>);</span><br><span class="line">  Dio dio = <span class="keyword">new</span> Dio(options);</span><br></pre></td></tr></table></figure>

<p>Dio实例的核心API是 :</p>
<p><strong>Future<response> request(String path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = <span class="keyword">await</span> request(</span><br><span class="line">    <span class="string">"/test"</span>, data: &#123;<span class="string">"id"</span>: <span class="number">12</span>, <span class="string">"name"</span>: <span class="string">"xx"</span>&#125;, <span class="keyword">new</span> Options(method: <span class="string">"GET"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便使用，Dio提供了一些其它的Restful API, 这些API都是<code>request</code>的别名。</p>
<p><strong>Future<response> get(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> post(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> put(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> delete(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> head(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> put(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> path(path, {data, Options options,CancelToken cancelToken})</response></strong></p>
<p><strong>Future<response> download(String urlPath, savePath,</response></strong><br>​    <strong>{OnDownloadProgress onProgress, data, bool flush: false, Options options,CancelToken cancelToken})</strong></p>
<h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>下面是所有的请求配置选项。 如果请求<code>method</code>没有指定，则默认为<code>GET</code> :</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// Http method.</span></span><br><span class="line">  <span class="built_in">String</span> method;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求基地址,可以包含子路径，如: "https://www.google.com/api/".</span></span><br><span class="line">  <span class="built_in">String</span> baseUrl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Http请求头.</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; headers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 连接服务器超时时间，单位是毫秒.</span></span><br><span class="line">  <span class="built_in">int</span> connectTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///  响应流上前后两次接受到数据的间隔，单位为毫秒。如果两次间隔超过[receiveTimeout]，</span></span><br><span class="line">  <span class="comment">///  [Dio] 将会抛出一个[DioErrorType.RECEIVE_TIMEOUT]的异常.</span></span><br><span class="line">  <span class="comment">///  注意: 这并不是接收数据的总时限.</span></span><br><span class="line">  <span class="built_in">int</span> receiveTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求数据,可以是任意类型.</span></span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求路径，如果 `path` 以 "http(s)"开始, 则 `baseURL` 会被忽略； 否则,</span></span><br><span class="line">  <span class="comment">/// 将会和baseUrl拼接出完整的的url.</span></span><br><span class="line">  <span class="built_in">String</span> path = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求的Content-Type，默认值是[ContentType.JSON].</span></span><br><span class="line">  <span class="comment">/// 如果您想以"application/x-www-form-urlencoded"格式编码请求数据,</span></span><br><span class="line">  <span class="comment">/// 可以设置此选项为 `ContentType.parse("application/x-www-form-urlencoded")`,  这样[Dio]</span></span><br><span class="line">  <span class="comment">/// 就会自动编码请求体.</span></span><br><span class="line">  ContentType contentType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// [responseType] 表示期望以那种格式(方式)接受响应数据。</span></span><br><span class="line">  <span class="comment">/// 目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 默认值是 `JSON`, 当响应头中content-type为"application/json"时，dio 会自动将响应内容转化为json对象。</span></span><br><span class="line">  <span class="comment">/// 如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`.</span></span><br><span class="line">  ResponseType responseType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// `validateStatus` 决定http响应状态码是否被dio视为请求成功， 返回`validateStatus`</span></span><br><span class="line">  <span class="comment">///  返回`true` , 请求结果就会按成功处理，否则会按失败处理.</span></span><br><span class="line">  ValidateStatus validateStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用户自定义字段，可以在 [Interceptor]、[Transformer] 和 [Response] 中取到.</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; extra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个完成的<a href="https://github.com/flutterchina/dio/blob/flutter/example/options.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><p>当请求成功时会返回一个Response对象，它包含如下字段：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// 响应数据，可能已经被转换了类型, 详情请参考Options中的[ResponseType].</span></span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line">  <span class="comment">/// 响应头</span></span><br><span class="line">  HttpHeaders headers;</span><br><span class="line">  <span class="comment">/// 本次请求信息</span></span><br><span class="line">  Options request;</span><br><span class="line">  <span class="comment">/// Http status code.</span></span><br><span class="line">  <span class="built_in">int</span> statusCode;</span><br><span class="line">  <span class="comment">/// 响应对象的自定义字段（可以在拦截器中设置它），调用方可以在`then`中获取.</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; extra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例如下:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="built_in">print</span>(response.data);</span><br><span class="line"><span class="built_in">print</span>(response.headers);</span><br><span class="line"><span class="built_in">print</span>(response.request);</span><br><span class="line"><span class="built_in">print</span>(response.statusCode);</span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>每一个 Dio 实例都有一个请求拦截器  <code>RequestInterceptor</code> 和一个响应拦截器 <code>ResponseInterceptor</code>, 通过拦截器你可以在请求之前或响应之后(但还没有被 <code>then</code> 或 <code>catchError</code>处理)做一些统一的预处理操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dio.interceptor.request.onSend = (Options options)&#123;</span><br><span class="line">    <span class="comment">// 在请求被发送之前做一些事情</span></span><br><span class="line">    <span class="keyword">return</span> options; <span class="comment">//continue</span></span><br><span class="line">    <span class="comment">// 如果你想完成请求并返回一些自定义数据，可以返回一个`Response`对象或返回`dio.resolve(data)`。</span></span><br><span class="line">    <span class="comment">// 这样请求将会被终止，上层then会被调用，then中返回的数据将是你的自定义数据data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果你想终止请求并触发一个错误,你可以返回一个`DioError`对象，或返回`dio.reject(errMsg)`，</span></span><br><span class="line">    <span class="comment">// 这样请求将被中止并触发异常，上层catchError会被调用。</span></span><br><span class="line">&#125;</span><br><span class="line">dio.interceptor.response.onSuccess = (Response response) &#123;</span><br><span class="line">    <span class="comment">// 在返回响应数据之前做一些预处理</span></span><br><span class="line">    <span class="keyword">return</span> response; <span class="comment">// continue</span></span><br><span class="line">&#125;;</span><br><span class="line">dio.interceptor.response.onError = (DioError e)&#123;</span><br><span class="line">    <span class="comment">// 当请求失败时做一些预处理</span></span><br><span class="line">    <span class="keyword">return</span> e;<span class="comment">//continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想移除拦截器，你可以将它们置为null:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dio.interceptor.request.onSend = <span class="keyword">null</span>;</span><br><span class="line">dio.interceptor.response.onSuccess = <span class="keyword">null</span>;</span><br><span class="line">dio.interceptor.response.onError = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="完成和终止请求-响应"><a href="#完成和终止请求-响应" class="headerlink" title="完成和终止请求/响应"></a>完成和终止请求/响应</h3><p>在所有拦截器中，你都可以改变请求执行流， 如果你想完成请求/响应并返回自定义数据，你可以返回一个 <code>Response</code> 对象或返回 <code>dio.resolve(data)</code>的结果。 如果你想终止(触发一个错误，上层<code>catchError</code>会被调用)一个请求/响应，那么可以返回一个<code>DioError</code> 对象或返回 <code>dio.reject(errMsg)</code> 的结果.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dio.interceptor.request.onSend = (Options options) &#123;</span><br><span class="line">  <span class="keyword">return</span> dio.resolve(<span class="string">"fake data"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"/test"</span>);</span><br><span class="line"><span class="built_in">print</span>(response.data); <span class="comment">//"fake data"</span></span><br></pre></td></tr></table></figure>

<h3 id="拦截器中支持异步任务"><a href="#拦截器中支持异步任务" class="headerlink" title="拦截器中支持异步任务"></a>拦截器中支持异步任务</h3><p>拦截器中不仅支持同步任务，而且也支持异步任务, 下面是在请求拦截器中发起异步任务的一个实例:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> dio.interceptor.request.onSend = (Options options) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...If no token, request token firstly.</span></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"/token"</span>);</span><br><span class="line">    <span class="comment">//Set the token to headers</span></span><br><span class="line">    options.headers[<span class="string">"token"</span>] = response.data[<span class="string">"data"</span>][<span class="string">"token"</span>];</span><br><span class="line">    <span class="keyword">return</span> options; <span class="comment">//continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock-unlock-拦截器"><a href="#Lock-unlock-拦截器" class="headerlink" title="Lock/unlock 拦截器"></a>Lock/unlock 拦截器</h3><p>你可以通过调用拦截器的 <code>lock()</code>/<code>unlock</code> 方法来锁定/解锁拦截器。一旦请求/响应拦截器被锁定，接下来的请求/响应将会在进入请求/响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行(进入拦截器)。这在一些需要串行化请求/响应的场景中非常实用，后面我们将给出一个示例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tokenDio = <span class="keyword">new</span> Dio(); <span class="comment">//Create a new instance to request the token.</span></span><br><span class="line">tokenDio.options = dio;</span><br><span class="line">dio.interceptor.request.onSend = (Options options) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// If no token, request token firstly and lock this interceptor</span></span><br><span class="line">  <span class="comment">// to prevent other request enter this interceptor.</span></span><br><span class="line">  dio.interceptor.request.lock();</span><br><span class="line">  <span class="comment">// We use a new Dio(to avoid dead lock) instance to request token.</span></span><br><span class="line">  Response response = <span class="keyword">await</span> tokenDio.<span class="keyword">get</span>(<span class="string">"/token"</span>);</span><br><span class="line">  <span class="comment">//Set the token to headers</span></span><br><span class="line">  options.headers[<span class="string">"token"</span>] = response.data[<span class="string">"data"</span>][<span class="string">"token"</span>];</span><br><span class="line">  dio.interceptor.request.unlock();</span><br><span class="line">  <span class="keyword">return</span> options; <span class="comment">//continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Clear()</strong></p>
<p>你也可以调用拦截器的<code>clear()</code>方法来清空等待队列。</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>当<strong>请求</strong>拦截器被锁定时，接下来的请求将会暂停，这等价于锁住了dio实例，因此，Dio示例上提供了<strong>请求</strong>拦截器<code>lock/unlock</code>的别名方法：</p>
<p><strong>dio.lock() ==  dio.interceptor.request.lock()</strong></p>
<p><strong>dio.unlock() ==  dio.interceptor.request.unlock()</strong></p>
<p><strong>dio.clear() ==  dio.interceptor.request.clear()</strong></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设这么一个场景：出于安全原因，我们需要给所有的请求头中添加一个csrfToken，如果csrfToken不存在，我们先去请求csrfToken，获取到csrfToken后，再发起后续请求。 由于请求csrfToken的过程是异步的，我们需要在请求过程中锁定后续请求（因为它们需要csrfToken), 直到csrfToken请求成功后，再解锁，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dio.interceptor.request.onSend = (Options options) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'send request：path:<span class="subst">$&#123;options.path&#125;</span>，baseURL:<span class="subst">$&#123;options.baseUrl&#125;</span>'</span>);</span><br><span class="line">    <span class="keyword">if</span> (csrfToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"no token，request token firstly..."</span>);</span><br><span class="line">      <span class="comment">//lock the dio.</span></span><br><span class="line">      dio.lock();</span><br><span class="line">      <span class="keyword">return</span> tokenDio.<span class="keyword">get</span>(<span class="string">"/token"</span>).then((d) &#123;</span><br><span class="line">        options.headers[<span class="string">"csrfToken"</span>] = csrfToken = d.data[<span class="string">'data'</span>][<span class="string">'token'</span>];</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"request token succeed, value: "</span> + d.data[<span class="string">'data'</span>][<span class="string">'token'</span>]);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'continue to perform request：path:<span class="subst">$&#123;options.path&#125;</span>，baseURL:<span class="subst">$&#123;options.path&#125;</span>'</span>);</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">      &#125;).whenComplete(() =&gt; dio.unlock()); <span class="comment">// unlock the dio</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      options.headers[<span class="string">"csrfToken"</span>] = csrfToken;</span><br><span class="line">      <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>完整的示例代码请点击 <a href="https://github.com/flutterchina/dio/blob/flutter/example/interceptorLock.dart" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当请求过程中发生错误时, Dio 会包装 <code>Error/Exception</code> 为一个 <code>DioError</code>:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//404</span></span><br><span class="line">  <span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">"https://wendux.github.io/xsddddd"</span>);</span><br><span class="line">&#125; on DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// The request was made and the server responded with a status code</span></span><br><span class="line">  <span class="comment">// that falls out of the range of 2xx and is also not 304.</span></span><br><span class="line">  <span class="keyword">if</span> (e.response) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e.response.data);</span><br><span class="line">    <span class="built_in">print</span>(e.response.headers);</span><br><span class="line">    <span class="built_in">print</span>(e.response.request);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Something happened in setting up or sending the request that triggered an Error</span></span><br><span class="line">    <span class="built_in">print</span>(e.request);</span><br><span class="line">    <span class="built_in">print</span>(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DioError-字段"><a href="#DioError-字段" class="headerlink" title="DioError 字段"></a>DioError 字段</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="comment">/// 响应信息, 如果错误发生在在服务器返回数据之前，它为 `null`</span></span><br><span class="line">  Response response;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 错误描述.</span></span><br><span class="line">  <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 错误类型，见下文</span></span><br><span class="line">  DioErrorType type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 错误栈信息，可能为null</span></span><br><span class="line">  StackTrace stackTrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DioErrorType"><a href="#DioErrorType" class="headerlink" title="DioErrorType"></a>DioErrorType</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DioErrorType &#123;</span><br><span class="line">  <span class="comment">/// Default error type, usually occurs before connecting the server.</span></span><br><span class="line">  DEFAULT,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// When opening  url timeout, it occurs.</span></span><br><span class="line">  CONNECT_TIMEOUT,</span><br><span class="line"></span><br><span class="line">  <span class="comment">///  Whenever more than [receiveTimeout] (in milliseconds) passes between two events from response stream,</span></span><br><span class="line">  <span class="comment">///  [Dio] will throw the [DioError] with [DioErrorType.RECEIVE_TIMEOUT].</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">///  Note: This is not the receiving time limitation.</span></span><br><span class="line">  RECEIVE_TIMEOUT,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// When the server response, but with a incorrect status, such as 404, 503...</span></span><br><span class="line">  RESPONSE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// When the request is cancelled, dio will throw a error with this type.</span></span><br><span class="line">  CANCEL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用application-x-www-form-urlencoded编码"><a href="#使用application-x-www-form-urlencoded编码" class="headerlink" title="使用application/x-www-form-urlencoded编码"></a>使用application/x-www-form-urlencoded编码</h2><p>默认情况下, Dio 会将请求数据(除过String类型)序列化为 <code>JSON</code>. 如果想要以 <code>application/x-www-form-urlencoded</code>格式编码, 你可以显式设置<code>contentType</code> :</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instance level</span></span><br><span class="line">dio.options.contentType=ContentType.parse(<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">//or works once</span></span><br><span class="line">dio.post(<span class="string">"/info"</span>,data:&#123;<span class="string">"id"</span>:<span class="number">5</span>&#125;, options: <span class="keyword">new</span> Options(contentType:ContentType.parse(<span class="string">"application/x-www-form-urlencoded"</span>)));</span><br></pre></td></tr></table></figure>

<p>这里有一个<a href="https://github.com/flutterchina/dio/blob/flutter/example/options.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h2><p>Dio支持发送 FormData, 请求数据将会以 <code>multipart/form-data</code>方式编码, FormData中可以一个或多个包含文件 .</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">"file"</span>: <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>)</span><br><span class="line">&#125;);</span><br><span class="line">response = <span class="keyword">await</span> dio.post(<span class="string">"/info"</span>, data: formData);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 只有 post 方法支持发送 FormData.</p>
</blockquote>
<p>这里有一个完整的<a href="https://github.com/flutterchina/dio/blob/flutter/example/formdata.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>转换器<code>Transformer</code> 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器<code>DefaultTransformer</code>作为默认的 <code>Transformer</code>. 如果你想对请求/响应数据进行自定义编解码处理，可以提供自定义转换器，通过 <code>dio.transformer</code>设置。</p>
<blockquote>
<p>请求转换器  <code>Transformer.transformRequest(...)</code>   只会被用于 ‘PUT’、 ‘POST’、 ‘PATCH’方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 <code>Transformer.transformResponse()</code> 会被用于所有请求方法的返回数据。</p>
</blockquote>
<h3 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h3><p>虽然在拦截器中也可以对数据进行预处理，但是转换器主要职责是对请求/响应数据进行编解码，之所以将转化器单独分离，一是为了和拦截器解耦，二是为了不修改原始请求数据(如果你在拦截器中修改请求数据(options.data)，会覆盖原始请求数据，而在某些时候您可能需要原始请求数据). Dio的请求流是：</p>
<p><em>请求拦截器</em> &gt;&gt; <em>请求转换器</em> &gt;&gt; <em>发起请求</em>  &gt;&gt; <em>响应转换器</em>  &gt;&gt; <em>响应拦截器</em>  &gt;&gt; <em>最终结果</em>。</p>
<p>这是一个自定义转换器的<a href="https://github.com/wendux/dio/blob/flutter/example/Transformer.dart" target="_blank" rel="noopener">示例</a>.</p>
<h2 id="设置Http代理"><a href="#设置Http代理" class="headerlink" title="设置Http代理"></a>设置Http代理</h2><p>Dio 是使用 HttpClient发起的http请求，所以你可以通过配置 <code>httpClient</code>来支持代理，示例如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  client.findProxy = (uri) &#123;</span><br><span class="line">    <span class="comment">//proxy all request to localhost:8888</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"PROXY localhost:8888"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 你也可以自己创建一个新的HttpClient实例返回。</span></span><br><span class="line">  <span class="comment">// return new HttpClient(SecurityContext);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完整的示例请查看<a href="https://github.com/wendux/dio/tree/flutter/example/proxy.dart" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="Https证书校验"><a href="#Https证书校验" class="headerlink" title="Https证书校验"></a>Https证书校验</h2><p>有两种方法可以校验https证书，假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> PEM=<span class="string">"XXXXX"</span>; <span class="comment">//证书内容</span></span><br><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  client.badCertificateCallback=(X509Certificate cert, <span class="built_in">String</span> host, <span class="built_in">int</span> port)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cert.pem==PEM)&#123; <span class="comment">// 证书一致，则放行</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>X509Certificate</code>是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。</p>
<p>对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到<code>badCertificateCallback</code>回调中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  SecurityContext sc = <span class="keyword">new</span> SecurityContext();</span><br><span class="line">  <span class="comment">//file为证书路径</span></span><br><span class="line">  sc.setTrustedCertificates(file);</span><br><span class="line">  HttpClient httpClient = <span class="keyword">new</span> HttpClient(context: sc);</span><br><span class="line">  <span class="keyword">return</span> httpClient;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，通过<code>setTrustedCertificates()</code>设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。</p>
<h2 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h2><p>你可以通过 <em>cancel token</em> 来取消发起的请求：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CancelToken token = <span class="keyword">new</span> CancelToken();</span><br><span class="line">dio.<span class="keyword">get</span>(url, cancelToken: token)</span><br><span class="line">    .catchError((DioError err)&#123;</span><br><span class="line">        <span class="keyword">if</span> (CancelToken.isCancel(err)) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Request canceled! '</span>+ err.message)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// handle error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// cancel the requests with "cancelled" message.</span></span><br><span class="line">token.cancel(<span class="string">"cancelled"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 同一个cancel token 可以用于多个请求，当一个cancel token取消时，所有使用该cancel token的请求都会被取消。</p>
</blockquote>
<p>完整的示例请参考<a href="https://github.com/flutterchina/dio/blob/flutter/example/cancelRequest.dart" target="_blank" rel="noopener">取消示例</a>.</p>
<h2 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h2><p>你可以通过 <code>cookieJar</code> 来自动管理请求/响应cookie.</p>
<blockquote>
<p> dio cookie 管理 API 是基于开源库 <a href="https://github.com/flutterchina/cookie_jar" target="_blank" rel="noopener">cookie_jar</a>.</p>
</blockquote>
<p>你可以创建一个<code>CookieJar</code> 或 <code>PersistCookieJar</code> 来帮您自动管理cookie,  dio 默认使用  <code>CookieJar</code> , 它会将cookie保存在内存中。 如果您想对cookie进行持久化,  请使用 <code>PersistCookieJar</code> ,  示例代码如下:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dio = <span class="keyword">new</span> Dio();</span><br><span class="line">dio.cookieJar = <span class="keyword">new</span> PersistCookieJar(<span class="string">"./cookies"</span>);</span><br></pre></td></tr></table></figure>

<p><code>PersistCookieJar</code> 实现了RFC中标准的cookie策略.  <code>PersistCookieJar</code> 会将cookie保存在文件中，所以 cookies 会一直存在除非显式调用 <code>delete</code> 删除.</p>
<p>更多关于 <a href="https://github.com/flutterchina/" target="_blank" rel="noopener">cookie_jar</a>  请参考 : <a href="https://github.com/flutterchina/cookie_jar" target="_blank" rel="noopener">https://github.com/flutterchina/cookie_jar</a> .</p>
<h2 id="Copyright-amp-License"><a href="#Copyright-amp-License" class="headerlink" title="Copyright &amp; License"></a>Copyright &amp; License</h2><p>此开源项目为Flutter中文网(<a href="https://flutterchina.club" target="_blank" rel="noopener">https://flutterchina.club</a>) 授权 ，license 是 MIT.   如果您喜欢，欢迎star.</p>
<p><strong>Flutter中文网开源项目计划</strong></p>
<p>开发一系列Flutter SDK之外常用(实用)的Package、插件，丰富Flutter第三方库，为Flutter生态贡献来自中国开发者的力量。所有项目将发布在 <a href="https://github.com/flutterchina/" target="_blank" rel="noopener">Github Flutter中文网 Organization</a> ，所有源码贡献者将加入到我们的Organization，成为成员. 目前社区已有几个开源项目开始公测，欢迎您加入开发或测试，详情请查看: <a href="https://flutterchina.club/opensource.html" target="_blank" rel="noopener">Flutter中文网开源项目</a>。 如果您想加入到“开源项目计划”， 请发邮件到<a href="mailto:824783146@qq.com" target="_blank" rel="noopener">824783146@qq.com</a>， 并附上自我介绍(个人基本信息+擅长/关注技术)。</p>
<h2 id="Features-and-bugs"><a href="#Features-and-bugs" class="headerlink" title="Features and bugs"></a>Features and bugs</h2><p>Please file feature requests and bugs at the <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">issue tracker</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/09/Flutter-Http请求开源库-dio/" data-id="ck0gj8yrq000af4gb2c2odg77" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Http/">Http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dio/">dio</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Github的webhooks网站自动化部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/Github的webhooks网站自动化部署/" class="article-date">
  <time datetime="2019-09-08T23:56:41.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/Github的webhooks网站自动化部署/">Github的webhooks网站自动化部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Github的webhooks进行网站自动化部署"><a href="#Github的webhooks进行网站自动化部署" class="headerlink" title="Github的webhooks进行网站自动化部署"></a>Github的webhooks进行网站自动化部署</h1><p><img src="/images/2019/09/09/bb535690-d292-11e9-9a4a-2f1c09bb03b0.png" alt="image.png"></p>
<p>相信很多码农都玩过了Git，如果对Git只是一知半解，可以移步LV写的 GIT常用操作总结，下面介绍到的一些关于 Git 的概念就不再赘述。</p>
<p>为啥想写这篇文章？主要是因为部门服务器因为安全性原因不允许SCP上传文件进行应用部署，然后有一些应用是放在Github上的，然后部署应用的步骤就变成：</p>
<p>1.git clone github项目 本地目录<br>2.配置一下应用的pm2.json并reload<br>3.Nginx配置一下反向代理并restart</p>
<p>当然如果只是一次性部署上去就不再修改的话并没啥问题，但是要是项目持续性修改迭代的话，就比较麻烦了，我们就在不断的重复着上面的步骤。作为一个码农，怎么允许不断的重复同样的工作，于是Github webhooks闪亮登场。</p>
<h1 id="关于Github-webhooks"><a href="#关于Github-webhooks" class="headerlink" title="关于Github webhooks"></a>关于Github webhooks</h1><ul>
<li>必须是Github上面的项目</li>
<li>订阅了确定的事件（包括push/pull等命令）</li>
<li>自动触发</li>
</ul>
<p>刚好符合了这几个条件，那接下来就看看如何进行网站自动化部署，主要会从下面几点来讲解：</p>
<ol>
<li>自动化shell脚本</li>
<li>服务端实现</li>
<li>配置github webhooks</li>
</ol>
<h1 id="自动化脚本"><a href="#自动化脚本" class="headerlink" title="自动化脚本"></a>自动化脚本</h1><p><code>auto_build.sh</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line">SITE_PATH='/root/nginx/www'</span><br><span class="line">cd $SITE_PATH</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git clean -f</span><br><span class="line">git pull</span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>Note: 在执行上面shell脚本之前我们必须第一次手动git clone项目进去</p>
<h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>Github webhooks需要跟我们的服务器进行通信，确保是可以推送到我们的服务器，所以会发送一个带有X-Hub-Signature的POST请求，为了方便我们直接用第三方的库github-webhook-handler来接收参数并且做监听事件的处理等工作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i github-webhook-handler -S</span><br></pre></td></tr></table></figure>

<p><code>index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">var</span> createHandler = <span class="built_in">require</span>(<span class="string">'github-webhook-handler'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径</span></span><br><span class="line"><span class="keyword">var</span> handler = createHandler(&#123; <span class="attr">path</span>: <span class="string">'/auto_build'</span>, <span class="attr">secret</span>: <span class="string">''</span> &#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  handler(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.end(<span class="string">'no such location'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">handler.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, err.message)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听到push事件的时候执行我们的自动化脚本</span></span><br><span class="line">handler.on(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received a push event for %s to %s'</span>,</span><br><span class="line">    event.payload.repository.name,</span><br><span class="line">    event.payload.ref);</span><br><span class="line"></span><br><span class="line">  runCommand(<span class="string">'sh'</span>, [<span class="string">'auto_build.sh'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> txt </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(txt);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runCommand</span>(<span class="params"> cmd, args, callback </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child = spawn( cmd, args );</span><br><span class="line">    <span class="keyword">var</span> response = <span class="string">''</span>;</span><br><span class="line">    child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> buffer </span>)</span>&#123; resp += buffer.toString(); &#125;);</span><br><span class="line">    child.stdout.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; callback( resp ) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于我们不需要监听issues，所以下面代码注释掉</span></span><br><span class="line"><span class="comment">//  handler.on('issues', function (event) &#123;</span></span><br><span class="line"><span class="comment">//    console.log('Received an issue event for %s action=%s: #%d %s',</span></span><br><span class="line"><span class="comment">//      event.payload.repository.name,</span></span><br><span class="line"><span class="comment">//      event.payload.action,</span></span><br><span class="line"><span class="comment">//      event.payload.issue.number,</span></span><br><span class="line"><span class="comment">//      event.payload.issue.title)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="配置github-webhooks"><a href="#配置github-webhooks" class="headerlink" title="配置github webhooks"></a>配置github webhooks</h1><p><img src="/images/2019/09/09/3f507120-d294-11e9-9a4a-2f1c09bb03b0.png" alt="image.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面就是利用Github webhooks进行网站自动化部署的全部内容了，不难发现其实这项技术还是有局限性的，那就是依赖于github，一般我们选择的都是免费github账号，所有项目都对外，一些敏感项目是不适合放置上去的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/09/Github的webhooks网站自动化部署/" data-id="ck0gj8ys1000ff4gbgq8wbt2g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webhooks/">webhooks</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化部署/">自动化部署</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-灭霸脚本" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/灭霸脚本/" class="article-date">
  <time datetime="2019-09-08T23:20:36.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/灭霸脚本/">灭霸脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Thanos-sh"><a href="#Thanos-sh" class="headerlink" title="Thanos.sh"></a>Thanos.sh</h1><p>This command could <del>delete</del> list half your files randomly.</p>
<p>don’t use it at home and other places. this is a real gun, use it wisely… </p>
<p>feel free to post your story on <figure class="highlight plain"><figcaption><span>waiting.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 灭霸脚本</span><br><span class="line">这个命令会随机“删掉”您一半的文件。。</span><br><span class="line"></span><br><span class="line">请不要在家里或其他地方使用。这是真家伙，要小心…</span><br><span class="line"></span><br><span class="line">你可以在```Story.md```文件里发布你的故事，期待中…</span><br><span class="line"> </span><br><span class="line"> ## 特别说明</span><br><span class="line"> &gt; 1. 支持mac系统，但是需要使用到```gshuf```命令，需要通过```brew```安装,安装命令如下：</span><br><span class="line">```shell</span><br><span class="line">    #安装brew</span><br><span class="line">    /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">    #安装gshuf</span><br><span class="line">    brew install coreutils</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol start="2">
<li>此脚本只会列出当前目录一半的文件。并且。。。总之小心点。。。  </li>
</ol>
</blockquote>
<h2 id="Invoke-Thanos-ps1"><a href="#Invoke-Thanos-ps1" class="headerlink" title="Invoke-Thanos.ps1"></a>Invoke-Thanos.ps1</h2><p>Invokes Thanos to remove each object with probability 1/2. It works with files, registry, environment variables, functions, variables, aliases and certificates.</p>
<p>For help, use <code>Get-Help .\Invoke-Thanos.ps1</code>. Be sure to not actually invoke it!</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">let "i=`find . -type f | wc -l`/2";</span><br><span class="line">if [[ uname=="Darwin" ]]; then</span><br><span class="line">    find . -not -name "Thanos.sh" -type f -print0 | gshuf -z -n $i | xargs -0  -- cat;</span><br><span class="line">else</span><br><span class="line">    find . -not -name "Thanos.sh" -type f -print0 | shuf -z -n $i | xargs -0  -- cat;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span> Explaination</span><br><span class="line"><span class="meta">#</span># Step 1: Get the count of files in current path divided by two.</span><br><span class="line"><span class="meta">#</span># Step 2: Get all the files in current path and print in one line.</span><br><span class="line"><span class="meta">#</span># Step 3: Turn half of the second step output into standard input randomly.</span><br><span class="line"><span class="meta">#</span># Step 4: Show half of the files in terminal.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Key Point</span><br><span class="line"><span class="meta">#</span># If you want to make delete, what you need to do is turn 'cat' into 'rm'.</span><br></pre></td></tr></table></figure>

<p>本人在线上服务器上运行了一次，…</p>
<p><img src="/images/2019/09/09/e0b9df90-d282-11e9-8020-8926e04ad9bb.png" alt="image.png"></p>
<p><img src="/images/2019/09/09/5aa65630-d283-11e9-937d-fb9e8ca7078f.png" alt="image.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/09/灭霸脚本/" data-id="ck0gj8yu0001pf4gbdpuw0rml" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/脚本/">脚本</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库备份恢复容器化项目实践经验总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/数据库备份恢复容器化项目实践经验总结/" class="article-date">
  <time datetime="2019-09-08T13:35:18.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文章/">文章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/数据库备份恢复容器化项目实践经验总结/">数据库备份恢复容器化项目实践经验总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据库备份恢复容器化项目实践经验总结"><a href="#数据库备份恢复容器化项目实践经验总结" class="headerlink" title="数据库备份恢复容器化项目实践经验总结"></a>数据库备份恢复容器化项目实践经验总结</h1><blockquote>
<p>本文分享了唯品会数据库Docker的异地容灾项目实践经验，项目中针对用户数据库的异地恢复场景的需求进行开发和测试，整合了网络，存储、调度、监控，镜像等多个模块。在实施完成后，从技术上总结关于选型、开发、踩坑、测试等方面的经验。</p>
</blockquote>
<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>数据库Docker的异地备份恢复容灾项目，针对用户数据库的异地备份恢复场景的需求进行开发和测试，整合了容器网络、存储、调度、监控、镜像等多个模块。同时针对数据库的日常运维工作开发了监控、资源调度、日志、Puppet自动推送等工具。</p>
<p>通过Docker天生隔离性和快速部署等特点，实现在单台物理机上运行多个数据库备份/恢复实例，大大提高服务器使用率，节省大量成本。通过对Docker本身和相关组件的研究和改造，从普通开源产品落地到公司内部生产环境，积累宝贵的开发经验。通过对Docker已经在其上层运行的数据库日常运维和监控，也积累宝贵的Docker运维经验，为更大规模推广容器提供基础。</p>
<p><img src="/images/2019/09/08/9adb4490-d23d-11e9-ad11-3306f19b341f.png" alt="image.png"></p>
<h1 id="关于容器技术"><a href="#关于容器技术" class="headerlink" title="关于容器技术"></a>关于容器技术</h1><p>通过实践，证明容器技术在易用性，可管理性，快速部署具备天然的优势。在资源利用率方面，容器部署在上百个物理节点上，提供约500多个数据库灾备实例，提升了硬件资源的利用率，节约了约400台物理机的采购成本。这些是容器技术带来的实实在在收益。在资源分配与隔离方面，又不输于虚拟机。CPU、内存、磁盘IO、网络IO限流等技术的应用，保证了资源的合理使用，从机制上阻止了单一实例的资源过分消耗的问题。</p>
<p>稳定性是使用容器技术非常关注的一个点，也是基石。MySQL备份/恢复属于CPU密集 + 磁盘IO密集 + 网络IO密集型业务，对于Docker daemon是个较大的考验。就目前来看，限制每台宿主机的容器数量（5个左右）的情况下，集群跑了三个多月没有出现因为容器负载过大导致的crash现象，还是值得信赖的。遇到的唯一相关问题是Docker daemon挂死，具体现象是docker info、docker ps没有响应，docker volume、docker images 正常，下面的容器运行正常。这是偶发事件，无法重现，以后需要继续观察。</p>
<p>由于容器以进程方式存在，体现出几乎与物理机上相当的性能，Overheads极低（低于10%）。从数据抽取任务的结果来看，与物理机相比，使用容器对成功率没有影响，效率也差不多。这也很符合最初预想，不管跑容器还是外部服务从物理机角度来说它们之间是没有什么区别的，都是一个进程，唯一不同是父进程不一样而已。</p>
<p>以上是容器“RUN”带来的好处，通过统一开发流程，应用微服务化，CI/CD等方面的改进，能够进一步利用容器“BUILD”、“SHIP” 优势，容器技术还来的潜力是巨大的。要说容器技术的缺点，还真的不明显。硬要提的话一个是需要一定的学习成本，改变开发流程与方式，一个是开发人员对容器技术的接受程度。这个项目仅用了不到二百人/天，对于一个采用新技术的项目来说，真的是很低的了。一开始我们也担心因为采用新技术导致开发推广有困难，后来实际能通过技术上解决问题，打消了大部分用户对使用Docker的疑虑，反而有助于该技术的普遍应用。</p>
<p>关于Docker daemon版本的选择，我们之前是有过一些讨论的。现在Docker社区非常活跃，当时我们用1.10.3， 到现在已经出了两个新版本了。在功能满足的前提下，稳定性是第一考量。Docker自1.9.0引入CNM网络模型，1.10算是比较成熟。CNM是我们希望在这个项目尝试的一部分。网络与Volume插件功能与稳定性的提升，开始支持磁盘IO读写限速，Device Mapper的支持，等等，都是选择了这个版本的原因。另外，Docker插件的引入，很好地解耦了Docker与底层模块的关系，使我们可以专注于底层（网络、存储）实现而不需要修改Docker daemon本身，同时避免产生升级依赖。</p>
<h1 id="关于容器存储"><a href="#关于容器存储" class="headerlink" title="关于容器存储"></a>关于容器存储</h1><p>容器外部卷使用Convoy，以插件的形式支持容器持久化数据。容器本身与外部卷均使用Device Mapper作为底层。没有选择分布式存储原因，主要是为了简化实现，更稳定。通过限制每个容器的BlkioDeviceReadBps、BlkioDeviceWriteBps、BlkioDeviceReadIOps、BlkioDeviceWriteIOps，使磁盘IO稳定地达到相当于95%物理机性能。</p>
<p><img src="/images/2019/09/08/b8684530-d23d-11e9-ad11-3306f19b341f.png" alt="image.png"></p>
<p>对于Device Mapper，因为是红帽推荐的，而OS又是用的CentOS7.2, 所以就用了它。测试过程中发现Device Mapper健壮性不是很好，仅仅在低并发下，也会出现容器删除失败的情况，容器并发启停偶尔出现找不到设备的情况。这种使用映射关系的设备，功能是丰富，实现上过于复杂，每次对设备的修改都需要额外去更新Metadata，并发场景出错的机会就大了。让我再选的话我会考虑Overlay这种更简单的driver。</p>
<p>对于Convoy，是来自Rancher的产品，Go语言，仍然处于未成熟阶段，版本号0.5, 并没有完全实现Volume Plugin接口。相比其它模块它的问题也是最多的，例如Volume创建失败，无法删除，UNIX Socket泄漏，重名冲突，异常自动退出等。属于能用，但未完善的状态，你自己得有一定开发调试能力去解决发现的问题。其它几个存储插件情况也差不多，Flocker、Blockbridge、Horcrux等等，有的连第一个正式发布版都还没有，Convoy反而相对好点，有点烂柿子堆里挑的感觉。</p>
<h1 id="关于容器监控"><a href="#关于容器监控" class="headerlink" title="关于容器监控"></a>关于容器监控</h1><p>容器监控在这个项目里还可以有很大的空间可以改进。项目里用的是cAdvisor，容器内top、free、iostat命令劫持，基于已有的Zabbix体系作数据收集与展示。结论是Zabbix完全不合适做容器监控，数据收集密度，展示质量，灵活度都没能满足需求。</p>
<p>后来在测试中尝试使用Telegraf + InfluxDB + Grafana。 只需要Grafana简单的配置，能够帮忙我们清晰地展示容器及服务进程CPU、内存、网络、磁盘等情况。Grafana上SQL查询语句的调试与开发，确实需要不少的时间，但这个工作量是一次性的。因为是Go写的，Telegraf CPU占用属于比较低的水平（0.4 – 5%）。功能上比较丰富，同时支持外部进程与容器的数据收集，多达55种数据源插件，有它就不需要布cAdvisor了，个人比较推荐。需要告警的同学，可以考虑把influxDB改成Prometheus。它包含Alertmanager实现Email、PagerDuty等消息通知。数据Backend可以选择自带的DB，也可以外接influxDB、Graphite、OpenTSDB等流行方案。</p>
<p><img src="/images/2019/09/08/cd4a2fe0-d23d-11e9-ad11-3306f19b341f.png" alt="image.png"></p>
<p>监控领域业界已经有很多开源方案可以参考，以下是要衡量的标准：易扩展、开销低、入侵小、大集中、易部署、实时性、展现清晰灵活。这方面希望与各位有更多的交流。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/08/数据库备份恢复容器化项目实践经验总结/" data-id="ck0gj8yu4001tf4gb2be6lot3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/备份/">备份</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-你也能懂相对论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/你也能懂相对论/" class="article-date">
  <time datetime="2019-09-08T11:25:53.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/你也能懂相对论/">你也能懂相对论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/2019/09/08/523a4280-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<h1 id="相对论"><a href="#相对论" class="headerlink" title="相对论"></a>相对论</h1><blockquote>
<p>光线在通过强引力场附近时会发生弯曲，这是广义相对论的重要预言之一</p>
</blockquote>
<p><img src="/images/2019/09/08/76abf0f0-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>如果我说，相对论与日常生用息息相关，你会信吗？或许就算我是一位知名的物理学教授，说服力相信也不会大得多少。以下我将要用比较浅白简单的文字和少许初等代数，说明并说服大家，相对论并不难懂，而且它在日常经验中是如此的明显、如此的必要！</p>
<p>1905 年被称为爱因斯坦的「奇迹年」，爱因斯坦向世界提出了一套非常明显、非常合理，但却一直不为人所理解的理论狭义相对论(special relativity)。被称为「狭义」是因为这个理论只在惯性座标系中适用；换句话说，即是在所有没有加速度的系统中都适用。狭义相对论建基于两大假设：</p>
<ul>
<li>在所有的惯性系统中，所有有物理定律保持不变。</li>
<li>对于所有系统中的所有观测者，光速永远不变，而且不是无限快的。</li>
</ul>
<p>假设(一)「所有自然定律不变」一般被称为相对性原理(principle of relativity)，明显比较合理，也比较容易理解。而乍看之下，光速相对于所有人都不变，而不论那人正在高速奔跑或者静止不动都没有关系，就显得较为奇怪了。要理解这一点，我们需要由速度的意义说起。速度，就是在说「每单位时间内走了多远」。说得再浅白一点，可以想像为「每秒走了多少米(m/s)」。但这只是惯用单位的问题，你当然可以想成「每小时走了多少公里(km/h)」，这正是司机们惯用的单位。在科学中，单位是至关重要的，因为不同单位的东西就是不同性质的东西，不可以混为一谈的比较，好像一个苹果永远不会等于一个橙。</p>
<p>假设(二)「光速相对所有人都不变」，就是说相对于所有人，光在每单位时间内走的距离都一样。就是说，当你向着一道光奔跑，「直觉上」你会认为你所看到的光速比起你在静止不动时快，因为在你向光跑去的「同时」，光亦向着你冲去。换成数学上的表达，就是说如果你用速度  v 向着光冲去，而我们用  c 代表你在静止时看到的光速，那你看到的光速就会变成了c + v。这就是所谓的伽俐略变换，亦被一般人叫做「常识」。当然了啊，两个物件互相冲去，当然会比其中一个不动、或两者互相远离快啊。但是，爱因斯坦却说不论你用什么速度，向着光或离开光移动，你到的光速都仍然为  c，不多也不少！</p>
<p>你会说：「这怎可能！这是违反常识的！」我的回答是，一般人的常识存在非常明显的漏洞，可是在爱因斯坦之前却一直没有人留意到这个严重的错误！这个错误就是「同时」这一概念的演绎。什么是「同时」？就是说大家的时钟显示的时间都一样啊！对，这也是爱因斯坦对「同时」的理解。但现在要再问一道问题，如何知道两个时钟的时间一样？</p>
<p>问题到肉了，可是你会觉得很无聊：「说什么废话！只要我看到两个钟的指针拍着的时间就是了！」好，停一停，想一想：我们能「看」到东西，是因为光进入到我们的眼球穿过水晶体折射后投影在视网膜上。总言之，我们能看到东西，是因为有光。光以一定的速度前进，而且因为光速有限，因此在不同距离发出的光相对于同一个观测者而言，会在不同时间到达。试想像，两个人相距非常远，而两个人都带着一个时钟，那么当然，任何一方都会觉得对方那个时钟所发出的光，会比自己手上的时钟所发出的光要用更多时间才能进入你的眼睛吧！好了，我希望大家想想，究竟事先要如何调整两个时钟，才能使你和对方都看到两个时钟是同步的呢？当然，这是办不到的！因为两个时钟相距两个人的距离都不同。若然你看到它们是同步的，对方就会看到他手上的走得较快，反之亦然。</p>
<p>如果你不太理解的话，请从头思考一次，先不要跳过读下去，因为刚才所说的就是相对论的精髓所在。重点是，要知道世界上并没有「对所有人都同时」这个概念存在，因此也可以说，「同时」这个概念对每个人都不同；说「对大家来说都是同时」就是错误的，没有可能发生。这是非常明显的，但却一直被我们所忽略。这完全是因为对于人类的感觉来说，光速(每秒三十万公里，能够环绕地球七个半圈) 实在是太快、太快了。</p>
<p>好了，接下来我要介绍相对论导致的两个非常重要的结果，这些结果令人类对时间及空间的概念有了根本上的改变：时间及空间其实是互相纠缠、难分难离的。在这部分我会以数学论证，狭义相对论所涉及的数学都只是基本数学运算以及向量微积分，相信对有会考物理根基的朋友来说不会太难。</p>
<p><img src="/images/2019/09/08/bc243660-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>在我们生活的三维空间中，每一件事件都可以用座标系的四个变量决定，就是(长，阔，高，时间)，数学表达为( x , y , z , t )。假设在座标系  S 中有一原点  O，在  S 内观测的人都会对每一件事件测得一组座标( x , y , z , t )；而现在有另一座标系S’正在相对S以速度  v 向右移动，它的原点  O’ 在时间  t = 0的时候刚好与  O重叠，而在S’内观测的人都会对每一件事件测得一组座标( x’ , y’ , z’ ,       t’ )。那么，在我们的「常识」中， ( x , y , z , t )与 ( x’ , y’ , z’ , t’ )的关系就是由伽俐略变换来决定：</p>
<p><img src="/images/2019/09/08/d1acc150-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>这就是我们认为的「常识」的数学表达方法。留意当中t’ = t，因为在传统的观念里，「同时」这概念仍然存在。明显地，在伽俐略变换当中，时间是独立地流逝的，与空间( x , y , z )无关。可是，在上文中我们知道「同时」是不存在的。</p>
<p><img src="/images/2019/09/08/e043a620-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>想像小明站在一节正在行进的列车车厢正中间，在车头及车尾都摆放了感应器。他向左右同时照射出两道光束。对小明来说，车厢并没有移动，所以他会看到两道光束同时到达感应器。可是，对于一位站在月台上的人来说，因为列车正在向右移动，右边的感应器不断远离光束，而左边的就不断靠边光束。所以他会看到左边那道光束首先到达感应器。因此，时间会因为观测者的运动状态不同而有所分别，而且这是非常明显的！请注意，上述两种情况都是正确的，没有谁对谁错，完全因为观点与角度而已。回到  S 和  S’ 座标系的讨论，因为两个座标系的运动状态不同，所以伽俐略变换就不是正确的描述了，我们必须改用另外一种座标变换方法，名为洛伦兹变换( Lorentz Transformation)：</p>
<p><img src="/images/2019/09/08/eae5aa10-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>有关这组公式的推导过程，有兴趣的朋友可以参考任何相对论课本。在这里我们有兴趣的是：如果时间及空间确实根据以上方程组变换的话，会有什么有趣的事情发生？</p>
<p><img src="/images/2019/09/08/f30d8640-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>首先，考虑一个「光钟」，这是一个纯粹由两块互相平行的平面镜组成的计时器，有一束光在两块镜之间来回反弹。然后我们定义这束光来回反弹一次的时间Δ t = 2 h / c 为一个时间单位，故此我们就有了这样一种有趣的计时器。</p>
<p><img src="/images/2019/09/08/fcb376f0-d22a-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>现在，我们让这个光钟在S座标系中以水平方向向右以均速  v 移动。所以我们就知道，如果我们称光钟为S’ 座标系，就有Δ t’ = 2 h / c。在S 座标系当中，光就是以斜线行进的，根据毕氐定理，我们得到  </p>
<p><img src="/images/2019/09/08/11de7890-d22b-11e9-9524-0dc4604f517e.png" alt="image.png">  </p>
<p>使用简单代数运算求得Δ t：</p>
<p><img src="/images/2019/09/08/1dd97cd0-d22b-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>因为v &lt; c，所以分母必定小于1 ，故此Δ t’ &lt; Δ t。换句话说，移动中的座标系的时间流逝得比较慢。这就是著名的时间迟滞(Time Dilation) 。 </p>
<p>除了移动中的人的时间在其他人眼中会变慢之外，移动中的物体看起来也会变短。这叫做长度收缩(Length Contraction)。如果L 0 是物体静止时的长度，L是物体相对于观测者以速度  v移动时的长度，那么我们就会得到   </p>
<p><img src="/images/2019/09/08/26465140-d22b-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>公式(3) 的推导过程与公式(2) 差不多，只要把光钟转个直角再考虑水平移动就可以了，有兴趣的朋友可以自己当做练习试试推导。</p>
<p>以上两个「违反直觉」的现象都已经被实验观测所证实了。其中一个重要的证明是关于宇宙射线的问题。每分每秒都有大量的宇宙射线攻击着地球，这些射线多是带电粒子诸如质子及电子等等，能量很高。幸好地球有磁场以及大气层的保护，不然地球上就不可能有生命存在了。</p>
<p>一些粒子与大气粒子碰撞后，会产生许多不同种类的粒子，向各个方向散射。这些粒子的寿命一般都非常短暂，就算在产生的一刻开始已经用接近光速前进，在它再衰变成其他粒子之前，前进的距离最多也只得几百米。但是，虽然地球的大气层厚度约为100公里，设置在地面上的仪器却可以探测到它们！这完全是因为这些粒子以接近光速行进，相对论的效应就会变得很大。如果在静止时这些粒子的寿命是  T，那么根据时间迟滞现象，地面上的人就会测得它们的寿命为</p>
<p><img src="/images/2019/09/08/2f689300-d22b-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>其中  v 是粒子的速度。明显地，当  v 非常接近  c 的时候，T’ 就会变得非常大，所以它们有足够的时间可以穿过厚厚的大气层落到地面。</p>
<p>我最后想介绍的是著名的爱因斯坦速度相加法则。在早前的讨论中，我们已经明白到，在光速不是无限快的条件下，时间必须是「相对」的。亦即是说，对于不同运动状态的观测者，时间的流逝速率各有不同。同样地对于空间来说也是如此。因此，我们就不能说两个互相靠近的人的相对速度  v’，会简单地为  v’ = v 1 + v 2，其中  v 1 和  v 2 分别为两个人的速度。那么  v’ 应该如何表达才对呢？其实简单得很，只要把洛伦兹公式对时间微分就可以了。详细的做法可以参考教科书，其结果为</p>
<p><img src="/images/2019/09/08/382ab360-d22b-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>因此可以看到在相对论下，相对速度  v’ 比较小。如果代入文章开头的例子，你和光束互相冲向对方，就有</p>
<p><img src="/images/2019/09/08/3e868220-d22b-11e9-9524-0dc4604f517e.png" alt="image.png"></p>
<p>所以你会惊讶地发现，c + v 仍然是  c！这是当然的，因为相对论本身必须符合它的假设：光速不变。</p>
<p>其实狭义相对论还有许多有趣的题目可以讨论的，例如著名的质能公式E = mc^2、双生子悖论、能量-动量四维向量、以及相对论性电磁场理论等等，或许在以后我会和大家深入讨论。而爱因斯坦在1916 年提出的广义相对论(general relativity)，则是一套把重力与加速度都包含在内的时空理论，能够非常准确地描述我们身处的宇宙。广义相对论所涉及的数学非常深奥，需要使用到十分抽象的黎曼几何以及张量的概念，确实并非每个学生也能明白。在以后我会试试为大家说明广义相对论的重要性。总而言之，在这篇文章中，我希望大家明白的事，是相对论其实并非一般人想像的那么深奥难懂。至少，就狭义相对论而言，只需要中学程度的物理及数学知识就可以了。</p>
<p><a href="https://hfdavidyu.com/2015/03/27/%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%87%82%E7%9B%B8%E5%B0%8D%E8%AB%96/" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.hsutimes.com/2019/09/08/你也能懂相对论/" data-id="ck0gj8ytb0016f4gbymky24uh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爱因斯坦/">爱因斯坦</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/相对论/">相对论</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文章/">文章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔试/">笔试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OCR/">OCR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/">OpenCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dio/">dio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jad/">jad</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nohup/">nohup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webhooks/">webhooks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反编译/">反编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备份/">备份</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/天平/">天平</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文章/">文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/暴力破解/">暴力破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爱因斯坦/">爱因斯坦</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/狂野飙车/">狂野飙车</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百科/">百科</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/相对论/">相对论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/矩阵/">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/素数/">素数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/红黑树/">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/脚本/">脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化部署/">自动化部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跑车/">跑车</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/边缘检测/">边缘检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/魔方/">魔方</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/OCR/" style="font-size: 10px;">OCR</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TensorFlow/" style="font-size: 11.67px;">TensorFlow</a> <a href="/tags/dio/" style="font-size: 10px;">dio</a> <a href="/tags/electron/" style="font-size: 10px;">electron</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/jad/" style="font-size: 10px;">jad</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/leetcode/" style="font-size: 16.67px;">leetcode</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nohup/" style="font-size: 10px;">nohup</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/webhooks/" style="font-size: 10px;">webhooks</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/反编译/" style="font-size: 10px;">反编译</a> <a href="/tags/备份/" style="font-size: 10px;">备份</a> <a href="/tags/天平/" style="font-size: 10px;">天平</a> <a href="/tags/数据库/" style="font-size: 11.67px;">数据库</a> <a href="/tags/文章/" style="font-size: 11.67px;">文章</a> <a href="/tags/暴力破解/" style="font-size: 10px;">暴力破解</a> <a href="/tags/机器学习/" style="font-size: 11.67px;">机器学习</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/爱因斯坦/" style="font-size: 10px;">爱因斯坦</a> <a href="/tags/狂野飙车/" style="font-size: 10px;">狂野飙车</a> <a href="/tags/百科/" style="font-size: 10px;">百科</a> <a href="/tags/相对论/" style="font-size: 10px;">相对论</a> <a href="/tags/矩阵/" style="font-size: 10px;">矩阵</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/素数/" style="font-size: 10px;">素数</a> <a href="/tags/红黑树/" style="font-size: 10px;">红黑树</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/脚本/" style="font-size: 10px;">脚本</a> <a href="/tags/自动化部署/" style="font-size: 10px;">自动化部署</a> <a href="/tags/跑车/" style="font-size: 10px;">跑车</a> <a href="/tags/边缘检测/" style="font-size: 10px;">边缘检测</a> <a href="/tags/递归/" style="font-size: 13.33px;">递归</a> <a href="/tags/链表/" style="font-size: 11.67px;">链表</a> <a href="/tags/面试/" style="font-size: 18.33px;">面试</a> <a href="/tags/魔方/" style="font-size: 10px;">魔方</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/23/HashMap类/">HashMap类</a>
          </li>
        
          <li>
            <a href="/2019/09/21/BigInteger类/">BigInteger类</a>
          </li>
        
          <li>
            <a href="/2019/09/21/客户端面试/">客户端面试</a>
          </li>
        
          <li>
            <a href="/2019/09/20/Java知识点/">Java知识点</a>
          </li>
        
          <li>
            <a href="/2019/09/18/面试笔记/">面试笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 times<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>